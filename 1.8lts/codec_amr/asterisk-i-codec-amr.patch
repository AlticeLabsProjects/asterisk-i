diff -Naur asterisk-1.8.3.2_com_rtsp/channels/chan_sip.c asterisk-1.8.3.2_com_amr/channels/chan_sip.c
--- asterisk-1.8.3.2_com_rtsp/channels/chan_sip.c	2012-03-15 11:13:53.000000000 +0000
+++ asterisk-1.8.3.2_com_amr/channels/chan_sip.c	2012-03-26 16:29:06.000000000 +0100
@@ -740,6 +740,9 @@
 static int global_max_se;                     /*!< Highest threshold for session refresh interval */
 
 static int global_dynamic_exclude_static = 0; /*!< Exclude static peers from contact registrations */
+
+static int global_amr_mode = DEFAULT_AMR_MODE;
+static int global_amr_octetalign = DEFAULT_OCTET_ALIGN;
 /*@}*/
 
 /*!
@@ -10218,6 +10221,51 @@
 		/* Indicate that we only expect 64Kbps */
 		ast_str_append(a_buf, 0, "a=fmtp:%d bitrate=64000\r\n", rtp_code);
 		break;
+	case AST_FORMAT_AMRNB:
+	      /* Indicate that we accept octet-align mode set to 1 (AMR-NB for exoteric devices)*/
+	      if (global_amr_octetalign)
+	      {
+	         if (global_amr_mode == -1)
+	            ast_str_append(a_buf, 0, "a=fmtp:%d mode-set=0,2,5,7; octet-align=1\r\n", rtp_code); // mode-set=0,2,5,7;
+	         else
+	            ast_str_append(a_buf, 0, "a=fmtp:%d mode-set=%d; octet-align=1\r\n", rtp_code, global_amr_mode); // mode-set=0,2,5,7;
+	      }
+	      else
+	      {
+	         if (global_amr_mode == -1)
+	            ast_str_append(a_buf, 0, "a=fmtp:%d mode-set=0,2,5,7\r\n", rtp_code); // mode-set=0,2,5,7;
+	         else
+	            ast_str_append(a_buf, 0, "a=fmtp:%d mode-set=%d\r\n", rtp_code, global_amr_mode); // mode-set=0,2,5,7;
+	      }
+	      break;
+	   case AST_FORMAT_AMRWB:
+	      if (global_amr_octetalign)
+	      {
+	         if (global_amr_mode == -1)
+	            ast_str_append(a_buf, 0, "a=fmtp:%d mode-set=0,2,5,7,8; octet-align=1\r\n", rtp_code); // mode-set=0,2,5,7,8;
+	         else
+	            ast_str_append(a_buf, 0, "a=fmtp:%d mode-set=%d; octet-align=1\r\n", rtp_code, global_amr_mode);
+	      }
+	      else
+	      {
+	         if (global_amr_mode == -1)
+	            ast_str_append(a_buf, 0, "a=fmtp:%d mode-set=0,2,5,7,8\r\n", rtp_code); // mode-set=0,2,5,7,8;
+	         else
+	            ast_str_append(a_buf, 0, "a=fmtp:%d mode-set=%d\r\n", rtp_code, global_amr_mode);
+	      }
+	      break;
+	   case AST_FORMAT_H263_PLUS_PLUS:
+	      ast_str_append(a_buf, 0, "a=fmtp:%d profile=0; level=10\r\n", rtp_code);
+	      break;
+	   case AST_FORMAT_H264:
+	      ast_str_append(a_buf, 0, "a=fmtp:%d profile-level-id=42E00A; max-br=64\r\n", rtp_code);
+	      break;
+	   case AST_FORMAT_MPEG4_VIDEO:
+	      ast_str_append(a_buf, 0, "a=fmtp:%d profile-level-id=1\r\n", rtp_code);
+	      break;
+	   case AST_FORMAT_MPEG4_AUDIO:
+	      ast_str_append(a_buf, 0, "a=fmtp:%d profile-level-id=15\r\n", rtp_code);
+	      break;
 	}
 
 	if (fmt.cur_ms && (fmt.cur_ms < *min_packet_size))
@@ -26619,6 +26667,9 @@
 	global_qualify_gap = DEFAULT_QUALIFY_GAP;
 	global_qualify_peers = DEFAULT_QUALIFY_PEERS;
 
+	global_amr_mode = DEFAULT_AMR_MODE;
+	global_amr_octetalign = DEFAULT_OCTET_ALIGN;
+
 	/* Initialize some reasonable defaults at SIP reload (used both for channel and as default for devices */
 	ast_copy_string(sip_cfg.default_context, DEFAULT_CONTEXT, sizeof(sip_cfg.default_context));
 	sip_cfg.default_subscribecontext[0] = '\0';
diff -Naur asterisk-1.8.3.2_com_rtsp/channels/sip/include/sip.h asterisk-1.8.3.2_com_amr/channels/sip/include/sip.h
--- asterisk-1.8.3.2_com_rtsp/channels/sip/include/sip.h	2012-03-15 11:13:53.000000000 +0000
+++ asterisk-1.8.3.2_com_amr/channels/sip/include/sip.h	2012-03-26 16:29:06.000000000 +0100
@@ -218,6 +218,8 @@
 #define DEFAULT_ENGINE     "asterisk"      /*!< Default RTP engine to use for sessions */
 #define DEFAULT_CAPABILITY (AST_FORMAT_ULAW | AST_FORMAT_TESTLAW | AST_FORMAT_ALAW | AST_FORMAT_GSM | AST_FORMAT_H263);
 #endif
+#define DEFAULT_AMR_MODE      -1
+#define DEFAULT_OCTET_ALIGN   TRUE
 /*@}*/
 
 /*! \name SIPflags
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/amr/decoder.c asterisk-1.8.3.2_com_amr/codecs/amr/decoder.c
--- asterisk-1.8.3.2_com_rtsp/codecs/amr/decoder.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/amr/decoder.c	2012-03-26 16:29:06.000000000 +0100
@@ -0,0 +1,158 @@
+/*
+ * ===================================================================
+ *  TS 26.104
+ *  REL-5 V5.4.0 2004-03
+ *  REL-6 V6.1.0 2004-03
+ *  3GPP AMR Floating-point Speech Codec
+ * ===================================================================
+ *
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <memory.h>
+#include "interf_dec.h"
+#include "sp_dec.h"
+#include "typedef.h"
+
+#ifndef ETSI
+#ifndef IF2
+#include <string.h>
+#define AMR_MAGIC_NUMBER "#!AMR\n"
+#endif
+#endif
+
+void Copyright(void){
+fprintf (stderr,
+"===================================================================\n"
+" TS 26.104                                                         \n"
+" REL-5 V5.4.0 2004-03                                              \n"
+" REL-6 V6.1.0 2004-03                                              \n"
+" 3GPP AMR Floating-point Speech Decoder                            \n"
+"===================================================================\n"
+);
+}
+/*
+ * main
+ *
+ *
+ * Function:
+ *    Speech decoder main program
+ *
+ *    Usage: decoder bitstream_file synthesis_file
+ *
+ *    Format for ETSI bitstream file:
+ *       1 word (2-byte) for the TX frame type
+ *       244 words (2-byte) containing 244 bits.
+ *          Bit 0 = 0x0000 and Bit 1 = 0x0001
+ *       1 word (2-byte) for the mode indication
+ *       4 words for future use, currently written as zero
+ *
+ *    Format for 3GPP bitstream file:
+ *       Holds mode information and bits packed to octets.
+ *       Size is from 1 byte to 31 bytes.
+ *
+ *    Format for synthesis_file:
+ *       Speech is written to a 16 bit 8kHz file.
+ *
+ *    ETSI bitstream file format is defined using ETSI as preprocessor
+ *    definition
+ * Returns:
+ *    0
+ */
+int main (int argc, char * argv[]){
+
+   FILE * file_speech, *file_analysis;
+
+   short synth[160];
+   int frames = 0;
+   int * destate;
+   int read_size;
+#ifndef ETSI
+   unsigned char analysis[32];
+   enum Mode dec_mode;
+#ifdef IF2
+   short block_size[16]={ 12, 13, 15, 17, 18, 20, 25, 30, 5, 0, 0, 0, 0, 0, 0, 0 };
+#else
+   char magic[8];
+   short block_size[16]={ 12, 13, 15, 17, 19, 20, 26, 31, 5, 0, 0, 0, 0, 0, 0, 0 };
+#endif
+#else
+   short analysis[250];
+#endif
+
+   /* Process command line options */
+   if (argc == 3){
+
+      file_speech = fopen(argv[2], "wb");
+      if (file_speech == NULL){
+         fprintf ( stderr, "%s%s%s\n","Use: ",argv[0], " input.file output.file " );
+         return 1;
+      }
+
+      file_analysis = fopen(argv[1], "rb");
+      if (file_analysis == NULL){
+         fprintf ( stderr, "%s%s%s\n","Use: ",argv[0], " input.file output.file " );
+         fclose(file_speech);
+         return 1;
+      }
+
+   }
+   else {
+      fprintf ( stderr, "%s%s%s\n","Use: ",argv[0], " input.file output.file " );
+      return 1;
+   }
+   Copyright();
+   /* init decoder */
+   destate = Decoder_Interface_init();
+
+#ifndef ETSI
+#ifndef IF2
+   /* read and verify magic number */
+   fread( magic, sizeof( char ), strlen( AMR_MAGIC_NUMBER ), file_analysis );
+   if ( strncmp( magic, AMR_MAGIC_NUMBER, strlen( AMR_MAGIC_NUMBER ) ) ) {
+	   fprintf( stderr, "%s%s\n", "Invalid magic number: ", magic );
+	   fclose( file_speech );
+	   fclose( file_analysis );
+	   return 1;
+   }
+#endif
+#endif
+
+#ifndef ETSI
+
+   /* find mode, read file */
+   while (fread(analysis, sizeof (unsigned char), 1, file_analysis ) > 0)
+   {
+#ifdef IF2
+      dec_mode = analysis[0] & 0x000F;
+#else
+      dec_mode = (analysis[0] >> 3) & 0x000F;
+#endif
+	  read_size = block_size[dec_mode];
+
+      fread(&analysis[1], sizeof (char), read_size, file_analysis );
+#else
+
+   read_size = 250;
+   /* read file */
+   while (fread(analysis, sizeof (short), read_size, file_analysis ) > 0)
+   {
+#endif
+
+      frames ++;
+
+      /* call decoder */
+      Decoder_Interface_Decode(destate, analysis, synth, 0);
+
+      fwrite( synth, sizeof (short), 160, file_speech );
+   }
+
+   Decoder_Interface_exit(destate);
+
+   fclose(file_speech);
+   fclose(file_analysis);
+   fprintf ( stderr, "\n%s%i%s\n","Decoded ", frames, " frames.");
+
+   return 0;
+}
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/amr/encoder.c asterisk-1.8.3.2_com_amr/codecs/amr/encoder.c
--- asterisk-1.8.3.2_com_rtsp/codecs/amr/encoder.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/amr/encoder.c	2012-03-26 16:29:06.000000000 +0100
@@ -0,0 +1,241 @@
+/*
+ * ===================================================================
+ *  TS 26.104
+ *  REL-5 V5.4.0 2004-03
+ *  REL-6 V6.1.0 2004-03
+ *  3GPP AMR Floating-point Speech Codec
+ * ===================================================================
+ *
+ */
+
+/*
+ * encoder.c
+ *
+ *
+ * Project:
+ *    AMR Floating-Point Codec
+ *
+ * Contains:
+ *    Speech encoder main program
+ *
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <memory.h>
+#include <string.h>
+#include "typedef.h"
+#include "interf_enc.h"
+
+#ifndef ETSI
+#ifndef IF2
+#define AMR_MAGIC_NUMBER "#!AMR\n"
+#endif
+#endif
+
+static const short modeConv[]={
+   475, 515, 59, 67, 74, 795, 102, 122};
+
+static void Usage(char* argv[])
+{
+   fprintf (stderr,
+      "Usage of %s:\n\n"
+      "[-dtx] mode speech_file bitstream_file \n\n"
+      "or \n\n"
+      "[-dtx] -modefile=mode_file speech_file bitstream_file \n\n\n"
+      "mode = MR475, MR515, MR59, MR67, MR74, MR795, MR102, MR122 \n\n\n",
+      argv[0]);
+}
+void Copyright(void){
+fprintf (stderr,
+"===================================================================\n"
+" TS 26.104                                                         \n"
+" REL-5 V5.4.0 2004-03                                              \n"
+" REL-6 V6.1.0 2004-03                                              \n"
+" 3GPP AMR Floating-point Speech Encoder                            \n"
+"===================================================================\n"
+);
+}
+/*
+ * main
+ *
+ *
+ * Function:
+ *    Speech encoder main program
+ *
+ *    Usage: encoder speech_file bitstream_file mode dtx mode_file
+ *
+ *    Format for speech_file:
+ *       Speech is read from a binary file of 16 bits data.
+ *
+ *    Format for ETSI bitstream file:
+ *       1 word (2-byte) for the TX frame type
+ *       244 words (2-byte) containing 244 bits.
+ *          Bit 0 = 0x0000 and Bit 1 = 0x0001
+ *       1 word (2-byte) for the mode indication
+ *       4 words for future use, currently written as zero
+ *
+ *    Format for 3GPP bitstream file:
+ *       Holds mode information and bits packed to octets.
+ *       Size is from 1 byte to 31 bytes.
+ *
+ *    ETSI bitstream file format is defined using ETSI as preprocessor
+ *    definition
+ *
+ *    mode        : MR475, MR515, MR59, MR67, MR74, MR795, MR102, MR122
+ *    mode_file   : reads mode information from a file
+ * Returns:
+ *    0
+ */
+int main (int argc, char * argv[]){
+
+   /* file strucrures */
+   FILE * file_speech = NULL;
+   FILE * file_encoded = NULL;
+   FILE * file_mode = NULL;
+
+   /* input speech vector */
+   short speech[160];
+
+   /* counters */
+   int byte_counter, frames = 0, bytes = 0;
+
+   /* pointer to encoder state structure */
+   int *enstate;
+
+   /* requested mode */
+   enum Mode req_mode = MR122;
+   int dtx = 0;
+
+   /* temporary variables */
+   char mode_string[9];
+   long mode_tmp;
+
+   /* bitstream filetype */
+#ifndef ETSI
+   unsigned char serial_data[32];
+#else
+   short serial_data[250] = {0};
+#endif
+
+   /* Process command line options */
+
+   if ((argc == 5) || (argc == 4)){
+      file_encoded = fopen(argv[argc - 1], "wb");
+      if (file_encoded == NULL){
+         Usage(argv);
+         return 1;
+      }
+      file_speech = fopen(argv[argc - 2], "rb");
+      if (file_speech == NULL){
+         fclose(file_encoded);
+         Usage(argv);
+         return 1;
+      }
+      if (strncmp(argv[argc - 3], "-modefile=", 10) == 0){
+         file_mode = fopen(&argv[argc - 3][10], "rt");
+         if (file_mode == NULL){
+            Usage(argv);
+            fclose(file_speech);
+            fclose(file_encoded);
+            return 1;
+         }
+      }
+      else {
+         mode_tmp = strtol(&argv[argc - 3][2], NULL, 0);
+         for (req_mode = 0; req_mode < 8; req_mode++){
+            if (mode_tmp == modeConv[req_mode])
+               break;
+         }
+         if (req_mode == 8){
+            Usage(argv);
+            fclose(file_speech);
+            fclose(file_encoded);
+            if (file_mode != NULL)
+               fclose(file_mode);
+            return 1;
+         }
+      }
+      if (argc == 5){
+         if ((strcmp(argv[1], "-dtx") != 0)){
+            Usage(argv);
+            fclose(file_speech);
+            fclose(file_encoded);
+            if (file_mode != NULL){
+               fclose(file_mode);
+            }
+            return 1;
+         }
+         else {
+            dtx = 1;
+         }
+      }
+   }
+   else {
+      Usage(argv);
+      return 1;
+   }
+
+
+   enstate = Encoder_Interface_init(dtx);
+
+   Copyright();
+#ifndef VAD2
+   fprintf( stderr, "%s\n", "Code compiled with VAD option: VAD1");
+#else
+   fprintf( stderr, "%s\n", "Code compiled with VAD option: VAD2");
+#endif
+
+#ifndef ETSI
+#ifndef IF2
+   /* write magic number to indicate single channel AMR file storage format */
+   	bytes = fwrite(AMR_MAGIC_NUMBER, sizeof(char), strlen(AMR_MAGIC_NUMBER), file_encoded);
+#endif
+#endif
+
+   /* read file */
+   while (fread( speech, sizeof (Word16), 160, file_speech ) > 0)
+   {
+      /* read mode */
+      if (file_mode != NULL){
+         req_mode = 8;
+         if (fscanf(file_mode, "%9s\n", mode_string) != EOF) {
+            mode_tmp = strtol(&mode_string[2], NULL, 0);
+            for (req_mode = 0; req_mode < 8; req_mode++){
+               if (mode_tmp == modeConv[req_mode]){
+                  break;
+               }
+            }
+         }
+         if (req_mode == 8){
+            break;
+         }
+      }
+
+      frames ++;
+
+      /* call encoder */
+      byte_counter = Encoder_Interface_Encode(enstate, req_mode, speech, serial_data, 0);
+
+      bytes += byte_counter;
+      fwrite(serial_data, sizeof (UWord8), byte_counter, file_encoded );
+      fflush(file_encoded);
+   }
+   Encoder_Interface_exit(enstate);
+
+#ifndef ETSI
+#ifdef IF2
+   fprintf ( stderr, "\n%s%i%s%i%s\n", "Frame structure AMR IF2: ", frames, " frames, ", bytes, " bytes.");
+#else
+   fprintf ( stderr, "\n%s%i%s%i%s\n", "Frame structure AMR MIME file storage format: ", frames, " frames, ", bytes, " bytes.");
+#endif
+#else
+   fprintf ( stderr, "\n%s%i%s\n", "Frame structure AMR ETSI: ", frames, " frames. ");
+#endif
+
+   fclose(file_speech);
+   fclose(file_encoded);
+   if (file_mode != NULL)
+      fclose(file_mode);
+
+   return 0;
+}
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/amr/interf_dec.c asterisk-1.8.3.2_com_amr/codecs/amr/interf_dec.c
--- asterisk-1.8.3.2_com_rtsp/codecs/amr/interf_dec.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/amr/interf_dec.c	2012-03-26 16:29:06.000000000 +0100
@@ -0,0 +1,882 @@
+/*
+ * ===================================================================
+ *  TS 26.104
+ *  REL-5 V5.4.0 2004-03
+ *  REL-6 V6.1.0 2004-03
+ *  3GPP AMR Floating-point Speech Codec
+ * ===================================================================
+ *
+ */
+
+/*
+ * interf_dec.c
+ *
+ *
+ * Project:
+ *     AMR Floating-Point Codec
+ *
+ * Contains:
+ *    This module provides means to conversion from 3GPP or ETSI
+ *    bitstream to AMR parameters
+ */
+
+/*
+ * include files
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <memory.h>
+#include "typedef.h"
+#include "sp_dec.h"
+#include "interf_rom.h"
+#include "rom_dec.h"
+
+/*
+ * definition of constants
+ */
+#define EHF_MASK 0x0008 /* encoder homing frame pattern */
+typedef
+
+struct
+{
+   int reset_flag_old;   /* previous was homing frame */
+
+
+   enum RXFrameType prev_ft;   /* previous frame type */
+   enum Mode prev_mode;   /* previous mode */
+   void *decoder_State;   /* Points decoder state */
+
+
+}dec_interface_State;
+
+#ifdef ETSI
+
+
+/*
+ * Bin2Int
+ *
+ *
+ * Parameters:
+ *    no_of_bits        I: number of bits associated with value
+ *    bits              O: address where bits are written
+ *
+ * Function:
+ *    Read nuber of bits from the array and convert to integer.
+ *
+ * Returns:
+ *    value
+ */
+static Word16 Bin2Int( Word16 no_of_bits, Word16 *bitstream )
+{
+   Word32 value, i, bit;
+
+
+   value = 0;
+
+   for ( i = 0; i < no_of_bits; i++ ) {
+      value = value << 1;
+      bit = *bitstream++;
+
+      if ( bit == 0x1 )
+         value = value + 1;
+   }
+   return( Word16 )( value );
+}
+
+
+/*
+ * Bits2Prm
+ *
+ *
+ * Parameters:
+ *    mode              I: AMR mode
+ *    bits              I: serial bits
+ *    param             O: AMR parameters
+ *
+ * Function:
+ *    Retrieves the vector of encoder parameters from
+ *    the received serial bits in a frame.
+ *
+ * Returns:
+ *    void
+ */
+static void Bits2Prm( enum Mode mode, Word16 bits[], Word16 prm[] )
+{
+   Word32 i;
+
+
+   switch ( mode ) {
+      case MR122:
+         for ( i = 0; i < PRMNO_MR122; i++ ) {
+            prm[i] = Bin2Int( bitno_MR122[i], bits );
+            bits += bitno_MR122[i];
+         }
+         break;
+
+      case MR102:
+         for ( i = 0; i < PRMNO_MR102; i++ ) {
+            prm[i] = Bin2Int( bitno_MR102[i], bits );
+            bits += bitno_MR102[i];
+         }
+         break;
+
+      case MR795:
+         for ( i = 0; i < PRMNO_MR795; i++ ) {
+            prm[i] = Bin2Int( bitno_MR795[i], bits );
+            bits += bitno_MR795[i];
+         }
+         break;
+
+      case MR74:
+         for ( i = 0; i < PRMNO_MR74; i++ ) {
+            prm[i] = Bin2Int( bitno_MR74[i], bits );
+            bits += bitno_MR74[i];
+         }
+         break;
+
+      case MR67:
+         for ( i = 0; i < PRMNO_MR67; i++ ) {
+            prm[i] = Bin2Int( bitno_MR67[i], bits );
+            bits += bitno_MR67[i];
+         }
+         break;
+
+      case MR59:
+         for ( i = 0; i < PRMNO_MR59; i++ ) {
+            prm[i] = Bin2Int( bitno_MR59[i], bits );
+            bits += bitno_MR59[i];
+         }
+         break;
+
+      case MR515:
+         for ( i = 0; i < PRMNO_MR515; i++ ) {
+            prm[i] = Bin2Int( bitno_MR515[i], bits );
+            bits += bitno_MR515[i];
+         }
+         break;
+
+      case MR475:
+         for ( i = 0; i < PRMNO_MR475; i++ ) {
+            prm[i] = Bin2Int( bitno_MR475[i], bits );
+            bits += bitno_MR475[i];
+         }
+         break;
+
+      case MRDTX:
+         for ( i = 0; i < PRMNO_MRDTX; i++ ) {
+            prm[i] = Bin2Int( bitno_MRDTX[i], bits );
+            bits += bitno_MRDTX[i];
+         }
+         break;
+   }
+   return;
+}
+
+#else
+
+#ifndef IF2
+
+/*
+ * DecoderMMS
+ *
+ *
+ * Parameters:
+ *    param             O: AMR parameters
+ *    stream            I: input bitstream
+ *    frame_type        O: frame type
+ *    speech_mode       O: speech mode in DTX
+ *
+ * Function:
+ *    AMR file storage format frame to decoder parameters
+ *
+ * Returns:
+ *    mode              used mode
+ */
+enum Mode DecoderMMS( Word16 *param, UWord8 *stream, enum RXFrameType
+                      *frame_type, enum Mode *speech_mode, Word16 *q_bit )
+{
+   enum Mode mode;
+   Word32 j;
+   Word16 *mask;
+
+
+   memset( param, 0, PRMNO_MR122 <<1 );
+   *q_bit = 0x01 & (*stream >> 2);
+   mode = 0x0F & (*stream >> 3);
+   stream++;
+
+   if ( mode == MRDTX ) {
+      mask = order_MRDTX;
+
+      for ( j = 1; j < 36; j++ ) {
+         if ( *stream & 0x80 )
+            param[ * mask] = ( short )( param[ * mask] + *( mask + 1 ) );
+         mask += 2;
+
+         if ( j % 8 )
+            *stream <<= 1;
+         else
+            stream++;
+      }
+
+      /* get SID type bit */
+
+      *frame_type = RX_SID_FIRST;
+      if (*stream & 0x80)
+         *frame_type = RX_SID_UPDATE;
+
+      /* since there is update, use it */
+      /* *frame_type = RX_SID_UPDATE; */
+
+      /* speech mode indicator */
+	  *speech_mode = (*stream >> 4) & 0x07;
+	  *speech_mode = ((*speech_mode & 0x0001) << 2) | (*speech_mode & 0x0002) | ((*speech_mode & 0x0004) >> 2);
+
+   }
+   else if ( mode == 15 ) {
+      *frame_type = RX_NO_DATA;
+   }
+   else if ( mode == MR475 ) {
+      mask = order_MR475;
+
+      for ( j = 1; j < 96; j++ ) {
+         if ( *stream & 0x80 )
+            param[ * mask] = ( short )( param[ * mask] + *( mask + 1 ) );
+         mask += 2;
+
+         if ( j % 8 )
+            *stream <<= 1;
+         else
+            stream++;
+      }
+      *frame_type = RX_SPEECH_GOOD;
+   }
+   else if ( mode == MR515 ) {
+      mask = order_MR515;
+
+      for ( j = 1; j < 104; j++ ) {
+         if ( *stream & 0x80 )
+            param[ * mask] = ( short )( param[ * mask] + *( mask + 1 ) );
+         mask += 2;
+
+         if ( j % 8 )
+            *stream <<= 1;
+         else
+            stream++;
+      }
+      *frame_type = RX_SPEECH_GOOD;
+   }
+   else if ( mode == MR59 ) {
+      mask = order_MR59;
+
+      for ( j = 1; j < 119; j++ ) {
+         if ( *stream & 0x80 )
+            param[ * mask] = ( short )( param[ * mask] + *( mask + 1 ) );
+         mask += 2;
+
+         if ( j % 8 )
+            *stream <<= 1;
+         else
+            stream++;
+      }
+      *frame_type = RX_SPEECH_GOOD;
+   }
+   else if ( mode == MR67 ) {
+      mask = order_MR67;
+
+      for ( j = 1; j < 135; j++ ) {
+         if ( *stream & 0x80 )
+            param[ * mask] = ( short )( param[ * mask] + *( mask + 1 ) );
+         mask += 2;
+
+         if ( j % 8 )
+            *stream <<= 1;
+         else
+            stream++;
+      }
+      *frame_type = RX_SPEECH_GOOD;
+   }
+   else if ( mode == MR74 ) {
+      mask = order_MR74;
+
+      for ( j = 1; j < 149; j++ ) {
+         if ( *stream & 0x80 )
+            param[ * mask] = ( short )( param[ * mask] + *( mask + 1 ) );
+         mask += 2;
+
+         if ( j % 8 )
+            *stream <<= 1;
+         else
+            stream++;
+      }
+      *frame_type = RX_SPEECH_GOOD;
+   }
+   else if ( mode == MR795 ) {
+      mask = order_MR795;
+
+      for ( j = 1; j < 160; j++ ) {
+         if ( *stream & 0x80 )
+            param[ * mask] = ( short )( param[ * mask] + *( mask + 1 ) );
+         mask += 2;
+
+         if ( j % 8 )
+            *stream <<= 1;
+         else
+            stream++;
+      }
+      *frame_type = RX_SPEECH_GOOD;
+   }
+   else if ( mode == MR102 ) {
+      mask = order_MR102;
+
+      for ( j = 1; j < 205; j++ ) {
+         if ( *stream & 0x80 )
+            param[ * mask] = ( short )( param[ * mask] + *( mask + 1 ) );
+         mask += 2;
+
+         if ( j % 8 )
+            *stream <<= 1;
+         else
+            stream++;
+      }
+      *frame_type = RX_SPEECH_GOOD;
+   }
+   else if ( mode == MR122 ) {
+      mask = order_MR122;
+
+      for ( j = 1; j < 245; j++ ) {
+         if ( *stream & 0x80 )
+            param[ * mask] = ( short )( param[ * mask] + *( mask + 1 ) );
+         mask += 2;
+
+         if ( j % 8 )
+            *stream <<= 1;
+         else
+            stream++;
+      }
+      *frame_type = RX_SPEECH_GOOD;
+   }
+   else
+      *frame_type = RX_SPEECH_BAD;
+   return mode;
+}
+
+#else
+
+/*
+ * Decoder3GPP
+ *
+ *
+ * Parameters:
+ *    param             O: AMR parameters
+ *    stream            I: input bitstream
+ *    frame_type        O: frame type
+ *    speech_mode       O: speech mode in DTX
+ *
+ * Function:
+ *    Resets state memory
+ *
+ * Returns:
+ *    mode              used mode
+ */
+enum Mode Decoder3GPP( Word16 *param, UWord8 *stream, enum RXFrameType
+                      *frame_type, enum Mode *speech_mode )
+{
+   enum Mode mode;
+   Word32 j;
+   Word16 *mask;
+
+
+   memset( param, 0, PRMNO_MR122 <<1 );
+   mode = 0xF & *stream;
+   *stream >>= 4;
+
+   if ( mode == MRDTX ) {
+      mask = order_MRDTX;
+
+      for ( j = 5; j < 40; j++ ) {
+         if ( *stream & 0x1 )
+            param[ * mask] = ( short )( param[ * mask] + *( mask + 1 ) );
+         mask += 2;
+
+         if ( j % 8 )
+            *stream >>= 1;
+         else
+            stream++;
+      }
+
+      /* get SID type bit */
+
+      *frame_type = RX_SID_FIRST;
+      if (*stream)
+         *frame_type = RX_SID_UPDATE;
+
+      /* since there is update, use it */
+      /* *frame_type = RX_SID_UPDATE; */
+      stream++;
+
+      /* speech mode indicator */
+      *speech_mode = *stream;
+   }
+   else if ( mode == 15 ) {
+      *frame_type = RX_NO_DATA;
+   }
+   else if ( mode == MR475 ) {
+      mask = order_MR475;
+
+      for ( j = 5; j < 100; j++ ) {
+         if ( *stream & 0x1 )
+            param[ * mask] = ( short )( param[ * mask] + *( mask + 1 ) );
+         mask += 2;
+
+         if ( j % 8 )
+            *stream >>= 1;
+         else
+            stream++;
+      }
+      *frame_type = RX_SPEECH_GOOD;
+   }
+   else if ( mode == MR515 ) {
+      mask = order_MR515;
+
+      for ( j = 5; j < 108; j++ ) {
+         if ( *stream & 0x1 )
+            param[ * mask] = ( short )( param[ * mask] + *( mask + 1 ) );
+         mask += 2;
+
+         if ( j % 8 )
+            *stream >>= 1;
+         else
+            stream++;
+      }
+      *frame_type = RX_SPEECH_GOOD;
+   }
+   else if ( mode == MR59 ) {
+      mask = order_MR59;
+
+      for ( j = 5; j < 123; j++ ) {
+         if ( *stream & 0x1 )
+            param[ * mask] = ( short )( param[ * mask] + *( mask + 1 ) );
+         mask += 2;
+
+         if ( j % 8 )
+            *stream >>= 1;
+         else
+            stream++;
+      }
+      *frame_type = RX_SPEECH_GOOD;
+   }
+   else if ( mode == MR67 ) {
+      mask = order_MR67;
+
+      for ( j = 5; j < 139; j++ ) {
+         if ( *stream & 0x1 )
+            param[ * mask] = ( short )( param[ * mask] + *( mask + 1 ) );
+         mask += 2;
+
+         if ( j % 8 )
+            *stream >>= 1;
+         else
+            stream++;
+      }
+      *frame_type = RX_SPEECH_GOOD;
+   }
+   else if ( mode == MR74 ) {
+      mask = order_MR74;
+
+      for ( j = 5; j < 153; j++ ) {
+         if ( *stream & 0x1 )
+            param[ * mask] = ( short )( param[ * mask] + *( mask + 1 ) );
+         mask += 2;
+
+         if ( j % 8 )
+            *stream >>= 1;
+         else
+            stream++;
+      }
+      *frame_type = RX_SPEECH_GOOD;
+   }
+   else if ( mode == MR795 ) {
+      mask = order_MR795;
+
+      for ( j = 5; j < 164; j++ ) {
+         if ( *stream & 0x1 )
+            param[ * mask] = ( short )( param[ * mask] + *( mask + 1 ) );
+         mask += 2;
+
+         if ( j % 8 )
+            *stream >>= 1;
+         else
+            stream++;
+      }
+      *frame_type = RX_SPEECH_GOOD;
+   }
+   else if ( mode == MR102 ) {
+      mask = order_MR102;
+
+      for ( j = 5; j < 209; j++ ) {
+         if ( *stream & 0x1 )
+            param[ * mask] = ( short )( param[ * mask] + *( mask + 1 ) );
+         mask += 2;
+
+         if ( j % 8 )
+            *stream >>= 1;
+         else
+            stream++;
+      }
+      *frame_type = RX_SPEECH_GOOD;
+   }
+   else if ( mode == MR122 ) {
+      mask = order_MR122;
+
+      for ( j = 5; j < 249; j++ ) {
+         if ( *stream & 0x1 )
+            param[ * mask] = ( short )( param[ * mask] + *( mask + 1 ) );
+         mask += 2;
+
+         if ( j % 8 )
+            *stream >>= 1;
+         else
+            stream++;
+      }
+      *frame_type = RX_SPEECH_GOOD;
+   }
+   else
+      *frame_type = RX_SPEECH_BAD;
+   return mode;
+}
+#endif
+#endif
+
+/*
+ * Decoder_Interface_reset
+ *
+ *
+ * Parameters:
+ *    st                O: state struct
+ *
+ * Function:
+ *    Reset homing frame counter
+ *
+ * Returns:
+ *    void
+ */
+void Decoder_Interface_reset( dec_interface_State *st )
+{
+   st->reset_flag_old = 1;
+   st->prev_ft = RX_SPEECH_GOOD;
+   st->prev_mode = MR475;   /* minimum bitrate */
+}
+
+
+/*
+ * Decoder_Interface_init
+ *
+ *
+ * Parameters:
+ *    void
+ *
+ * Function:
+ *    Allocates state memory and initializes state memory
+ *
+ * Returns:
+ *    success           : pointer to structure
+ *    failure           : NULL
+ */
+void * Decoder_Interface_init( void )
+{
+   dec_interface_State * s;
+
+   /* allocate memory */
+   if ( ( s = ( dec_interface_State * ) malloc( sizeof( dec_interface_State ) ) ) ==
+         NULL ) {
+      fprintf( stderr, "Decoder_Interface_init: "
+            "can not malloc state structure\n" );
+      return NULL;
+   }
+   s->decoder_State = Speech_Decode_Frame_init( );
+
+   if ( s->decoder_State == NULL ) {
+      free( s );
+      return NULL;
+   }
+   Decoder_Interface_reset( s );
+   return s;
+}
+
+
+/*
+ * Decoder_Interface_exit
+ *
+ *
+ * Parameters:
+ *    state                I: state structure
+ *
+ * Function:
+ *    The memory used for state memory is freed
+ *
+ * Returns:
+ *    Void
+ */
+void Decoder_Interface_exit( void *state )
+{
+   dec_interface_State * s;
+   s = ( dec_interface_State * )state;
+
+   /* free memory */
+   Speech_Decode_Frame_exit(s->decoder_State );
+   free( s );
+   s = NULL;
+   state = NULL;
+}
+
+
+/*
+ * Decoder_Interface_Decode
+ *
+ *
+ * Parameters:
+ *    st                B: state structure
+ *    bits              I: bit stream
+ *    synth             O: synthesized speech
+ *    bfi               I: bad frame indicator
+ *
+ * Function:
+ *    Decode bit stream to synthesized speech
+ *
+ * Returns:
+ *    Void
+ */
+void Decoder_Interface_Decode( void *st,
+
+#ifndef ETSI
+      UWord8 *bits,
+
+#else
+      Word16 *bits,
+#endif
+
+      Word16 *synth, int bfi)
+{
+   enum Mode mode;   /* AMR mode */
+
+#ifndef ETSI
+   enum Mode speech_mode = MR475;   /* speech mode */
+#endif
+
+   Word16 prm[PRMNO_MR122];   /* AMR parameters */
+
+   enum RXFrameType frame_type;   /* frame type */
+   dec_interface_State * s;   /* pointer to structure */
+
+   const Word16 *homing;   /* pointer to homing frame */
+   Word16 homingSize;   /* frame size for homing frame */
+   Word32 i;   /* counter */
+   Word32 resetFlag = 1;   /* homing frame */
+
+#ifndef ETSI
+#ifndef IF2
+   Word16 q_bit;
+#endif
+#endif
+
+   s = ( dec_interface_State * )st;
+
+#ifndef ETSI
+
+   /*
+    * extract mode information and frametype,
+    * octets to parameters
+    */
+#ifdef IF2
+   mode = Decoder3GPP( prm, bits, &frame_type, &speech_mode );
+#else
+   mode = DecoderMMS( prm, bits, &frame_type, &speech_mode, &q_bit );
+   if (!bfi)	bfi = 1 - q_bit;
+#endif
+
+   if ( bfi == 1 ) {
+      if ( mode <= MR122 ) {
+         frame_type = RX_SPEECH_BAD;
+      }
+      else if ( frame_type != RX_NO_DATA ) {
+         frame_type = RX_SID_BAD;
+         mode = s->prev_mode;
+      }
+   } else {
+       if ( frame_type == RX_SID_FIRST || frame_type == RX_SID_UPDATE) {
+           mode = speech_mode;
+       }
+       else if ( frame_type == RX_NO_DATA ) {
+           mode = s->prev_mode;
+       }
+       /*
+        * if no mode information
+        * guess one from the previous frame
+        */
+       if ( frame_type == RX_SPEECH_BAD ) {
+          mode = s->prev_mode;
+          if ( s->prev_ft >= RX_SID_FIRST ) {
+             frame_type = RX_SID_BAD;
+          }
+       }
+   }
+#else
+   bfi = 0;
+   frame_type = bits[0];
+
+   switch ( frame_type ) {
+      case 0:
+         frame_type = RX_SPEECH_GOOD;
+         mode = bits[245];
+         Bits2Prm( mode, &bits[1], prm );
+         break;
+
+      case 1:
+         frame_type = RX_SID_FIRST;
+         mode = bits[245];
+         break;
+
+      case 2:
+         frame_type = RX_SID_UPDATE;
+         mode = bits[245];
+         Bits2Prm( MRDTX, &bits[1], prm );
+         break;
+
+      case 3:
+         frame_type = RX_NO_DATA;
+         mode = s->prev_mode;
+         break;
+   }
+#endif
+
+   /* test for homing frame */
+   if ( s->reset_flag_old == 1 ) {
+      switch ( mode ) {
+         case MR122:
+            homing = dhf_MR122;
+            homingSize = 18;
+            break;
+
+         case MR102:
+            homing = dhf_MR102;
+            homingSize = 12;
+            break;
+
+         case MR795:
+            homing = dhf_MR795;
+            homingSize = 8;
+            break;
+
+         case MR74:
+            homing = dhf_MR74;
+            homingSize = 7;
+            break;
+
+         case MR67:
+            homing = dhf_MR67;
+            homingSize = 7;
+            break;
+
+         case MR59:
+            homing = dhf_MR59;
+            homingSize = 7;
+            break;
+
+         case MR515:
+            homing = dhf_MR515;
+            homingSize = 7;
+            break;
+
+         case MR475:
+            homing = dhf_MR475;
+            homingSize = 7;
+            break;
+
+         default:
+            homing = NULL;
+            homingSize = 0;
+            break;
+      }
+
+      for ( i = 0; i < homingSize; i++ ) {
+         resetFlag = prm[i] ^ homing[i];
+
+         if ( resetFlag )
+            break;
+      }
+   }
+
+   if ( ( resetFlag == 0 ) && ( s->reset_flag_old != 0 ) ) {
+      for ( i = 0; i < 160; i++ ) {
+         synth[i] = EHF_MASK;
+      }
+   }
+   else
+      Speech_Decode_Frame( s->decoder_State, mode, prm, frame_type, synth );
+
+   if ( s->reset_flag_old == 0 ) {
+      /* check whole frame */
+      switch ( mode ) {
+         case MR122:
+            homing = dhf_MR122;
+            homingSize = PRMNO_MR122;
+            break;
+
+         case MR102:
+            homing = dhf_MR102;
+            homingSize = PRMNO_MR102;
+            break;
+
+         case MR795:
+            homing = dhf_MR795;
+            homingSize = PRMNO_MR795;
+            break;
+
+         case MR74:
+            homing = dhf_MR74;
+            homingSize = PRMNO_MR74;
+            break;
+
+         case MR67:
+            homing = dhf_MR67;
+            homingSize = PRMNO_MR67;
+            break;
+
+         case MR59:
+            homing = dhf_MR59;
+            homingSize = PRMNO_MR59;
+            break;
+
+         case MR515:
+            homing = dhf_MR515;
+            homingSize = PRMNO_MR515;
+            break;
+
+         case MR475:
+            homing = dhf_MR475;
+            homingSize = PRMNO_MR475;
+            break;
+
+         default:
+            homing = NULL;
+            homingSize = 0;
+      }
+
+      for ( i = 0; i < homingSize; i++ ) {
+         resetFlag = prm[i] ^ homing[i];
+
+         if ( resetFlag )
+            break;
+      }
+   }
+
+   /* reset decoder if current frame is a homing frame */
+   if ( resetFlag == 0 ) {
+      Speech_Decode_Frame_reset( s->decoder_State );
+   }
+   s->reset_flag_old = !resetFlag;
+   s->prev_ft = frame_type;
+   s->prev_mode = mode;
+}
+  
\ No newline at end of file
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/amr/interf_dec.h asterisk-1.8.3.2_com_amr/codecs/amr/interf_dec.h
--- asterisk-1.8.3.2_com_rtsp/codecs/amr/interf_dec.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/amr/interf_dec.h	2012-03-26 16:29:06.000000000 +0100
@@ -0,0 +1,55 @@
+/*
+ * ===================================================================
+ *  TS 26.104
+ *  REL-5 V5.4.0 2004-03
+ *  REL-6 V6.1.0 2004-03
+ *  3GPP AMR Floating-point Speech Codec
+ * ===================================================================
+ *
+ */
+
+/*
+ * interf_dec.h
+ *
+ *
+ * Project:
+ *    AMR Floating-Point Codec
+ *
+ * Contains:
+ *    Defines interface to AMR decoder
+ *
+ */
+
+#ifndef _interf_dec_h_
+#define _interf_dec_h_
+
+/*
+ * Function prototypes
+ */
+/*
+ * Conversion from packed bitstream to endoded parameters
+ * Decoding parameters to speech
+ */
+void Decoder_Interface_Decode( void *st,
+
+#ifndef ETSI
+      unsigned char *bits,
+
+#else
+      short *bits,
+#endif
+
+      short *synth, int bfi );
+
+/*
+ * Reserve and init. memory
+ */
+void *Decoder_Interface_init( void );
+
+/*
+ * Exit and free memory
+ */
+void Decoder_Interface_exit( void *state );
+
+#endif
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/amr/.interf_dec.o.d asterisk-1.8.3.2_com_amr/codecs/amr/.interf_dec.o.d
--- asterisk-1.8.3.2_com_rtsp/codecs/amr/.interf_dec.o.d	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/amr/.interf_dec.o.d	2012-03-28 11:20:26.000000000 +0100
@@ -0,0 +1,94 @@
+interf_dec.o interf_dec.o: interf_dec.c /usr/include/stdlib.h \
+  /usr/include/features.h /usr/include/sys/cdefs.h \
+  /usr/include/bits/wordsize.h /usr/include/gnu/stubs.h \
+  /usr/include/gnu/stubs-32.h \
+  /usr/lib/gcc/i386-redhat-linux/4.1.2/include/stddef.h \
+  /usr/include/sys/types.h /usr/include/bits/types.h \
+  /usr/include/bits/typesizes.h /usr/include/time.h /usr/include/endian.h \
+  /usr/include/bits/endian.h /usr/include/sys/select.h \
+  /usr/include/bits/select.h /usr/include/bits/sigset.h \
+  /usr/include/bits/time.h /usr/include/sys/sysmacros.h \
+  /usr/include/bits/pthreadtypes.h /usr/include/alloca.h \
+  /usr/include/stdio.h /usr/include/libio.h /usr/include/_G_config.h \
+  /usr/include/wchar.h /usr/include/bits/wchar.h /usr/include/gconv.h \
+  /usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h \
+  /usr/include/bits/stdio_lim.h /usr/include/bits/sys_errlist.h \
+  /usr/include/bits/stdio.h /usr/include/memory.h /usr/include/string.h \
+  /usr/include/bits/string.h /usr/include/bits/string2.h typedef.h \
+  sp_dec.h interf_rom.h rom_dec.h
+
+/usr/include/stdlib.h:
+
+/usr/include/features.h:
+
+/usr/include/sys/cdefs.h:
+
+/usr/include/bits/wordsize.h:
+
+/usr/include/gnu/stubs.h:
+
+/usr/include/gnu/stubs-32.h:
+
+/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stddef.h:
+
+/usr/include/sys/types.h:
+
+/usr/include/bits/types.h:
+
+/usr/include/bits/typesizes.h:
+
+/usr/include/time.h:
+
+/usr/include/endian.h:
+
+/usr/include/bits/endian.h:
+
+/usr/include/sys/select.h:
+
+/usr/include/bits/select.h:
+
+/usr/include/bits/sigset.h:
+
+/usr/include/bits/time.h:
+
+/usr/include/sys/sysmacros.h:
+
+/usr/include/bits/pthreadtypes.h:
+
+/usr/include/alloca.h:
+
+/usr/include/stdio.h:
+
+/usr/include/libio.h:
+
+/usr/include/_G_config.h:
+
+/usr/include/wchar.h:
+
+/usr/include/bits/wchar.h:
+
+/usr/include/gconv.h:
+
+/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h:
+
+/usr/include/bits/stdio_lim.h:
+
+/usr/include/bits/sys_errlist.h:
+
+/usr/include/bits/stdio.h:
+
+/usr/include/memory.h:
+
+/usr/include/string.h:
+
+/usr/include/bits/string.h:
+
+/usr/include/bits/string2.h:
+
+typedef.h:
+
+sp_dec.h:
+
+interf_rom.h:
+
+rom_dec.h:
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/amr/interf_enc.c asterisk-1.8.3.2_com_amr/codecs/amr/interf_enc.c
--- asterisk-1.8.3.2_com_rtsp/codecs/amr/interf_enc.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/amr/interf_enc.c	2012-03-26 16:29:06.000000000 +0100
@@ -0,0 +1,798 @@
+/*
+ * ===================================================================
+ *  TS 26.104
+ *  REL-5 V5.4.0 2004-03
+ *  REL-6 V6.1.0 2004-03
+ *  3GPP AMR Floating-point Speech Codec
+ * ===================================================================
+ *
+ */
+
+/*
+ * interf_enc.c
+ *
+ *
+ * Project:
+ *    AMR Floating-Point Codec
+ *
+ * Contains:
+ *    This module contains all the functions needed encoding 160
+ *    16-bit speech samples to AMR encoder parameters.
+ *
+ */
+
+/*
+ * include files
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <memory.h>
+#include "sp_enc.h"
+#include "interf_rom.h"
+
+/*
+ * Declare structure types
+ */
+/* Declaration transmitted frame types */
+enum TXFrameType { TX_SPEECH_GOOD = 0,
+                   TX_SID_FIRST,
+                   TX_SID_UPDATE,
+                   TX_NO_DATA,
+                   TX_SPEECH_DEGRADED,
+                   TX_SPEECH_BAD,
+                   TX_SID_BAD,
+                   TX_ONSET,
+                   TX_N_FRAMETYPES     /* number of frame types */
+};
+
+/* Declaration of interface structure */
+typedef struct
+{
+   Word16 sid_update_counter;   /* Number of frames since last SID */
+   Word16 sid_handover_debt;   /* Number of extra SID_UPD frames to schedule */
+   Word32 dtx;
+   enum TXFrameType prev_ft;   /* Type of the previous frame */
+   void *encoderState;   /* Points encoder state structure */
+} enc_interface_State;
+
+
+#ifdef ETSI
+/*
+ * Prm2Bits
+ *
+ *
+ * Parameters:
+ *    value             I: value to be converted to binary
+ *    no_of_bits        I: number of bits associated with value
+ *    bitstream         O: address where bits are written
+ *
+ * Function:
+ *    Convert integer to binary and write the bits to the array.
+ *    The most significant bits are written first.
+ * Returns:
+ *    void
+ */
+static void Int2Bin( Word16 value, Word16 no_of_bits, Word16 *bitstream )
+{
+   Word32 i, bit;
+   Word16 *pt_bitstream;
+
+   pt_bitstream = &bitstream[no_of_bits];
+
+   for ( i = 0; i < no_of_bits; i++ ) {
+      bit = value & 0x0001;
+
+      if ( bit == 0 ) {
+         * --pt_bitstream = 0;
+      }
+      else {
+         * --pt_bitstream = 1;
+      }
+      value = ( Word16 )( value >> 1 );
+   }
+}
+
+
+/*
+ * Prm2Bits
+ *
+ *
+ * Parameters:
+ *    mode              I: AMR mode
+ *    prm               I: analysis parameters
+ *    bits              O: serial bits
+ *
+ * Function:
+ *    converts the encoder parameter vector into a vector of serial bits.
+ * Returns:
+ *    void
+ */
+static void Prm2Bits( enum Mode mode, Word16 prm[], Word16 bits[] )
+{
+   Word32 i;
+
+   switch ( mode ) {
+      case MR122:
+         for ( i = 0; i < PRMNO_MR122; i++ ) {
+            Int2Bin( prm[i], bitno_MR122[i], bits );
+            bits += bitno_MR122[i];
+         }
+         break;
+
+      case MR102:
+         for ( i = 0; i < PRMNO_MR102; i++ ) {
+            Int2Bin( prm[i], bitno_MR102[i], bits );
+            bits += bitno_MR102[i];
+         }
+         break;
+
+      case MR795:
+         for ( i = 0; i < PRMNO_MR795; i++ ) {
+            Int2Bin( prm[i], bitno_MR795[i], bits );
+            bits += bitno_MR795[i];
+         }
+         break;
+
+      case MR74:
+         for ( i = 0; i < PRMNO_MR74; i++ ) {
+            Int2Bin( prm[i], bitno_MR74[i], bits );
+            bits += bitno_MR74[i];
+         }
+         break;
+
+      case MR67:
+         for ( i = 0; i < PRMNO_MR67; i++ ) {
+            Int2Bin( prm[i], bitno_MR67[i], bits );
+            bits += bitno_MR67[i];
+         }
+         break;
+
+      case MR59:
+         for ( i = 0; i < PRMNO_MR59; i++ ) {
+            Int2Bin( prm[i], bitno_MR59[i], bits );
+            bits += bitno_MR59[i];
+         }
+         break;
+
+      case MR515:
+         for ( i = 0; i < PRMNO_MR515; i++ ) {
+            Int2Bin( prm[i], bitno_MR515[i], bits );
+            bits += bitno_MR515[i];
+         }
+         break;
+
+      case MR475:
+         for ( i = 0; i < PRMNO_MR475; i++ ) {
+            Int2Bin( prm[i], bitno_MR475[i], bits );
+            bits += bitno_MR475[i];
+         }
+         break;
+
+      case MRDTX:
+         for ( i = 0; i < PRMNO_MRDTX; i++ ) {
+            Int2Bin( prm[i], bitno_MRDTX[i], bits );
+            bits += bitno_MRDTX[i];
+         }
+         break;
+   }
+   return;
+}
+
+#else
+
+#ifndef IF2
+
+/*
+ * EncoderMMS
+ *
+ *
+ * Parameters:
+ *    mode                 I: AMR mode
+ *    param                I: Encoder output parameters
+ *    stream               O: packed speech frame
+ *    frame_type           I: frame type (DTX)
+ *    speech_mode          I: speech mode (DTX)
+ *
+ * Function:
+ *    Pack encoder output parameters to octet structure according
+ *    importance table and AMR file storage format according to
+ *    RFC 3267.
+ * Returns:
+ *    number of octets
+ */
+static int EncoderMMS( enum Mode mode, Word16 *param, UWord8 *stream, enum
+      TXFrameType frame_type, enum Mode speech_mode )
+{
+   Word32 j = 0, k;
+   Word16 *mask;
+
+   memset(stream, 0, block_size[mode]);
+
+   *stream = toc_byte[mode];
+   stream++;
+
+   if ( mode == 15 ) {
+      return 1;
+   }
+   else if ( mode == MRDTX ) {
+      mask = order_MRDTX;
+
+      for ( j = 1; j < 36; j++ ) {
+         if ( param[ * mask] & *( mask + 1 ) )
+            *stream += 0x01;
+         mask += 2;
+
+         if ( j % 8 )
+            *stream <<= 1;
+         else
+            stream++;
+      }
+
+      /* add SID type information */
+      if ( frame_type == TX_SID_UPDATE )
+         *stream += 0x01;
+      *stream <<= 3;
+
+      /* speech mode indication */
+      *stream += ( unsigned char )(((speech_mode & 0x0001) << 2) | (speech_mode & 0x0002) | ((speech_mode & 0x0004) >> 2));
+
+	  *stream <<= 1;
+
+      /* don't shift at the end of the function */
+      return 6;
+   }
+   else if ( mode == MR475 ) {
+      mask = order_MR475;
+
+      for ( j = 1; j < 96; j++ ) {
+         if ( param[ * mask] & *( mask + 1 ) )
+            *stream += 0x01;
+         mask += 2;
+
+         if ( j % 8 )
+            *stream <<= 1;
+         else
+            stream++;
+      }
+   }
+   else if ( mode == MR515 ) {
+      mask = order_MR515;
+
+      for ( j = 1; j < 104; j++ ) {
+         if ( param[ * mask] & *( mask + 1 ) )
+            *stream += 0x01;
+         mask += 2;
+
+         if ( j % 8 )
+            *stream <<= 1;
+         else
+            stream++;
+      }
+   }
+   else if ( mode == MR59 ) {
+      mask = order_MR59;
+
+      for ( j = 1; j < 119; j++ ) {
+         if ( param[ * mask] & *( mask + 1 ) )
+            *stream += 0x01;
+         mask += 2;
+
+         if ( j % 8 )
+            *stream <<= 1;
+         else
+            stream++;
+      }
+   }
+   else if ( mode == MR67 ) {
+      mask = order_MR67;
+
+      for ( j = 1; j < 135; j++ ) {
+         if ( param[ * mask] & *( mask + 1 ) )
+            *stream += 0x01;
+         mask += 2;
+
+         if ( j % 8 )
+            *stream <<= 1;
+         else
+            stream++;
+      }
+   }
+   else if ( mode == MR74 ) {
+      mask = order_MR74;
+
+      for ( j = 1; j < 149; j++ ) {
+         if ( param[ * mask] & *( mask + 1 ) )
+            *stream += 0x01;
+         mask += 2;
+
+         if ( j % 8 )
+            *stream <<= 1;
+         else
+            stream++;
+      }
+   }
+   else if ( mode == MR795 ) {
+      mask = order_MR795;
+
+      for ( j = 1; j < 160; j++ ) {
+         if ( param[ * mask] & *( mask + 1 ) )
+            *stream += 0x01;
+         mask += 2;
+
+         if ( j % 8 )
+            *stream <<= 1;
+         else
+            stream++;
+      }
+   }
+   else if ( mode == MR102 ) {
+      mask = order_MR102;
+
+      for ( j = 1; j < 205; j++ ) {
+         if ( param[ * mask] & *( mask + 1 ) )
+            *stream += 0x01;
+         mask += 2;
+
+         if ( j % 8 )
+            *stream <<= 1;
+         else
+            stream++;
+      }
+   }
+   else if ( mode == MR122 ) {
+      mask = order_MR122;
+
+      for ( j = 1; j < 245; j++ ) {
+         if ( param[ * mask] & *( mask + 1 ) )
+            *stream += 0x01;
+         mask += 2;
+
+         if ( j % 8 )
+            *stream <<= 1;
+         else
+            stream++;
+      }
+   }
+
+   /* shift remaining bits */
+   if ( k = j % 8 )	*stream <<= ( 8 - k );
+   return( (int)block_size[mode] );
+}
+
+#else
+
+/*
+ * Encoder3GPP
+ *
+ *
+ * Parameters:
+ *    mode                 I: AMR mode
+ *    param                I: Encoder output parameters
+ *    stream               O: packed speech frame
+ *    frame_type           I: frame type (DTX)
+ *    speech_mode          I: speech mode (DTX)
+ *
+ * Function:
+ *    Pack encoder output parameters to octet structure according
+ *    importance table.
+ * Returns:
+ *    number of octets
+ */
+static int Encoder3GPP( enum Mode mode, Word16 *param, UWord8 *stream, enum
+      TXFrameType frame_type, enum Mode speech_mode )
+{
+   Word32 j = 0;
+   Word16 *mask;
+
+   memset(stream, 0, block_size[mode]);
+
+   if ( mode == 15 ) {
+      *stream = 0xF;
+      return 1;
+   }
+   else if ( mode == MRDTX ) {
+      mask = order_MRDTX;
+      *stream = 0x40;
+
+      for ( j = 5; j < 40; j++ ) {
+         if ( param[ * mask] & *( mask + 1 ) )
+            *stream += 0x80;
+         mask += 2;
+
+         if ( j % 8 )
+            *stream >>= 1;
+         else
+            stream++;
+      }
+
+      /* add SID type information */
+      if ( frame_type == TX_SID_UPDATE )
+         *stream += 0x80;
+      stream++;
+
+      /* speech mode indication */
+      *stream = ( unsigned char )speech_mode;
+
+      /* don't shift at the end of the function */
+      return 6;
+   }
+   else if ( mode == MR475 ) {
+      mask = order_MR475;
+      *stream = 0;
+
+      for ( j = 5; j < 100; j++ ) {
+         if ( param[ * mask] & *( mask + 1 ) )
+            *stream += 0x80;
+         mask += 2;
+
+         if ( j % 8 )
+            *stream >>= 1;
+         else
+            stream++;
+      }
+   }
+   else if ( mode == MR515 ) {
+      mask = order_MR515;
+      *stream = 0x8;
+
+      for ( j = 5; j < 108; j++ ) {
+         if ( param[ * mask] & *( mask + 1 ) )
+            *stream += 0x80;
+         mask += 2;
+
+         if ( j % 8 )
+            *stream >>= 1;
+         else
+            stream++;
+      }
+   }
+   else if ( mode == MR59 ) {
+      mask = order_MR59;
+      *stream = 0x10;
+
+      for ( j = 5; j < 123; j++ ) {
+         if ( param[ * mask] & *( mask + 1 ) )
+            *stream += 0x80;
+         mask += 2;
+
+         if ( j % 8 )
+            *stream >>= 1;
+         else
+            stream++;
+      }
+   }
+   else if ( mode == MR67 ) {
+      mask = order_MR67;
+      *stream = 0x18;
+
+      for ( j = 5; j < 139; j++ ) {
+         if ( param[ * mask] & *( mask + 1 ) )
+            *stream += 0x80;
+         mask += 2;
+
+         if ( j % 8 )
+            *stream >>= 1;
+         else
+            stream++;
+      }
+   }
+   else if ( mode == MR74 ) {
+      mask = order_MR74;
+      *stream = 0x20;
+
+      for ( j = 5; j < 153; j++ ) {
+         if ( param[ * mask] & *( mask + 1 ) )
+            *stream += 0x80;
+         mask += 2;
+
+         if ( j % 8 )
+            *stream >>= 1;
+         else
+            stream++;
+      }
+   }
+   else if ( mode == MR795 ) {
+      mask = order_MR795;
+      *stream = 0x28;
+
+      for ( j = 5; j < 164; j++ ) {
+         if ( param[ * mask] & *( mask + 1 ) )
+            *stream += 0x80;
+         mask += 2;
+
+         if ( j % 8 )
+            *stream >>= 1;
+         else
+            stream++;
+      }
+   }
+   else if ( mode == MR102 ) {
+      mask = order_MR102;
+      *stream = 0x30;
+
+      for ( j = 5; j < 209; j++ ) {
+         if ( param[ * mask] & *( mask + 1 ) )
+            *stream += 0x80;
+         mask += 2;
+
+         if ( j % 8 )
+            *stream >>= 1;
+         else
+            stream++;
+      }
+   }
+   else if ( mode == MR122 ) {
+      mask = order_MR122;
+      *stream = 0x38;
+
+      for ( j = 5; j < 249; j++ ) {
+         if ( param[ * mask] & *( mask + 1 ) )
+            *stream += 0x80;
+         mask += 2;
+
+         if ( j % 8 )
+            *stream >>= 1;
+         else
+            stream++;
+      }
+   }
+
+   /* shift remaining bits */
+   *stream >>= ( 8 - j % 8 );
+   return( (int)block_size[mode] );
+}
+#endif
+#endif
+
+/*
+ * Sid_Sync_reset
+ *
+ *
+ * Parameters:
+ *    st                O: state structure
+ *
+ * Function:
+ *    Initializes state memory
+ *
+ * Returns:
+ *    void
+ */
+static void Sid_Sync_reset( enc_interface_State *st )
+{
+   st->sid_update_counter = 3;
+   st->sid_handover_debt = 0;
+   st->prev_ft = TX_SPEECH_GOOD;
+}
+
+
+/*
+ * Encoder_Interface_Encode
+ *
+ *
+ * Parameters:
+ *    st                I: pointer to state structure
+ *    mode              I: Speech Mode
+ *    speech            I: Input speech
+ *    serial            O: Output octet structure 3GPP or
+ *                         ETSI serial stream
+ *    force_speech      I: Force speech in DTX
+ *
+ * Function:
+ *    Encoding and packing one frame of speech
+ *
+ * Returns:
+ *    number of octets
+ */
+int Encoder_Interface_Encode( void *st, enum Mode mode, Word16 *speech,
+
+#ifndef ETSI
+      UWord8 *serial,
+
+#else
+      Word16 *serial,
+#endif
+
+      int force_speech )
+{
+   Word16 prm[PRMNO_MR122];   /* speech parameters, max size */
+   const Word16 *homing;   /* pointer to homing frame */
+   Word16 homing_size;   /* frame size for homing frame */
+
+
+   enc_interface_State * s;
+   enum TXFrameType txFrameType;   /* frame type */
+
+   int i, noHoming = 0;
+
+
+   /*
+    * used encoder mode,
+    * if used_mode == -1, force VAD on
+    */
+   enum Mode used_mode = -force_speech;
+
+
+   s = ( enc_interface_State * )st;
+
+    /*
+     * Checks if all samples of the input frame matches the encoder
+     * homing frame pattern, which is 0x0008 for all samples.
+     */
+   for ( i = 0; i < 160; i++ ) {
+      noHoming = speech[i] ^ 0x0008;
+
+      if ( noHoming )
+         break;
+   }
+
+   if (noHoming){
+      Speech_Encode_Frame( s->encoderState, mode, speech, prm, &used_mode );
+   }
+   else {
+      switch ( mode ) {
+         case MR122:
+            homing = dhf_MR122;
+            homing_size = 18;
+            break;
+
+         case MR102:
+            homing = dhf_MR102;
+            homing_size = 12;
+            break;
+
+         case MR795:
+            homing = dhf_MR795;
+            homing_size = 8;
+            break;
+
+         case MR74:
+            homing = dhf_MR74;
+            homing_size = 7;
+            break;
+
+         case MR67:
+            homing = dhf_MR67;
+            homing_size = 7;
+            break;
+
+         case MR59:
+            homing = dhf_MR59;
+            homing_size = 7;
+            break;
+
+         case MR515:
+            homing = dhf_MR515;
+            homing_size = 7;
+            break;
+
+         case MR475:
+            homing = dhf_MR475;
+            homing_size = 7;
+            break;
+
+         default:
+            homing = NULL;
+            homing_size = 0;
+            break;
+      }
+      for( i = 0; i < homing_size; i++){
+         prm[i] = homing[i];
+      }
+      /* rest of the parameters are zero */
+      memset(&prm[homing_size], 0, (PRMNO_MR122 - homing_size) << 1);
+      used_mode = mode;
+   }
+   if ( used_mode == MRDTX ) {
+      s->sid_update_counter--;
+
+      if ( s->prev_ft == TX_SPEECH_GOOD ) {
+         txFrameType = TX_SID_FIRST;
+         s->sid_update_counter = 3;
+      }
+      else {
+         /* TX_SID_UPDATE or TX_NO_DATA */
+         if ( ( s->sid_handover_debt > 0 ) && ( s->sid_update_counter > 2 ) ) {
+              /*
+               * ensure extra updates are properly delayed after
+               * a possible SID_FIRST
+               */
+            txFrameType = TX_SID_UPDATE;
+            s->sid_handover_debt--;
+         }
+         else {
+            if ( s->sid_update_counter == 0 ) {
+               txFrameType = TX_SID_UPDATE;
+               s->sid_update_counter = 8;
+            }
+            else {
+               txFrameType = TX_NO_DATA;
+               used_mode = 15;
+            }
+         }
+      }
+   }
+   else {
+      s->sid_update_counter = 8;
+      txFrameType = TX_SPEECH_GOOD;
+   }
+   s->prev_ft = txFrameType;
+
+   if ( noHoming == 0 ) {
+      Speech_Encode_Frame_reset( s->encoderState, s->dtx );
+      Sid_Sync_reset( s );
+   }
+
+#ifndef ETSI
+#ifdef IF2
+   return Encoder3GPP( used_mode, prm, serial, txFrameType, mode );
+
+#else
+   return EncoderMMS( used_mode, prm, serial, txFrameType, mode );
+
+#endif
+#else
+
+   Prm2Bits( used_mode, prm, &serial[1] );
+   serial[0] = ( Word16 )txFrameType;
+   serial[245] = ( Word16 )mode;
+   return 500;
+#endif
+
+}
+
+
+/*
+ * Encoder_Interface_init
+ *
+ *
+ * Parameters:
+ *    dtx               I: DTX flag
+ *
+ * Function:
+ *    Allocates state memory and initializes state memory
+ *
+ * Returns:
+ *    pointer to encoder interface structure
+ */
+void * Encoder_Interface_init( int dtx )
+{
+   enc_interface_State * s;
+
+   /* allocate memory */
+   if ( ( s = ( enc_interface_State * ) malloc( sizeof( enc_interface_State ) ) ) ==
+         NULL ) {
+      fprintf( stderr, "Encoder_Interface_init: "
+            "can not malloc state structure\n" );
+      return NULL;
+   }
+   s->encoderState = Speech_Encode_Frame_init( dtx );
+   Sid_Sync_reset( s );
+   s->dtx = dtx;
+   return s;
+}
+
+
+/*
+ * DecoderInterfaceExit
+ *
+ *
+ * Parameters:
+ *    state             I: state structure
+ *
+ * Function:
+ *    The memory used for state memory is freed
+ *
+ * Returns:
+ *    Void
+ */
+void Encoder_Interface_exit( void *state )
+{
+   enc_interface_State * s;
+   s = ( enc_interface_State * )state;
+
+   /* free memory */
+   Speech_Encode_Frame_exit( &s->encoderState );
+   free( s );
+   state = NULL;
+}
+  
\ No newline at end of file
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/amr/interf_enc.h asterisk-1.8.3.2_com_amr/codecs/amr/interf_enc.h
--- asterisk-1.8.3.2_com_rtsp/codecs/amr/interf_enc.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/amr/interf_enc.h	2012-03-26 16:29:06.000000000 +0100
@@ -0,0 +1,58 @@
+/*
+ * ===================================================================
+ *  TS 26.104
+ *  REL-5 V5.4.0 2004-03
+ *  REL-6 V6.1.0 2004-03
+ *  3GPP AMR Floating-point Speech Codec
+ * ===================================================================
+ *
+ */
+
+/*
+ * interf_enc.h
+ *
+ *
+ * Project:
+ *    AMR Floating-Point Codec
+ *
+ * Contains:
+ *    Defines interface to AMR encoder
+ *
+ */
+
+#ifndef _interf_enc_h_
+#define _interf_enc_h_
+
+/*
+ * include files
+ */
+#include"sp_enc.h"
+
+/*
+ * Function prototypes
+ */
+/*
+ * Encodes one frame of speech
+ * Returns packed octets
+ */
+int Encoder_Interface_Encode( void *st, enum Mode mode, short *speech,
+
+#ifndef ETSI
+      unsigned char *serial,  /* max size 31 bytes */
+
+#else
+      short *serial, /* size 500 bytes */
+#endif
+
+      int forceSpeech );   /* use speech mode */
+
+/*
+ * Reserve and init. memory
+ */
+void *Encoder_Interface_init( int dtx );
+
+/*
+ * Exit and free memory
+ */
+void Encoder_Interface_exit( void *state );
+#endif
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/amr/.interf_enc.o.d asterisk-1.8.3.2_com_amr/codecs/amr/.interf_enc.o.d
--- asterisk-1.8.3.2_com_rtsp/codecs/amr/.interf_enc.o.d	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/amr/.interf_enc.o.d	2012-03-28 11:20:26.000000000 +0100
@@ -0,0 +1,92 @@
+interf_enc.o interf_enc.o: interf_enc.c /usr/include/stdlib.h \
+  /usr/include/features.h /usr/include/sys/cdefs.h \
+  /usr/include/bits/wordsize.h /usr/include/gnu/stubs.h \
+  /usr/include/gnu/stubs-32.h \
+  /usr/lib/gcc/i386-redhat-linux/4.1.2/include/stddef.h \
+  /usr/include/sys/types.h /usr/include/bits/types.h \
+  /usr/include/bits/typesizes.h /usr/include/time.h /usr/include/endian.h \
+  /usr/include/bits/endian.h /usr/include/sys/select.h \
+  /usr/include/bits/select.h /usr/include/bits/sigset.h \
+  /usr/include/bits/time.h /usr/include/sys/sysmacros.h \
+  /usr/include/bits/pthreadtypes.h /usr/include/alloca.h \
+  /usr/include/stdio.h /usr/include/libio.h /usr/include/_G_config.h \
+  /usr/include/wchar.h /usr/include/bits/wchar.h /usr/include/gconv.h \
+  /usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h \
+  /usr/include/bits/stdio_lim.h /usr/include/bits/sys_errlist.h \
+  /usr/include/bits/stdio.h /usr/include/memory.h /usr/include/string.h \
+  /usr/include/bits/string.h /usr/include/bits/string2.h sp_enc.h \
+  typedef.h interf_rom.h
+
+/usr/include/stdlib.h:
+
+/usr/include/features.h:
+
+/usr/include/sys/cdefs.h:
+
+/usr/include/bits/wordsize.h:
+
+/usr/include/gnu/stubs.h:
+
+/usr/include/gnu/stubs-32.h:
+
+/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stddef.h:
+
+/usr/include/sys/types.h:
+
+/usr/include/bits/types.h:
+
+/usr/include/bits/typesizes.h:
+
+/usr/include/time.h:
+
+/usr/include/endian.h:
+
+/usr/include/bits/endian.h:
+
+/usr/include/sys/select.h:
+
+/usr/include/bits/select.h:
+
+/usr/include/bits/sigset.h:
+
+/usr/include/bits/time.h:
+
+/usr/include/sys/sysmacros.h:
+
+/usr/include/bits/pthreadtypes.h:
+
+/usr/include/alloca.h:
+
+/usr/include/stdio.h:
+
+/usr/include/libio.h:
+
+/usr/include/_G_config.h:
+
+/usr/include/wchar.h:
+
+/usr/include/bits/wchar.h:
+
+/usr/include/gconv.h:
+
+/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h:
+
+/usr/include/bits/stdio_lim.h:
+
+/usr/include/bits/sys_errlist.h:
+
+/usr/include/bits/stdio.h:
+
+/usr/include/memory.h:
+
+/usr/include/string.h:
+
+/usr/include/bits/string.h:
+
+/usr/include/bits/string2.h:
+
+sp_enc.h:
+
+typedef.h:
+
+interf_rom.h:
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/amr/interf_rom.h asterisk-1.8.3.2_com_amr/codecs/amr/interf_rom.h
--- asterisk-1.8.3.2_com_rtsp/codecs/amr/interf_rom.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/amr/interf_rom.h	2012-03-26 16:29:06.000000000 +0100
@@ -0,0 +1,1802 @@
+/*
+ * ===================================================================
+ *  TS 26.104
+ *  REL-5 V5.4.0 2004-03
+ *  REL-6 V6.1.0 2004-03
+ *  3GPP AMR Floating-point Speech Codec
+ * ===================================================================
+ *
+ */
+
+/*
+ * interf_rom.h
+ *
+ *
+ * Project:
+ *    AMR Floating-Point Codec
+ *
+ * Contains:
+ *    Tables:           Subjective importance
+ *                      Homing frames
+ *
+ *
+ */
+
+#ifndef _interf_rom_h_
+#define _interf_rom_h_
+
+/*
+ * include files
+ */
+#include"typedef.h"
+
+/*
+ * definition of constants
+ */
+
+/* number of parameters */
+#define PRMNO_MR475 17
+#define PRMNO_MR515 19
+#define PRMNO_MR59  19
+#define PRMNO_MR67  19
+#define PRMNO_MR74  19
+#define PRMNO_MR795 23
+#define PRMNO_MR102 39
+#define PRMNO_MR122 57
+#define PRMNO_MRDTX 5
+
+/*
+ * tables
+ */
+#ifndef IF2
+#ifndef ETSI
+static const UWord8 block_size[16]={ 13, 14, 16, 18, 20, 21, 27, 32,
+                                    6 , 0 , 0 , 0 , 0 , 0 , 0 , 1  };
+
+static const UWord8 toc_byte[16]={0x04, 0x0C, 0x14, 0x1C, 0x24, 0x2C, 0x34, 0x3C,
+								  0x44, 0x4C, 0x54, 0x5C, 0x64, 0x6C, 0x74, 0x7C};
+#endif
+#else
+/* One encoded frame (bytes) */
+static const UWord8 block_size[16]={ 13, 14, 16, 18, 19, 21, 26, 31,
+                                    5 , 0 , 0 , 0 , 0 , 0 , 0 , 1  };
+#endif
+
+/* Subjective importance of the speech encoded bits */
+static Word16 order_MR475[] =
+{
+   0, 0x80,
+   0, 0x40,
+   0, 0x20,
+   0, 0x10,
+   0, 0x8,
+   0, 0x4,
+   0, 0x2,
+   0, 0x1,
+   1, 0x80,
+   1, 0x40,
+   1, 0x20,
+   1, 0x10,
+   1, 0x8,
+   1, 0x4,
+   1, 0x2,
+   1, 0x1,
+   3, 0x80,
+   3, 0x40,
+   3, 0x20,
+   3, 0x10,
+   3, 0x8,
+   3, 0x4,
+   7, 0x8,
+   7, 0x4,
+   10, 0x8,
+   10, 0x4,
+   14, 0x8,
+   14, 0x4,
+   6, 0x1,
+   6, 0x2,
+   6, 0x4,
+   6, 0x8,
+   13, 0x1,
+   13, 0x2,
+   13, 0x4,
+   13, 0x8,
+   2, 0x20,
+   2, 0x10,
+   2, 0x4,
+   2, 0x1,
+   13, 0x10,
+   13, 0x20,
+   13, 0x40,
+   13, 0x80,
+   3, 0x2,
+   3, 0x1,
+   6, 0x10,
+   6, 0x20,
+   6, 0x40,
+   6, 0x80,
+   5, 0x2,
+   5, 0x1,
+   2, 0x40,
+   2, 0x8,
+   2, 0x2,
+   7, 0x2,
+   7, 0x1,
+   9, 0x2,
+   9, 0x1,
+   10, 0x2,
+   10, 0x1,
+   12, 0x2,
+   12, 0x1,
+   14, 0x2,
+   14, 0x1,
+   16, 0x2,
+   16, 0x1,
+   4, 0x20,
+   4, 0x10,
+   4, 0x4,
+   4, 0x2,
+   8, 0x20,
+   8, 0x10,
+   8, 0x4,
+   8, 0x2,
+   11, 0x20,
+   11, 0x10,
+   11, 0x4,
+   11, 0x2,
+   15, 0x20,
+   15, 0x10,
+   15, 0x4,
+   15, 0x2,
+   4, 0x8,
+   8, 0x8,
+   11, 0x8,
+   15, 0x8,
+   4, 0x1,
+   8, 0x1,
+   11, 0x1,
+   15, 0x1,
+   4, 0x40,
+   8, 0x40,
+   11, 0x40,
+   15, 0x40
+};
+static Word16 order_MR515[] =
+{
+   0, 0x1,
+   0, 0x2,
+   0, 0x4,
+   0, 0x8,
+   0, 0x10,
+   0, 0x20,
+   0, 0x40,
+   0, 0x80,
+   1, 0x1,
+   1, 0x2,
+   1, 0x4,
+   1, 0x8,
+   1, 0x10,
+   1, 0x20,
+   1, 0x40,
+   1, 0x80,
+   3, 0x80,
+   3, 0x40,
+   3, 0x20,
+   3, 0x10,
+   3, 0x8,
+   7, 0x8,
+   11, 0x8,
+   15, 0x8,
+   6, 0x1,
+   6, 0x2,
+   6, 0x4,
+   10, 0x1,
+   10, 0x2,
+   10, 0x4,
+   14, 0x1,
+   14, 0x2,
+   14, 0x4,
+   18, 0x1,
+   18, 0x2,
+   18, 0x4,
+   6, 0x8,
+   10, 0x8,
+   14, 0x8,
+   18, 0x8,
+   3, 0x4,
+   7, 0x4,
+   11, 0x4,
+   15, 0x4,
+   2, 0x10,
+   6, 0x10,
+   10, 0x10,
+   14, 0x10,
+   18, 0x10,
+   3, 0x2,
+   7, 0x2,
+   11, 0x2,
+   2, 0x20,
+   2, 0x4,
+   2, 0x1,
+   6, 0x20,
+   10, 0x20,
+   14, 0x20,
+   18, 0x20,
+   2, 0x2,
+   3, 0x1,
+   7, 0x1,
+   11, 0x1,
+   15, 0x2,
+   2, 0x8,
+   2, 0x40,
+   15, 0x1,
+   5, 0x1,
+   5, 0x2,
+   9, 0x1,
+   9, 0x2,
+   13, 0x1,
+   4, 0x4,
+   8, 0x4,
+   12, 0x4,
+   16, 0x4,
+   13, 0x2,
+   17, 0x1,
+   17, 0x2,
+   4, 0x2,
+   8, 0x2,
+   12, 0x2,
+   16, 0x2,
+   4, 0x20,
+   8, 0x20,
+   4, 0x10,
+   8, 0x10,
+   12, 0x20,
+   12, 0x10,
+   16, 0x20,
+   16, 0x10,
+   4, 0x40,
+   8, 0x40,
+   12, 0x40,
+   16, 0x40,
+   4, 0x1,
+   8, 0x1,
+   12, 0x1,
+   16, 0x1,
+   4, 0x8,
+   8, 0x8,
+   12, 0x8,
+   16, 0x8
+};
+static Word16 order_MR59[] =
+{
+   0, 0x80,
+   0, 0x40,
+   0, 0x8,
+   0, 0x4,
+   0, 0x10,
+   0, 0x2,
+   0, 0x1,
+   0, 0x20,
+   1, 0x8,
+   1, 0x2,
+   1, 0x100,
+   1, 0x80,
+   1, 0x20,
+   1, 0x10,
+   1, 0x4,
+   1, 0x40,
+   1, 0x1,
+   3, 0x20,
+   11, 0x20,
+   3, 0x10,
+   11, 0x10,
+   3, 0x40,
+   11, 0x40,
+   3, 0x80,
+   11, 0x80,
+   3, 0x8,
+   11, 0x8,
+   7, 0x8,
+   15, 0x8,
+   6, 0x1,
+   10, 0x1,
+   14, 0x1,
+   18, 0x1,
+   3, 0x4,
+   11, 0x4,
+   7, 0x4,
+   15, 0x4,
+   6, 0x2,
+   10, 0x2,
+   14, 0x2,
+   18, 0x2,
+   7, 0x2,
+   15, 0x2,
+   3, 0x2,
+   11, 0x2,
+   3, 0x1,
+   11, 0x1,
+   6, 0x4,
+   10, 0x4,
+   14, 0x4,
+   18, 0x4,
+   6, 0x8,
+   10, 0x8,
+   14, 0x8,
+   18, 0x8,
+   6, 0x10,
+   10, 0x10,
+   14, 0x10,
+   18, 0x10,
+   2, 0x40,
+   2, 0x10,
+   2, 0x4,
+   2, 0x8,
+   2, 0x80,
+   2, 0x100,
+   2, 0x20,
+   2, 0x2,
+   17, 0x1,
+   5, 0x2,
+   13, 0x2,
+   17, 0x2,
+   9, 0x2,
+   9, 0x1,
+   5, 0x1,
+   13, 0x1,
+   2, 0x1,
+   6, 0x20,
+   10, 0x20,
+   14, 0x20,
+   18, 0x20,
+   7, 0x1,
+   15, 0x1,
+   4, 0x4,
+   8, 0x4,
+   12, 0x4,
+   16, 0x4,
+   4, 0x8,
+   8, 0x8,
+   12, 0x8,
+   16, 0x8,
+   4, 0x40,
+   8, 0x40,
+   12, 0x40,
+   16, 0x40,
+   4, 0x80,
+   8, 0x80,
+   12, 0x80,
+   16, 0x80,
+   4, 0x100,
+   8, 0x100,
+   12, 0x100,
+   16, 0x100,
+   4, 0x1,
+   8, 0x1,
+   12, 0x1,
+   16, 0x1,
+   4, 0x2,
+   8, 0x2,
+   12, 0x2,
+   16, 0x2,
+   4, 0x10,
+   8, 0x10,
+   12, 0x10,
+   16, 0x10,
+   4, 0x20,
+   8, 0x20,
+   12, 0x20,
+   16, 0x20
+};
+static Word16 order_MR67[] =
+{
+   0, 0x80,
+   0, 0x40,
+   0, 0x8,
+   0, 0x10,
+   0, 0x4,
+   0, 0x2,
+   1, 0x8,
+   0, 0x1,
+   0, 0x20,
+   1, 0x100,
+   1, 0x80,
+   1, 0x20,
+   1, 0x2,
+   1, 0x10,
+   1, 0x4,
+   1, 0x40,
+   3, 0x20,
+   11, 0x20,
+   3, 0x10,
+   11, 0x10,
+   3, 0x40,
+   11, 0x40,
+   3, 0x80,
+   11, 0x80,
+   3, 0x8,
+   11, 0x8,
+   1, 0x1,
+   7, 0x8,
+   15, 0x8,
+   7, 0x4,
+   15, 0x4,
+   3, 0x4,
+   11, 0x4,
+   7, 0x2,
+   15, 0x2,
+   6, 0x40,
+   10, 0x40,
+   14, 0x40,
+   18, 0x40,
+   3, 0x2,
+   11, 0x2,
+   6, 0x8,
+   10, 0x8,
+   14, 0x8,
+   18, 0x8,
+   6, 0x4,
+   10, 0x4,
+   14, 0x4,
+   18, 0x4,
+   7, 0x1,
+   15, 0x1,
+   3, 0x1,
+   11, 0x1,
+   2, 0x40,
+   2, 0x4,
+   6, 0x2,
+   10, 0x2,
+   14, 0x2,
+   18, 0x2,
+   2, 0x10,
+   2, 0x8,
+   2, 0x80,
+   2, 0x100,
+   2, 0x20,
+   2, 0x2,
+   2, 0x1,
+   6, 0x10,
+   10, 0x10,
+   14, 0x10,
+   18, 0x10,
+   5, 0x1,
+   9, 0x1,
+   13, 0x1,
+   17, 0x1,
+   6, 0x1,
+   10, 0x1,
+   14, 0x1,
+   18, 0x1,
+   5, 0x2,
+   9, 0x2,
+   13, 0x2,
+   17, 0x2,
+   18, 0x20,
+   14, 0x20,
+   10, 0x20,
+   6, 0x20,
+   5, 0x4,
+   9, 0x4,
+   13, 0x4,
+   17, 0x4,
+   4, 0x4,
+   8, 0x4,
+   12, 0x4,
+   16, 0x4,
+   4, 0x20,
+   8, 0x20,
+   12, 0x20,
+   16, 0x20,
+   4, 0x40,
+   8, 0x40,
+   12, 0x40,
+   16, 0x40,
+   4, 0x200,
+   8, 0x200,
+   12, 0x200,
+   16, 0x200,
+   4, 0x400,
+   8, 0x400,
+   12, 0x400,
+   16, 0x400,
+   4, 0x1,
+   8, 0x1,
+   12, 0x1,
+   16, 0x1,
+   4, 0x2,
+   8, 0x2,
+   12, 0x2,
+   16, 0x2,
+   4, 0x8,
+   8, 0x8,
+   12, 0x8,
+   16, 0x8,
+   4, 0x10,
+   8, 0x10,
+   12, 0x10,
+   16, 0x10,
+   4, 0x80,
+   8, 0x80,
+   12, 0x80,
+   16, 0x80,
+   4, 0x100,
+   8, 0x100,
+   12, 0x100,
+   16, 0x100
+};
+static Word16 order_MR74[] =
+{
+   0, 0x80,
+   0, 0x40,
+   0, 0x20,
+   0, 0x10,
+   0, 0x8,
+   0, 0x4,
+   0, 0x2,
+   0, 0x1,
+   1, 0x100,
+   1, 0x80,
+   1, 0x40,
+   1, 0x20,
+   1, 0x10,
+   1, 0x8,
+   1, 0x4,
+   1, 0x2,
+   1, 0x1,
+   3, 0x80,
+   11, 0x80,
+   3, 0x40,
+   11, 0x40,
+   3, 0x20,
+   11, 0x20,
+   3, 0x10,
+   11, 0x10,
+   3, 0x8,
+   11, 0x8,
+   6, 0x40,
+   10, 0x40,
+   14, 0x40,
+   18, 0x40,
+   6, 0x20,
+   10, 0x20,
+   14, 0x20,
+   18, 0x20,
+   6, 0x8,
+   10, 0x8,
+   14, 0x8,
+   18, 0x8,
+   6, 0x4,
+   10, 0x4,
+   14, 0x4,
+   18, 0x4,
+   7, 0x10,
+   15, 0x10,
+   7, 0x8,
+   15, 0x8,
+   2, 0x10,
+   2, 0x8,
+   2, 0x4,
+   2, 0x100,
+   2, 0x80,
+   2, 0x40,
+   3, 0x4,
+   7, 0x4,
+   11, 0x4,
+   15, 0x4,
+   6, 0x2,
+   10, 0x2,
+   14, 0x2,
+   18, 0x2,
+   2, 0x20,
+   2, 0x2,
+   2, 0x1,
+   5, 0x1,
+   9, 0x1,
+   13, 0x1,
+   17, 0x1,
+   6, 0x1,
+   10, 0x1,
+   14, 0x1,
+   18, 0x1,
+   5, 0x2,
+   9, 0x2,
+   13, 0x2,
+   17, 0x2,
+   5, 0x4,
+   9, 0x4,
+   6, 0x10,
+   10, 0x10,
+   14, 0x10,
+   18, 0x10,
+   13, 0x4,
+   17, 0x4,
+   5, 0x8,
+   9, 0x8,
+   13, 0x8,
+   17, 0x8,
+   3, 0x2,
+   3, 0x1,
+   7, 0x2,
+   7, 0x1,
+   11, 0x2,
+   11, 0x1,
+   15, 0x2,
+   15, 0x1,
+   4, 0x20,
+   4, 0x10,
+   4, 0x8,
+   4, 0x4,
+   4, 0x2,
+   4, 0x1,
+   8, 0x20,
+   8, 0x10,
+   8, 0x8,
+   8, 0x4,
+   8, 0x2,
+   8, 0x1,
+   12, 0x20,
+   12, 0x10,
+   12, 0x8,
+   12, 0x4,
+   12, 0x2,
+   12, 0x1,
+   16, 0x20,
+   16, 0x10,
+   16, 0x8,
+   16, 0x4,
+   16, 0x2,
+   16, 0x1,
+   4, 0x1000,
+   8, 0x1000,
+   12, 0x1000,
+   16, 0x1000,
+   4, 0x800,
+   8, 0x800,
+   12, 0x800,
+   16, 0x800,
+   4, 0x400,
+   8, 0x400,
+   12, 0x400,
+   16, 0x400,
+   4, 0x200,
+   8, 0x200,
+   12, 0x200,
+   16, 0x200,
+   4, 0x100,
+   8, 0x100,
+   12, 0x100,
+   16, 0x100,
+   4, 0x80,
+   8, 0x80,
+   12, 0x80,
+   16, 0x80,
+   4, 0x40,
+   8, 0x40,
+   12, 0x40,
+   16, 0x40
+};
+static Word16 order_MR795[] =
+{
+   0, 0x1,
+   0, 0x2,
+   0, 0x4,
+   0, 0x8,
+   0, 0x10,
+   0, 0x20,
+   0, 0x40,
+   1, 0x8,
+   1, 0x2,
+   1, 0x100,
+   1, 0x80,
+   1, 0x20,
+   1, 0x10,
+   1, 0x4,
+   1, 0x40,
+   1, 0x1,
+   2, 0x40,
+   2, 0x10,
+   2, 0x4,
+   2, 0x8,
+   2, 0x80,
+   2, 0x100,
+   2, 0x20,
+   7, 0x10,
+   12, 0x10,
+   17, 0x10,
+   22, 0x10,
+   7, 0x8,
+   12, 0x8,
+   17, 0x8,
+   22, 0x8,
+   7, 0x4,
+   12, 0x4,
+   17, 0x4,
+   22, 0x4,
+   6, 0x8,
+   11, 0x8,
+   16, 0x8,
+   21, 0x8,
+   6, 0x4,
+   11, 0x4,
+   16, 0x4,
+   21, 0x4,
+   3, 0x80,
+   13, 0x80,
+   3, 0x40,
+   13, 0x40,
+   3, 0x20,
+   13, 0x20,
+   3, 0x10,
+   13, 0x10,
+   3, 0x8,
+   13, 0x8,
+   8, 0x20,
+   18, 0x20,
+   8, 0x10,
+   18, 0x10,
+   8, 0x8,
+   18, 0x8,
+   7, 0x2,
+   12, 0x2,
+   17, 0x2,
+   22, 0x2,
+   3, 0x4,
+   13, 0x4,
+   8, 0x4,
+   18, 0x4,
+   0, 0x80,
+   0, 0x100,
+   2, 0x2,
+   2, 0x1,
+   3, 0x2,
+   13, 0x2,
+   3, 0x1,
+   13, 0x1,
+   8, 0x2,
+   18, 0x2,
+   8, 0x1,
+   18, 0x1,
+   6, 0x2,
+   11, 0x2,
+   16, 0x2,
+   21, 0x2,
+   7, 0x1,
+   12, 0x1,
+   17, 0x1,
+   22, 0x1,
+   6, 0x1,
+   11, 0x1,
+   16, 0x1,
+   21, 0x1,
+   15, 0x1,
+   15, 0x2,
+   15, 0x4,
+   4, 0x2,
+   9, 0x2,
+   14, 0x2,
+   19, 0x2,
+   4, 0x10,
+   9, 0x10,
+   14, 0x10,
+   19, 0x10,
+   4, 0x80,
+   9, 0x80,
+   14, 0x80,
+   19, 0x80,
+   4, 0x800,
+   9, 0x800,
+   14, 0x800,
+   19, 0x800,
+   15, 0x8,
+   20, 0x1,
+   20, 0x2,
+   20, 0x4,
+   20, 0x8,
+   10, 0x1,
+   10, 0x2,
+   10, 0x4,
+   10, 0x8,
+   5, 0x1,
+   5, 0x2,
+   5, 0x4,
+   5, 0x8,
+   4, 0x1,
+   4, 0x4,
+   4, 0x8,
+   4, 0x20,
+   4, 0x100,
+   4, 0x1000,
+   9, 0x1,
+   9, 0x4,
+   9, 0x8,
+   9, 0x20,
+   9, 0x100,
+   9, 0x1000,
+   14, 0x1,
+   14, 0x4,
+   14, 0x8,
+   14, 0x20,
+   14, 0x100,
+   14, 0x1000,
+   19, 0x1,
+   19, 0x4,
+   19, 0x8,
+   19, 0x20,
+   19, 0x100,
+   19, 0x1000,
+   4, 0x40,
+   9, 0x40,
+   14, 0x40,
+   19, 0x40,
+   4, 0x400,
+   9, 0x400,
+   14, 0x400,
+   19, 0x400,
+   4, 0x200,
+   9, 0x200,
+   14, 0x200,
+   19, 0x200,
+   0, 0x1,
+   0, 0x2,
+   0, 0x4,
+   0, 0x8,
+   0, 0x10,
+   0, 0x20,
+   0, 0x40,
+   1, 0x8,
+   1, 0x2,
+   1, 0x100,
+   1, 0x80,
+   1, 0x20,
+   1, 0x10,
+   1, 0x4,
+   1, 0x40,
+   1, 0x1,
+   2, 0x40,
+   2, 0x10,
+   2, 0x4,
+   2, 0x8,
+   2, 0x80,
+   2, 0x100,
+   2, 0x20,
+   7, 0x10,
+   12, 0x10,
+   17, 0x10,
+   22, 0x10,
+   7, 0x8,
+   12, 0x8,
+   17, 0x8,
+   22, 0x8,
+   7, 0x4,
+   12, 0x4,
+   17, 0x4,
+   22, 0x4,
+   6, 0x8,
+   11, 0x8,
+   16, 0x8,
+   21, 0x8,
+   6, 0x4,
+   11, 0x4,
+   16, 0x4,
+   21, 0x4,
+   3, 0x80,
+   13, 0x80,
+   3, 0x40,
+   13, 0x40,
+   3, 0x20,
+   13, 0x20,
+   3, 0x10,
+   13, 0x10,
+   3, 0x8,
+   13, 0x8,
+   8, 0x20,
+   18, 0x20,
+   8, 0x10,
+   18, 0x10,
+   8, 0x8,
+   18, 0x8,
+   7, 0x2,
+   12, 0x2,
+   17, 0x2,
+   22, 0x2,
+   3, 0x4,
+   13, 0x4,
+   8, 0x4,
+   18, 0x4,
+   0, 0x80,
+   0, 0x100,
+   2, 0x2,
+   2, 0x1,
+   3, 0x2,
+   13, 0x2,
+   3, 0x1,
+   13, 0x1,
+   8, 0x2,
+   18, 0x2,
+   8, 0x1,
+   18, 0x1,
+   6, 0x2,
+   11, 0x2,
+   16, 0x2,
+   21, 0x2,
+   7, 0x1,
+   12, 0x1,
+   17, 0x1,
+   22, 0x1,
+   6, 0x1,
+   11, 0x1,
+   16, 0x1,
+   21, 0x1,
+   15, 0x1,
+   15, 0x2,
+   15, 0x4,
+   4, 0x2,
+   9, 0x2,
+   14, 0x2,
+   19, 0x2,
+   4, 0x10,
+   9, 0x10,
+   14, 0x10,
+   19, 0x10,
+   4, 0x80,
+   9, 0x80,
+   14, 0x80,
+   19, 0x80,
+   4, 0x800,
+   9, 0x800,
+   14, 0x800,
+   19, 0x800,
+   15, 0x8,
+   20, 0x1,
+   20, 0x2,
+   20, 0x4,
+   20, 0x8,
+   10, 0x1,
+   10, 0x2,
+   10, 0x4,
+   10, 0x8,
+   5, 0x1,
+   5, 0x2,
+   5, 0x4,
+   5, 0x8,
+   4, 0x1,
+   4, 0x4,
+   4, 0x8,
+   4, 0x20,
+   4, 0x100,
+   4, 0x1000,
+   9, 0x1,
+   9, 0x4,
+   9, 0x8,
+   9, 0x20,
+   9, 0x100,
+   9, 0x1000,
+   14, 0x1,
+   14, 0x4,
+   14, 0x8,
+   14, 0x20,
+   14, 0x100,
+   14, 0x1000,
+   19, 0x1,
+   19, 0x4,
+   19, 0x8,
+   19, 0x20,
+   19, 0x100,
+   19, 0x1000,
+   4, 0x40,
+   9, 0x40,
+   14, 0x40,
+   19, 0x40,
+   4, 0x400,
+   9, 0x400,
+   14, 0x400,
+   19, 0x400,
+   4, 0x200,
+   9, 0x200,
+   14, 0x200,
+   19, 0x200
+};
+static Word16 order_MR102[] =
+{
+   0, 0x1,
+   0, 0x2,
+   0, 0x4,
+   0, 0x8,
+   0, 0x10,
+   0, 0x20,
+   0, 0x40,
+   0, 0x80,
+   1, 0x1,
+   1, 0x2,
+   1, 0x4,
+   1, 0x8,
+   1, 0x10,
+   1, 0x20,
+   1, 0x40,
+   1, 0x80,
+   1, 0x100,
+   3, 0x80,
+   3, 0x40,
+   3, 0x20,
+   3, 0x10,
+   3, 0x8,
+   3, 0x4,
+   21, 0x80,
+   21, 0x40,
+   21, 0x20,
+   21, 0x10,
+   21, 0x8,
+   21, 0x4,
+   12, 0x10,
+   12, 0x8,
+   30, 0x10,
+   30, 0x8,
+   11, 0x40,
+   11, 0x8,
+   11, 0x4,
+   20, 0x40,
+   20, 0x8,
+   20, 0x4,
+   29, 0x40,
+   29, 0x8,
+   29, 0x4,
+   38, 0x40,
+   38, 0x8,
+   38, 0x4,
+   3, 0x2,
+   3, 0x1,
+   21, 0x2,
+   21, 0x1,
+   12, 0x4,
+   12, 0x2,
+   30, 0x4,
+   30, 0x2,
+   11, 0x20,
+   20, 0x20,
+   29, 0x20,
+   38, 0x20,
+   2, 0x40,
+   2, 0x4,
+   2, 0x10,
+   2, 0x8,
+   2, 0x80,
+   2, 0x100,
+   2, 0x20,
+   2, 0x2,
+   2, 0x1,
+   7, 0x1,
+   6, 0x1,
+   5, 0x1,
+   4, 0x1,
+   16, 0x1,
+   15, 0x1,
+   14, 0x1,
+   13, 0x1,
+   25, 0x1,
+   24, 0x1,
+   23, 0x1,
+   22, 0x1,
+   34, 0x1,
+   33, 0x1,
+   32, 0x1,
+   31, 0x1,
+   11, 0x2,
+   11, 0x10,
+   11, 0x1,
+   20, 0x2,
+   20, 0x10,
+   20, 0x1,
+   29, 0x2,
+   29, 0x10,
+   29, 0x1,
+   38, 0x2,
+   38, 0x10,
+   38, 0x1,
+   12, 0x1,
+   30, 0x1,
+   17, 0x200,
+   17, 0x100,
+   18, 0x100,
+   18, 0x200,
+   18, 0x80,
+   17, 0x80,
+   18, 0x20,
+   17, 0x20,
+   17, 0x40,
+   18, 0x40,
+   19, 0x40,
+   19, 0x20,
+   18, 0x10,
+   19, 0x8,
+   17, 0x10,
+   19, 0x10,
+   17, 0x8,
+   18, 0x8,
+   26, 0x200,
+   26, 0x100,
+   27, 0x100,
+   27, 0x200,
+   27, 0x80,
+   26, 0x80,
+   27, 0x20,
+   26, 0x20,
+   26, 0x40,
+   27, 0x40,
+   28, 0x40,
+   28, 0x20,
+   27, 0x10,
+   28, 0x8,
+   26, 0x10,
+   28, 0x10,
+   26, 0x8,
+   27, 0x8,
+   35, 0x200,
+   35, 0x100,
+   36, 0x100,
+   36, 0x200,
+   36, 0x80,
+   35, 0x80,
+   36, 0x20,
+   35, 0x20,
+   35, 0x40,
+   36, 0x40,
+   37, 0x40,
+   37, 0x20,
+   36, 0x10,
+   37, 0x8,
+   35, 0x10,
+   37, 0x10,
+   35, 0x8,
+   36, 0x8,
+   8, 0x200,
+   8, 0x100,
+   9, 0x100,
+   9, 0x200,
+   9, 0x80,
+   8, 0x80,
+   9, 0x20,
+   8, 0x20,
+   8, 0x40,
+   9, 0x40,
+   10, 0x40,
+   10, 0x20,
+   9, 0x10,
+   10, 0x8,
+   8, 0x10,
+   10, 0x10,
+   8, 0x8,
+   9, 0x8,
+   37, 0x4,
+   35, 0x1,
+   36, 0x1,
+   37, 0x1,
+   35, 0x4,
+   37, 0x2,
+   35, 0x2,
+   36, 0x4,
+   36, 0x2,
+   28, 0x4,
+   26, 0x1,
+   27, 0x1,
+   28, 0x1,
+   26, 0x4,
+   28, 0x2,
+   26, 0x2,
+   27, 0x4,
+   27, 0x2,
+   19, 0x4,
+   17, 0x1,
+   18, 0x1,
+   19, 0x1,
+   17, 0x4,
+   19, 0x2,
+   17, 0x2,
+   18, 0x4,
+   18, 0x2,
+   10, 0x4,
+   8, 0x1,
+   9, 0x1,
+   10, 0x1,
+   8, 0x4,
+   10, 0x2,
+   8, 0x2,
+   9, 0x4,
+   9, 0x2
+};
+static Word16 order_MR122[] =
+{
+   0, 0x40,
+   0, 0x20,
+   0, 0x10,
+   0, 0x8,
+   0, 0x4,
+   0, 0x2,
+   0, 0x1,
+   1, 0x80,
+   1, 0x40,
+   1, 0x20,
+   1, 0x10,
+   1, 0x8,
+   1, 0x4,
+   1, 0x2,
+   1, 0x1,
+   2, 0x1,
+   2, 0x100,
+   2, 0x80,
+   2, 0x40,
+   2, 0x20,
+   2, 0x10,
+   2, 0x8,
+   2, 0x4,
+   2, 0x2,
+   3, 0x80,
+   3, 0x40,
+   3, 0x20,
+   3, 0x10,
+   3, 0x8,
+   5, 0x100,
+   31, 0x100,
+   5, 0x80,
+   31, 0x80,
+   5, 0x40,
+   31, 0x40,
+   5, 0x20,
+   31, 0x20,
+   5, 0x10,
+   31, 0x10,
+   5, 0x8,
+   31, 0x8,
+   5, 0x4,
+   31, 0x4,
+   5, 0x2,
+   31, 0x2,
+   5, 0x1,
+   31, 0x1,
+   6, 0x8,
+   19, 0x8,
+   32, 0x8,
+   45, 0x8,
+   6, 0x4,
+   19, 0x4,
+   32, 0x4,
+   45, 0x4,
+   6, 0x2,
+   19, 0x2,
+   32, 0x2,
+   45, 0x2,
+   17, 0x10,
+   30, 0x10,
+   43, 0x10,
+   56, 0x10,
+   17, 0x8,
+   30, 0x8,
+   43, 0x8,
+   56, 0x8,
+   17, 0x4,
+   30, 0x4,
+   43, 0x4,
+   56, 0x4,
+   18, 0x20,
+   44, 0x20,
+   18, 0x10,
+   44, 0x10,
+   18, 0x8,
+   44, 0x8,
+   18, 0x4,
+   44, 0x4,
+   18, 0x2,
+   44, 0x2,
+   3, 0x4,
+   3, 0x2,
+   3, 0x1,
+   4, 0x20,
+   4, 0x10,
+   4, 0x8,
+   4, 0x4,
+   6, 0x1,
+   19, 0x1,
+   32, 0x1,
+   45, 0x1,
+   17, 0x2,
+   30, 0x2,
+   43, 0x2,
+   56, 0x2,
+   7, 0x8,
+   20, 0x8,
+   33, 0x8,
+   46, 0x8,
+   8, 0x8,
+   21, 0x8,
+   34, 0x8,
+   47, 0x8,
+   17, 0x1,
+   30, 0x1,
+   43, 0x1,
+   56, 0x1,
+   9, 0x8,
+   22, 0x8,
+   35, 0x8,
+   48, 0x8,
+   10, 0x8,
+   23, 0x8,
+   36, 0x8,
+   49, 0x8,
+   11, 0x8,
+   24, 0x8,
+   37, 0x8,
+   50, 0x8,
+   4, 0x2,
+   4, 0x1,
+   7, 0x1,
+   7, 0x2,
+   7, 0x4,
+   8, 0x1,
+   8, 0x2,
+   8, 0x4,
+   9, 0x1,
+   9, 0x2,
+   9, 0x4,
+   10, 0x1,
+   10, 0x2,
+   10, 0x4,
+   11, 0x1,
+   11, 0x2,
+   11, 0x4,
+   20, 0x1,
+   20, 0x2,
+   20, 0x4,
+   21, 0x1,
+   21, 0x2,
+   21, 0x4,
+   22, 0x1,
+   22, 0x2,
+   22, 0x4,
+   23, 0x1,
+   23, 0x2,
+   23, 0x4,
+   24, 0x1,
+   24, 0x2,
+   24, 0x4,
+   33, 0x1,
+   33, 0x2,
+   33, 0x4,
+   34, 0x1,
+   34, 0x2,
+   34, 0x4,
+   35, 0x1,
+   35, 0x2,
+   35, 0x4,
+   36, 0x1,
+   36, 0x2,
+   36, 0x4,
+   37, 0x1,
+   37, 0x2,
+   37, 0x4,
+   46, 0x1,
+   46, 0x2,
+   46, 0x4,
+   47, 0x1,
+   47, 0x2,
+   47, 0x4,
+   48, 0x1,
+   48, 0x2,
+   48, 0x4,
+   49, 0x1,
+   49, 0x2,
+   49, 0x4,
+   50, 0x1,
+   50, 0x2,
+   50, 0x4,
+   12, 0x1,
+   12, 0x2,
+   12, 0x4,
+   13, 0x1,
+   13, 0x2,
+   13, 0x4,
+   14, 0x1,
+   14, 0x2,
+   14, 0x4,
+   15, 0x1,
+   15, 0x2,
+   15, 0x4,
+   16, 0x1,
+   16, 0x2,
+   16, 0x4,
+   25, 0x1,
+   25, 0x2,
+   25, 0x4,
+   26, 0x1,
+   26, 0x2,
+   26, 0x4,
+   27, 0x1,
+   27, 0x2,
+   27, 0x4,
+   28, 0x1,
+   28, 0x2,
+   28, 0x4,
+   29, 0x1,
+   29, 0x2,
+   29, 0x4,
+   38, 0x1,
+   38, 0x2,
+   38, 0x4,
+   39, 0x1,
+   39, 0x2,
+   39, 0x4,
+   40, 0x1,
+   40, 0x2,
+   40, 0x4,
+   41, 0x1,
+   41, 0x2,
+   41, 0x4,
+   42, 0x1,
+   42, 0x2,
+   42, 0x4,
+   51, 0x1,
+   51, 0x2,
+   51, 0x4,
+   52, 0x1,
+   52, 0x2,
+   52, 0x4,
+   53, 0x1,
+   53, 0x2,
+   53, 0x4,
+   54, 0x1,
+   54, 0x2,
+   54, 0x4,
+   55, 0x1,
+   55, 0x2,
+   55, 0x4,
+   18, 0x1,
+   44, 0x1
+};
+static Word16 order_MRDTX[] =
+{
+   0, 0x4,
+   0, 0x2,
+   0, 0x1,
+   1, 0x80,
+   1, 0x40,
+   1, 0x20,
+   1, 0x10,
+   1, 0x8,
+   1, 0x4,
+   1, 0x2,
+   1, 0x1,
+   2, 0x100,
+   2, 0x80,
+   2, 0x40,
+   2, 0x20,
+   2, 0x10,
+   2, 0x8,
+   2, 0x4,
+   2, 0x2,
+   2, 0x1,
+   3, 0x100,
+   3, 0x80,
+   3, 0x40,
+   3, 0x20,
+   3, 0x10,
+   3, 0x8,
+   3, 0x4,
+   3, 0x2,
+   3, 0x1,
+   4, 0x20,
+   4, 0x10,
+   4, 0x8,
+   4, 0x4,
+   4, 0x2,
+   4, 0x1
+};
+
+/* Homing frames for the decoder */
+static const Word16 dhf_MR475[PRMNO_MR475] =
+{
+   0x00F8,
+   0x009D,
+   0x001C,
+   0x0066,
+   0x0000,
+   0x0003,
+   0x0028,
+   0x000F,
+   0x0038,
+   0x0001,
+   0x000F,
+   0x0031,
+   0x0002,
+   0x0008,
+   0x000F,
+   0x0026,
+   0x0003
+};
+static const Word16 dhf_MR515[PRMNO_MR515] =
+{
+   0x00F8,
+   0x009D,
+   0x001C,
+   0x0066,
+   0x0000,
+   0x0003,
+   0x0037,
+   0x000F,
+   0x0000,
+   0x0003,
+   0x0005,
+   0x000F,
+   0x0037,
+   0x0003,
+   0x0037,
+   0x000F,
+   0x0023,
+   0x0003,
+   0x001F
+};
+static const Word16 dhf_MR59[PRMNO_MR59] =
+{
+   0x00F8,
+   0x00E3,
+   0x002F,
+   0x00BD,
+   0x0000,
+   0x0003,
+   0x0037,
+   0x000F,
+   0x0001,
+   0x0003,
+   0x000F,
+   0x0060,
+   0x00F9,
+   0x0003,
+   0x0037,
+   0x000F,
+   0x0000,
+   0x0003,
+   0x0037
+};
+static const Word16 dhf_MR67[PRMNO_MR67] =
+{
+   0x00F8,
+   0x00E3,
+   0x002F,
+   0x00BD,
+   0x0002,
+   0x0007,
+   0x0000,
+   0x000F,
+   0x0098,
+   0x0007,
+   0x0061,
+   0x0060,
+   0x05C5,
+   0x0007,
+   0x0000,
+   0x000F,
+   0x0318,
+   0x0007,
+   0x0000
+};
+static const Word16 dhf_MR74[PRMNO_MR74] =
+{
+   0x00F8,
+   0x00E3,
+   0x002F,
+   0x00BD,
+   0x0006,
+   0x000F,
+   0x0000,
+   0x001B,
+   0x0208,
+   0x000F,
+   0x0062,
+   0x0060,
+   0x1BA6,
+   0x000F,
+   0x0000,
+   0x001B,
+   0x0006,
+   0x000F,
+   0x0000
+};
+static const Word16 dhf_MR795[PRMNO_MR795] =
+{
+   0x00C2,
+   0x00E3,
+   0x002F,
+   0x00BD,
+   0x0006,
+   0x000F,
+   0x000A,
+   0x0000,
+   0x0039,
+   0x1C08,
+   0x0007,
+   0x000A,
+   0x000B,
+   0x0063,
+   0x11A6,
+   0x000F,
+   0x0001,
+   0x0000,
+   0x0039,
+   0x09A0,
+   0x000F,
+   0x0002,
+   0x0001
+};
+static const Word16 dhf_MR102[PRMNO_MR102] =
+{
+   0x00F8,
+   0x00E3,
+   0x002F,
+   0x0045,
+   0x0000,
+   0x0000,
+   0x0000,
+   0x0000,
+   0x0000,
+   0x0000,
+   0x0000,
+   0x0000,
+   0x001B,
+   0x0000,
+   0x0001,
+   0x0000,
+   0x0001,
+   0x0326,
+   0x00CE,
+   0x007E,
+   0x0051,
+   0x0062,
+   0x0000,
+   0x0000,
+   0x0000,
+   0x0000,
+   0x015A,
+   0x0359,
+   0x0076,
+   0x0000,
+   0x001B,
+   0x0000,
+   0x0000,
+   0x0000,
+   0x0000,
+   0x017C,
+   0x0215,
+   0x0038,
+   0x0030
+};
+static const Word16 dhf_MR122[PRMNO_MR122] =
+{
+   0x0004,
+   0x002A,
+   0x00DB,
+   0x0096,
+   0x002A,
+   0x0156,
+   0x000B,
+   0x0000,
+   0x0000,
+   0x0000,
+   0x0000,
+   0x0000,
+   0x0000,
+   0x0000,
+   0x0000,
+   0x0000,
+   0x0000,
+   0x0000,
+   0x0036,
+   0x000B,
+   0x0000,
+   0x000F,
+   0x000E,
+   0x000C,
+   0x000D,
+   0x0000,
+   0x0001,
+   0x0005,
+   0x0007,
+   0x0001,
+   0x0008,
+   0x0024,
+   0x0000,
+   0x0001,
+   0x0000,
+   0x0005,
+   0x0006,
+   0x0001,
+   0x0002,
+   0x0004,
+   0x0007,
+   0x0004,
+   0x0002,
+   0x0003,
+   0x0036,
+   0x000B,
+   0x0000,
+   0x0002,
+   0x0004,
+   0x0000,
+   0x0003,
+   0x0006,
+   0x0001,
+   0x0007,
+   0x0006,
+   0x0005,
+   0x0000
+};
+
+
+/* parameter sizes (# of bits), one table per mode */
+static const Word16 bitno_MR475[PRMNO_MR475] =
+{
+   8, 8, 7,    /* LSP VQ          */
+   8, 7, 2, 8, /* first subframe  */
+   4, 7, 2,    /* second subframe */
+   4, 7, 2, 8, /* third subframe  */
+   4, 7, 2     /* fourth subframe */
+};
+static const Word16 bitno_MR515[PRMNO_MR515] =
+{
+   8, 8, 7,    /* LSP VQ          */
+   8, 7, 2, 6, /* first subframe  */
+   4, 7, 2, 6, /* second subframe */
+   4, 7, 2, 6, /* third subframe  */
+   4, 7, 2, 6  /* fourth subframe */
+};
+static const Word16 bitno_MR59[PRMNO_MR59] =
+{
+   8, 9, 9,    /* LSP VQ          */
+   8, 9, 2, 6, /* first subframe  */
+   4, 9, 2, 6, /* second subframe */
+   8, 9, 2, 6, /* third subframe  */
+   4, 9, 2, 6  /* fourth subframe */
+};
+static const Word16 bitno_MR67[PRMNO_MR67] =
+{
+   8, 9, 9,       /* LSP VQ          */
+   8, 11, 3, 7,   /* first subframe  */
+   4, 11, 3, 7,   /* second subframe */
+   8, 11, 3, 7,   /* third subframe  */
+   4, 11, 3, 7    /* fourth subframe */
+};
+static const Word16 bitno_MR74[PRMNO_MR74] =
+{
+   8, 9, 9,       /* LSP VQ          */
+   8, 13, 4, 7,   /* first subframe  */
+   5, 13, 4, 7,   /* second subframe */
+   8, 13, 4, 7,   /* third subframe  */
+   5, 13, 4, 7    /* fourth subframe */
+};
+static const Word16 bitno_MR795[PRMNO_MR795] =
+{
+   9, 9, 9,          /* LSP VQ          */
+   8, 13, 4, 4, 5,   /* first subframe  */
+   6, 13, 4, 4, 5,   /* second subframe */
+   8, 13, 4, 4, 5,   /* third subframe  */
+   6, 13, 4, 4, 5    /* fourth subframe */
+};
+static const Word16 bitno_MR102[PRMNO_MR102] =
+{
+   8, 9, 9,                      /* LSP VQ          */
+   8, 1, 1, 1, 1, 10, 10, 7, 7,  /* first subframe  */
+   5, 1, 1, 1, 1, 10, 10, 7, 7,  /* second subframe */
+   8, 1, 1, 1, 1, 10, 10, 7, 7,  /* third subframe  */
+   5, 1, 1, 1, 1, 10, 10, 7, 7   /* fourth subframe */
+};
+static const Word16 bitno_MR122[PRMNO_MR122] =
+{
+   7, 8, 9, 8, 6,                            /* LSP VQ          */
+   9, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 5,    /* first subframe  */
+   6, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 5,    /* second subframe */
+   9, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 5,    /* third subframe  */
+   6, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 5     /* fourth subframe */
+};
+static const Word16 bitno_MRDTX[PRMNO_MRDTX] =
+{
+   3, 8, 9, 9, 6
+};
+
+#endif
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/amr/Makefile asterisk-1.8.3.2_com_amr/codecs/amr/Makefile
--- asterisk-1.8.3.2_com_rtsp/codecs/amr/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/amr/Makefile	2012-03-26 16:29:06.000000000 +0100
@@ -0,0 +1,69 @@
+# AMR code make file
+
+MAKEFILENAME=Makefile
+
+#include $(ASTTOPDIR)/Makefile.rules
+include ../../Makefile.rules
+
+# Use MODE=DEBUG for debuggable library (default target builds both)
+#
+# default mode = NORM ==> no debug, no wmops
+#
+
+# Use VAD=VAD1 for VAD option 1, or VAD=VAD2 for VAD option 2
+#
+# default mode = VAD1
+#
+VAD=VAD1
+
+#
+# compiler flags (for normal, DEBUG compilation)
+#
+
+CFLAGS = -Wall  -I. -O4 -D$(VAD)
+CFLAGSDEPEND = -MM $(CFLAGS)                    # for make depend
+
+
+
+#
+# source/object files
+#
+
+OBJS=sp_enc.o sp_dec.o interf_enc.o interf_dec.o
+
+
+LIB=libamr.a
+#
+# default target: build standalone speech encoder and decoder
+#
+all: $(LIB)
+
+$(LIB): $(OBJS)
+	$(ECHO_PREFIX) echo "   [AR] $^ -> $@"
+	$(CMD_PREFIX) $(AR) cr $@ $^
+	$(CMD_PREFIX) $(RANLIB) $@
+
+#
+# make / clean dependency list
+#
+depend:
+	$(MAKE) -f $(MAKEFILENAME) $(MFLAGS) $(MAKEDEFS) clean_depend
+	$(CC) $(CFLAGSDEPEND) $(ALL_SRCS) >> $(MAKEFILENAME)
+
+clean_depend:
+	chmod u+w $(MAKEFILENAME)
+	(awk 'BEGIN{f=1}{if (f) print $0}/^\# DO NOT DELETE THIS LINE -- make depend depends on it./{f=0}'\
+	    < $(MAKEFILENAME) > .depend && \
+	mv .depend $(MAKEFILENAME)) || exit 1;
+
+#
+# remove object/executable files
+#
+clean:
+	rm -f $(LIB) *.o core
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+sp_enc.o: sp_enc.c sp_enc.h typedef.h rom_enc.h
+interf_enc.o: interf_enc.c sp_enc.h typedef.h interf_rom.h rom_dec.h
+sp_dec.o: sp_dec.c sp_dec.h rom_dec.h typedef.h
+interf_dec.o: interf_dec.c typedef.h sp_dec.h interf_rom.h rom_dec.h
\ No newline at end of file
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/amr/rom_dec.h asterisk-1.8.3.2_com_amr/codecs/amr/rom_dec.h
--- asterisk-1.8.3.2_com_rtsp/codecs/amr/rom_dec.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/amr/rom_dec.h	2012-03-26 16:29:06.000000000 +0100
@@ -0,0 +1,13310 @@
+/*
+ * ===================================================================
+ *  TS 26.104
+ *  REL-5 V5.4.0 2004-03
+ *  REL-6 V6.1.0 2004-03
+ *  3GPP AMR Floating-point Speech Codec
+ * ===================================================================
+ *
+ */
+
+/*
+ * rom_dec.h
+ *
+ *
+ * Project:
+ *    AMR Floating-Point Codec
+ *
+ * Contains:
+ *    This file contains all the tables needed by AMR decoder functions.
+ *
+ */
+
+#ifndef _ROM_DEC_H_
+#define _ROM_DEC_H_
+
+/*
+ * include files
+ */
+#include"typedef.h"
+#include"interf_rom.h"
+
+/*
+ * definition of constants
+ */
+#define M               10      /* Order of LP filter */
+#define MP1             (M+1)   /* Order of LP filter + 1 */
+#define L_WINDOW        240     /* Window size in LP analysis */
+#define L_NEXT          40      /* Overhead in LP analysis */
+#define LTPG_MEM_SIZE   5       /* number of stored past LTP coding gains + 1 */
+#define N_FRAME         7       /* old pitch gains in average calculation */
+#define DTX_HIST_SIZE   8       /* DTX history size */
+#define L_TOTAL         320     /* Total size of speech buffer. */
+#define L_FRAME         160     /* Frame size */
+#define L_FRAME_BY2     80      /* Frame size divided by 2 */
+#define L_SUBFR         40      /* Subframe size */
+#define L_CODE          40      /* codevector length */
+#define PIT_MAX         143     /* Maximum pitch lag */
+#define PIT_MIN         20      /* Minimum pitch lag */
+#define PIT_MIN_MR122   18      /* Minimum pitch lag (MR122 mode) */
+#define L_INTERPOL      (10+1)  /* Length of filter for interpolation */
+#define NPRED 4                 /* number of prediction taps */
+#define SHARPMIN  0             /* Minimum value of pitch sharpening */
+#define MAX_PRM_SIZE    57      /* max. num. of params */
+#define L_INTER_SRCH    4           /* Length of filter for CL LTP search interpolation */
+#define GP_CLIP         0.95F   /* Pitch gain clipping */
+#define UP_SAMP_MAX     6
+#define NB_TRACK        5       /* number of tracks */
+#define NB_TRACK_MR102  4       /* number of tracks mode mr102 */
+#define STEP            5       /* codebook step size */
+#define STEP_MR102      4       /* codebook step size mode mr102 */
+#define NC              M/2     /* Order of LP filter divided by 2 */
+
+/* vad */
+#define COMPLEN               9        /* Number of sub-bands used by VAD */
+#define L_ENERGYHIST          60
+#define L_CBGAINHIST          7
+#define PHDGAINMEMSIZE        5
+#define MIN_ENERGY            -14336   /* 14 Q10 */
+#define MIN_ENERGY_MR122      -2381    /* 14 / (20*log10(2)) Q10 */
+#define PN_INITIAL_SEED       0x70816958L /* Pseudo noise generator seed value  */
+#define MIN_16                (Word16)-32768
+#define MAX_16                (Word16)0x7fff
+#define MAX_32                (Word32)0x7fffffffL
+#define EXPCONST              5243     /* 0.16 in Q15 */
+#define DTX_MAX_EMPTY_THRESH  50
+#define DTX_ELAPSED_FRAMES_THRESH (24 + 7 -1)
+#define LSF_GAP               205      /* Minimum distance between LSF after quantization; 50 Hz = 205 */
+#define LSP_PRED_FAC_MR122    21299    /* MR122 LSP prediction factor (0.65 Q15) */
+#define POS_CODE              8191
+#define NEG_CODE              8191
+#define NMAX                  9        /* largest N used in median calculation */
+#define MEAN_ENER_MR122       783741L  /* 36/(20*log10(2)) (Q17) */
+#define SHARPMAX              13017    /* Maximum value of pitch sharpening */
+#define FRAMEENERGYLIMIT      17578    /* 150 */
+#define LOWERNOISELIMIT       20       /*  5 */
+#define UPPERNOISELIMIT       1953     /* 50 */
+#define AZ_SIZE               (4*M+4)  /* Size of array of LP filters in 4 subfr.s */
+#define AGC_FAC               29491    /* Factor for automatic gain control 0.9 */
+#define PHDGAINMEMSIZE        5
+#define PHDTHR1LTP            9830     /* 0.6 in Q14 */
+#define PHDTHR2LTP            14746    /* 0.9 in Q14 */
+#define ONFACTPLUS1           16384    /* 2.0 in Q13 */
+#define ONLENGTH              2
+#define DTX_HANG_CONST        7        /* yields eight frames of SP HANGOVER */
+
+/* number of parameters */
+#define PRMNO_MR475 17
+#define PRMNO_MR515 19
+#define PRMNO_MR59  19
+#define PRMNO_MR67  19
+#define PRMNO_MR74  19
+#define PRMNO_MR795 23
+#define PRMNO_MR102 39
+#define PRMNO_MR122 57
+#define PRMNO_MRDTX 5
+
+/*
+ * tables
+ */
+
+/* level adjustment for different modes Q11 */
+static const Word16 dtx_log_en_adjust[9] =
+{
+   - 1023,
+   /* MR475 */ - 878,
+   /* MR515 */ - 732,
+   /* MR59  */ - 586,
+   /* MR67  */ - 440,
+   /* MR74  */ - 294,
+   /* MR795 */ - 148,
+   /* MR102 */ 0,
+   /* MR122 */ 0,
+   /* MRDTX */
+};
+
+/* attenuation factors for codebook gain */
+static const Word32 cdown[7] =
+   {
+      32767,
+      32112,
+      32112,
+      32112,
+      32112,
+      32112,
+      22937
+   };
+
+/* attenuation factors for adaptive codebook gain */
+static const Word32 pdown[7] =
+   {
+      32767,
+      32112,
+      32112,
+      26214,
+      9830,
+      6553,
+      6553
+   };
+
+/* algebraic code book gain MA predictor coefficients */
+static const Word32 pred[NPRED] =
+{
+   5571,
+   4751,
+   2785,
+   1556
+};
+
+/* algebraic code book gain MA predictor coefficients (MR122) */
+static const Word32 pred_MR122[NPRED] =
+{
+   44,
+   37,
+   22,
+   12
+};
+
+static const Word32 gamma4_gamma3_MR122[M] =
+{
+   22938,
+   16057,
+   11240,
+   7868,
+   5508,
+   3856,
+   2699,
+   1889,
+   1322,
+   925
+};
+static const Word32 gamma3[M] =
+{
+   18022,
+   9912,
+   5451,
+   2998,
+   1649,
+   907,
+   499,
+   274,
+   151,
+   83
+};
+static const Word32 gamma4_MR122[M] =
+{
+   24576,
+   18432,
+   13824,
+   10368,
+   7776,
+   5832,
+   4374,
+   3281,
+   2461,
+   1846
+};
+
+
+/* adaptive codebook gain quantization table (MR122, MR795) */
+#define NB_QUA_PITCH 16
+static const Word32 qua_gain_pitch[NB_QUA_PITCH] =
+{
+   0,
+   3277,
+   6556,
+   8192,
+   9830,
+   11469,
+   12288,
+   13107,
+   13926,
+   14746,
+   15565,
+   16384,
+   17203,
+   18022,
+   18842,
+   19661
+};
+
+/* fixed codebook gain quantization table (MR122, MR795) */
+#define NB_QUA_CODE 32
+static const Word32 qua_gain_code[NB_QUA_CODE * 3] =
+{
+/* gain factor (g_fac) and quantized energy error (qua_ener_MR122, qua_ener)
+ * are stored:
+ *
+ * qua_ener_MR122 = log2(g_fac)      (not the rounded floating point value, but
+ *                                    the value the original EFR algorithm
+ *                                    calculates from g_fac [using Log2])
+ * qua_ener       = 20*log10(g_fac); (rounded floating point value)
+ *
+ *
+ * g_fac (Q11),
+ * qua_ener_MR122 (Q10),
+ * qua_ener (Q10)
+ */ 159,
+   - 3776,
+   - 22731,
+   206,
+   - 3394,
+   - 20428,
+   268,
+   - 3005,
+   - 18088,
+   349,
+   - 2615,
+   - 15739,
+   419,
+   - 2345,
+   - 14113,
+   482,
+   - 2138,
+   - 12867,
+   554,
+   - 1932,
+   - 11629,
+   637,
+   - 1726,
+   - 10387,
+   733,
+   - 1518,
+   - 9139,
+   842,
+   - 1314,
+   - 7906,
+   969,
+   - 1106,
+   - 6656,
+   1114,
+   - 900,
+   - 5416,
+   1281,
+   - 694,
+   - 4173,
+   1473,
+   - 487,
+   - 2931,
+   1694,
+   - 281,
+   - 1688,
+   1948,
+   - 75,
+   - 445,
+   2241,
+   133,
+   801,
+   2577,
+   339,
+   2044,
+   2963,
+   545,
+   3285,
+   3408,
+   752,
+   4530,
+   3919,
+   958,
+   5772,
+   4507,
+   1165,
+   7016,
+   5183,
+   1371,
+   8259,
+   5960,
+   1577,
+   9501,
+   6855,
+   1784,
+   10745,
+   7883,
+   1991,
+   11988,
+   9065,
+   2197,
+   13231,
+   10425,
+   2404,
+   14474,
+   12510,
+   2673,
+   16096,
+   16263,
+   3060,
+   18429,
+   21142,
+   3448,
+   20763,
+   27485,
+   3836,
+   23097
+};
+
+/* gray coding table */
+static const Word8 gray[8] =
+{
+   0,
+   1,
+   3,
+   2,
+   6,
+   4,
+   5,
+   7
+};
+
+/* gray decoding table */
+static const Word32 dgray[8] =
+{
+   0,
+   1,
+   3,
+   2,
+   5,
+   6,
+   4,
+   7
+};
+
+/* table[i] = sqrt((i+16)*2^-6) * 2^15, i.e. sqrt(x) scaled Q15 */
+static const Word32 sqrt_table[49] =
+{
+   16384,
+   16888,
+   17378,
+   17854,
+   18318,
+   18770,
+   19212,
+   19644,
+   20066,
+   20480,
+   20886,
+   21283,
+   21674,
+   22058,
+   22435,
+   22806,
+   23170,
+   23530,
+   23884,
+   24232,
+   24576,
+   24915,
+   25249,
+   25580,
+   25905,
+   26227,
+   26545,
+   26859,
+   27170,
+   27477,
+   27780,
+   28081,
+   28378,
+   28672,
+   28963,
+   29251,
+   29537,
+   29819,
+   30099,
+   30377,
+   30652,
+   30924,
+   31194,
+   31462,
+   31727,
+   31991,
+   32252,
+   32511,
+   32767
+};
+
+static const Word32 inv_sqrt_table[49] =
+{
+   32767,
+   31790,
+   30894,
+   30070,
+   29309,
+   28602,
+   27945,
+   27330,
+   26755,
+   26214,
+   25705,
+   25225,
+   24770,
+   24339,
+   23930,
+   23541,
+   23170,
+   22817,
+   22479,
+   22155,
+   21845,
+   21548,
+   21263,
+   20988,
+   20724,
+   20470,
+   20225,
+   19988,
+   19760,
+   19539,
+   19326,
+   19119,
+   18919,
+   18725,
+   18536,
+   18354,
+   18176,
+   18004,
+   17837,
+   17674,
+   17515,
+   17361,
+   17211,
+   17064,
+   16921,
+   16782,
+   16646,
+   16514,
+   16384
+};
+/* table used inbase 2 logharithm computation */
+static const Word32 log2_table[33] =
+{
+   0,
+   1455,
+   2866,
+   4236,
+   5568,
+   6863,
+   8124,
+   9352,
+   10549,
+   11716,
+   12855,
+   13967,
+   15054,
+   16117,
+   17156,
+   18172,
+   19167,
+   20142,
+   21097,
+   22033,
+   22951,
+   23852,
+   24735,
+   25603,
+   26455,
+   27291,
+   28113,
+   28922,
+   29716,
+   30497,
+   31266,
+   32023,
+   32767
+};
+
+/* table used in 2 to the power computation */
+static const Word32 pow2_table[33] =
+{
+   16384,
+   16743,
+   17109,
+   17484,
+   17867,
+   18258,
+   18658,
+   19066,
+   19484,
+   19911,
+   20347,
+   20792,
+   21247,
+   21713,
+   22188,
+   22674,
+   23170,
+   23678,
+   24196,
+   24726,
+   25268,
+   25821,
+   26386,
+   26964,
+   27554,
+   28158,
+   28774,
+   29405,
+   30048,
+   30706,
+   31379,
+   32066,
+   32767
+};
+
+/* table of cos(x) */
+static const Word32 cos_table[65] =
+{
+   32767,
+   32729,
+   32610,
+   32413,
+   32138,
+   31786,
+   31357,
+   30853,
+   30274,
+   29622,
+   28899,
+   28106,
+   27246,
+   26320,
+   25330,
+   24279,
+   23170,
+   22006,
+   20788,
+   19520,
+   18205,
+   16846,
+   15447,
+   14010,
+   12540,
+   11039,
+   9512,
+   7962,
+   6393,
+   4808,
+   3212,
+   1608,
+   0,
+   - 1608,
+   - 3212,
+   - 4808,
+   - 6393,
+   - 7962,
+   - 9512,
+   - 11039,
+   - 12540,
+   - 14010,
+   - 15447,
+   - 16846,
+   - 18205,
+   - 19520,
+   - 20788,
+   - 22006,
+   - 23170,
+   - 24279,
+   - 25330,
+   - 26320,
+   - 27246,
+   - 28106,
+   - 28899,
+   - 29622,
+   - 30274,
+   - 30853,
+   - 31357,
+   - 31786,
+   - 32138,
+   - 32413,
+   - 32610,
+   - 32729,
+   - 32768
+};
+
+/* slope used to compute y = acos(x) */
+static const Word32 acos_slope[64] =
+{
+   - 26887,
+   - 8812,
+   - 5323,
+   - 3813,
+   - 2979,
+   - 2444,
+   - 2081,
+   - 1811,
+   - 1608,
+   - 1450,
+   - 1322,
+   - 1219,
+   - 1132,
+   - 1059,
+   - 998,
+   - 946,
+   - 901,
+   - 861,
+   - 827,
+   - 797,
+   - 772,
+   - 750,
+   - 730,
+   - 713,
+   - 699,
+   - 687,
+   - 677,
+   - 668,
+   - 662,
+   - 657,
+   - 654,
+   - 652,
+   - 652,
+   - 654,
+   - 657,
+   - 662,
+   - 668,
+   - 677,
+   - 687,
+   - 699,
+   - 713,
+   - 730,
+   - 750,
+   - 772,
+   - 797,
+   - 827,
+   - 861,
+   - 901,
+   - 946,
+   - 998,
+   - 1059,
+   - 1132,
+   - 1219,
+   - 1322,
+   - 1450,
+   - 1608,
+   - 1811,
+   - 2081,
+   - 2444,
+   - 2979,
+   - 3813,
+   - 5323,
+   - 8812,
+   - 26887
+};
+
+/* All impulse responses are in Q15 */
+/* phase dispersion impulse response (MR795) */
+static const Word32 ph_imp_low_MR795[] =
+{
+   26777,
+   801,
+   2505,
+   - 683,
+   - 1382,
+   582,
+   604,
+   - 1274,
+   3511,
+   - 5894,
+   4534,
+   - 499,
+   - 1940,
+   3011,
+   - 5058,
+   5614,
+   - 1990,
+   - 1061,
+   - 1459,
+   4442,
+   - 700,
+   - 5335,
+   4609,
+   452,
+   - 589,
+   - 3352,
+   2953,
+   1267,
+   - 1212,
+   - 2590,
+   1731,
+   3670,
+   - 4475,
+   - 975,
+   4391,
+   - 2537,
+   949,
+   - 1363,
+   - 979,
+   5734
+};
+/* phase dispersion impulse response (MR795) */
+static const Word32 ph_imp_mid_MR795[] =
+{
+   30274,
+   3831,
+   - 4036,
+   2972,
+   - 1048,
+   - 1002,
+   2477,
+   - 3043,
+   2815,
+   - 2231,
+   1753,
+   - 1611,
+   1714,
+   - 1775,
+   1543,
+   - 1008,
+   429,
+   - 169,
+   472,
+   - 1264,
+   2176,
+   - 2706,
+   2523,
+   - 1621,
+   344,
+   826,
+   - 1529,
+   1724,
+   - 1657,
+   1701,
+   - 2063,
+   2644,
+   - 3060,
+   2897,
+   - 1978,
+   557,
+   780,
+   - 1369,
+   842,
+   655
+};
+
+/* phase dispersion impulse response (MR475 - MR67) */
+static const Word32 ph_imp_low[] =
+{
+   14690,
+   11518,
+   1268,
+   - 2761,
+   - 5671,
+   7514,
+   - 35,
+   - 2807,
+   - 3040,
+   4823,
+   2952,
+   - 8424,
+   3785,
+   1455,
+   2179,
+   - 8637,
+   8051,
+   - 2103,
+   - 1454,
+   777,
+   1108,
+   - 2385,
+   2254,
+   - 363,
+   - 674,
+   - 2103,
+   6046,
+   - 5681,
+   1072,
+   3123,
+   - 5058,
+   5312,
+   - 2329,
+   - 3728,
+   6924,
+   - 3889,
+   675,
+   - 1775,
+   29,
+   10145
+};
+
+/* phase dispersion impulse response (MR475 - MR67) */
+static const Word32 ph_imp_mid[] =
+{
+   30274,
+   3831,
+   - 4036,
+   2972,
+   - 1048,
+   - 1002,
+   2477,
+   - 3043,
+   2815,
+   - 2231,
+   1753,
+   - 1611,
+   1714,
+   - 1775,
+   1543,
+   - 1008,
+   429,
+   - 169,
+   472,
+   - 1264,
+   2176,
+   - 2706,
+   2523,
+   - 1621,
+   344,
+   826,
+   - 1529,
+   1724,
+   - 1657,
+   1701,
+   - 2063,
+   2644,
+   - 3060,
+   2897,
+   - 1978,
+   557,
+   780,
+   - 1369,
+   842,
+   655
+};
+
+/* initialization table for the MA predictor in DTX */
+#define PAST_RQ_INIT_SIZE 8
+
+/* initalization table for MA predictor in dtx mode */
+static const Word32 past_rq_init[80] =
+{
+   - 258,
+   - 318,
+   - 439,
+   - 634,
+   - 656,
+   - 773,
+   - 711,
+   - 502,
+   - 268,
+   - 193,
+   - 2,
+   125,
+   122,
+   - 39,
+   - 9,
+   105,
+   129,
+   283,
+   372,
+   575,
+   - 277,
+   - 324,
+   - 197,
+   - 487,
+   - 445,
+   - 362,
+   - 292,
+   - 27,
+   177,
+   543,
+   342,
+   517,
+   516,
+   130,
+   27,
+   - 104,
+   - 120,
+   - 140,
+   - 74,
+   - 56,
+   - 564,
+   - 943,
+   - 1520,
+   - 965,
+   - 814,
+   - 526,
+   - 322,
+   - 2,
+   159,
+   657,
+   - 312,
+   - 284,
+   - 386,
+   - 597,
+   - 493,
+   - 526,
+   - 418,
+   - 229,
+   105,
+   449,
+   - 557,
+   - 870,
+   - 1075,
+   - 919,
+   - 950,
+   - 752,
+   - 709,
+   - 316,
+   62,
+   486,
+   - 314,
+   - 191,
+   - 203,
+   - 330,
+   - 160,
+   - 103,
+   - 51,
+   131,
+   338,
+   515
+};
+
+#define ALPHA     29491
+#define ONE_ALPHA 3277
+/* LSF means (not in MR122) */
+static const Word32 mean_lsf_3[10] =
+{
+   1546,
+   2272,
+   3778,
+   5488,
+   6972,
+   8382,
+   10047,
+   11229,
+   12766,
+   13714
+};
+
+#define ALPHA_122     31128
+#define ONE_ALPHA_122 1639
+/* LSF means ->normalize frequency domain */
+static const Word32 mean_lsf_5[10] =
+{
+   1384,
+   2077,
+   3420,
+   5108,
+   6742,
+   8122,
+   9863,
+   11092,
+   12714,
+   13701
+};
+
+/* LSF prediction factors (not in MR122) */
+static const Word32 pred_fac[10] =
+{
+   9556,
+   10769,
+   12571,
+   13292,
+   14381,
+   11651,
+   10588,
+   9767,
+   8593,
+   6484
+};
+#define DICO1_SIZE_3  256
+#define DICO2_SIZE_3  512
+#define DICO3_SIZE_3  512
+
+/* 1st LSF quantizer (not in MR122 and MR795) */
+static const Word32 dico1_lsf_3[] =
+{
+   6,
+   82,
+   - 131,
+   154,
+   - 56,
+   - 735,
+   183,
+   - 65,
+   - 265,
+   9,
+   - 210,
+   - 361,
+   113,
+   718,
+   1817,
+   1010,
+   1214,
+   1573,
+   857,
+   1333,
+   2276,
+   827,
+   1568,
+   1933,
+   717,
+   1989,
+   2206,
+   838,
+   1172,
+   1823,
+   721,
+   1000,
+   2154,
+   286,
+   476,
+   1509,
+   - 247,
+   - 531,
+   230,
+   147,
+   - 82,
+   569,
+   26,
+   - 177,
+   - 944,
+   - 27,
+   - 273,
+   692,
+   - 164,
+   - 264,
+   - 183,
+   224,
+   790,
+   1039,
+   899,
+   946,
+   601,
+   485,
+   771,
+   1150,
+   524,
+   677,
+   903,
+   - 140,
+   375,
+   778,
+   410,
+   676,
+   429,
+   301,
+   530,
+   1009,
+   719,
+   646,
+   38,
+   226,
+   367,
+   40,
+   145,
+   - 45,
+   - 505,
+   290,
+   121,
+   - 121,
+   302,
+   127,
+   166,
+   - 124,
+   - 383,
+   - 956,
+   - 358,
+   - 455,
+   - 977,
+   715,
+   878,
+   894,
+   978,
+   923,
+   211,
+   477,
+   272,
+   64,
+   188,
+   - 78,
+   17,
+   - 143,
+   - 65,
+   38,
+   643,
+   586,
+   621,
+   - 134,
+   - 426,
+   - 651,
+   347,
+   545,
+   2820,
+   1188,
+   2726,
+   2442,
+   142,
+   - 80,
+   1735,
+   283,
+   130,
+   461,
+   - 262,
+   - 399,
+   - 1145,
+   - 411,
+   155,
+   430,
+   329,
+   375,
+   779,
+   53,
+   - 226,
+   - 139,
+   - 129,
+   - 236,
+   1682,
+   285,
+   744,
+   1327,
+   738,
+   697,
+   1664,
+   312,
+   409,
+   266,
+   325,
+   720,
+   135,
+   1,
+   221,
+   453,
+   8,
+   203,
+   145,
+   299,
+   640,
+   760,
+   29,
+   468,
+   638,
+   103,
+   429,
+   379,
+   420,
+   954,
+   932,
+   1326,
+   1210,
+   1258,
+   704,
+   1012,
+   1152,
+   - 166,
+   - 444,
+   - 266,
+   - 316,
+   - 130,
+   - 376,
+   191,
+   1151,
+   1904,
+   - 240,
+   - 543,
+   - 1260,
+   - 112,
+   268,
+   1207,
+   70,
+   1062,
+   1583,
+   278,
+   1360,
+   1574,
+   - 258,
+   - 272,
+   - 768,
+   19,
+   563,
+   2240,
+   - 3,
+   - 265,
+   135,
+   - 295,
+   - 591,
+   - 388,
+   140,
+   354,
+   - 206,
+   - 260,
+   - 504,
+   - 795,
+   - 433,
+   - 718,
+   - 1319,
+   109,
+   331,
+   962,
+   - 429,
+   - 87,
+   652,
+   - 296,
+   426,
+   1019,
+   - 239,
+   775,
+   851,
+   489,
+   1334,
+   1073,
+   - 334,
+   - 332,
+   25,
+   543,
+   1206,
+   1807,
+   326,
+   61,
+   727,
+   578,
+   849,
+   1405,
+   - 208,
+   - 277,
+   329,
+   - 152,
+   64,
+   669,
+   - 434,
+   - 678,
+   - 727,
+   - 454,
+   - 71,
+   251,
+   605,
+   480,
+   254,
+   - 482,
+   11,
+   996,
+   - 289,
+   395,
+   486,
+   722,
+   1049,
+   1440,
+   - 30,
+   - 316,
+   - 786,
+   - 106,
+   - 115,
+   - 619,
+   861,
+   1474,
+   1412,
+   1055,
+   1366,
+   1184,
+   812,
+   1237,
+   925,
+   42,
+   - 251,
+   - 576,
+   342,
+   141,
+   - 454,
+   - 168,
+   - 80,
+   1359,
+   - 342,
+   - 656,
+   - 1763,
+   100,
+   821,
+   725,
+   990,
+   747,
+   800,
+   332,
+   440,
+   568,
+   663,
+   379,
+   852,
+   112,
+   165,
+   - 369,
+   597,
+   910,
+   282,
+   - 8,
+   834,
+   1281,
+   - 352,
+   572,
+   695,
+   462,
+   2246,
+   1806,
+   345,
+   190,
+   1374,
+   416,
+   915,
+   2166,
+   168,
+   - 82,
+   280,
+   - 516,
+   - 446,
+   840,
+   47,
+   533,
+   44,
+   - 362,
+   - 711,
+   - 1143,
+   22,
+   193,
+   1472,
+   - 85,
+   233,
+   1813,
+   - 62,
+   579,
+   1504,
+   550,
+   944,
+   1749,
+   723,
+   650,
+   1148,
+   972,
+   884,
+   1395,
+   - 425,
+   643,
+   0,
+   1000,
+   952,
+   1098,
+   249,
+   1446,
+   672,
+   - 334,
+   - 87,
+   2172,
+   - 554,
+   1882,
+   2672,
+   140,
+   1826,
+   1853,
+   920,
+   1749,
+   2590,
+   1076,
+   1933,
+   2038,
+   - 137,
+   - 443,
+   - 1555,
+   1269,
+   1174,
+   468,
+   - 493,
+   - 122,
+   1521,
+   - 451,
+   1033,
+   1214,
+   482,
+   1695,
+   1118,
+   815,
+   649,
+   384,
+   - 446,
+   - 692,
+   107,
+   - 319,
+   - 605,
+   - 118,
+   - 207,
+   - 505,
+   525,
+   - 468,
+   - 12,
+   2736,
+   75,
+   1934,
+   1305,
+   880,
+   2358,
+   2267,
+   1285,
+   1575,
+   2004,
+   - 48,
+   - 304,
+   - 1186,
+   - 435,
+   - 461,
+   - 251,
+   - 366,
+   - 404,
+   - 547,
+   - 289,
+   - 605,
+   - 597,
+   - 538,
+   - 810,
+   - 165,
+   - 120,
+   3,
+   356,
+   639,
+   1241,
+   1502,
+   96,
+   177,
+   750,
+   - 435,
+   - 585,
+   - 1174,
+   - 356,
+   109,
+   - 79,
+   - 485,
+   288,
+   2005,
+   9,
+   1116,
+   731,
+   880,
+   2134,
+   946,
+   - 265,
+   1585,
+   1065,
+   1157,
+   1210,
+   843,
+   - 498,
+   - 668,
+   431,
+   374,
+   321,
+   - 229,
+   1440,
+   2101,
+   1381,
+   449,
+   461,
+   1155,
+   - 105,
+   39,
+   - 384,
+   - 263,
+   367,
+   182,
+   - 371,
+   - 660,
+   773,
+   - 188,
+   1151,
+   971,
+   1333,
+   1632,
+   1435,
+   774,
+   1267,
+   1221,
+   - 482,
+   - 832,
+   - 1489,
+   - 237,
+   - 210,
+   860,
+   890,
+   1615,
+   1064,
+   472,
+   1062,
+   1192,
+   185,
+   1077,
+   989,
+   - 568,
+   - 992,
+   - 1704,
+   - 449,
+   - 902,
+   - 2043,
+   - 142,
+   - 377,
+   - 458,
+   - 210,
+   - 554,
+   - 1029,
+   - 11,
+   1133,
+   2265,
+   - 329,
+   - 675,
+   - 893,
+   - 250,
+   657,
+   1187,
+   519,
+   1510,
+   1779,
+   520,
+   539,
+   1403,
+   527,
+   1421,
+   1302,
+   - 563,
+   - 871,
+   - 1248,
+   - 147,
+   - 463,
+   879,
+   - 76,
+   2334,
+   2840,
+   563,
+   2573,
+   2385,
+   632,
+   1926,
+   2920,
+   719,
+   2023,
+   1840,
+   - 545,
+   - 723,
+   1108,
+   129,
+   - 125,
+   884,
+   1417,
+   1632,
+   925,
+   - 94,
+   1566,
+   1751,
+   - 341,
+   1533,
+   1551,
+   591,
+   395,
+   - 274,
+   - 76,
+   981,
+   2831,
+   153,
+   2985,
+   1844,
+   1032,
+   2565,
+   2749,
+   1508,
+   2832,
+   1879,
+   791,
+   1199,
+   538,
+   - 190,
+   - 453,
+   1489,
+   - 278,
+   - 548,
+   1158,
+   - 245,
+   1941,
+   2044,
+   1024,
+   1560,
+   1650,
+   512,
+   253,
+   466,
+   - 62,
+   - 323,
+   1151,
+   - 473,
+   - 376,
+   507,
+   - 433,
+   1380,
+   2162,
+   899,
+   1943,
+   1445,
+   134,
+   704,
+   440,
+   460,
+   525,
+   - 28,
+   - 450,
+   279,
+   1338,
+   0,
+   971,
+   252,
+   - 445,
+   - 627,
+   - 991,
+   - 348,
+   - 602,
+   - 1424,
+   398,
+   712,
+   1656,
+   - 107,
+   314,
+   - 178,
+   93,
+   2226,
+   2238,
+   518,
+   849,
+   656,
+   - 462,
+   - 711,
+   - 447,
+   174,
+   - 34,
+   1191,
+   - 119,
+   42,
+   1005,
+   - 372,
+   274,
+   758,
+   1036,
+   2352,
+   1838,
+   675,
+   1724,
+   1498,
+   430,
+   1286,
+   2133,
+   - 129,
+   - 439,
+   0,
+   - 373,
+   800,
+   2144,
+   6,
+   1587,
+   2478,
+   478,
+   596,
+   2128,
+   - 428,
+   - 736,
+   1505,
+   385,
+   178,
+   980,
+   139,
+   449,
+   1225,
+   - 526,
+   - 842,
+   - 982,
+   145,
+   1554,
+   1242,
+   623,
+   1448,
+   656,
+   349,
+   1016,
+   1482,
+   31,
+   - 280,
+   415,
+   - 316,
+   724,
+   1641,
+   360,
+   1058,
+   556,
+   - 436,
+   - 358,
+   1201,
+   - 355,
+   1123,
+   1939,
+   401,
+   1584,
+   2248,
+   - 527,
+   - 1012,
+   355,
+   233,
+   238,
+   2233,
+   - 550,
+   - 897,
+   - 639,
+   - 365,
+   - 501,
+   1957,
+   389,
+   1860,
+   1621,
+   162,
+   1132,
+   1264,
+   - 237,
+   1174,
+   1390,
+   - 640,
+   - 411,
+   116,
+   - 228,
+   1694,
+   2298,
+   1639,
+   2186,
+   2267,
+   562,
+   1273,
+   2658,
+   323,
+   338,
+   1774,
+   578,
+   1107,
+   852,
+   22,
+   594,
+   934,
+   - 143,
+   718,
+   446
+};
+
+/* 2nd LSF quantizer (not in MR122) */
+static const Word32 dico2_lsf_3[] =
+{
+   50,
+   71,
+   - 9,
+   - 338,
+   - 698,
+   - 1407,
+   102,
+   - 138,
+   - 820,
+   - 310,
+   - 469,
+   - 1147,
+   414,
+   67,
+   - 267,
+   1060,
+   814,
+   1441,
+   1548,
+   1360,
+   1272,
+   1754,
+   1895,
+   1661,
+   2019,
+   2133,
+   1820,
+   1808,
+   2318,
+   1845,
+   644,
+   - 93,
+   454,
+   858,
+   329,
+   - 136,
+   489,
+   - 258,
+   - 128,
+   - 198,
+   - 745,
+   - 41,
+   - 52,
+   - 265,
+   - 985,
+   346,
+   137,
+   479,
+   - 1741,
+   - 748,
+   - 684,
+   - 1163,
+   - 1725,
+   - 367,
+   - 895,
+   - 1145,
+   - 784,
+   - 488,
+   - 946,
+   - 968,
+   - 85,
+   - 390,
+   - 725,
+   215,
+   - 340,
+   - 171,
+   1020,
+   916,
+   1969,
+   564,
+   179,
+   746,
+   662,
+   977,
+   1734,
+   887,
+   622,
+   914,
+   939,
+   856,
+   1165,
+   309,
+   688,
+   803,
+   917,
+   161,
+   570,
+   118,
+   - 20,
+   - 283,
+   - 816,
+   - 42,
+   204,
+   - 1228,
+   - 325,
+   - 462,
+   - 963,
+   - 202,
+   - 143,
+   - 988,
+   - 484,
+   - 361,
+   - 702,
+   - 978,
+   - 477,
+   - 302,
+   - 790,
+   - 1188,
+   - 100,
+   - 786,
+   - 1088,
+   - 1054,
+   - 947,
+   - 1684,
+   - 202,
+   - 843,
+   - 782,
+   - 1039,
+   - 1378,
+   - 901,
+   - 624,
+   - 110,
+   - 85,
+   356,
+   213,
+   - 10,
+   - 493,
+   364,
+   774,
+   425,
+   822,
+   479,
+   - 83,
+   557,
+   520,
+   - 992,
+   - 1560,
+   - 572,
+   - 603,
+   - 741,
+   - 26,
+   - 502,
+   - 638,
+   - 903,
+   209,
+   306,
+   147,
+   - 316,
+   - 593,
+   - 596,
+   - 85,
+   - 211,
+   - 225,
+   - 918,
+   - 529,
+   117,
+   233,
+   - 439,
+   - 738,
+   1101,
+   751,
+   633,
+   1457,
+   1716,
+   1511,
+   1765,
+   1457,
+   910,
+   1122,
+   1156,
+   849,
+   1354,
+   868,
+   470,
+   - 871,
+   - 1150,
+   - 1796,
+   - 871,
+   - 861,
+   - 992,
+   - 118,
+   155,
+   212,
+   - 1051,
+   - 849,
+   - 606,
+   - 1117,
+   - 1849,
+   - 2750,
+   - 1019,
+   - 1427,
+   - 1869,
+   370,
+   - 184,
+   - 414,
+   959,
+   493,
+   104,
+   958,
+   1039,
+   543,
+   154,
+   653,
+   201,
+   1249,
+   507,
+   150,
+   663,
+   503,
+   230,
+   623,
+   777,
+   675,
+   659,
+   88,
+   - 110,
+   843,
+   244,
+   224,
+   382,
+   541,
+   302,
+   724,
+   433,
+   666,
+   1166,
+   734,
+   341,
+   - 138,
+   20,
+   - 397,
+   - 1183,
+   - 424,
+   - 46,
+   - 321,
+   - 352,
+   - 124,
+   1333,
+   1021,
+   1080,
+   262,
+   366,
+   723,
+   922,
+   283,
+   - 551,
+   31,
+   - 636,
+   - 611,
+   - 689,
+   - 697,
+   - 415,
+   - 952,
+   - 779,
+   - 201,
+   - 1329,
+   - 598,
+   - 359,
+   - 953,
+   - 1285,
+   166,
+   493,
+   305,
+   221,
+   846,
+   703,
+   610,
+   840,
+   936,
+   774,
+   - 723,
+   - 1324,
+   - 1261,
+   - 357,
+   - 1025,
+   - 1388,
+   - 1096,
+   - 1376,
+   - 365,
+   - 1416,
+   - 1881,
+   - 608,
+   - 1798,
+   - 1727,
+   - 674,
+   - 545,
+   - 1173,
+   - 703,
+   678,
+   786,
+   148,
+   - 123,
+   696,
+   1288,
+   644,
+   350,
+   - 10,
+   414,
+   614,
+   15,
+   137,
+   344,
+   - 211,
+   - 814,
+   - 1512,
+   - 819,
+   - 391,
+   - 930,
+   - 588,
+   47,
+   - 591,
+   - 898,
+   - 909,
+   - 1097,
+   - 163,
+   - 1272,
+   - 1167,
+   - 157,
+   - 1464,
+   - 1525,
+   - 389,
+   - 1274,
+   - 1188,
+   - 624,
+   671,
+   213,
+   454,
+   124,
+   - 274,
+   - 525,
+   - 729,
+   - 496,
+   - 152,
+   - 1344,
+   122,
+   135,
+   - 2905,
+   - 589,
+   - 394,
+   - 1728,
+   441,
+   - 50,
+   1476,
+   904,
+   787,
+   316,
+   236,
+   - 440,
+   - 347,
+   217,
+   413,
+   - 911,
+   - 917,
+   121,
+   - 455,
+   - 932,
+   202,
+   - 92,
+   - 465,
+   - 375,
+   488,
+   390,
+   474,
+   876,
+   729,
+   316,
+   - 1815,
+   - 1312,
+   - 669,
+   87,
+   962,
+   432,
+   563,
+   - 249,
+   - 1058,
+   250,
+   285,
+   1105,
+   1141,
+   427,
+   696,
+   - 1038,
+   - 1664,
+   - 1582,
+   - 948,
+   346,
+   160,
+   - 309,
+   - 272,
+   - 858,
+   670,
+   624,
+   1250,
+   - 944,
+   - 408,
+   - 666,
+   - 606,
+   - 320,
+   - 384,
+   - 492,
+   230,
+   65,
+   334,
+   - 50,
+   - 16,
+   - 16,
+   - 690,
+   - 1397,
+   1791,
+   1716,
+   1399,
+   2478,
+   2063,
+   1404,
+   1245,
+   1471,
+   1426,
+   - 382,
+   - 1037,
+   - 2,
+   173,
+   - 398,
+   1145,
+   1491,
+   2024,
+   1801,
+   772,
+   1274,
+   1506,
+   1429,
+   1735,
+   2001,
+   1079,
+   1218,
+   1273,
+   - 1154,
+   - 1851,
+   - 1329,
+   - 808,
+   - 1133,
+   - 1096,
+   - 451,
+   - 1033,
+   - 1722,
+   65,
+   578,
+   - 84,
+   - 1476,
+   - 2434,
+   - 1778,
+   - 765,
+   - 1366,
+   - 494,
+   - 218,
+   - 594,
+   - 931,
+   337,
+   - 236,
+   562,
+   2357,
+   2662,
+   1938,
+   1489,
+   1276,
+   874,
+   189,
+   358,
+   374,
+   - 1519,
+   - 2281,
+   - 2346,
+   - 967,
+   - 1271,
+   - 2095,
+   - 628,
+   - 1188,
+   - 1542,
+   1661,
+   1043,
+   546,
+   565,
+   1061,
+   732,
+   - 64,
+   - 836,
+   - 434,
+   - 436,
+   - 96,
+   203,
+   1078,
+   1216,
+   1636,
+   907,
+   1534,
+   986,
+   326,
+   965,
+   845,
+   142,
+   - 84,
+   197,
+   470,
+   2379,
+   1570,
+   1133,
+   470,
+   1214,
+   395,
+   1376,
+   1200,
+   1125,
+   1042,
+   348,
+   - 543,
+   - 1234,
+   - 376,
+   - 215,
+   - 181,
+   481,
+   - 1947,
+   - 1621,
+   - 210,
+   - 750,
+   - 1185,
+   390,
+   29,
+   - 399,
+   27,
+   820,
+   1236,
+   755,
+   695,
+   979,
+   409,
+   - 174,
+   1197,
+   1035,
+   912,
+   1356,
+   1846,
+   - 992,
+   - 1437,
+   484,
+   - 1485,
+   - 1700,
+   208,
+   - 412,
+   1204,
+   1432,
+   - 271,
+   896,
+   1144,
+   - 416,
+   1777,
+   1434,
+   - 1696,
+   - 2644,
+   - 204,
+   - 1789,
+   - 1551,
+   1033,
+   - 1656,
+   - 1559,
+   1303,
+   - 1253,
+   - 1589,
+   1081,
+   - 669,
+   - 1095,
+   - 66,
+   - 682,
+   320,
+   - 345,
+   659,
+   305,
+   1069,
+   - 1292,
+   - 804,
+   - 19,
+   - 1635,
+   - 1291,
+   29,
+   - 1683,
+   - 497,
+   71,
+   - 287,
+   - 7,
+   - 100,
+   - 494,
+   - 962,
+   - 237,
+   852,
+   1881,
+   1740,
+   - 1217,
+   - 1387,
+   227,
+   - 660,
+   302,
+   373,
+   96,
+   1087,
+   1257,
+   - 1074,
+   - 1669,
+   160,
+   485,
+   2076,
+   1798,
+   - 934,
+   - 220,
+   552,
+   - 596,
+   - 612,
+   237,
+   336,
+   1720,
+   879,
+   643,
+   629,
+   434,
+   1267,
+   522,
+   1633,
+   15,
+   244,
+   - 441,
+   1475,
+   717,
+   184,
+   1819,
+   1590,
+   1709,
+   988,
+   261,
+   937,
+   2093,
+   2345,
+   1520,
+   2139,
+   1858,
+   1606,
+   - 577,
+   - 579,
+   - 1203,
+   - 956,
+   135,
+   - 488,
+   - 464,
+   51,
+   - 338,
+   - 629,
+   - 348,
+   - 723,
+   1146,
+   2073,
+   1442,
+   2192,
+   1466,
+   911,
+   - 1444,
+   - 1572,
+   - 2278,
+   1400,
+   710,
+   1297,
+   1335,
+   633,
+   928,
+   1434,
+   2194,
+   2594,
+   2422,
+   2204,
+   1881,
+   982,
+   2242,
+   1854,
+   380,
+   792,
+   1145,
+   - 63,
+   - 539,
+   414,
+   - 252,
+   - 964,
+   - 314,
+   - 1261,
+   - 683,
+   - 780,
+   - 831,
+   - 526,
+   - 1005,
+   - 1666,
+   - 1135,
+   - 424,
+   - 1611,
+   - 452,
+   - 299,
+   1268,
+   1048,
+   642,
+   1147,
+   853,
+   856,
+   - 675,
+   - 336,
+   139,
+   2268,
+   1343,
+   1418,
+   29,
+   768,
+   797,
+   - 1224,
+   423,
+   564,
+   - 1318,
+   - 1082,
+   245,
+   - 1302,
+   - 812,
+   573,
+   - 1298,
+   - 1617,
+   646,
+   - 968,
+   834,
+   723,
+   993,
+   1652,
+   2027,
+   - 191,
+   - 817,
+   432,
+   662,
+   60,
+   198,
+   626,
+   997,
+   1330,
+   1648,
+   1963,
+   1289,
+   - 1597,
+   - 93,
+   - 45,
+   - 1088,
+   37,
+   - 84,
+   1653,
+   2607,
+   2337,
+   1065,
+   2040,
+   2377,
+   1139,
+   2326,
+   2118,
+   859,
+   357,
+   1510,
+   664,
+   1227,
+   1099,
+   479,
+   1360,
+   912,
+   1897,
+   1754,
+   2019,
+   1168,
+   1909,
+   1784,
+   399,
+   34,
+   256,
+   - 593,
+   - 304,
+   - 1053,
+   547,
+   1694,
+   1407,
+   647,
+   - 99,
+   - 341,
+   1492,
+   1647,
+   1190,
+   38,
+   - 644,
+   - 212,
+   395,
+   846,
+   222,
+   - 704,
+   - 765,
+   - 716,
+   - 724,
+   - 1964,
+   - 2804,
+   - 150,
+   291,
+   - 82,
+   1233,
+   1459,
+   1007,
+   - 140,
+   - 155,
+   153,
+   439,
+   297,
+   1568,
+   - 1529,
+   - 410,
+   - 636,
+   1536,
+   455,
+   - 237,
+   - 1328,
+   - 139,
+   - 260,
+   531,
+   554,
+   868,
+   269,
+   1264,
+   606,
+   - 233,
+   883,
+   463,
+   742,
+   600,
+   - 120,
+   - 73,
+   421,
+   212,
+   - 439,
+   - 58,
+   804,
+   - 1286,
+   - 1241,
+   728,
+   294,
+   - 490,
+   50,
+   - 591,
+   - 905,
+   - 1254,
+   42,
+   - 687,
+   147,
+   - 25,
+   273,
+   596,
+   - 311,
+   1213,
+   601,
+   - 754,
+   849,
+   584,
+   429,
+   607,
+   587,
+   - 602,
+   - 166,
+   461,
+   - 796,
+   - 823,
+   777,
+   1380,
+   910,
+   1755,
+   119,
+   1417,
+   972,
+   - 219,
+   - 880,
+   - 1596,
+   - 1049,
+   - 1010,
+   438,
+   - 713,
+   - 1379,
+   78,
+   0,
+   - 447,
+   - 1179,
+   - 1136,
+   - 1319,
+   - 1573,
+   2248,
+   1767,
+   1309,
+   946,
+   1583,
+   1432,
+   1150,
+   482,
+   436,
+   - 469,
+   - 1108,
+   618,
+   - 447,
+   - 966,
+   1088,
+   - 1252,
+   - 1515,
+   - 114,
+   - 1104,
+   - 2008,
+   - 579,
+   210,
+   613,
+   497,
+   - 1975,
+   - 1437,
+   642,
+   - 1269,
+   - 856,
+   1011,
+   - 1646,
+   - 1185,
+   1063,
+   - 1555,
+   - 672,
+   1204,
+   - 1692,
+   - 1114,
+   623,
+   - 979,
+   - 1326,
+   - 1277,
+   539,
+   - 147,
+   894,
+   - 1354,
+   - 897,
+   - 434,
+   888,
+   475,
+   428,
+   153,
+   - 384,
+   338,
+   - 1492,
+   - 511,
+   359,
+   - 974,
+   - 1115,
+   - 470,
+   105,
+   - 550,
+   677,
+   - 937,
+   - 1145,
+   877,
+   380,
+   - 260,
+   210,
+   1685,
+   924,
+   1256,
+   1775,
+   1190,
+   1095,
+   1419,
+   631,
+   533,
+   627,
+   299,
+   - 347,
+   - 411,
+   - 534,
+   647,
+   - 650,
+   29,
+   - 595,
+   - 378,
+   - 1367,
+   1563,
+   1402,
+   1121,
+   1465,
+   1089,
+   1410,
+   648,
+   - 2096,
+   - 1090,
+   - 6,
+   311,
+   - 194,
+   - 869,
+   - 639,
+   - 831,
+   416,
+   - 1162,
+   - 1224,
+   1349,
+   - 1247,
+   - 941,
+   1813,
+   - 2193,
+   - 1987,
+   453,
+   - 619,
+   - 1367,
+   - 956,
+   - 1606,
+   - 1972,
+   - 1507,
+   - 1175,
+   - 1057,
+   - 1104,
+   - 377,
+   601,
+   201,
+   1876,
+   825,
+   374,
+   - 430,
+   - 1323,
+   29,
+   - 1397,
+   - 1249,
+   - 1331,
+   - 1007,
+   - 1504,
+   960,
+   - 1401,
+   - 2009,
+   197,
+   - 1379,
+   - 1949,
+   - 236,
+   - 1077,
+   123,
+   422,
+   615,
+   1269,
+   546,
+   - 306,
+   1526,
+   904,
+   1194,
+   1788,
+   1177,
+   - 626,
+   - 884,
+   - 1526,
+   199,
+   766,
+   1504,
+   - 1065,
+   862,
+   197,
+   - 1034,
+   - 1773,
+   - 887,
+   - 800,
+   145,
+   599,
+   - 1134,
+   - 519,
+   626,
+   - 1205,
+   - 1926,
+   500,
+   - 910,
+   - 1041,
+   - 1395,
+   - 1476,
+   - 1567,
+   - 969,
+   - 523,
+   842,
+   34,
+   1794,
+   646,
+   862,
+   - 1207,
+   - 1888,
+   - 1002,
+   - 78,
+   - 9,
+   - 672,
+   1044,
+   759,
+   80,
+   - 600,
+   1139,
+   1019,
+   57,
+   2000,
+   1422,
+   - 833,
+   1414,
+   1121,
+   - 1202,
+   1630,
+   1260,
+   - 461,
+   1420,
+   1244,
+   1537,
+   975,
+   253,
+   - 283,
+   324,
+   - 359,
+   599,
+   - 195,
+   106,
+   588,
+   62,
+   - 587,
+   - 757,
+   645,
+   205,
+   51,
+   1201,
+   758,
+   - 1209,
+   673,
+   - 390,
+   - 624,
+   1581,
+   941,
+   - 151,
+   1023,
+   735,
+   2820,
+   1301,
+   690,
+   - 302,
+   524,
+   - 99,
+   - 900,
+   - 1588,
+   - 1189,
+   1084,
+   251,
+   238,
+   2014,
+   1792,
+   1010,
+   1245,
+   1633,
+   1741,
+   - 1227,
+   - 1540,
+   - 1208,
+   - 621,
+   456,
+   - 109,
+   40,
+   - 65,
+   788,
+   - 805,
+   - 699,
+   - 1350,
+   - 583,
+   904,
+   832,
+   - 801,
+   532,
+   594,
+   1972,
+   1408,
+   1351,
+   - 1177,
+   - 1880,
+   - 2114,
+   - 773,
+   568,
+   948,
+   - 1015,
+   1079,
+   1260,
+   - 1111,
+   482,
+   - 130,
+   1778,
+   1044,
+   780,
+   - 1491,
+   245,
+   912,
+   - 316,
+   - 1141,
+   - 917,
+   - 536,
+   - 1442,
+   - 2346,
+   - 785,
+   - 1546,
+   - 1988,
+   - 2003,
+   257,
+   909,
+   - 1849,
+   - 633,
+   - 1209,
+   - 1538,
+   - 1918,
+   - 1054,
+   1606,
+   2239,
+   1576,
+   - 567,
+   - 1500,
+   - 1544,
+   - 1279,
+   195,
+   1369,
+   - 817,
+   293,
+   1219,
+   - 525,
+   630,
+   1197,
+   - 1698,
+   - 2425,
+   - 1840,
+   - 303,
+   731,
+   747,
+   - 1169,
+   - 251,
+   269,
+   - 950,
+   - 75,
+   1684,
+   - 1182,
+   - 453,
+   1005,
+   - 1599,
+   585,
+   378,
+   - 2075,
+   - 571,
+   - 427,
+   - 529,
+   - 1159,
+   - 1171,
+   - 283,
+   - 205,
+   - 564,
+   - 796,
+   1246,
+   717,
+   2277,
+   927,
+   539,
+   - 454,
+   559,
+   440,
+   - 717,
+   1460,
+   1615,
+   - 1030,
+   1052,
+   1610,
+   - 1169,
+   - 138,
+   847,
+   226,
+   39,
+   - 612,
+   - 1251,
+   - 106,
+   - 729,
+   - 651,
+   968,
+   1302,
+   - 714,
+   - 636,
+   1727,
+   353,
+   1069,
+   410,
+   - 798,
+   - 156,
+   1099,
+   - 574,
+   918,
+   446,
+   - 1310,
+   1012,
+   466,
+   1408,
+   1591,
+   765,
+   1429,
+   1380,
+   1757,
+   1949,
+   1956,
+   2378,
+   1578,
+   2047,
+   2148,
+   916,
+   98,
+   - 7,
+   1893,
+   1418,
+   2141,
+   348,
+   1405,
+   1579,
+   152,
+   1134,
+   1801,
+   - 267,
+   154,
+   1395,
+   - 1166,
+   469,
+   1054,
+   - 1142,
+   - 405,
+   - 1073,
+   - 1341,
+   - 2264,
+   - 1581,
+   - 364,
+   869,
+   1706,
+   - 1162,
+   549,
+   1550,
+   - 1225,
+   - 1932,
+   - 1666,
+   - 1485,
+   - 1977,
+   - 2055,
+   - 1727,
+   - 906,
+   - 98,
+   - 1897,
+   233,
+   1492,
+   892,
+   108,
+   - 331,
+   - 1728,
+   - 1170,
+   - 1700,
+   - 1060,
+   1980,
+   1790,
+   - 1070,
+   - 1741,
+   - 1909,
+   - 11,
+   1539,
+   1317,
+   - 1600,
+   94,
+   497,
+   421,
+   443,
+   - 197,
+   - 1578,
+   - 349,
+   - 994,
+   - 599,
+   - 539,
+   1140,
+   - 965,
+   - 1419,
+   - 129,
+   - 1341,
+   175,
+   - 447,
+   - 375,
+   1311,
+   2055,
+   - 371,
+   - 650,
+   - 307,
+   - 1073,
+   605,
+   365,
+   - 2057,
+   - 113,
+   430,
+   652,
+   914,
+   967,
+   - 1012,
+   - 1586,
+   - 2323,
+   1505,
+   1248,
+   559,
+   262,
+   - 486,
+   - 401,
+   - 1727,
+   1342,
+   1546,
+   50,
+   56,
+   432,
+   - 330,
+   119,
+   - 604,
+   - 1517,
+   - 1080,
+   - 810,
+   946,
+   1127,
+   1055,
+   - 1400,
+   - 1703,
+   - 1712,
+   - 1270,
+   - 704,
+   - 1317,
+   807,
+   1821,
+   1143,
+   2760,
+   1606,
+   2171,
+   1120,
+   409,
+   - 150,
+   - 147,
+   404,
+   959,
+   2439,
+   1911,
+   2189,
+   - 906,
+   - 141,
+   - 866,
+   - 904,
+   - 142,
+   - 458,
+   - 557,
+   - 708,
+   - 1679,
+   - 830,
+   - 1431,
+   - 1583,
+   - 1842,
+   - 1346,
+   - 1086,
+   - 1604,
+   - 272,
+   915,
+   - 1196,
+   772,
+   1056,
+   - 638,
+   - 1234,
+   - 1897,
+   - 500,
+   - 81,
+   - 822,
+   - 1289,
+   - 1613,
+   - 735,
+   - 117,
+   785,
+   168,
+   - 1090,
+   1133,
+   922,
+   - 1096,
+   - 746,
+   1384,
+   287,
+   - 547,
+   - 1063,
+   - 1376,
+   - 2201,
+   - 1204,
+   - 2176,
+   - 1570,
+   - 1757,
+   - 1511,
+   - 2241,
+   - 771,
+   - 1737,
+   1099,
+   830,
+   - 1588,
+   724,
+   1243,
+   - 1542,
+   693,
+   805,
+   - 1690,
+   - 240,
+   1665,
+   - 1700,
+   - 4,
+   - 668,
+   2149,
+   816,
+   1042,
+   - 818,
+   - 1841,
+   22,
+   - 764,
+   - 507,
+   449,
+   - 1151,
+   - 617,
+   289,
+   - 843,
+   - 1596,
+   - 240,
+   498,
+   - 234,
+   - 657,
+   - 752,
+   480,
+   1678,
+   - 319,
+   - 481,
+   193,
+   - 811,
+   171,
+   - 119,
+   - 2128,
+   - 202,
+   - 848,
+   1717,
+   1140,
+   1700
+};
+
+/* 3rd LSF quantizer (not in MR122, MR515 and MR475) */
+static const Word32 dico3_lsf_3[] =
+{
+   67,
+   - 17,
+   66,
+   - 12,
+   - 1690,
+   - 581,
+   - 104,
+   - 272,
+   - 1076,
+   - 1186,
+   - 1845,
+   - 376,
+   - 1140,
+   - 926,
+   - 420,
+   - 58,
+   - 259,
+   - 656,
+   - 1134,
+   - 553,
+   1788,
+   1227,
+   455,
+   129,
+   462,
+   441,
+   - 240,
+   - 528,
+   840,
+   514,
+   130,
+   - 75,
+   1114,
+   623,
+   153,
+   216,
+   1068,
+   564,
+   - 6,
+   - 276,
+   1119,
+   727,
+   190,
+   - 68,
+   704,
+   306,
+   119,
+   - 264,
+   329,
+   61,
+   - 100,
+   156,
+   364,
+   123,
+   183,
+   - 208,
+   - 171,
+   - 123,
+   220,
+   - 65,
+   - 306,
+   - 62,
+   402,
+   17,
+   - 660,
+   - 938,
+   - 266,
+   0,
+   385,
+   235,
+   276,
+   285,
+   320,
+   268,
+   - 336,
+   - 200,
+   - 724,
+   17,
+   - 84,
+   381,
+   - 544,
+   429,
+   494,
+   519,
+   - 117,
+   288,
+   304,
+   329,
+   643,
+   157,
+   701,
+   508,
+   1200,
+   625,
+   796,
+   608,
+   998,
+   421,
+   492,
+   632,
+   1204,
+   780,
+   446,
+   132,
+   1257,
+   844,
+   547,
+   449,
+   829,
+   658,
+   541,
+   470,
+   1132,
+   1258,
+   918,
+   639,
+   547,
+   51,
+   423,
+   279,
+   9,
+   392,
+   83,
+   94,
+   542,
+   543,
+   229,
+   - 147,
+   - 198,
+   129,
+   194,
+   - 185,
+   - 863,
+   - 1321,
+   - 302,
+   30,
+   - 597,
+   - 629,
+   - 19,
+   114,
+   - 900,
+   - 1081,
+   466,
+   353,
+   - 1483,
+   - 1573,
+   15,
+   - 143,
+   - 1708,
+   - 2059,
+   - 751,
+   196,
+   - 1876,
+   - 2067,
+   - 642,
+   - 258,
+   - 2335,
+   - 1470,
+   - 450,
+   - 564,
+   - 584,
+   - 186,
+   - 872,
+   - 414,
+   - 1805,
+   - 988,
+   - 1125,
+   - 1310,
+   - 726,
+   - 1129,
+   28,
+   169,
+   - 1039,
+   - 864,
+   - 718,
+   - 246,
+   484,
+   36,
+   - 233,
+   - 49,
+   265,
+   67,
+   289,
+   467,
+   178,
+   543,
+   810,
+   540,
+   84,
+   282,
+   672,
+   703,
+   - 975,
+   - 777,
+   129,
+   287,
+   - 938,
+   - 227,
+   955,
+   595,
+   - 1617,
+   - 289,
+   836,
+   649,
+   - 1847,
+   - 215,
+   1106,
+   718,
+   - 2034,
+   - 1085,
+   650,
+   440,
+   - 2101,
+   - 529,
+   907,
+   575,
+   - 2011,
+   - 336,
+   670,
+   204,
+   - 2389,
+   - 692,
+   360,
+   137,
+   - 2156,
+   - 2204,
+   - 9,
+   280,
+   - 266,
+   119,
+   39,
+   193,
+   78,
+   - 59,
+   - 120,
+   226,
+   - 975,
+   - 858,
+   - 781,
+   - 1095,
+   - 619,
+   - 413,
+   - 451,
+   - 842,
+   - 1216,
+   - 1321,
+   - 813,
+   - 883,
+   - 1376,
+   - 1615,
+   - 394,
+   - 428,
+   - 737,
+   - 1113,
+   - 549,
+   - 790,
+   - 880,
+   - 975,
+   - 967,
+   - 642,
+   - 985,
+   - 886,
+   - 1273,
+   - 1361,
+   - 473,
+   - 804,
+   - 1401,
+   - 1407,
+   160,
+   - 265,
+   - 919,
+   - 275,
+   - 248,
+   - 250,
+   - 718,
+   - 380,
+   97,
+   - 103,
+   - 375,
+   - 229,
+   - 415,
+   - 193,
+   - 135,
+   - 555,
+   628,
+   361,
+   119,
+   216,
+   579,
+   364,
+   391,
+   209,
+   634,
+   522,
+   - 154,
+   - 148,
+   526,
+   389,
+   170,
+   33,
+   105,
+   267,
+   64,
+   380,
+   - 1503,
+   - 1000,
+   - 30,
+   - 369,
+   - 1070,
+   58,
+   647,
+   223,
+   - 1520,
+   - 291,
+   621,
+   307,
+   - 1531,
+   156,
+   762,
+   404,
+   - 2029,
+   141,
+   734,
+   499,
+   - 1849,
+   - 650,
+   306,
+   512,
+   - 187,
+   - 104,
+   - 59,
+   438,
+   134,
+   - 230,
+   156,
+   - 186,
+   - 61,
+   - 260,
+   - 16,
+   10,
+   - 569,
+   - 3,
+   - 421,
+   - 297,
+   - 1725,
+   - 521,
+   - 346,
+   178,
+   - 1362,
+   - 59,
+   - 44,
+   157,
+   - 2146,
+   - 461,
+   - 470,
+   - 349,
+   - 2170,
+   - 1,
+   - 369,
+   - 121,
+   - 1579,
+   - 373,
+   - 900,
+   - 1015,
+   - 1117,
+   - 591,
+   - 613,
+   - 784,
+   - 561,
+   122,
+   - 75,
+   - 449,
+   - 4,
+   - 171,
+   - 123,
+   - 372,
+   192,
+   168,
+   - 76,
+   - 132,
+   252,
+   - 107,
+   340,
+   210,
+   392,
+   509,
+   272,
+   181,
+   - 109,
+   145,
+   218,
+   119,
+   - 416,
+   - 263,
+   485,
+   265,
+   - 181,
+   - 8,
+   - 286,
+   226,
+   - 244,
+   - 218,
+   69,
+   - 290,
+   - 158,
+   191,
+   - 1,
+   - 64,
+   - 592,
+   - 90,
+   213,
+   - 96,
+   255,
+   435,
+   178,
+   - 80,
+   - 369,
+   - 18,
+   - 33,
+   - 80,
+   - 42,
+   415,
+   140,
+   - 222,
+   1143,
+   651,
+   649,
+   329,
+   767,
+   556,
+   249,
+   235,
+   948,
+   413,
+   442,
+   279,
+   141,
+   339,
+   356,
+   557,
+   - 470,
+   - 170,
+   99,
+   237,
+   - 569,
+   - 800,
+   352,
+   565,
+   282,
+   473,
+   470,
+   332,
+   - 199,
+   - 690,
+   - 1284,
+   - 917,
+   - 193,
+   - 426,
+   - 800,
+   - 1122,
+   - 26,
+   - 371,
+   - 490,
+   - 193,
+   637,
+   595,
+   519,
+   330,
+   408,
+   - 115,
+   79,
+   12,
+   477,
+   87,
+   - 103,
+   - 376,
+   - 666,
+   - 347,
+   - 277,
+   - 291,
+   - 510,
+   - 481,
+   169,
+   297,
+   - 829,
+   - 738,
+   - 205,
+   - 171,
+   - 320,
+   - 540,
+   328,
+   283,
+   - 859,
+   - 958,
+   442,
+   - 2,
+   556,
+   686,
+   130,
+   56,
+   1383,
+   1012,
+   755,
+   427,
+   612,
+   741,
+   628,
+   553,
+   - 339,
+   - 796,
+   134,
+   277,
+   - 633,
+   - 1085,
+   - 2,
+   - 246,
+   - 880,
+   - 1035,
+   - 1607,
+   - 1064,
+   - 994,
+   - 474,
+   - 1138,
+   - 488,
+   - 414,
+   - 795,
+   73,
+   - 206,
+   - 8,
+   - 139,
+   439,
+   204,
+   - 176,
+   - 578,
+   23,
+   131,
+   - 269,
+   - 757,
+   - 191,
+   245,
+   - 109,
+   - 338,
+   112,
+   316,
+   120,
+   - 406,
+   - 118,
+   611,
+   - 180,
+   - 186,
+   - 645,
+   115,
+   - 173,
+   34,
+   - 518,
+   - 489,
+   - 151,
+   61,
+   - 583,
+   - 844,
+   220,
+   - 138,
+   - 681,
+   - 1020,
+   391,
+   - 17,
+   - 598,
+   - 321,
+   157,
+   - 295,
+   129,
+   155,
+   - 926,
+   - 875,
+   - 987,
+   285,
+   241,
+   - 83,
+   - 125,
+   - 125,
+   620,
+   597,
+   432,
+   92,
+   393,
+   78,
+   409,
+   61,
+   - 393,
+   - 739,
+   - 413,
+   - 748,
+   83,
+   54,
+   361,
+   27,
+   - 1084,
+   130,
+   - 337,
+   - 694,
+   - 1565,
+   297,
+   318,
+   - 19,
+   - 1873,
+   36,
+   51,
+   - 317,
+   - 2323,
+   - 246,
+   231,
+   - 84,
+   - 2306,
+   - 783,
+   40,
+   - 179,
+   - 2233,
+   - 930,
+   - 474,
+   - 462,
+   - 754,
+   - 86,
+   - 288,
+   - 626,
+   - 2411,
+   - 455,
+   - 63,
+   171,
+   - 1099,
+   - 1094,
+   - 26,
+   - 143,
+   - 1193,
+   - 455,
+   - 406,
+   - 381,
+   - 605,
+   - 210,
+   - 96,
+   - 51,
+   - 580,
+   - 476,
+   - 276,
+   - 15,
+   - 1195,
+   - 634,
+   - 1203,
+   - 881,
+   - 378,
+   - 221,
+   - 669,
+   - 952,
+   594,
+   178,
+   - 403,
+   - 676,
+   763,
+   327,
+   601,
+   290,
+   172,
+   300,
+   203,
+   157,
+   - 56,
+   - 336,
+   356,
+   24,
+   - 228,
+   - 296,
+   - 259,
+   - 29,
+   - 186,
+   263,
+   416,
+   14,
+   - 353,
+   373,
+   - 12,
+   - 216,
+   257,
+   96,
+   174,
+   57,
+   - 1526,
+   - 616,
+   - 954,
+   - 499,
+   - 497,
+   - 152,
+   - 333,
+   125,
+   105,
+   200,
+   179,
+   - 97,
+   - 331,
+   - 224,
+   765,
+   697,
+   760,
+   256,
+   301,
+   59,
+   455,
+   - 85,
+   204,
+   288,
+   - 514,
+   240,
+   251,
+   - 109,
+   256,
+   417,
+   - 34,
+   - 413,
+   101,
+   430,
+   384,
+   156,
+   - 31,
+   - 10,
+   206,
+   426,
+   589,
+   145,
+   143,
+   71,
+   808,
+   906,
+   333,
+   349,
+   986,
+   938,
+   589,
+   331,
+   1300,
+   824,
+   187,
+   509,
+   1062,
+   653,
+   379,
+   466,
+   1462,
+   937,
+   401,
+   274,
+   787,
+   861,
+   265,
+   2,
+   609,
+   553,
+   28,
+   305,
+   926,
+   340,
+   106,
+   386,
+   241,
+   - 267,
+   - 147,
+   225,
+   - 178,
+   - 534,
+   347,
+   502,
+   - 643,
+   - 381,
+   397,
+   30,
+   - 651,
+   - 733,
+   - 435,
+   398,
+   - 407,
+   - 726,
+   - 484,
+   - 248,
+   - 789,
+   - 914,
+   - 438,
+   - 476,
+   - 498,
+   - 390,
+   75,
+   - 295,
+   - 964,
+   - 590,
+   - 606,
+   150,
+   - 121,
+   - 49,
+   - 155,
+   - 78,
+   935,
+   550,
+   389,
+   38,
+   - 321,
+   127,
+   424,
+   315,
+   - 285,
+   - 113,
+   283,
+   259,
+   658,
+   203,
+   322,
+   486,
+   903,
+   505,
+   748,
+   417,
+   611,
+   423,
+   555,
+   512,
+   239,
+   - 83,
+   - 578,
+   - 19,
+   - 339,
+   - 731,
+   349,
+   13,
+   - 934,
+   - 1399,
+   - 114,
+   - 360,
+   107,
+   692,
+   182,
+   90,
+   - 1243,
+   - 1538,
+   - 1551,
+   - 725,
+   - 568,
+   - 903,
+   - 1363,
+   - 525,
+   - 517,
+   - 853,
+   - 861,
+   - 1004,
+   - 168,
+   - 690,
+   - 835,
+   63,
+   - 137,
+   - 556,
+   - 547,
+   144,
+   - 286,
+   - 817,
+   485,
+   319,
+   - 147,
+   - 408,
+   526,
+   246,
+   - 347,
+   - 434,
+   297,
+   - 28,
+   - 290,
+   - 471,
+   - 1110,
+   - 1285,
+   - 460,
+   - 359,
+   - 988,
+   - 794,
+   1347,
+   1299,
+   690,
+   523,
+   1216,
+   1068,
+   1094,
+   757,
+   825,
+   1140,
+   752,
+   494,
+   1252,
+   1365,
+   1195,
+   898,
+   521,
+   1053,
+   532,
+   432,
+   - 334,
+   - 216,
+   - 313,
+   - 263,
+   - 160,
+   52,
+   - 472,
+   - 155,
+   127,
+   136,
+   - 380,
+   44,
+   851,
+   410,
+   - 162,
+   - 489,
+   123,
+   - 255,
+   - 796,
+   - 667,
+   1090,
+   917,
+   789,
+   493,
+   1397,
+   1197,
+   558,
+   202,
+   - 51,
+   - 118,
+   - 342,
+   - 701,
+   83,
+   108,
+   - 42,
+   - 441,
+   61,
+   95,
+   287,
+   256,
+   - 27,
+   89,
+   524,
+   531,
+   351,
+   227,
+   592,
+   545,
+   697,
+   155,
+   - 164,
+   307,
+   638,
+   274,
+   - 489,
+   - 50,
+   754,
+   240,
+   - 166,
+   - 124,
+   - 116,
+   - 579,
+   - 1212,
+   - 63,
+   190,
+   - 295,
+   - 1040,
+   - 1296,
+   147,
+   - 376,
+   - 177,
+   - 113,
+   841,
+   1241,
+   1051,
+   668,
+   2,
+   293,
+   551,
+   304,
+   - 1096,
+   - 953,
+   - 248,
+   376,
+   - 750,
+   - 965,
+   87,
+   516,
+   - 275,
+   - 516,
+   689,
+   391,
+   - 379,
+   - 643,
+   876,
+   594,
+   - 390,
+   - 1013,
+   - 645,
+   573,
+   - 107,
+   - 568,
+   - 689,
+   - 826,
+   - 1025,
+   - 27,
+   - 328,
+   - 203,
+   861,
+   749,
+   548,
+   233,
+   - 1660,
+   - 1043,
+   451,
+   108,
+   - 660,
+   - 620,
+   430,
+   236,
+   21,
+   - 396,
+   - 1158,
+   - 631,
+   1372,
+   1298,
+   967,
+   577,
+   1125,
+   1125,
+   589,
+   454,
+   - 323,
+   - 865,
+   - 467,
+   153,
+   - 468,
+   - 699,
+   - 804,
+   - 509,
+   - 392,
+   - 718,
+   - 204,
+   - 35,
+   - 603,
+   - 1093,
+   - 567,
+   - 162,
+   - 505,
+   - 1004,
+   - 102,
+   350,
+   219,
+   224,
+   423,
+   252,
+   395,
+   591,
+   608,
+   363,
+   - 746,
+   - 96,
+   373,
+   172,
+   171,
+   295,
+   714,
+   339,
+   233,
+   77,
+   107,
+   277,
+   157,
+   153,
+   - 499,
+   - 356,
+   1547,
+   1073,
+   576,
+   494,
+   - 292,
+   - 339,
+   - 504,
+   - 592,
+   - 903,
+   - 72,
+   - 619,
+   - 481,
+   - 1594,
+   - 1117,
+   - 567,
+   - 254,
+   - 793,
+   - 507,
+   - 564,
+   - 291,
+   - 492,
+   - 532,
+   502,
+   560,
+   - 382,
+   427,
+   600,
+   230,
+   - 227,
+   477,
+   251,
+   75,
+   285,
+   842,
+   813,
+   476,
+   - 1310,
+   - 1333,
+   186,
+   377,
+   - 587,
+   - 917,
+   643,
+   381,
+   - 1186,
+   - 553,
+   411,
+   82,
+   - 1127,
+   - 820,
+   - 174,
+   - 540,
+   - 604,
+   119,
+   543,
+   205,
+   - 380,
+   657,
+   909,
+   567,
+   112,
+   - 298,
+   - 374,
+   114,
+   - 857,
+   - 251,
+   56,
+   159,
+   401,
+   345,
+   - 34,
+   - 140,
+   - 111,
+   - 607,
+   41,
+   614,
+   355,
+   - 114,
+   - 77,
+   474,
+   578,
+   56,
+   1450,
+   924,
+   1098,
+   1420,
+   741,
+   400,
+   246,
+   22,
+   588,
+   313,
+   - 121,
+   327,
+   831,
+   472,
+   - 1138,
+   - 608,
+   856,
+   552,
+   - 1241,
+   - 1072,
+   638,
+   600,
+   - 358,
+   254,
+   - 333,
+   - 303,
+   - 646,
+   739,
+   358,
+   74,
+   1226,
+   1671,
+   1221,
+   849,
+   2241,
+   1624,
+   983,
+   636,
+   1841,
+   1477,
+   749,
+   384,
+   350,
+   263,
+   87,
+   128,
+   - 1902,
+   - 941,
+   - 144,
+   - 64,
+   - 1734,
+   - 255,
+   288,
+   - 31,
+   - 2644,
+   - 1238,
+   366,
+   235,
+   - 1643,
+   - 1092,
+   - 1344,
+   - 304,
+   - 541,
+   - 1075,
+   - 1116,
+   123,
+   - 1178,
+   - 252,
+   - 816,
+   - 180,
+   - 1016,
+   533,
+   565,
+   233,
+   - 487,
+   - 430,
+   - 188,
+   334,
+   867,
+   1236,
+   534,
+   171,
+   - 1590,
+   - 1607,
+   635,
+   630,
+   - 2196,
+   310,
+   924,
+   412,
+   - 2358,
+   - 328,
+   956,
+   529,
+   - 2639,
+   - 377,
+   630,
+   278,
+   - 2602,
+   317,
+   799,
+   299,
+   - 2406,
+   133,
+   340,
+   31,
+   - 2156,
+   - 1468,
+   131,
+   125,
+   - 1184,
+   - 490,
+   - 139,
+   46,
+   - 744,
+   447,
+   891,
+   564,
+   67,
+   - 451,
+   646,
+   604,
+   - 553,
+   - 429,
+   - 876,
+   396,
+   162,
+   - 66,
+   1305,
+   915,
+   479,
+   579,
+   1088,
+   794,
+   450,
+   278,
+   566,
+   324,
+   - 1057,
+   - 154,
+   148,
+   - 177,
+   - 2545,
+   168,
+   1070,
+   592,
+   - 2351,
+   - 42,
+   819,
+   345,
+   - 2344,
+   - 707,
+   721,
+   250,
+   - 2175,
+   - 1497,
+   - 309,
+   122,
+   - 78,
+   - 73,
+   120,
+   173,
+   - 4,
+   262,
+   - 263,
+   - 261,
+   - 431,
+   - 64,
+   - 405,
+   - 732,
+   - 2609,
+   116,
+   - 83,
+   - 193,
+   - 1525,
+   - 944,
+   - 477,
+   - 725,
+   - 508,
+   307,
+   170,
+   172,
+   832,
+   417,
+   832,
+   686,
+   - 225,
+   177,
+   894,
+   818,
+   - 482,
+   - 389,
+   1279,
+   1039,
+   - 383,
+   201,
+   - 350,
+   40,
+   730,
+   635,
+   226,
+   526,
+   503,
+   462,
+   338,
+   398,
+   535,
+   714,
+   40,
+   - 282,
+   1482,
+   1471,
+   1085,
+   731,
+   1561,
+   1072,
+   909,
+   693,
+   1419,
+   1282,
+   889,
+   879,
+   1153,
+   728,
+   1186,
+   840,
+   - 226,
+   1130,
+   949,
+   689,
+   - 494,
+   - 986,
+   - 1556,
+   - 128,
+   - 568,
+   - 721,
+   - 713,
+   - 26,
+   317,
+   524,
+   70,
+   135,
+   - 405,
+   - 865,
+   - 1766,
+   - 652,
+   - 174,
+   - 801,
+   885,
+   773,
+   - 153,
+   - 91,
+   1099,
+   751,
+   - 506,
+   - 1149,
+   853,
+   646,
+   241,
+   782,
+   519,
+   539,
+   1853,
+   1700,
+   1101,
+   684,
+   - 1249,
+   - 1486,
+   - 464,
+   188,
+   - 893,
+   - 1409,
+   - 1312,
+   - 341,
+   - 135,
+   438,
+   - 175,
+   18,
+   1111,
+   976,
+   319,
+   208,
+   - 1430,
+   - 1768,
+   83,
+   458,
+   - 530,
+   - 1000,
+   307,
+   129,
+   - 840,
+   - 15,
+   - 29,
+   - 356,
+   - 911,
+   - 924,
+   - 1147,
+   - 242,
+   - 119,
+   - 528,
+   127,
+   - 133,
+   - 761,
+   - 765,
+   190,
+   - 83,
+   - 315,
+   895,
+   522,
+   231,
+   - 222,
+   102,
+   - 63,
+   - 428,
+   316,
+   699,
+   379,
+   70,
+   25,
+   716,
+   314,
+   - 108,
+   507,
+   874,
+   566,
+   238,
+   108,
+   941,
+   519,
+   195,
+   425,
+   - 60,
+   - 427,
+   257,
+   139,
+   - 103,
+   - 630,
+   446,
+   334,
+   370,
+   412,
+   48,
+   - 172,
+   - 690,
+   - 283,
+   557,
+   187,
+   - 286,
+   158,
+   483,
+   140,
+   270,
+   - 344,
+   - 631,
+   924,
+   579,
+   - 116,
+   132,
+   142,
+   466,
+   - 68,
+   - 64,
+   230,
+   - 145,
+   - 302,
+   - 542,
+   - 803,
+   - 912,
+   1018,
+   737,
+   - 773,
+   1015,
+   630,
+   297,
+   - 2596,
+   95,
+   445,
+   336,
+   - 2122,
+   491,
+   510,
+   191,
+   - 1253,
+   161,
+   - 2,
+   - 324,
+   - 1450,
+   - 633,
+   - 712,
+   - 105,
+   - 842,
+   - 254,
+   - 411,
+   100,
+   - 640,
+   - 290,
+   1010,
+   763,
+   - 650,
+   313,
+   1169,
+   730,
+   140,
+   505,
+   1030,
+   766,
+   772,
+   287,
+   1067,
+   823,
+   495,
+   749,
+   305,
+   323,
+   - 164,
+   462,
+   78,
+   399,
+   - 342,
+   - 874,
+   69,
+   597,
+   - 16,
+   620,
+   621,
+   337,
+   - 138,
+   - 444,
+   - 265,
+   218,
+   84,
+   - 450,
+   953,
+   666,
+   - 222,
+   - 803,
+   541,
+   604,
+   - 921,
+   - 1376,
+   244,
+   116,
+   - 841,
+   - 723,
+   630,
+   588,
+   140,
+   663,
+   294,
+   368,
+   935,
+   1046,
+   881,
+   759,
+   1746,
+   1464,
+   916,
+   628,
+   436,
+   963,
+   281,
+   1,
+   - 119,
+   74,
+   542,
+   213,
+   1,
+   - 567,
+   301,
+   241,
+   260,
+   435,
+   222,
+   396,
+   936,
+   957,
+   1108,
+   703,
+   510,
+   506,
+   808,
+   478,
+   601,
+   694,
+   960,
+   620,
+   972,
+   741,
+   980,
+   600,
+   834,
+   717,
+   767,
+   684,
+   643,
+   972,
+   935,
+   638,
+   501,
+   661,
+   720,
+   851,
+   - 105,
+   - 632,
+   - 303,
+   - 117,
+   - 429,
+   130,
+   789,
+   442,
+   - 522,
+   - 188,
+   704,
+   373,
+   - 759,
+   42,
+   814,
+   523,
+   - 531,
+   - 1137,
+   373,
+   578,
+   - 682,
+   - 1203,
+   - 455,
+   285,
+   - 1163,
+   - 1577,
+   - 1098,
+   44,
+   81,
+   - 82,
+   712,
+   363,
+   477,
+   246,
+   954,
+   622,
+   1604,
+   1622,
+   1277,
+   891,
+   1409,
+   859,
+   924,
+   892,
+   774,
+   1041,
+   947,
+   1142,
+   40,
+   - 546,
+   - 75,
+   288,
+   - 616,
+   - 106,
+   - 697,
+   - 26,
+   - 169,
+   - 160,
+   - 891,
+   - 739,
+   - 279,
+   - 384,
+   - 1029,
+   - 350,
+   1781,
+   1308,
+   1046,
+   816,
+   1580,
+   1533,
+   1472,
+   1178,
+   1505,
+   1076,
+   1216,
+   899,
+   890,
+   904,
+   564,
+   654,
+   920,
+   692,
+   1021,
+   856,
+   - 493,
+   132,
+   177,
+   505,
+   71,
+   195,
+   - 28,
+   97,
+   456,
+   351,
+   - 164,
+   88,
+   439,
+   278,
+   - 40,
+   350,
+   1395,
+   949,
+   234,
+   - 95,
+   - 805,
+   - 472,
+   38,
+   - 163,
+   367,
+   - 98,
+   489,
+   523,
+   1025,
+   1178,
+   1212,
+   906,
+   319,
+   1314,
+   814,
+   461,
+   - 123,
+   - 543,
+   - 804,
+   447,
+   - 748,
+   - 324,
+   - 897,
+   - 1127,
+   - 737,
+   - 501,
+   - 789,
+   - 713,
+   715,
+   777,
+   1239,
+   922,
+   1949,
+   1939,
+   1368,
+   865,
+   730,
+   880,
+   758,
+   388,
+   - 871,
+   454,
+   17,
+   - 251,
+   - 381,
+   - 810,
+   - 1583,
+   239,
+   - 521,
+   - 966,
+   - 792,
+   259,
+   - 890,
+   - 1358,
+   - 770,
+   - 73,
+   166,
+   349,
+   - 212,
+   323,
+   - 840,
+   - 301,
+   473,
+   435,
+   - 679,
+   - 464,
+   728,
+   351,
+   - 156,
+   - 199,
+   667,
+   432,
+   29,
+   - 252,
+   415,
+   480,
+   - 731,
+   - 379,
+   145,
+   559,
+   - 528,
+   - 631,
+   - 1158,
+   - 159,
+   445,
+   273,
+   123,
+   639,
+   373,
+   - 126,
+   800,
+   568,
+   84,
+   - 162,
+   720,
+   712,
+   - 830,
+   - 536,
+   - 185,
+   222,
+   408,
+   452,
+   501,
+   771,
+   - 897,
+   - 1355,
+   - 67,
+   442,
+   - 792,
+   - 1406,
+   566,
+   602,
+   167,
+   - 326,
+   509,
+   330,
+   - 95,
+   - 626,
+   - 730,
+   - 344,
+   1668,
+   1217,
+   779,
+   455,
+   1316,
+   828,
+   584,
+   719,
+   404,
+   - 31,
+   1013,
+   789,
+   89,
+   107,
+   891,
+   549,
+   871,
+   1581,
+   917,
+   671,
+   866,
+   1479,
+   1289,
+   854,
+   391,
+   1068,
+   1122,
+   812,
+   78,
+   - 562,
+   345,
+   563,
+   429,
+   - 103,
+   417,
+   787,
+   - 122,
+   - 437,
+   411,
+   788,
+   - 913,
+   - 417,
+   602,
+   754,
+   - 226,
+   - 16,
+   151,
+   760,
+   - 700,
+   118,
+   - 104,
+   - 14,
+   - 1128,
+   48,
+   284,
+   393,
+   - 390,
+   - 419,
+   - 639,
+   - 116,
+   - 910,
+   306,
+   316,
+   - 13,
+   1207,
+   984,
+   821,
+   669,
+   - 1195,
+   - 693,
+   140,
+   - 213,
+   - 884,
+   - 416,
+   - 199,
+   - 558,
+   - 616,
+   245,
+   - 404,
+   - 664,
+   262,
+   56,
+   - 617,
+   - 724,
+   - 85,
+   - 491,
+   - 320,
+   - 656,
+   - 570,
+   - 831,
+   - 129,
+   - 528,
+   - 1506,
+   - 63,
+   - 367,
+   - 385,
+   - 358,
+   - 321,
+   4,
+   51,
+   - 366,
+   - 214,
+   319,
+   511,
+   146,
+   671,
+   - 17,
+   - 291,
+   - 110,
+   464,
+   - 139,
+   - 496,
+   - 202,
+   220,
+   - 312,
+   - 631,
+   - 660,
+   - 73,
+   - 655,
+   - 820,
+   - 662,
+   - 653,
+   - 1288,
+   - 857,
+   - 430,
+   - 953,
+   - 959,
+   - 264,
+   - 49,
+   - 468,
+   - 72,
+   - 381,
+   - 350,
+   - 563,
+   - 193,
+   - 407,
+   55,
+   - 408,
+   - 803,
+   11,
+   - 309,
+   649,
+   188,
+   - 198,
+   - 512,
+   461,
+   - 79,
+   - 458,
+   - 1318,
+   - 263,
+   - 134,
+   - 523,
+   - 1657,
+   - 435,
+   - 495,
+   - 765,
+   57,
+   - 347,
+   - 414,
+   434,
+   - 1141,
+   - 242,
+   - 664,
+   - 857,
+   34,
+   - 68,
+   - 707,
+   - 338
+};
+#define MR515_3_SIZE  128
+
+/* 3rd LSF quantizer (MR515 and MR475) */
+static const Word32 mr515_3_lsf[] =
+{
+   419,
+   163,
+   - 30,
+   - 262,
+   - 455,
+   - 789,
+   - 1430,
+   - 721,
+   1006,
+   664,
+   269,
+   25,
+   619,
+   260,
+   183,
+   96,
+   - 968,
+   - 1358,
+   - 388,
+   135,
+   - 693,
+   835,
+   456,
+   154,
+   1105,
+   703,
+   569,
+   363,
+   1625,
+   1326,
+   985,
+   748,
+   - 220,
+   219,
+   76,
+   - 208,
+   - 1455,
+   - 1662,
+   49,
+   149,
+   - 964,
+   - 172,
+   - 752,
+   - 336,
+   625,
+   209,
+   - 250,
+   - 66,
+   - 1017,
+   - 838,
+   - 2,
+   317,
+   - 2168,
+   - 1485,
+   - 138,
+   123,
+   - 1876,
+   - 2099,
+   - 521,
+   85,
+   - 967,
+   - 366,
+   - 695,
+   - 881,
+   - 921,
+   - 1011,
+   - 763,
+   - 949,
+   - 124,
+   - 256,
+   - 352,
+   - 660,
+   178,
+   463,
+   354,
+   304,
+   - 1744,
+   - 591,
+   - 282,
+   79,
+   - 2249,
+   175,
+   867,
+   499,
+   - 138,
+   - 180,
+   - 181,
+   - 21,
+   - 2291,
+   - 1241,
+   - 460,
+   - 520,
+   - 771,
+   451,
+   - 10,
+   - 308,
+   271,
+   - 65,
+   4,
+   214,
+   - 279,
+   - 435,
+   - 43,
+   - 348,
+   - 670,
+   35,
+   - 65,
+   - 211,
+   806,
+   535,
+   85,
+   297,
+   57,
+   239,
+   722,
+   493,
+   225,
+   661,
+   840,
+   547,
+   - 540,
+   - 376,
+   14,
+   349,
+   469,
+   721,
+   331,
+   162,
+   - 544,
+   - 752,
+   - 62,
+   - 10,
+   398,
+   - 88,
+   724,
+   701,
+   - 19,
+   - 533,
+   - 94,
+   601,
+   136,
+   - 71,
+   - 681,
+   - 747,
+   - 166,
+   - 344,
+   261,
+   - 50,
+   161,
+   - 52,
+   485,
+   337,
+   - 1675,
+   50,
+   190,
+   - 93,
+   - 2282,
+   - 231,
+   - 194,
+   - 82,
+   - 95,
+   - 595,
+   - 154,
+   128,
+   894,
+   501,
+   588,
+   457,
+   - 345,
+   206,
+   122,
+   110,
+   - 631,
+   - 227,
+   - 569,
+   3,
+   408,
+   239,
+   397,
+   226,
+   - 197,
+   - 2,
+   128,
+   491,
+   1281,
+   904,
+   292,
+   215,
+   538,
+   306,
+   259,
+   509,
+   - 677,
+   - 1047,
+   13,
+   321,
+   - 679,
+   - 588,
+   - 358,
+   - 212,
+   - 558,
+   243,
+   646,
+   479,
+   486,
+   342,
+   634,
+   532,
+   107,
+   802,
+   331,
+   136,
+   - 112,
+   - 398,
+   - 1031,
+   - 286,
+   - 326,
+   - 705,
+   288,
+   272,
+   1299,
+   1144,
+   1178,
+   860,
+   - 423,
+   121,
+   - 385,
+   - 148,
+   - 295,
+   - 302,
+   - 834,
+   - 819,
+   16,
+   - 24,
+   - 201,
+   - 476,
+   555,
+   91,
+   - 245,
+   294,
+   - 38,
+   - 379,
+   - 962,
+   - 1221,
+   - 1191,
+   - 1518,
+   - 273,
+   - 395,
+   - 390,
+   - 1013,
+   - 645,
+   573,
+   - 1843,
+   - 1030,
+   505,
+   468,
+   744,
+   947,
+   609,
+   493,
+   - 689,
+   - 1172,
+   - 628,
+   - 135,
+   - 1026,
+   195,
+   411,
+   196,
+   1582,
+   1147,
+   575,
+   337,
+   - 1239,
+   - 777,
+   - 648,
+   - 142,
+   595,
+   825,
+   967,
+   735,
+   - 1206,
+   - 970,
+   - 81,
+   - 342,
+   - 745,
+   13,
+   - 72,
+   375,
+   454,
+   19,
+   1407,
+   921,
+   - 1647,
+   - 172,
+   861,
+   562,
+   928,
+   1537,
+   1063,
+   740,
+   - 2472,
+   - 952,
+   264,
+   82,
+   - 502,
+   - 965,
+   - 1334,
+   123,
+   867,
+   1236,
+   534,
+   171,
+   - 2320,
+   - 460,
+   780,
+   363,
+   - 1190,
+   - 617,
+   252,
+   - 61,
+   - 174,
+   34,
+   1011,
+   788,
+   - 2333,
+   247,
+   423,
+   153,
+   - 16,
+   - 355,
+   262,
+   449,
+   - 1576,
+   - 1073,
+   - 544,
+   - 371,
+   - 615,
+   - 305,
+   1051,
+   805,
+   687,
+   528,
+   6,
+   - 182,
+   935,
+   875,
+   1002,
+   809,
+   199,
+   257,
+   126,
+   76,
+   - 584,
+   - 1138,
+   599,
+   556,
+   - 1105,
+   - 1391,
+   - 1591,
+   - 519,
+   - 977,
+   - 1325,
+   108,
+   347,
+   - 722,
+   - 975,
+   365,
+   101,
+   - 145,
+   681,
+   249,
+   - 153,
+   0,
+   - 334,
+   - 570,
+   159,
+   412,
+   285,
+   - 336,
+   - 617,
+   - 953,
+   - 966,
+   887,
+   689,
+   - 1251,
+   84,
+   - 185,
+   - 398,
+   - 592,
+   433,
+   1044,
+   653,
+   85,
+   329,
+   - 40,
+   361,
+   - 433,
+   - 705,
+   466,
+   574,
+   - 154,
+   654,
+   592,
+   290,
+   - 167,
+   72,
+   349,
+   175,
+   674,
+   297,
+   977,
+   720,
+   1235,
+   1204,
+   757,
+   488,
+   - 400,
+   - 269,
+   538,
+   372,
+   - 1350,
+   - 1387,
+   - 1194,
+   - 91,
+   1262,
+   876,
+   775,
+   700,
+   - 599,
+   - 38,
+   - 430,
+   - 722,
+   1976,
+   1630,
+   991,
+   608,
+   111,
+   276,
+   - 226,
+   - 96,
+   - 947,
+   - 388,
+   - 11,
+   - 7,
+   - 303,
+   - 531,
+   - 839,
+   338,
+   1734,
+   1710,
+   1405,
+   1013,
+   - 516,
+   - 855,
+   - 645,
+   210,
+   - 688,
+   - 416,
+   513,
+   230,
+   - 822,
+   - 637,
+   - 1146,
+   - 320,
+   - 952,
+   - 658,
+   - 694,
+   183,
+   - 114,
+   - 623,
+   818,
+   674,
+   - 191,
+   - 204,
+   731,
+   635,
+   51,
+   1221,
+   883,
+   576,
+   - 954,
+   - 431,
+   826,
+   598,
+   - 342,
+   - 755,
+   - 900,
+   - 407,
+   - 1126,
+   - 354,
+   - 206,
+   - 512,
+   - 547,
+   - 810,
+   - 357,
+   - 620,
+   66,
+   515,
+   - 73,
+   - 410,
+   - 872,
+   - 945,
+   - 1444,
+   - 1227,
+   191,
+   - 17,
+   - 544,
+   - 231,
+   - 1540,
+   - 544,
+   - 901,
+   - 886
+};
+#define MR795_1_SIZE  512
+
+/* 1st LSF quantizer (MR795) */
+static const Word32 mr795_1_lsf[] =
+{
+   - 890,
+   - 1550,
+   - 2541,
+   - 819,
+   - 970,
+   175,
+   - 826,
+   - 1234,
+   - 762,
+   - 599,
+   - 22,
+   634,
+   - 811,
+   - 987,
+   - 902,
+   - 323,
+   203,
+   26,
+   - 383,
+   - 235,
+   - 781,
+   - 399,
+   1262,
+   906,
+   - 932,
+   - 1399,
+   - 1380,
+   - 624,
+   93,
+   87,
+   - 414,
+   - 539,
+   - 691,
+   37,
+   633,
+   510,
+   - 387,
+   - 476,
+   - 1330,
+   399,
+   66,
+   263,
+   - 407,
+   - 49,
+   - 335,
+   - 417,
+   1041,
+   1865,
+   - 779,
+   - 1089,
+   - 1440,
+   - 746,
+   - 858,
+   832,
+   - 581,
+   - 759,
+   - 371,
+   - 673,
+   - 506,
+   2088,
+   - 560,
+   - 634,
+   - 1179,
+   271,
+   241,
+   14,
+   - 438,
+   - 244,
+   - 397,
+   463,
+   1202,
+   1047,
+   - 606,
+   - 797,
+   - 1438,
+   - 51,
+   - 323,
+   481,
+   - 224,
+   - 584,
+   - 527,
+   494,
+   881,
+   682,
+   - 433,
+   - 306,
+   - 1002,
+   554,
+   659,
+   222,
+   171,
+   - 160,
+   - 353,
+   681,
+   1798,
+   1565,
+   - 852,
+   - 1181,
+   - 1695,
+   - 336,
+   - 666,
+   114,
+   - 581,
+   - 756,
+   - 744,
+   - 195,
+   375,
+   497,
+   - 465,
+   - 804,
+   - 1098,
+   154,
+   282,
+   - 131,
+   - 50,
+   - 191,
+   - 719,
+   323,
+   732,
+   1542,
+   - 722,
+   - 819,
+   - 1404,
+   105,
+   - 250,
+   185,
+   - 178,
+   - 502,
+   - 742,
+   321,
+   510,
+   1111,
+   - 323,
+   - 567,
+   - 966,
+   127,
+   484,
+   338,
+   - 160,
+   52,
+   - 338,
+   732,
+   1367,
+   1554,
+   - 626,
+   - 802,
+   - 1696,
+   - 286,
+   - 586,
+   676,
+   - 695,
+   - 343,
+   - 370,
+   - 490,
+   295,
+   1893,
+   - 630,
+   - 574,
+   - 1014,
+   - 80,
+   645,
+   - 69,
+   - 6,
+   - 318,
+   - 364,
+   782,
+   1450,
+   1038,
+   - 313,
+   - 733,
+   - 1395,
+   120,
+   60,
+   477,
+   - 264,
+   - 585,
+   - 123,
+   711,
+   1245,
+   633,
+   - 91,
+   - 355,
+   - 1016,
+   771,
+   758,
+   261,
+   253,
+   81,
+   - 474,
+   930,
+   2215,
+   1720,
+   - 808,
+   - 1099,
+   - 1925,
+   - 560,
+   - 782,
+   169,
+   - 804,
+   - 1074,
+   - 188,
+   - 626,
+   - 55,
+   1405,
+   - 694,
+   - 716,
+   - 1194,
+   - 660,
+   354,
+   329,
+   - 514,
+   - 55,
+   - 543,
+   366,
+   1033,
+   1182,
+   - 658,
+   - 959,
+   - 1357,
+   - 55,
+   - 184,
+   93,
+   - 605,
+   - 286,
+   - 662,
+   404,
+   449,
+   827,
+   - 286,
+   - 350,
+   - 1263,
+   628,
+   306,
+   227,
+   - 16,
+   147,
+   - 623,
+   186,
+   923,
+   2146,
+   - 674,
+   - 890,
+   - 1606,
+   - 443,
+   - 228,
+   339,
+   - 369,
+   - 790,
+   - 409,
+   231,
+   86,
+   1469,
+   - 448,
+   - 581,
+   - 1061,
+   594,
+   450,
+   - 177,
+   - 124,
+   - 170,
+   - 447,
+   671,
+   1159,
+   1404,
+   - 476,
+   - 667,
+   - 1511,
+   - 77,
+   - 138,
+   716,
+   - 177,
+   - 372,
+   - 381,
+   451,
+   934,
+   915,
+   - 250,
+   - 432,
+   - 822,
+   272,
+   828,
+   446,
+   26,
+   19,
+   - 31,
+   698,
+   1692,
+   2168,
+   - 646,
+   - 977,
+   - 1924,
+   - 179,
+   - 473,
+   268,
+   - 379,
+   - 745,
+   - 691,
+   11,
+   127,
+   1033,
+   - 488,
+   - 917,
+   - 825,
+   61,
+   323,
+   135,
+   147,
+   - 145,
+   - 686,
+   685,
+   786,
+   1682,
+   - 506,
+   - 848,
+   - 1297,
+   35,
+   90,
+   222,
+   - 23,
+   - 346,
+   - 670,
+   455,
+   591,
+   1287,
+   - 203,
+   - 593,
+   - 1086,
+   652,
+   352,
+   437,
+   39,
+   63,
+   - 457,
+   841,
+   1265,
+   2105,
+   - 520,
+   - 882,
+   - 1584,
+   - 328,
+   - 711,
+   1421,
+   - 596,
+   - 342,
+   - 70,
+   209,
+   173,
+   1928,
+   - 423,
+   - 598,
+   - 921,
+   421,
+   605,
+   - 38,
+   - 2,
+   - 245,
+   - 127,
+   896,
+   1969,
+   1135,
+   - 379,
+   - 518,
+   - 1579,
+   173,
+   118,
+   753,
+   - 55,
+   - 381,
+   - 52,
+   985,
+   1021,
+   753,
+   - 2,
+   - 291,
+   - 891,
+   753,
+   992,
+   423,
+   264,
+   131,
+   - 196,
+   895,
+   2274,
+   2543,
+   - 635,
+   - 1088,
+   - 2499,
+   - 529,
+   - 982,
+   526,
+   - 764,
+   - 830,
+   - 548,
+   - 436,
+   316,
+   599,
+   - 675,
+   - 940,
+   - 746,
+   - 57,
+   236,
+   - 11,
+   - 201,
+   - 81,
+   - 798,
+   16,
+   845,
+   1558,
+   - 737,
+   - 985,
+   - 1212,
+   - 468,
+   17,
+   290,
+   - 279,
+   - 584,
+   - 700,
+   183,
+   822,
+   705,
+   - 265,
+   - 492,
+   - 1187,
+   421,
+   152,
+   468,
+   - 390,
+   166,
+   - 268,
+   39,
+   1550,
+   1868,
+   - 635,
+   - 966,
+   - 1571,
+   - 453,
+   - 492,
+   910,
+   - 284,
+   - 1027,
+   - 75,
+   - 181,
+   - 133,
+   1852,
+   - 445,
+   - 624,
+   - 1174,
+   420,
+   367,
+   - 49,
+   - 389,
+   - 212,
+   - 169,
+   707,
+   1073,
+   1208,
+   - 539,
+   - 710,
+   - 1449,
+   83,
+   - 163,
+   484,
+   - 236,
+   - 543,
+   - 355,
+   338,
+   1175,
+   814,
+   - 246,
+   - 309,
+   - 958,
+   606,
+   760,
+   60,
+   166,
+   - 8,
+   - 163,
+   - 306,
+   1849,
+   2563,
+   - 747,
+   - 1025,
+   - 1783,
+   - 419,
+   - 446,
+   209,
+   - 718,
+   - 566,
+   - 534,
+   - 506,
+   693,
+   857,
+   - 463,
+   - 697,
+   - 1082,
+   325,
+   431,
+   - 206,
+   - 15,
+   - 8,
+   - 763,
+   545,
+   919,
+   1518,
+   - 611,
+   - 783,
+   - 1313,
+   256,
+   - 55,
+   208,
+   - 165,
+   - 348,
+   - 662,
+   321,
+   680,
+   930,
+   - 326,
+   - 429,
+   - 951,
+   484,
+   446,
+   570,
+   - 197,
+   72,
+   - 73,
+   909,
+   1455,
+   1741,
+   - 563,
+   - 737,
+   - 1974,
+   - 124,
+   - 416,
+   718,
+   - 478,
+   - 404,
+   - 314,
+   - 16,
+   446,
+   1636,
+   - 551,
+   - 537,
+   - 750,
+   - 58,
+   638,
+   214,
+   55,
+   - 185,
+   - 271,
+   1148,
+   1301,
+   1212,
+   - 483,
+   - 671,
+   - 1264,
+   117,
+   285,
+   543,
+   - 204,
+   - 391,
+   - 111,
+   513,
+   1538,
+   854,
+   - 114,
+   - 190,
+   - 978,
+   877,
+   595,
+   464,
+   260,
+   260,
+   - 311,
+   748,
+   2283,
+   2216,
+   - 517,
+   - 945,
+   - 2171,
+   - 326,
+   - 708,
+   378,
+   - 812,
+   - 691,
+   - 232,
+   - 560,
+   687,
+   1409,
+   - 732,
+   - 690,
+   - 836,
+   - 359,
+   645,
+   386,
+   - 265,
+   62,
+   - 678,
+   145,
+   1644,
+   1208,
+   - 555,
+   - 988,
+   - 1233,
+   - 78,
+   14,
+   114,
+   - 327,
+   - 358,
+   - 489,
+   392,
+   677,
+   697,
+   - 201,
+   - 236,
+   - 1140,
+   693,
+   449,
+   178,
+   - 243,
+   256,
+   - 433,
+   611,
+   1385,
+   2456,
+   - 612,
+   - 901,
+   - 1464,
+   - 307,
+   - 17,
+   499,
+   - 315,
+   - 667,
+   - 254,
+   256,
+   428,
+   1463,
+   - 486,
+   - 422,
+   - 1056,
+   655,
+   370,
+   18,
+   - 102,
+   - 185,
+   - 276,
+   755,
+   1578,
+   1335,
+   - 488,
+   - 603,
+   - 1418,
+   182,
+   - 93,
+   870,
+   - 73,
+   - 458,
+   - 348,
+   835,
+   862,
+   957,
+   - 282,
+   - 333,
+   - 746,
+   547,
+   839,
+   428,
+   273,
+   - 89,
+   13,
+   940,
+   1708,
+   2576,
+   - 418,
+   - 1084,
+   - 1758,
+   - 44,
+   - 358,
+   259,
+   - 497,
+   - 643,
+   - 560,
+   99,
+   557,
+   961,
+   - 421,
+   - 766,
+   - 917,
+   295,
+   326,
+   184,
+   175,
+   15,
+   - 626,
+   532,
+   878,
+   1981,
+   - 443,
+   - 768,
+   - 1275,
+   221,
+   156,
+   268,
+   39,
+   - 363,
+   - 505,
+   695,
+   772,
+   1140,
+   - 162,
+   - 459,
+   - 912,
+   709,
+   444,
+   658,
+   25,
+   303,
+   - 312,
+   1268,
+   1410,
+   1715,
+   - 297,
+   - 766,
+   - 1836,
+   - 263,
+   - 108,
+   1070,
+   - 406,
+   - 13,
+   - 129,
+   57,
+   438,
+   2734,
+   - 374,
+   - 487,
+   - 835,
+   304,
+   696,
+   164,
+   104,
+   - 235,
+   5,
+   1611,
+   1900,
+   1399,
+   - 229,
+   - 582,
+   - 1325,
+   405,
+   192,
+   817,
+   - 87,
+   - 438,
+   111,
+   1028,
+   1199,
+   993,
+   68,
+   - 175,
+   - 934,
+   1033,
+   1117,
+   451,
+   478,
+   200,
+   - 248,
+   2127,
+   2696,
+   2042,
+   - 835,
+   - 1323,
+   - 2131,
+   - 799,
+   - 692,
+   466,
+   - 812,
+   - 1032,
+   - 469,
+   - 622,
+   288,
+   920,
+   - 701,
+   - 841,
+   - 1070,
+   - 411,
+   512,
+   8,
+   - 390,
+   - 91,
+   - 744,
+   - 30,
+   1043,
+   1161,
+   - 822,
+   - 1148,
+   - 1156,
+   - 294,
+   - 46,
+   110,
+   - 411,
+   - 374,
+   - 678,
+   214,
+   531,
+   668,
+   - 406,
+   - 420,
+   - 1194,
+   487,
+   232,
+   303,
+   - 318,
+   91,
+   - 472,
+   123,
+   1232,
+   2445,
+   - 722,
+   - 952,
+   - 1495,
+   - 738,
+   - 675,
+   1332,
+   - 543,
+   - 606,
+   - 211,
+   - 95,
+   - 98,
+   1508,
+   - 549,
+   - 514,
+   - 1193,
+   473,
+   211,
+   73,
+   - 288,
+   - 112,
+   - 389,
+   537,
+   1332,
+   1258,
+   - 567,
+   - 755,
+   - 1545,
+   71,
+   - 283,
+   632,
+   - 170,
+   - 481,
+   - 493,
+   681,
+   1002,
+   817,
+   - 356,
+   - 331,
+   - 877,
+   419,
+   706,
+   346,
+   241,
+   - 34,
+   - 326,
+   377,
+   1950,
+   1883,
+   - 727,
+   - 1075,
+   - 1625,
+   - 233,
+   - 543,
+   116,
+   - 524,
+   - 806,
+   - 585,
+   - 73,
+   478,
+   729,
+   - 288,
+   - 925,
+   - 1143,
+   173,
+   447,
+   - 52,
+   68,
+   - 229,
+   - 606,
+   449,
+   529,
+   1797,
+   - 591,
+   - 875,
+   - 1363,
+   183,
+   - 144,
+   324,
+   - 103,
+   - 452,
+   - 666,
+   623,
+   488,
+   1176,
+   - 238,
+   - 511,
+   - 1004,
+   326,
+   552,
+   458,
+   136,
+   108,
+   - 319,
+   626,
+   1343,
+   1883,
+   - 490,
+   - 646,
+   - 1730,
+   - 186,
+   - 449,
+   984,
+   - 738,
+   - 76,
+   - 170,
+   - 550,
+   755,
+   2560,
+   - 496,
+   - 510,
+   - 947,
+   210,
+   694,
+   - 52,
+   84,
+   - 322,
+   - 199,
+   1090,
+   1625,
+   1224,
+   - 376,
+   - 603,
+   - 1396,
+   343,
+   74,
+   632,
+   - 175,
+   - 502,
+   - 32,
+   972,
+   1332,
+   734,
+   52,
+   - 295,
+   - 1113,
+   1065,
+   918,
+   160,
+   393,
+   107,
+   - 397,
+   1214,
+   2649,
+   1741,
+   - 632,
+   - 1201,
+   - 1891,
+   - 719,
+   - 277,
+   353,
+   - 651,
+   - 880,
+   - 122,
+   - 211,
+   209,
+   1338,
+   - 562,
+   - 714,
+   - 1059,
+   - 208,
+   388,
+   159,
+   - 320,
+   - 61,
+   - 551,
+   293,
+   1092,
+   1443,
+   - 648,
+   - 865,
+   - 1253,
+   - 49,
+   - 143,
+   305,
+   - 401,
+   - 227,
+   - 585,
+   561,
+   532,
+   927,
+   - 117,
+   - 443,
+   - 1188,
+   507,
+   436,
+   292,
+   - 79,
+   233,
+   - 458,
+   671,
+   1025,
+   2396,
+   - 633,
+   - 842,
+   - 1525,
+   - 308,
+   - 286,
+   640,
+   - 373,
+   - 621,
+   - 407,
+   418,
+   253,
+   1305,
+   - 315,
+   - 581,
+   - 1137,
+   572,
+   685,
+   - 281,
+   61,
+   - 68,
+   - 371,
+   991,
+   1101,
+   1498,
+   - 493,
+   - 683,
+   - 1362,
+   - 47,
+   164,
+   704,
+   - 256,
+   - 314,
+   - 268,
+   631,
+   949,
+   1052,
+   - 118,
+   - 348,
+   - 833,
+   68,
+   1180,
+   568,
+   152,
+   117,
+   34,
+   1113,
+   1902,
+   2239,
+   - 601,
+   - 959,
+   - 1706,
+   - 143,
+   - 489,
+   480,
+   - 332,
+   - 655,
+   - 574,
+   54,
+   353,
+   1192,
+   - 462,
+   - 652,
+   - 796,
+   150,
+   549,
+   112,
+   195,
+   - 111,
+   - 515,
+   679,
+   1108,
+   1647,
+   - 558,
+   - 749,
+   - 1217,
+   - 9,
+   272,
+   341,
+   - 53,
+   - 265,
+   - 535,
+   489,
+   843,
+   1298,
+   - 120,
+   - 482,
+   - 1032,
+   632,
+   543,
+   408,
+   179,
+   306,
+   - 526,
+   1124,
+   1464,
+   2244,
+   - 417,
+   - 786,
+   - 1562,
+   - 224,
+   - 384,
+   1364,
+   - 377,
+   - 459,
+   - 25,
+   385,
+   489,
+   2174,
+   - 332,
+   - 651,
+   - 829,
+   544,
+   553,
+   61,
+   22,
+   - 113,
+   - 89,
+   1128,
+   1725,
+   1524,
+   - 216,
+   - 373,
+   - 1653,
+   161,
+   316,
+   908,
+   - 165,
+   - 222,
+   - 67,
+   1362,
+   1175,
+   789,
+   73,
+   - 252,
+   - 767,
+   738,
+   932,
+   616,
+   362,
+   246,
+   - 126,
+   787,
+   2654,
+   3027,
+   - 691,
+   - 1106,
+   - 2190,
+   - 565,
+   - 588,
+   524,
+   - 590,
+   - 979,
+   - 490,
+   - 263,
+   397,
+   982,
+   - 577,
+   - 837,
+   - 945,
+   - 22,
+   435,
+   - 49,
+   - 190,
+   - 118,
+   - 629,
+   - 88,
+   1240,
+   1513,
+   - 636,
+   - 1051,
+   - 1019,
+   - 291,
+   189,
+   259,
+   - 257,
+   - 470,
+   - 629,
+   145,
+   945,
+   894,
+   - 326,
+   - 364,
+   - 1094,
+   543,
+   260,
+   630,
+   - 202,
+   189,
+   - 209,
+   357,
+   1379,
+   2091,
+   - 569,
+   - 1075,
+   - 1449,
+   - 714,
+   - 239,
+   919,
+   - 420,
+   - 705,
+   - 84,
+   - 109,
+   - 114,
+   2407,
+   - 413,
+   - 529,
+   - 1177,
+   482,
+   368,
+   131,
+   - 186,
+   - 72,
+   - 131,
+   861,
+   1255,
+   1220,
+   - 611,
+   - 658,
+   - 1341,
+   227,
+   - 121,
+   631,
+   - 176,
+   - 489,
+   - 218,
+   745,
+   1175,
+   957,
+   - 321,
+   - 148,
+   - 936,
+   671,
+   966,
+   216,
+   340,
+   - 3,
+   - 143,
+   469,
+   1848,
+   2437,
+   - 729,
+   - 961,
+   - 1683,
+   - 213,
+   - 254,
+   321,
+   - 511,
+   - 438,
+   - 521,
+   - 126,
+   725,
+   903,
+   - 340,
+   - 685,
+   - 1032,
+   316,
+   480,
+   20,
+   23,
+   - 89,
+   - 551,
+   353,
+   1051,
+   1789,
+   - 544,
+   - 757,
+   - 1364,
+   298,
+   - 25,
+   436,
+   - 100,
+   - 392,
+   - 519,
+   467,
+   754,
+   1078,
+   - 210,
+   - 398,
+   - 1078,
+   620,
+   658,
+   630,
+   33,
+   147,
+   - 178,
+   921,
+   1687,
+   1921,
+   - 325,
+   - 528,
+   - 1978,
+   2,
+   - 285,
+   910,
+   - 371,
+   - 490,
+   - 230,
+   0,
+   597,
+   2010,
+   - 496,
+   - 395,
+   - 834,
+   37,
+   945,
+   245,
+   181,
+   - 160,
+   - 144,
+   1481,
+   1373,
+   1357,
+   - 355,
+   - 601,
+   - 1270,
+   298,
+   322,
+   672,
+   - 193,
+   - 336,
+   77,
+   1089,
+   1533,
+   922,
+   177,
+   - 39,
+   - 1125,
+   996,
+   781,
+   536,
+   456,
+   366,
+   - 432,
+   1415,
+   2440,
+   2279,
+   - 466,
+   - 758,
+   - 2325,
+   - 303,
+   - 509,
+   387,
+   - 727,
+   - 557,
+   66,
+   - 145,
+   643,
+   1248,
+   - 544,
+   - 676,
+   - 916,
+   - 225,
+   862,
+   588,
+   - 152,
+   40,
+   - 533,
+   423,
+   1423,
+   1558,
+   - 572,
+   - 843,
+   - 1145,
+   - 128,
+   85,
+   461,
+   - 238,
+   - 257,
+   - 584,
+   605,
+   748,
+   861,
+   24,
+   - 202,
+   - 1409,
+   797,
+   487,
+   303,
+   - 181,
+   364,
+   - 182,
+   616,
+   1378,
+   2942,
+   - 494,
+   - 852,
+   - 1441,
+   - 292,
+   61,
+   812,
+   - 84,
+   - 723,
+   - 182,
+   555,
+   532,
+   1506,
+   - 365,
+   - 493,
+   - 1057,
+   822,
+   588,
+   11,
+   - 14,
+   - 18,
+   - 230,
+   1001,
+   1401,
+   1451,
+   - 474,
+   - 569,
+   - 1292,
+   302,
+   62,
+   1062,
+   - 70,
+   - 376,
+   - 222,
+   982,
+   974,
+   1149,
+   - 196,
+   - 234,
+   - 795,
+   479,
+   1098,
+   499,
+   362,
+   58,
+   70,
+   1147,
+   2069,
+   2857,
+   - 487,
+   - 878,
+   - 1824,
+   73,
+   - 288,
+   348,
+   - 358,
+   - 500,
+   - 508,
+   199,
+   721,
+   1242,
+   - 78,
+   - 697,
+   - 795,
+   361,
+   536,
+   196,
+   374,
+   110,
+   - 735,
+   847,
+   1051,
+   1896,
+   - 366,
+   - 713,
+   - 1182,
+   315,
+   320,
+   429,
+   72,
+   - 215,
+   - 450,
+   759,
+   886,
+   1363,
+   - 30,
+   - 428,
+   - 834,
+   861,
+   627,
+   796,
+   118,
+   468,
+   - 279,
+   1355,
+   1883,
+   1893,
+   - 188,
+   - 642,
+   - 1612,
+   63,
+   - 175,
+   1198,
+   - 418,
+   - 211,
+   51,
+   414,
+   587,
+   2601,
+   - 234,
+   - 557,
+   - 858,
+   424,
+   889,
+   222,
+   136,
+   - 101,
+   83,
+   1413,
+   2278,
+   1383,
+   - 84,
+   - 445,
+   - 1389,
+   414,
+   313,
+   1045,
+   29,
+   - 343,
+   65,
+   1552,
+   1647,
+   980,
+   183,
+   - 91,
+   - 829,
+   1273,
+   1413,
+   360,
+   553,
+   272,
+   - 107,
+   1587,
+   3149,
+   2603
+};
+#define DICO1_SIZE_5  128
+#define DICO2_SIZE_5  256
+#define DICO3_SIZE_5  256
+#define DICO4_SIZE_5  256
+#define DICO5_SIZE_5  64
+
+/* 1st LSF quantizer (MR122) */
+static const Word32 dico1_lsf_5[DICO1_SIZE_5 * 4] =
+{
+   - 451,
+   - 1065,
+   - 529,
+   - 1305,
+   - 450,
+   - 756,
+   - 497,
+   - 863,
+   - 384,
+   - 619,
+   - 413,
+   - 669,
+   - 317,
+   - 538,
+   - 331,
+   - 556,
+   - 414,
+   - 508,
+   - 424,
+   - 378,
+   - 274,
+   - 324,
+   - 434,
+   - 614,
+   - 226,
+   - 500,
+   - 232,
+   - 514,
+   - 263,
+   - 377,
+   - 298,
+   - 410,
+   - 151,
+   - 710,
+   - 174,
+   - 818,
+   - 149,
+   - 412,
+   - 156,
+   - 429,
+   - 288,
+   - 462,
+   - 186,
+   - 203,
+   - 170,
+   - 302,
+   - 191,
+   - 321,
+   - 131,
+   - 147,
+   - 297,
+   - 395,
+   - 228,
+   - 214,
+   - 245,
+   - 192,
+   - 67,
+   - 316,
+   - 71,
+   - 327,
+   - 104,
+   - 205,
+   - 94,
+   - 183,
+   - 143,
+   - 38,
+   - 193,
+   - 95,
+   16,
+   - 76,
+   - 124,
+   - 248,
+   23,
+   - 237,
+   24,
+   - 244,
+   18,
+   - 136,
+   44,
+   - 111,
+   - 33,
+   - 24,
+   - 25,
+   0,
+   149,
+   19,
+   23,
+   - 143,
+   158,
+   - 169,
+   174,
+   - 181,
+   133,
+   - 55,
+   165,
+   - 26,
+   111,
+   84,
+   98,
+   75,
+   87,
+   183,
+   - 115,
+   - 11,
+   - 8,
+   130,
+   11,
+   170,
+   254,
+   77,
+   205,
+   17,
+   183,
+   112,
+   262,
+   194,
+   202,
+   287,
+   95,
+   189,
+   - 42,
+   - 105,
+   234,
+   179,
+   39,
+   186,
+   163,
+   345,
+   332,
+   199,
+   299,
+   161,
+   - 54,
+   285,
+   - 78,
+   281,
+   - 133,
+   141,
+   - 182,
+   111,
+   249,
+   341,
+   271,
+   364,
+   93,
+   403,
+   75,
+   391,
+   92,
+   510,
+   - 138,
+   220,
+   - 185,
+   - 29,
+   - 34,
+   361,
+   - 115,
+   320,
+   3,
+   554,
+   99,
+   286,
+   218,
+   591,
+   - 245,
+   406,
+   - 268,
+   453,
+   0,
+   580,
+   25,
+   606,
+   275,
+   532,
+   148,
+   450,
+   - 73,
+   739,
+   - 285,
+   518,
+   - 288,
+   94,
+   - 203,
+   674,
+   - 140,
+   - 74,
+   205,
+   714,
+   - 114,
+   299,
+   176,
+   923,
+   182,
+   557,
+   240,
+   705,
+   - 16,
+   513,
+   485,
+   593,
+   293,
+   384,
+   451,
+   617,
+   - 38,
+   50,
+   563,
+   529,
+   303,
+   209,
+   459,
+   363,
+   433,
+   452,
+   450,
+   454,
+   367,
+   606,
+   477,
+   741,
+   432,
+   353,
+   368,
+   267,
+   361,
+   716,
+   273,
+   583,
+   453,
+   166,
+   510,
+   172,
+   201,
+   629,
+   274,
+   191,
+   568,
+   639,
+   302,
+   298,
+   634,
+   387,
+   643,
+   350,
+   587,
+   560,
+   612,
+   565,
+   600,
+   788,
+   487,
+   672,
+   512,
+   1015,
+   321,
+   333,
+   357,
+   854,
+   - 125,
+   413,
+   474,
+   712,
+   17,
+   - 151,
+   564,
+   285,
+   270,
+   - 241,
+   971,
+   889,
+   489,
+   220,
+   510,
+   896,
+   549,
+   924,
+   327,
+   825,
+   290,
+   911,
+   540,
+   1108,
+   158,
+   805,
+   199,
+   957,
+   511,
+   730,
+   100,
+   874,
+   13,
+   791,
+   435,
+   632,
+   676,
+   972,
+   249,
+   900,
+   467,
+   1218,
+   781,
+   1074,
+   585,
+   785,
+   - 23,
+   669,
+   267,
+   1043,
+   619,
+   1084,
+   615,
+   1145,
+   622,
+   905,
+   916,
+   1049,
+   80,
+   331,
+   584,
+   1075,
+   89,
+   639,
+   988,
+   961,
+   770,
+   720,
+   798,
+   699,
+   492,
+   447,
+   899,
+   627,
+   271,
+   1188,
+   725,
+   1333,
+   87,
+   603,
+   832,
+   1603,
+   616,
+   1127,
+   890,
+   1505,
+   1000,
+   1156,
+   866,
+   1009,
+   995,
+   827,
+   1149,
+   858,
+   817,
+   1450,
+   773,
+   1320,
+   500,
+   1389,
+   312,
+   1153,
+   - 20,
+   1084,
+   64,
+   1283,
+   2,
+   1172,
+   399,
+   1869,
+   514,
+   1706,
+   502,
+   1636,
+   886,
+   1522,
+   416,
+   600,
+   1131,
+   1350,
+   1275,
+   1390,
+   889,
+   1795,
+   914,
+   1766,
+   227,
+   1183,
+   1250,
+   1826,
+   505,
+   1854,
+   919,
+   2353,
+   - 199,
+   431,
+   152,
+   1735,
+   - 213,
+   - 28,
+   392,
+   1334,
+   - 153,
+   - 52,
+   978,
+   1151,
+   - 323,
+   - 400,
+   813,
+   1703,
+   - 136,
+   84,
+   1449,
+   2015,
+   - 331,
+   - 143,
+   - 137,
+   1192,
+   - 256,
+   534,
+   - 157,
+   1031,
+   - 307,
+   - 439,
+   542,
+   731,
+   - 329,
+   - 420,
+   - 97,
+   616,
+   - 362,
+   - 168,
+   - 322,
+   366,
+   - 247,
+   - 110,
+   - 211,
+   89,
+   - 196,
+   - 309,
+   20,
+   59,
+   - 364,
+   - 463,
+   - 286,
+   89,
+   - 336,
+   175,
+   - 432,
+   141,
+   - 379,
+   - 190,
+   - 434,
+   - 196,
+   - 79,
+   150,
+   - 278,
+   - 227,
+   - 280,
+   166,
+   - 555,
+   - 422,
+   - 155,
+   541,
+   - 366,
+   54,
+   - 29,
+   - 83,
+   - 301,
+   - 774,
+   186,
+   628,
+   - 397,
+   - 264,
+   242,
+   293,
+   - 197,
+   - 585,
+   124,
+   410,
+   53,
+   - 133,
+   10,
+   340,
+   - 570,
+   - 1065,
+   65,
+   - 446,
+   68,
+   - 493,
+   383,
+   937,
+   - 357,
+   - 711,
+   - 359,
+   - 250,
+   - 677,
+   - 1068,
+   292,
+   - 26,
+   363,
+   6,
+   607,
+   1313,
+   - 127,
+   - 10,
+   1513,
+   1886,
+   713,
+   972,
+   1469,
+   2181,
+   1443,
+   2016
+};
+
+/* 2nd LSF quantizer (MR122) */
+static const Word32 dico2_lsf_5[DICO2_SIZE_5 * 4] =
+{
+   - 1631,
+   - 1600,
+   - 1796,
+   - 2290,
+   - 1027,
+   - 1770,
+   - 1100,
+   - 2025,
+   - 1277,
+   - 1388,
+   - 1367,
+   - 1534,
+   - 947,
+   - 1461,
+   - 972,
+   - 1524,
+   - 999,
+   - 1222,
+   - 1020,
+   - 1172,
+   - 815,
+   - 987,
+   - 992,
+   - 1371,
+   - 1216,
+   - 1006,
+   - 1289,
+   - 1094,
+   - 744,
+   - 1268,
+   - 755,
+   - 1293,
+   - 862,
+   - 923,
+   - 905,
+   - 984,
+   - 678,
+   - 1051,
+   - 685,
+   - 1050,
+   - 1087,
+   - 985,
+   - 1062,
+   - 679,
+   - 989,
+   - 641,
+   - 1127,
+   - 976,
+   - 762,
+   - 654,
+   - 890,
+   - 806,
+   - 833,
+   - 1091,
+   - 706,
+   - 629,
+   - 621,
+   - 806,
+   - 640,
+   - 812,
+   - 775,
+   - 634,
+   - 779,
+   - 543,
+   - 996,
+   - 565,
+   - 1075,
+   - 580,
+   - 546,
+   - 611,
+   - 572,
+   - 619,
+   - 760,
+   - 290,
+   - 879,
+   - 526,
+   - 823,
+   - 462,
+   - 795,
+   - 253,
+   - 553,
+   - 415,
+   - 589,
+   - 439,
+   - 533,
+   - 340,
+   - 692,
+   - 935,
+   - 505,
+   - 772,
+   - 702,
+   - 1131,
+   - 263,
+   - 306,
+   - 971,
+   - 483,
+   - 445,
+   - 74,
+   - 555,
+   - 548,
+   - 614,
+   - 129,
+   - 693,
+   - 234,
+   - 396,
+   - 246,
+   - 475,
+   - 250,
+   - 265,
+   - 404,
+   - 376,
+   - 514,
+   - 417,
+   - 510,
+   - 300,
+   - 313,
+   - 334,
+   - 664,
+   - 463,
+   - 814,
+   - 386,
+   - 704,
+   - 337,
+   - 615,
+   - 234,
+   - 201,
+   - 233,
+   - 239,
+   - 167,
+   - 567,
+   - 203,
+   - 619,
+   - 147,
+   - 415,
+   - 115,
+   - 352,
+   - 166,
+   - 750,
+   - 171,
+   - 761,
+   - 270,
+   - 879,
+   - 264,
+   - 903,
+   - 367,
+   - 744,
+   43,
+   - 475,
+   14,
+   - 653,
+   43,
+   - 670,
+   11,
+   - 448,
+   - 59,
+   - 521,
+   - 126,
+   - 119,
+   - 155,
+   - 613,
+   - 42,
+   - 863,
+   - 27,
+   - 931,
+   136,
+   - 483,
+   183,
+   - 468,
+   55,
+   - 298,
+   55,
+   - 304,
+   313,
+   - 609,
+   313,
+   - 720,
+   322,
+   - 167,
+   100,
+   - 541,
+   - 3,
+   - 119,
+   - 111,
+   - 187,
+   233,
+   - 236,
+   260,
+   - 234,
+   26,
+   - 165,
+   134,
+   - 45,
+   - 40,
+   - 549,
+   360,
+   - 203,
+   378,
+   - 388,
+   450,
+   - 383,
+   275,
+   20,
+   182,
+   - 103,
+   246,
+   - 111,
+   431,
+   37,
+   462,
+   - 146,
+   487,
+   - 157,
+   - 284,
+   - 59,
+   503,
+   - 184,
+   24,
+   53,
+   - 3,
+   54,
+   122,
+   259,
+   333,
+   66,
+   484,
+   104,
+   436,
+   68,
+   195,
+   116,
+   190,
+   206,
+   269,
+   - 9,
+   482,
+   352,
+   382,
+   285,
+   399,
+   277,
+   452,
+   256,
+   69,
+   186,
+   13,
+   297,
+   - 13,
+   259,
+   - 95,
+   30,
+   56,
+   394,
+   196,
+   425,
+   205,
+   456,
+   281,
+   577,
+   15,
+   191,
+   375,
+   290,
+   407,
+   576,
+   - 56,
+   227,
+   544,
+   405,
+   0,
+   549,
+   - 92,
+   528,
+   - 229,
+   351,
+   - 245,
+   338,
+   - 362,
+   435,
+   167,
+   527,
+   - 75,
+   302,
+   91,
+   824,
+   129,
+   599,
+   496,
+   679,
+   186,
+   749,
+   153,
+   737,
+   - 281,
+   600,
+   - 348,
+   615,
+   - 236,
+   769,
+   41,
+   881,
+   38,
+   890,
+   - 220,
+   841,
+   - 357,
+   883,
+   - 393,
+   903,
+   - 634,
+   474,
+   - 444,
+   850,
+   - 175,
+   678,
+   - 493,
+   242,
+   - 519,
+   785,
+   - 714,
+   582,
+   - 541,
+   366,
+   - 543,
+   434,
+   - 597,
+   500,
+   - 765,
+   222,
+   - 702,
+   917,
+   - 743,
+   962,
+   - 869,
+   501,
+   - 899,
+   548,
+   - 379,
+   200,
+   - 435,
+   157,
+   - 819,
+   214,
+   - 861,
+   157,
+   - 614,
+   40,
+   - 632,
+   94,
+   - 883,
+   - 54,
+   - 741,
+   516,
+   - 501,
+   298,
+   - 614,
+   - 171,
+   - 870,
+   - 161,
+   - 865,
+   - 23,
+   - 818,
+   93,
+   - 1015,
+   - 267,
+   - 662,
+   - 359,
+   - 549,
+   2,
+   - 442,
+   - 121,
+   - 377,
+   0,
+   - 227,
+   33,
+   - 414,
+   - 126,
+   - 129,
+   212,
+   - 934,
+   34,
+   - 1082,
+   - 282,
+   - 1119,
+   - 268,
+   - 710,
+   - 825,
+   - 420,
+   - 191,
+   - 1076,
+   - 928,
+   - 917,
+   - 93,
+   - 628,
+   - 358,
+   97,
+   7,
+   - 206,
+   - 393,
+   - 101,
+   24,
+   - 203,
+   38,
+   - 168,
+   83,
+   - 599,
+   - 423,
+   - 279,
+   426,
+   - 700,
+   118,
+   - 75,
+   206,
+   - 981,
+   - 673,
+   - 680,
+   417,
+   - 367,
+   37,
+   - 279,
+   474,
+   - 129,
+   - 318,
+   319,
+   296,
+   - 626,
+   - 39,
+   343,
+   602,
+   - 696,
+   - 39,
+   - 303,
+   940,
+   104,
+   233,
+   - 380,
+   137,
+   - 36,
+   269,
+   - 75,
+   - 214,
+   120,
+   43,
+   - 529,
+   - 477,
+   459,
+   164,
+   - 202,
+   - 229,
+   - 49,
+   - 167,
+   609,
+   792,
+   98,
+   - 220,
+   915,
+   148,
+   293,
+   283,
+   869,
+   91,
+   575,
+   394,
+   326,
+   - 78,
+   717,
+   67,
+   365,
+   - 323,
+   616,
+   - 36,
+   731,
+   27,
+   619,
+   238,
+   632,
+   273,
+   448,
+   99,
+   801,
+   476,
+   869,
+   273,
+   685,
+   64,
+   789,
+   72,
+   1021,
+   217,
+   793,
+   459,
+   734,
+   360,
+   646,
+   480,
+   360,
+   322,
+   429,
+   464,
+   638,
+   430,
+   756,
+   363,
+   1000,
+   404,
+   683,
+   528,
+   602,
+   615,
+   655,
+   413,
+   946,
+   687,
+   937,
+   602,
+   904,
+   604,
+   555,
+   737,
+   786,
+   662,
+   467,
+   654,
+   362,
+   589,
+   929,
+   710,
+   498,
+   478,
+   415,
+   420,
+   693,
+   883,
+   813,
+   683,
+   781,
+   925,
+   913,
+   939,
+   726,
+   732,
+   491,
+   853,
+   531,
+   948,
+   734,
+   963,
+   315,
+   808,
+   761,
+   755,
+   1144,
+   760,
+   655,
+   1076,
+   826,
+   1057,
+   1091,
+   838,
+   1003,
+   808,
+   1047,
+   1133,
+   659,
+   1101,
+   992,
+   1050,
+   1074,
+   1075,
+   971,
+   694,
+   1226,
+   1054,
+   571,
+   841,
+   884,
+   1404,
+   1379,
+   1096,
+   1080,
+   861,
+   1231,
+   735,
+   1284,
+   760,
+   1272,
+   991,
+   1367,
+   1053,
+   1257,
+   700,
+   1050,
+   534,
+   988,
+   453,
+   1264,
+   599,
+   1140,
+   679,
+   1621,
+   815,
+   1384,
+   521,
+   1317,
+   393,
+   1564,
+   805,
+   1448,
+   686,
+   1068,
+   648,
+   875,
+   307,
+   1083,
+   361,
+   1047,
+   317,
+   1417,
+   964,
+   675,
+   571,
+   1152,
+   79,
+   1114,
+   - 47,
+   1530,
+   311,
+   1721,
+   314,
+   1166,
+   689,
+   514,
+   - 94,
+   349,
+   282,
+   1412,
+   328,
+   1025,
+   487,
+   - 65,
+   57,
+   805,
+   970,
+   36,
+   62,
+   769,
+   - 263,
+   791,
+   - 346,
+   637,
+   699,
+   - 137,
+   620,
+   534,
+   541,
+   - 735,
+   194,
+   711,
+   300,
+   - 268,
+   - 863,
+   926,
+   769,
+   - 708,
+   - 428,
+   506,
+   174,
+   - 892,
+   - 630,
+   435,
+   547,
+   - 1435,
+   - 258,
+   621,
+   471,
+   - 1018,
+   - 1368,
+   - 393,
+   521,
+   - 920,
+   - 686,
+   - 25,
+   20,
+   - 982,
+   - 1156,
+   340,
+   9,
+   - 1558,
+   - 1135,
+   - 352,
+   48,
+   - 1579,
+   - 402,
+   - 887,
+   6,
+   - 1156,
+   - 888,
+   - 548,
+   - 352,
+   - 1643,
+   - 1168,
+   - 159,
+   610,
+   - 2024,
+   - 963,
+   - 225,
+   193,
+   - 1656,
+   - 1960,
+   - 245,
+   - 493,
+   - 964,
+   - 1680,
+   - 936,
+   - 635,
+   - 1299,
+   - 1744,
+   - 1388,
+   - 604,
+   - 1540,
+   - 835,
+   - 1397,
+   - 135,
+   - 1588,
+   - 290,
+   - 1670,
+   - 712,
+   - 2011,
+   - 1632,
+   - 1663,
+   - 27,
+   - 2258,
+   - 811,
+   - 1157,
+   184,
+   - 1265,
+   189,
+   - 1367,
+   586,
+   - 2011,
+   201,
+   - 790,
+   712,
+   - 1210,
+   3,
+   - 1033,
+   808,
+   - 1251,
+   830,
+   - 111,
+   635,
+   - 1636,
+   447,
+   - 463,
+   - 949,
+   - 445,
+   - 928,
+   - 504,
+   - 1162,
+   - 501,
+   - 1211,
+   144,
+   - 351,
+   - 372,
+   - 1052,
+   - 283,
+   - 1059,
+   - 279,
+   - 1123,
+   - 575,
+   - 1438,
+   - 587,
+   - 1614,
+   - 935,
+   - 984,
+   229,
+   690,
+   - 921,
+   - 719,
+   - 403,
+   1362,
+   - 685,
+   - 465,
+   874,
+   397,
+   - 509,
+   - 46,
+   317,
+   1334,
+   - 485,
+   456,
+   813,
+   439,
+   - 411,
+   339,
+   898,
+   1067,
+   - 425,
+   46,
+   1441,
+   497,
+   - 909,
+   - 800,
+   1465,
+   1046,
+   - 254,
+   - 321,
+   1430,
+   1165,
+   68,
+   350,
+   1034,
+   666,
+   370,
+   11,
+   1311,
+   790,
+   143,
+   232,
+   1041,
+   1562,
+   - 114,
+   663,
+   1616,
+   1078,
+   454,
+   579,
+   1275,
+   1040,
+   - 76,
+   909,
+   752,
+   1067,
+   153,
+   512,
+   348,
+   1214,
+   614,
+   385,
+   1843,
+   808,
+   269,
+   1034,
+   203,
+   1086,
+   652,
+   1017,
+   1783,
+   1130,
+   429,
+   1327,
+   387,
+   1384,
+   - 49,
+   1183,
+   - 72,
+   1215,
+   - 416,
+   1001,
+   544,
+   1749,
+   - 352,
+   1223,
+   - 502,
+   1199,
+   - 589,
+   569,
+   - 227,
+   1630,
+   - 142,
+   1578,
+   - 230,
+   1715,
+   - 714,
+   1288,
+   - 838,
+   1398,
+   1131,
+   1357,
+   - 208,
+   1232,
+   437,
+   965,
+   - 929,
+   818,
+   811,
+   1410,
+   859,
+   1507,
+   164,
+   1212,
+   1387,
+   1793,
+   484,
+   1874,
+   456,
+   2063,
+   996,
+   1170,
+   1326,
+   1402,
+   1316,
+   1360,
+   1135,
+   1262,
+   1234,
+   1618,
+   1361,
+   1768,
+   1421,
+   1227,
+   1584,
+   1347,
+   854,
+   672,
+   1685,
+   1566,
+   1139,
+   1270,
+   2016,
+   1825,
+   1773,
+   1581,
+   1532,
+   1460,
+   1487,
+   946,
+   1659,
+   1021,
+   1744,
+   1212,
+   1392,
+   977,
+   1772,
+   1161,
+   1826,
+   1164,
+   1718,
+   1429,
+   1973,
+   1591,
+   1185,
+   864,
+   2132,
+   1061,
+   1799,
+   814,
+   1838,
+   757,
+   2104,
+   1315,
+   2054,
+   1258,
+   2113,
+   915,
+   2331,
+   930,
+   1467,
+   1147,
+   2590,
+   1439,
+   2245,
+   1744,
+   2090,
+   1620,
+   2358,
+   1454,
+   2666,
+   1506,
+   1876,
+   1837,
+   2070,
+   1975,
+   1739,
+   1577,
+   682,
+   1289,
+   1584,
+   2045,
+   1454,
+   2098,
+   2498,
+   2004,
+   2711,
+   2066,
+   726,
+   1588,
+   2756,
+   2336,
+   228,
+   847,
+   2456,
+   1659,
+   36,
+   301,
+   1942,
+   1957,
+   - 446,
+   - 96,
+   2154,
+   1396,
+   1533,
+   1101,
+   14,
+   608,
+   - 923,
+   - 732,
+   1383,
+   1982,
+   1345,
+   952,
+   - 680,
+   321,
+   1281,
+   1268,
+   - 1594,
+   365,
+   941,
+   946,
+   - 1737,
+   - 822,
+   2374,
+   2787,
+   1821,
+   2788
+};
+
+/* 3rd LSF quantizer (MR122) */
+static const Word32 dico3_lsf_5[DICO3_SIZE_5 * 4] =
+{
+   - 1812,
+   - 2275,
+   - 1879,
+   - 2537,
+   - 1640,
+   - 1848,
+   - 1695,
+   - 2004,
+   - 1220,
+   - 1912,
+   - 1221,
+   - 2106,
+   - 1559,
+   - 1588,
+   - 1573,
+   - 1556,
+   - 1195,
+   - 1615,
+   - 1224,
+   - 1727,
+   - 1359,
+   - 1151,
+   - 1616,
+   - 1948,
+   - 1274,
+   - 1391,
+   - 1305,
+   - 1403,
+   - 1607,
+   - 1179,
+   - 1676,
+   - 1311,
+   - 1443,
+   - 1478,
+   - 1367,
+   - 898,
+   - 1256,
+   - 1059,
+   - 1331,
+   - 1134,
+   - 982,
+   - 1133,
+   - 1149,
+   - 1504,
+   - 1080,
+   - 1308,
+   - 1020,
+   - 1183,
+   - 980,
+   - 1486,
+   - 967,
+   - 1495,
+   - 988,
+   - 922,
+   - 1047,
+   - 1077,
+   - 838,
+   - 1179,
+   - 858,
+   - 1222,
+   - 1131,
+   - 1041,
+   - 1064,
+   - 767,
+   - 872,
+   - 1157,
+   - 701,
+   - 880,
+   - 706,
+   - 906,
+   - 774,
+   - 1016,
+   - 578,
+   - 1080,
+   - 801,
+   - 1478,
+   - 591,
+   - 1111,
+   - 592,
+   - 1146,
+   - 713,
+   - 1388,
+   - 640,
+   - 1376,
+   - 597,
+   - 1059,
+   - 416,
+   - 903,
+   - 686,
+   - 832,
+   - 661,
+   - 708,
+   - 444,
+   - 868,
+   - 490,
+   - 921,
+   - 374,
+   - 776,
+   - 619,
+   - 1170,
+   - 585,
+   - 549,
+   - 769,
+   - 795,
+   - 435,
+   - 659,
+   - 530,
+   - 741,
+   - 498,
+   - 837,
+   - 357,
+   - 597,
+   - 279,
+   - 871,
+   - 243,
+   - 887,
+   - 282,
+   - 665,
+   - 280,
+   - 667,
+   - 165,
+   - 560,
+   - 394,
+   - 903,
+   - 362,
+   - 410,
+   - 448,
+   - 583,
+   - 409,
+   - 574,
+   - 313,
+   - 357,
+   - 637,
+   - 548,
+   - 570,
+   - 436,
+   - 896,
+   - 504,
+   - 382,
+   - 757,
+   - 58,
+   - 481,
+   - 165,
+   - 618,
+   - 191,
+   - 374,
+   - 234,
+   - 382,
+   - 222,
+   - 683,
+   - 25,
+   - 480,
+   - 418,
+   - 359,
+   - 730,
+   - 353,
+   - 324,
+   - 157,
+   - 432,
+   - 322,
+   - 394,
+   - 303,
+   - 284,
+   - 104,
+   - 601,
+   - 289,
+   - 556,
+   - 196,
+   - 588,
+   - 150,
+   - 659,
+   - 608,
+   - 473,
+   - 24,
+   - 68,
+   - 448,
+   - 474,
+   - 8,
+   - 506,
+   - 45,
+   - 748,
+   - 184,
+   - 844,
+   - 252,
+   - 901,
+   - 91,
+   - 584,
+   - 97,
+   - 652,
+   138,
+   - 764,
+   - 131,
+   - 678,
+   - 12,
+   - 670,
+   165,
+   - 259,
+   - 3,
+   - 840,
+   - 107,
+   - 909,
+   37,
+   - 992,
+   44,
+   - 854,
+   - 415,
+   - 839,
+   13,
+   - 1001,
+   - 271,
+   - 1026,
+   - 309,
+   - 798,
+   - 478,
+   - 832,
+   - 488,
+   - 943,
+   168,
+   - 1112,
+   - 387,
+   - 1185,
+   - 101,
+   - 1183,
+   - 40,
+   - 941,
+   - 316,
+   - 1030,
+   - 770,
+   - 1044,
+   - 625,
+   - 1081,
+   - 538,
+   - 1224,
+   - 299,
+   - 1312,
+   - 436,
+   - 1197,
+   - 663,
+   - 1167,
+   - 161,
+   - 1216,
+   - 690,
+   - 1237,
+   - 831,
+   - 1432,
+   - 720,
+   - 1403,
+   - 493,
+   - 898,
+   - 740,
+   - 922,
+   - 801,
+   - 1102,
+   - 402,
+   - 1579,
+   - 964,
+   - 1061,
+   - 638,
+   - 1269,
+   - 1438,
+   - 1499,
+   - 934,
+   - 1502,
+   - 895,
+   - 1598,
+   - 564,
+   - 1723,
+   - 717,
+   - 606,
+   - 597,
+   - 1166,
+   - 1085,
+   - 1369,
+   - 468,
+   - 1946,
+   - 1493,
+   - 1838,
+   - 953,
+   - 1932,
+   - 931,
+   - 1499,
+   - 188,
+   - 1635,
+   - 421,
+   - 1457,
+   - 338,
+   - 1448,
+   - 22,
+   - 1942,
+   - 422,
+   - 2006,
+   - 249,
+   - 496,
+   - 114,
+   - 1910,
+   - 755,
+   - 1289,
+   174,
+   - 1451,
+   - 109,
+   - 482,
+   - 257,
+   - 1221,
+   - 508,
+   - 1617,
+   151,
+   - 1694,
+   208,
+   - 654,
+   107,
+   - 1651,
+   29,
+   - 1141,
+   279,
+   - 1215,
+   306,
+   - 1228,
+   - 506,
+   - 730,
+   - 175,
+   - 1236,
+   - 101,
+   - 969,
+   551,
+   - 870,
+   278,
+   - 823,
+   315,
+   - 563,
+   376,
+   - 1051,
+   228,
+   - 507,
+   280,
+   - 599,
+   281,
+   - 758,
+   253,
+   - 305,
+   379,
+   - 755,
+   - 134,
+   - 611,
+   660,
+   - 824,
+   536,
+   - 817,
+   646,
+   - 413,
+   49,
+   - 341,
+   177,
+   - 453,
+   526,
+   - 482,
+   589,
+   - 71,
+   339,
+   - 657,
+   264,
+   - 244,
+   295,
+   - 237,
+   315,
+   - 387,
+   569,
+   - 506,
+   - 9,
+   - 377,
+   14,
+   - 160,
+   661,
+   - 216,
+   40,
+   - 308,
+   - 46,
+   95,
+   214,
+   - 242,
+   167,
+   - 86,
+   192,
+   - 56,
+   27,
+   - 76,
+   31,
+   36,
+   309,
+   - 106,
+   - 182,
+   - 113,
+   74,
+   - 441,
+   - 22,
+   23,
+   139,
+   81,
+   - 11,
+   44,
+   15,
+   - 87,
+   - 137,
+   - 118,
+   - 207,
+   - 158,
+   - 58,
+   272,
+   - 92,
+   - 156,
+   - 441,
+   8,
+   - 136,
+   128,
+   - 221,
+   101,
+   - 218,
+   40,
+   - 197,
+   - 76,
+   - 456,
+   9,
+   - 445,
+   33,
+   - 423,
+   226,
+   60,
+   73,
+   - 222,
+   156,
+   - 399,
+   280,
+   - 318,
+   245,
+   - 341,
+   166,
+   - 499,
+   339,
+   - 190,
+   327,
+   - 219,
+   325,
+   - 137,
+   - 89,
+   - 596,
+   100,
+   - 627,
+   144,
+   - 677,
+   487,
+   28,
+   252,
+   - 391,
+   214,
+   - 41,
+   282,
+   - 28,
+   99,
+   - 286,
+   331,
+   49,
+   459,
+   - 388,
+   565,
+   - 369,
+   436,
+   28,
+   336,
+   - 9,
+   397,
+   - 167,
+   618,
+   34,
+   596,
+   - 17,
+   561,
+   - 140,
+   299,
+   79,
+   522,
+   125,
+   203,
+   2,
+   244,
+   288,
+   255,
+   211,
+   175,
+   82,
+   596,
+   187,
+   517,
+   108,
+   381,
+   255,
+   365,
+   297,
+   497,
+   352,
+   327,
+   - 82,
+   25,
+   210,
+   371,
+   245,
+   261,
+   3,
+   545,
+   449,
+   140,
+   294,
+   44,
+   295,
+   212,
+   347,
+   244,
+   494,
+   331,
+   528,
+   201,
+   307,
+   349,
+   411,
+   613,
+   284,
+   614,
+   413,
+   464,
+   322,
+   624,
+   397,
+   97,
+   200,
+   - 160,
+   384,
+   149,
+   362,
+   495,
+   525,
+   269,
+   585,
+   33,
+   491,
+   - 121,
+   433,
+   427,
+   611,
+   498,
+   516,
+   171,
+   443,
+   497,
+   666,
+   440,
+   275,
+   566,
+   575,
+   146,
+   639,
+   155,
+   670,
+   - 33,
+   173,
+   212,
+   696,
+   - 166,
+   601,
+   - 191,
+   695,
+   - 489,
+   503,
+   175,
+   742,
+   214,
+   476,
+   372,
+   1083,
+   578,
+   530,
+   586,
+   777,
+   425,
+   874,
+   315,
+   841,
+   374,
+   848,
+   - 165,
+   565,
+   35,
+   991,
+   - 39,
+   1062,
+   329,
+   712,
+   786,
+   840,
+   645,
+   795,
+   661,
+   676,
+   571,
+   918,
+   632,
+   1079,
+   673,
+   817,
+   318,
+   388,
+   874,
+   1012,
+   564,
+   848,
+   880,
+   620,
+   557,
+   479,
+   671,
+   453,
+   692,
+   468,
+   840,
+   642,
+   844,
+   645,
+   506,
+   428,
+   897,
+   567,
+   837,
+   387,
+   962,
+   499,
+   691,
+   561,
+   939,
+   926,
+   783,
+   296,
+   790,
+   268,
+   1028,
+   530,
+   874,
+   329,
+   548,
+   143,
+   675,
+   291,
+   503,
+   66,
+   1041,
+   359,
+   786,
+   97,
+   805,
+   33,
+   837,
+   470,
+   511,
+   49,
+   1092,
+   327,
+   1174,
+   323,
+   3,
+   242,
+   872,
+   474,
+   689,
+   429,
+   1329,
+   678,
+   1042,
+   620,
+   1109,
+   664,
+   321,
+   193,
+   889,
+   950,
+   1153,
+   874,
+   893,
+   635,
+   877,
+   862,
+   948,
+   913,
+   1293,
+   665,
+   1320,
+   639,
+   997,
+   793,
+   1402,
+   1030,
+   1176,
+   1012,
+   1110,
+   959,
+   1410,
+   925,
+   1403,
+   915,
+   543,
+   862,
+   1116,
+   1222,
+   835,
+   1190,
+   835,
+   1190,
+   959,
+   1148,
+   1147,
+   1376,
+   1300,
+   1193,
+   1415,
+   1231,
+   1335,
+   1341,
+   746,
+   1092,
+   1711,
+   1283,
+   1389,
+   1073,
+   1334,
+   1566,
+   1153,
+   1475,
+   1645,
+   1137,
+   1825,
+   1220,
+   1056,
+   1382,
+   1521,
+   1730,
+   1632,
+   1545,
+   1620,
+   1542,
+   855,
+   1596,
+   865,
+   1667,
+   693,
+   885,
+   1716,
+   1519,
+   1167,
+   1296,
+   2209,
+   1760,
+   1952,
+   1493,
+   2020,
+   1482,
+   1534,
+   1866,
+   1694,
+   2008,
+   1566,
+   748,
+   1761,
+   825,
+   294,
+   1392,
+   1084,
+   2058,
+   621,
+   1315,
+   365,
+   1287,
+   198,
+   1028,
+   488,
+   1408,
+   249,
+   403,
+   1014,
+   1561,
+   324,
+   363,
+   1645,
+   1044,
+   193,
+   367,
+   2034,
+   1859,
+   - 251,
+   579,
+   750,
+   994,
+   - 243,
+   30,
+   1325,
+   879,
+   - 28,
+   - 169,
+   624,
+   917,
+   - 453,
+   159,
+   186,
+   1370,
+   - 614,
+   6,
+   537,
+   392,
+   - 94,
+   - 291,
+   781,
+   229,
+   - 128,
+   - 298,
+   245,
+   491,
+   - 701,
+   - 648,
+   972,
+   789,
+   - 501,
+   - 640,
+   178,
+   255,
+   - 365,
+   - 390,
+   - 255,
+   317,
+   - 958,
+   - 294,
+   - 191,
+   228,
+   - 775,
+   - 447,
+   157,
+   - 237,
+   - 657,
+   - 720,
+   - 407,
+   92,
+   - 117,
+   - 611,
+   334,
+   - 230,
+   - 679,
+   - 1084,
+   - 144,
+   - 317,
+   - 901,
+   - 861,
+   - 738,
+   - 360,
+   - 85,
+   - 727,
+   - 90,
+   - 787,
+   100,
+   - 22,
+   - 391,
+   - 263,
+   - 56,
+   - 73,
+   - 337,
+   - 754,
+   5,
+   - 189,
+   - 706,
+   - 624,
+   89,
+   - 344,
+   - 135,
+   - 1113,
+   - 353,
+   - 237,
+   - 684,
+   - 1135,
+   - 275,
+   - 1102,
+   - 269,
+   - 1203,
+   152,
+   145,
+   - 722,
+   - 1232,
+   49,
+   80,
+   - 1248,
+   - 776,
+   - 248,
+   391,
+   - 732,
+   - 547,
+   469,
+   218,
+   - 255,
+   - 864,
+   69,
+   366,
+   - 166,
+   - 485,
+   - 688,
+   191,
+   - 1212,
+   - 1196,
+   - 170,
+   - 169,
+   - 1308,
+   - 1631,
+   321,
+   470,
+   - 1419,
+   - 1243,
+   - 64,
+   272,
+   - 1361,
+   - 248,
+   492,
+   565,
+   - 721,
+   - 609,
+   195,
+   485,
+   - 573,
+   - 133,
+   427,
+   202,
+   - 171,
+   - 118,
+   199,
+   575,
+   2,
+   - 31,
+   694,
+   755,
+   - 1366,
+   - 39,
+   552,
+   557,
+   - 489,
+   271,
+   680,
+   537,
+   13,
+   - 453,
+   855,
+   954,
+   - 133,
+   - 52,
+   - 81,
+   738,
+   - 1169,
+   637,
+   1055,
+   1059,
+   - 95,
+   676,
+   1259,
+   1081,
+   489,
+   305,
+   - 449,
+   954,
+   - 534,
+   996,
+   - 969,
+   866,
+   - 1058,
+   1059,
+   - 1294,
+   618,
+   - 1416,
+   617,
+   - 458,
+   1366,
+   - 159,
+   1821,
+   - 774,
+   - 528,
+   - 14,
+   1110,
+   - 1202,
+   - 901,
+   - 772,
+   433,
+   - 1256,
+   - 1255,
+   - 1011,
+   - 302,
+   - 602,
+   - 585,
+   - 759,
+   - 1618,
+   - 760,
+   - 1549,
+   - 840,
+   - 1921,
+   - 816,
+   - 539,
+   - 1769,
+   - 2235,
+   - 227,
+   - 36,
+   - 2034,
+   - 1831,
+   - 2107,
+   - 1126,
+   - 2471,
+   - 1816,
+   - 1470,
+   252,
+   - 2701,
+   - 415,
+   - 571,
+   - 467,
+   1509,
+   1554,
+   2180,
+   1975,
+   2326,
+   2020
+};
+
+/* 4th LSF quantizer (MR122) */
+static const Word32 dico4_lsf_5[DICO4_SIZE_5 * 4] =
+{
+   - 1857,
+   - 1681,
+   - 1857,
+   - 1755,
+   - 2056,
+   - 1150,
+   - 2134,
+   - 1654,
+   - 1619,
+   - 1099,
+   - 1704,
+   - 1131,
+   - 1345,
+   - 1608,
+   - 1359,
+   - 1638,
+   - 1338,
+   - 1293,
+   - 1325,
+   - 1265,
+   - 1664,
+   - 1649,
+   - 1487,
+   - 851,
+   - 1346,
+   - 1832,
+   - 1413,
+   - 2188,
+   - 1282,
+   - 681,
+   - 1785,
+   - 1649,
+   - 966,
+   - 1082,
+   - 1183,
+   - 1676,
+   - 1054,
+   - 1073,
+   - 1142,
+   - 1158,
+   - 1207,
+   - 744,
+   - 1274,
+   - 997,
+   - 934,
+   - 1383,
+   - 927,
+   - 1416,
+   - 1010,
+   - 1305,
+   - 783,
+   - 955,
+   - 1049,
+   - 900,
+   - 993,
+   - 817,
+   - 737,
+   - 823,
+   - 972,
+   - 1189,
+   - 738,
+   - 1094,
+   - 738,
+   - 1154,
+   - 784,
+   - 801,
+   - 810,
+   - 786,
+   - 892,
+   - 520,
+   - 1000,
+   - 818,
+   - 644,
+   - 965,
+   - 577,
+   - 882,
+   - 541,
+   - 694,
+   - 671,
+   - 917,
+   - 595,
+   - 642,
+   - 646,
+   - 615,
+   - 956,
+   - 621,
+   - 925,
+   - 515,
+   - 727,
+   - 483,
+   - 815,
+   - 485,
+   - 840,
+   - 578,
+   - 440,
+   - 713,
+   - 578,
+   - 325,
+   - 657,
+   - 670,
+   - 386,
+   - 570,
+   - 441,
+   - 666,
+   - 514,
+   - 787,
+   - 392,
+   - 529,
+   - 522,
+   - 453,
+   - 487,
+   - 423,
+   - 616,
+   - 585,
+   - 617,
+   - 157,
+   - 662,
+   - 268,
+   - 680,
+   - 348,
+   - 322,
+   - 323,
+   - 632,
+   - 444,
+   - 304,
+   - 430,
+   - 332,
+   - 458,
+   - 277,
+   - 468,
+   - 659,
+   - 793,
+   - 319,
+   - 636,
+   - 227,
+   - 554,
+   - 373,
+   - 347,
+   - 334,
+   - 210,
+   - 456,
+   - 192,
+   - 530,
+   - 242,
+   - 216,
+   - 198,
+   - 366,
+   - 370,
+   - 338,
+   - 161,
+   - 409,
+   - 748,
+   - 107,
+   - 380,
+   - 294,
+   - 643,
+   - 223,
+   - 665,
+   - 234,
+   - 741,
+   - 141,
+   - 496,
+   - 130,
+   - 510,
+   - 139,
+   - 327,
+   - 172,
+   - 305,
+   - 306,
+   - 580,
+   - 164,
+   - 263,
+   - 262,
+   - 172,
+   - 67,
+   - 402,
+   31,
+   - 366,
+   - 10,
+   - 436,
+   - 86,
+   - 527,
+   71,
+   - 377,
+   - 22,
+   - 609,
+   - 12,
+   - 678,
+   - 67,
+   - 319,
+   63,
+   - 191,
+   35,
+   - 181,
+   - 39,
+   - 242,
+   126,
+   - 167,
+   - 140,
+   - 544,
+   155,
+   - 297,
+   174,
+   - 297,
+   38,
+   - 8,
+   117,
+   - 380,
+   197,
+   - 452,
+   240,
+   - 522,
+   223,
+   - 103,
+   110,
+   - 187,
+   87,
+   - 155,
+   169,
+   - 47,
+   157,
+   26,
+   - 83,
+   - 100,
+   128,
+   80,
+   209,
+   - 62,
+   6,
+   7,
+   22,
+   5,
+   318,
+   - 20,
+   248,
+   - 45,
+   - 200,
+   - 63,
+   156,
+   - 69,
+   250,
+   - 183,
+   369,
+   - 126,
+   - 113,
+   - 76,
+   - 142,
+   - 122,
+   - 64,
+   - 254,
+   - 31,
+   35,
+   - 177,
+   - 71,
+   - 7,
+   171,
+   93,
+   27,
+   108,
+   212,
+   - 330,
+   - 209,
+   - 123,
+   - 70,
+   - 279,
+   95,
+   - 96,
+   20,
+   - 188,
+   - 61,
+   - 314,
+   87,
+   - 300,
+   - 78,
+   - 354,
+   - 134,
+   11,
+   122,
+   - 140,
+   122,
+   - 275,
+   152,
+   - 293,
+   140,
+   - 82,
+   138,
+   - 321,
+   - 111,
+   - 480,
+   - 156,
+   - 359,
+   76,
+   - 254,
+   - 40,
+   - 635,
+   - 96,
+   - 522,
+   79,
+   - 507,
+   8,
+   - 268,
+   303,
+   - 539,
+   68,
+   - 446,
+   61,
+   - 522,
+   306,
+   111,
+   189,
+   - 435,
+   122,
+   - 379,
+   166,
+   - 571,
+   - 398,
+   - 632,
+   - 74,
+   - 747,
+   - 95,
+   - 455,
+   194,
+   - 952,
+   83,
+   - 798,
+   192,
+   - 755,
+   192,
+   - 781,
+   - 162,
+   - 619,
+   234,
+   - 663,
+   - 297,
+   - 488,
+   - 109,
+   - 964,
+   - 132,
+   - 838,
+   - 68,
+   - 843,
+   58,
+   - 1112,
+   - 86,
+   - 805,
+   - 299,
+   - 944,
+   - 253,
+   - 778,
+   - 50,
+   - 965,
+   - 549,
+   - 352,
+   - 98,
+   - 992,
+   - 343,
+   - 1117,
+   - 315,
+   - 1117,
+   - 307,
+   - 1155,
+   - 374,
+   - 637,
+   - 230,
+   - 1166,
+   - 43,
+   - 1299,
+   - 100,
+   - 925,
+   - 393,
+   - 1274,
+   - 600,
+   - 689,
+   - 130,
+   - 1479,
+   - 312,
+   - 1321,
+   - 254,
+   - 1464,
+   - 442,
+   - 1292,
+   - 613,
+   - 1261,
+   - 503,
+   - 1501,
+   - 368,
+   - 1322,
+   26,
+   - 1432,
+   - 66,
+   - 1743,
+   - 161,
+   - 1644,
+   - 467,
+   - 1760,
+   - 548,
+   - 1393,
+   - 568,
+   - 1556,
+   - 871,
+   - 1495,
+   - 1034,
+   - 1387,
+   - 571,
+   - 1917,
+   - 528,
+   - 1783,
+   - 123,
+   - 1897,
+   - 231,
+   - 2054,
+   - 323,
+   - 2052,
+   - 906,
+   - 1976,
+   - 567,
+   - 1917,
+   - 620,
+   - 2047,
+   - 989,
+   - 1077,
+   - 370,
+   - 2031,
+   - 704,
+   - 2355,
+   - 749,
+   - 2740,
+   - 1089,
+   - 1909,
+   159,
+   - 2012,
+   248,
+   - 626,
+   - 123,
+   - 2339,
+   - 962,
+   - 669,
+   - 408,
+   - 1379,
+   - 1174,
+   - 452,
+   - 364,
+   - 1044,
+   - 735,
+   - 132,
+   183,
+   - 1620,
+   - 752,
+   - 547,
+   - 307,
+   - 777,
+   - 1261,
+   - 98,
+   41,
+   - 880,
+   - 1091,
+   - 257,
+   97,
+   - 1602,
+   - 1833,
+   31,
+   - 26,
+   - 644,
+   - 561,
+   - 180,
+   - 546,
+   - 385,
+   - 1095,
+   - 410,
+   - 802,
+   - 414,
+   - 827,
+   - 457,
+   - 970,
+   - 490,
+   - 1109,
+   - 215,
+   - 916,
+   - 144,
+   - 937,
+   - 493,
+   - 1269,
+   - 517,
+   - 1507,
+   181,
+   101,
+   - 332,
+   - 889,
+   - 836,
+   - 937,
+   - 559,
+   - 429,
+   - 629,
+   - 547,
+   - 183,
+   - 337,
+   - 545,
+   - 82,
+   - 250,
+   - 286,
+   5,
+   - 132,
+   - 348,
+   - 252,
+   - 293,
+   - 472,
+   - 158,
+   100,
+   - 29,
+   197,
+   - 236,
+   - 424,
+   - 861,
+   - 213,
+   - 140,
+   - 7,
+   - 427,
+   - 443,
+   187,
+   - 97,
+   - 684,
+   - 736,
+   - 293,
+   258,
+   - 368,
+   - 152,
+   - 150,
+   392,
+   - 609,
+   175,
+   - 142,
+   299,
+   - 138,
+   152,
+   - 119,
+   329,
+   - 486,
+   - 52,
+   293,
+   198,
+   - 183,
+   117,
+   175,
+   331,
+   - 58,
+   - 274,
+   231,
+   300,
+   - 288,
+   330,
+   - 305,
+   372,
+   - 111,
+   409,
+   - 9,
+   423,
+   83,
+   256,
+   67,
+   367,
+   - 19,
+   248,
+   91,
+   113,
+   - 35,
+   406,
+   - 191,
+   154,
+   238,
+   296,
+   5,
+   197,
+   141,
+   221,
+   313,
+   198,
+   211,
+   421,
+   244,
+   334,
+   88,
+   426,
+   - 243,
+   454,
+   202,
+   552,
+   - 5,
+   403,
+   291,
+   185,
+   219,
+   301,
+   251,
+   138,
+   128,
+   69,
+   197,
+   288,
+   - 140,
+   - 61,
+   188,
+   361,
+   197,
+   598,
+   442,
+   273,
+   290,
+   143,
+   472,
+   482,
+   157,
+   370,
+   415,
+   321,
+   372,
+   385,
+   402,
+   552,
+   155,
+   24,
+   550,
+   263,
+   - 11,
+   21,
+   360,
+   227,
+   147,
+   - 254,
+   424,
+   97,
+   366,
+   - 13,
+   375,
+   141,
+   449,
+   232,
+   396,
+   507,
+   474,
+   272,
+   701,
+   324,
+   362,
+   - 47,
+   587,
+   148,
+   543,
+   69,
+   400,
+   - 51,
+   561,
+   59,
+   220,
+   - 10,
+   352,
+   147,
+   206,
+   211,
+   653,
+   185,
+   563,
+   297,
+   565,
+   284,
+   594,
+   121,
+   766,
+   192,
+   398,
+   118,
+   642,
+   434,
+   233,
+   264,
+   481,
+   467,
+   129,
+   - 165,
+   699,
+   239,
+   90,
+   26,
+   342,
+   474,
+   - 55,
+   27,
+   388,
+   94,
+   - 172,
+   0,
+   725,
+   379,
+   - 60,
+   337,
+   370,
+   465,
+   95,
+   319,
+   806,
+   595,
+   78,
+   260,
+   497,
+   851,
+   210,
+   560,
+   458,
+   574,
+   - 464,
+   202,
+   497,
+   625,
+   - 202,
+   152,
+   48,
+   712,
+   - 20,
+   566,
+   100,
+   715,
+   455,
+   468,
+   411,
+   605,
+   319,
+   646,
+   195,
+   615,
+   401,
+   538,
+   680,
+   739,
+   201,
+   667,
+   434,
+   954,
+   454,
+   425,
+   646,
+   491,
+   606,
+   681,
+   416,
+   508,
+   497,
+   822,
+   426,
+   815,
+   660,
+   647,
+   628,
+   716,
+   697,
+   466,
+   618,
+   457,
+   685,
+   460,
+   365,
+   309,
+   721,
+   567,
+   836,
+   601,
+   609,
+   300,
+   825,
+   459,
+   943,
+   687,
+   681,
+   533,
+   915,
+   598,
+   591,
+   243,
+   876,
+   451,
+   874,
+   420,
+   786,
+   317,
+   732,
+   220,
+   922,
+   317,
+   1108,
+   367,
+   531,
+   466,
+   1028,
+   649,
+   1053,
+   615,
+   1034,
+   553,
+   829,
+   602,
+   1021,
+   799,
+   927,
+   803,
+   878,
+   763,
+   799,
+   496,
+   1373,
+   773,
+   585,
+   770,
+   803,
+   930,
+   1099,
+   793,
+   1222,
+   862,
+   1209,
+   895,
+   1025,
+   727,
+   772,
+   845,
+   1172,
+   1115,
+   867,
+   1021,
+   830,
+   1013,
+   841,
+   910,
+   506,
+   703,
+   1239,
+   1077,
+   620,
+   819,
+   1196,
+   1083,
+   1155,
+   1081,
+   1142,
+   907,
+   1547,
+   1121,
+   1309,
+   648,
+   1343,
+   612,
+   1484,
+   988,
+   1479,
+   937,
+   985,
+   1328,
+   955,
+   1341,
+   429,
+   910,
+   841,
+   1338,
+   564,
+   1179,
+   412,
+   1156,
+   1427,
+   1320,
+   1434,
+   1330,
+   640,
+   760,
+   1726,
+   1410,
+   190,
+   555,
+   1073,
+   1005,
+   426,
+   257,
+   839,
+   980,
+   235,
+   231,
+   1520,
+   1167,
+   109,
+   293,
+   1014,
+   1569,
+   305,
+   142,
+   1148,
+   539,
+   - 291,
+   - 108,
+   1213,
+   972,
+   22,
+   - 216,
+   667,
+   828,
+   - 482,
+   438,
+   453,
+   1431,
+   - 581,
+   - 422,
+   789,
+   387,
+   - 358,
+   - 454,
+   174,
+   780,
+   - 36,
+   - 372,
+   390,
+   - 134,
+   - 629,
+   160,
+   - 306,
+   751,
+   - 1258,
+   - 331,
+   177,
+   522,
+   - 248,
+   574,
+   - 251,
+   639,
+   - 531,
+   407,
+   - 596,
+   394,
+   - 419,
+   789,
+   - 617,
+   801,
+   - 986,
+   399,
+   - 857,
+   727,
+   - 7,
+   518,
+   - 703,
+   310,
+   - 1143,
+   - 24,
+   - 1002,
+   287,
+   - 960,
+   363,
+   - 1299,
+   312,
+   - 1534,
+   245,
+   - 1557,
+   305,
+   28,
+   153,
+   - 859,
+   - 175,
+   - 33,
+   332,
+   - 1398,
+   - 154,
+   212,
+   410,
+   - 593,
+   - 197,
+   - 1092,
+   - 704,
+   - 904,
+   - 65,
+   282,
+   367,
+   - 918,
+   - 686,
+   345,
+   93,
+   - 258,
+   - 357,
+   696,
+   644,
+   - 693,
+   - 28,
+   448,
+   493,
+   - 273,
+   193,
+   527,
+   546,
+   - 243,
+   - 513,
+   384,
+   - 136,
+   273,
+   - 353,
+   512,
+   - 142,
+   537,
+   - 198,
+   941,
+   750,
+   83,
+   248,
+   578,
+   861,
+   - 56,
+   592,
+   842,
+   44,
+   892,
+   24,
+   33,
+   890,
+   - 16,
+   982,
+   831,
+   1398,
+   1535,
+   1898,
+   1716,
+   1376,
+   1948,
+   1465
+};
+
+/* 5th LSF quantizer (MR122) */
+static const Word32 dico5_lsf_5[DICO5_SIZE_5 * 4] =
+{
+   - 1002,
+   - 929,
+   - 1096,
+   - 1203,
+   - 641,
+   - 931,
+   - 604,
+   - 961,
+   - 779,
+   - 673,
+   - 835,
+   - 788,
+   - 416,
+   - 664,
+   - 458,
+   - 766,
+   - 652,
+   - 521,
+   - 662,
+   - 495,
+   - 1023,
+   - 509,
+   - 1023,
+   - 428,
+   - 444,
+   - 552,
+   - 368,
+   - 449,
+   - 479,
+   - 211,
+   - 1054,
+   - 903,
+   - 316,
+   - 249,
+   - 569,
+   - 591,
+   - 569,
+   - 275,
+   - 541,
+   - 191,
+   - 716,
+   - 188,
+   - 842,
+   - 264,
+   - 333,
+   - 248,
+   - 318,
+   - 228,
+   - 275,
+   1,
+   - 567,
+   - 228,
+   - 115,
+   - 221,
+   - 238,
+   - 374,
+   - 197,
+   - 507,
+   - 222,
+   - 579,
+   - 258,
+   - 432,
+   - 61,
+   - 244,
+   - 345,
+   2,
+   - 338,
+   39,
+   - 215,
+   - 169,
+   - 58,
+   0,
+   - 56,
+   - 6,
+   - 203,
+   - 131,
+   1,
+   - 186,
+   - 5,
+   - 211,
+   6,
+   - 380,
+   11,
+   - 418,
+   - 116,
+   131,
+   - 134,
+   113,
+   89,
+   - 4,
+   71,
+   - 2,
+   - 19,
+   - 192,
+   262,
+   24,
+   189,
+   151,
+   - 133,
+   - 109,
+   186,
+   - 153,
+   166,
+   - 219,
+   37,
+   139,
+   193,
+   171,
+   337,
+   124,
+   158,
+   - 61,
+   141,
+   226,
+   - 13,
+   190,
+   231,
+   34,
+   354,
+   109,
+   316,
+   201,
+   244,
+   164,
+   330,
+   - 85,
+   390,
+   - 84,
+   254,
+   327,
+   257,
+   335,
+   491,
+   147,
+   476,
+   105,
+   54,
+   77,
+   437,
+   370,
+   421,
+   314,
+   449,
+   342,
+   329,
+   126,
+   673,
+   292,
+   571,
+   388,
+   243,
+   193,
+   653,
+   320,
+   621,
+   280,
+   194,
+   380,
+   517,
+   581,
+   45,
+   323,
+   111,
+   422,
+   489,
+   395,
+   734,
+   534,
+   622,
+   546,
+   486,
+   502,
+   318,
+   572,
+   189,
+   550,
+   385,
+   422,
+   - 157,
+   153,
+   - 125,
+   382,
+   - 197,
+   386,
+   - 263,
+   334,
+   228,
+   697,
+   - 188,
+   1,
+   51,
+   297,
+   - 507,
+   213,
+   - 376,
+   397,
+   - 24,
+   255,
+   - 547,
+   89,
+   - 502,
+   - 94,
+   387,
+   179,
+   - 620,
+   68,
+   - 684,
+   112,
+   - 642,
+   - 350,
+   - 260,
+   172,
+   - 438,
+   - 324,
+   264,
+   648,
+   - 964,
+   - 4,
+   - 1121,
+   7,
+   - 134,
+   134,
+   - 1133,
+   - 306,
+   143,
+   96,
+   - 420,
+   - 497,
+   - 1221,
+   - 350,
+   - 1527,
+   - 685,
+   - 161,
+   72,
+   873,
+   691,
+   732,
+   283,
+   921,
+   353,
+   334,
+   475,
+   1095,
+   821,
+   864,
+   524,
+   843,
+   497,
+   714,
+   711,
+   788,
+   750,
+   1076,
+   714,
+   1204,
+   753
+};
+
+
+
+/* Scaling factors for the lsp variability operation */
+static const Word16 lsf_hist_mean_scale[M] =
+{
+   20000,
+   20000,
+   20000,
+   20000,
+   20000,
+   18000,
+   16384,
+   8192,
+   0,
+   0
+};
+
+/*
+ * The tables contains the following data:
+ *
+ * g_pitch        (Q14),
+ * g_fac          (Q12), (g_code = g_code0*g_fac),
+ * qua_ener_MR122 (Q10), (log2(g_fac))
+ * qua_ener       (Q10)  (20*log10(g_fac))
+ *
+ * The log2() and log10() values are calculated on the fixed point value
+ * (g_fac Q12) and not on the original floating point value of g_fac
+ * to make the quantizer/MA predictdor use corresponding values.
+ */
+
+#define MR475_VQ_SIZE 256
+
+/* The table contains the following data:
+ *
+ * g_pitch(0)        (Q14)  for sub-
+ * g_fac(0)          (Q12)  frame 0 and 2
+ * g_pitch(1)        (Q14)  for sub-
+ * g_fac(2)          (Q12)  frame 1 and 3
+ *
+ */
+static const Word32 table_gain_MR475[MR475_VQ_SIZE * 4] =
+{
+/*
+ * g_pit(0),
+ * g_fac(0),
+ * g_pit(1),
+ * g_fac(1)
+ */ 812,
+   128,
+   542,
+   140,
+   2873,
+   1135,
+   2266,
+   3402,
+   2067,
+   563,
+   12677,
+   647,
+   4132,
+   1798,
+   5601,
+   5285,
+   7689,
+   374,
+   3735,
+   441,
+   10912,
+   2638,
+   11807,
+   2494,
+   20490,
+   797,
+   5218,
+   675,
+   6724,
+   8354,
+   5282,
+   1696,
+   1488,
+   428,
+   5882,
+   452,
+   5332,
+   4072,
+   3583,
+   1268,
+   2469,
+   901,
+   15894,
+   1005,
+   14982,
+   3271,
+   10331,
+   4858,
+   3635,
+   2021,
+   2596,
+   835,
+   12360,
+   4892,
+   12206,
+   1704,
+   13432,
+   1604,
+   9118,
+   2341,
+   3968,
+   1538,
+   5479,
+   9936,
+   3795,
+   417,
+   1359,
+   414,
+   3640,
+   1569,
+   7995,
+   3541,
+   11405,
+   645,
+   8552,
+   635,
+   4056,
+   1377,
+   16608,
+   6124,
+   11420,
+   700,
+   2007,
+   607,
+   12415,
+   1578,
+   11119,
+   4654,
+   13680,
+   1708,
+   11990,
+   1229,
+   7996,
+   7297,
+   13231,
+   5715,
+   2428,
+   1159,
+   2073,
+   1941,
+   6218,
+   6121,
+   3546,
+   1804,
+   8925,
+   1802,
+   8679,
+   1580,
+   13935,
+   3576,
+   13313,
+   6237,
+   6142,
+   1130,
+   5994,
+   1734,
+   14141,
+   4662,
+   11271,
+   3321,
+   12226,
+   1551,
+   13931,
+   3015,
+   5081,
+   10464,
+   9444,
+   6706,
+   1689,
+   683,
+   1436,
+   1306,
+   7212,
+   3933,
+   4082,
+   2713,
+   7793,
+   704,
+   15070,
+   802,
+   6299,
+   5212,
+   4337,
+   5357,
+   6676,
+   541,
+   6062,
+   626,
+   13651,
+   3700,
+   11498,
+   2408,
+   16156,
+   716,
+   12177,
+   751,
+   8065,
+   11489,
+   6314,
+   2256,
+   4466,
+   496,
+   7293,
+   523,
+   10213,
+   3833,
+   8394,
+   3037,
+   8403,
+   966,
+   14228,
+   1880,
+   8703,
+   5409,
+   16395,
+   4863,
+   7420,
+   1979,
+   6089,
+   1230,
+   9371,
+   4398,
+   14558,
+   3363,
+   13559,
+   2873,
+   13163,
+   1465,
+   5534,
+   1678,
+   13138,
+   14771,
+   7338,
+   600,
+   1318,
+   548,
+   4252,
+   3539,
+   10044,
+   2364,
+   10587,
+   622,
+   13088,
+   669,
+   14126,
+   3526,
+   5039,
+   9784,
+   15338,
+   619,
+   3115,
+   590,
+   16442,
+   3013,
+   15542,
+   4168,
+   15537,
+   1611,
+   15405,
+   1228,
+   16023,
+   9299,
+   7534,
+   4976,
+   1990,
+   1213,
+   11447,
+   1157,
+   12512,
+   5519,
+   9475,
+   2644,
+   7716,
+   2034,
+   13280,
+   2239,
+   16011,
+   5093,
+   8066,
+   6761,
+   10083,
+   1413,
+   5002,
+   2347,
+   12523,
+   5975,
+   15126,
+   2899,
+   18264,
+   2289,
+   15827,
+   2527,
+   16265,
+   10254,
+   14651,
+   11319,
+   1797,
+   337,
+   3115,
+   397,
+   3510,
+   2928,
+   4592,
+   2670,
+   7519,
+   628,
+   11415,
+   656,
+   5946,
+   2435,
+   6544,
+   7367,
+   8238,
+   829,
+   4000,
+   863,
+   10032,
+   2492,
+   16057,
+   3551,
+   18204,
+   1054,
+   6103,
+   1454,
+   5884,
+   7900,
+   18752,
+   3468,
+   1864,
+   544,
+   9198,
+   683,
+   11623,
+   4160,
+   4594,
+   1644,
+   3158,
+   1157,
+   15953,
+   2560,
+   12349,
+   3733,
+   17420,
+   5260,
+   6106,
+   2004,
+   2917,
+   1742,
+   16467,
+   5257,
+   16787,
+   1680,
+   17205,
+   1759,
+   4773,
+   3231,
+   7386,
+   6035,
+   14342,
+   10012,
+   4035,
+   442,
+   4194,
+   458,
+   9214,
+   2242,
+   7427,
+   4217,
+   12860,
+   801,
+   11186,
+   825,
+   12648,
+   2084,
+   12956,
+   6554,
+   9505,
+   996,
+   6629,
+   985,
+   10537,
+   2502,
+   15289,
+   5006,
+   12602,
+   2055,
+   15484,
+   1653,
+   16194,
+   6921,
+   14231,
+   5790,
+   2626,
+   828,
+   5615,
+   1686,
+   13663,
+   5778,
+   3668,
+   1554,
+   11313,
+   2633,
+   9770,
+   1459,
+   14003,
+   4733,
+   15897,
+   6291,
+   6278,
+   1870,
+   7910,
+   2285,
+   16978,
+   4571,
+   16576,
+   3849,
+   15248,
+   2311,
+   16023,
+   3244,
+   14459,
+   17808,
+   11847,
+   2763,
+   1981,
+   1407,
+   1400,
+   876,
+   4335,
+   3547,
+   4391,
+   4210,
+   5405,
+   680,
+   17461,
+   781,
+   6501,
+   5118,
+   8091,
+   7677,
+   7355,
+   794,
+   8333,
+   1182,
+   15041,
+   3160,
+   14928,
+   3039,
+   20421,
+   880,
+   14545,
+   852,
+   12337,
+   14708,
+   6904,
+   1920,
+   4225,
+   933,
+   8218,
+   1087,
+   10659,
+   4084,
+   10082,
+   4533,
+   2735,
+   840,
+   20657,
+   1081,
+   16711,
+   5966,
+   15873,
+   4578,
+   10871,
+   2574,
+   3773,
+   1166,
+   14519,
+   4044,
+   20699,
+   2627,
+   15219,
+   2734,
+   15274,
+   2186,
+   6257,
+   3226,
+   13125,
+   19480,
+   7196,
+   930,
+   2462,
+   1618,
+   4515,
+   3092,
+   13852,
+   4277,
+   10460,
+   833,
+   17339,
+   810,
+   16891,
+   2289,
+   15546,
+   8217,
+   13603,
+   1684,
+   3197,
+   1834,
+   15948,
+   2820,
+   15812,
+   5327,
+   17006,
+   2438,
+   16788,
+   1326,
+   15671,
+   8156,
+   11726,
+   8556,
+   3762,
+   2053,
+   9563,
+   1317,
+   13561,
+   6790,
+   12227,
+   1936,
+   8180,
+   3550,
+   13287,
+   1778,
+   16299,
+   6599,
+   16291,
+   7758,
+   8521,
+   2551,
+   7225,
+   2645,
+   18269,
+   7489,
+   16885,
+   2248,
+   17882,
+   2884,
+   17265,
+   3328,
+   9417,
+   20162,
+   11042,
+   8320,
+   1286,
+   620,
+   1431,
+   583,
+   5993,
+   2289,
+   3978,
+   3626,
+   5144,
+   752,
+   13409,
+   830,
+   5553,
+   2860,
+   11764,
+   5908,
+   10737,
+   560,
+   5446,
+   564,
+   13321,
+   3008,
+   11946,
+   3683,
+   19887,
+   798,
+   9825,
+   728,
+   13663,
+   8748,
+   7391,
+   3053,
+   2515,
+   778,
+   6050,
+   833,
+   6469,
+   5074,
+   8305,
+   2463,
+   6141,
+   1865,
+   15308,
+   1262,
+   14408,
+   4547,
+   13663,
+   4515,
+   3137,
+   2983,
+   2479,
+   1259,
+   15088,
+   4647,
+   15382,
+   2607,
+   14492,
+   2392,
+   12462,
+   2537,
+   7539,
+   2949,
+   12909,
+   12060,
+   5468,
+   684,
+   3141,
+   722,
+   5081,
+   1274,
+   12732,
+   4200,
+   15302,
+   681,
+   7819,
+   592,
+   6534,
+   2021,
+   16478,
+   8737,
+   13364,
+   882,
+   5397,
+   899,
+   14656,
+   2178,
+   14741,
+   4227,
+   14270,
+   1298,
+   13929,
+   2029,
+   15477,
+   7482,
+   15815,
+   4572,
+   2521,
+   2013,
+   5062,
+   1804,
+   5159,
+   6582,
+   7130,
+   3597,
+   10920,
+   1611,
+   11729,
+   1708,
+   16903,
+   3455,
+   16268,
+   6640,
+   9306,
+   1007,
+   9369,
+   2106,
+   19182,
+   5037,
+   12441,
+   4269,
+   15919,
+   1332,
+   15357,
+   3512,
+   11898,
+   14141,
+   16101,
+   6854,
+   2010,
+   737,
+   3779,
+   861,
+   11454,
+   2880,
+   3564,
+   3540,
+   9057,
+   1241,
+   12391,
+   896,
+   8546,
+   4629,
+   11561,
+   5776,
+   8129,
+   589,
+   8218,
+   588,
+   18728,
+   3755,
+   12973,
+   3149,
+   15729,
+   758,
+   16634,
+   754,
+   15222,
+   11138,
+   15871,
+   2208,
+   4673,
+   610,
+   10218,
+   678,
+   15257,
+   4146,
+   5729,
+   3327,
+   8377,
+   1670,
+   19862,
+   2321,
+   15450,
+   5511,
+   14054,
+   5481,
+   5728,
+   2888,
+   7580,
+   1346,
+   14384,
+   5325,
+   16236,
+   3950,
+   15118,
+   3744,
+   15306,
+   1435,
+   14597,
+   4070,
+   12301,
+   15696,
+   7617,
+   1699,
+   2170,
+   884,
+   4459,
+   4567,
+   18094,
+   3306,
+   12742,
+   815,
+   14926,
+   907,
+   15016,
+   4281,
+   15518,
+   8368,
+   17994,
+   1087,
+   2358,
+   865,
+   16281,
+   3787,
+   15679,
+   4596,
+   16356,
+   1534,
+   16584,
+   2210,
+   16833,
+   9697,
+   15929,
+   4513,
+   3277,
+   1085,
+   9643,
+   2187,
+   11973,
+   6068,
+   9199,
+   4462,
+   8955,
+   1629,
+   10289,
+   3062,
+   16481,
+   5155,
+   15466,
+   7066,
+   13678,
+   2543,
+   5273,
+   2277,
+   16746,
+   6213,
+   16655,
+   3408,
+   20304,
+   3363,
+   18688,
+   1985,
+   14172,
+   12867,
+   15154,
+   15703,
+   4473,
+   1020,
+   1681,
+   886,
+   4311,
+   4301,
+   8952,
+   3657,
+   5893,
+   1147,
+   11647,
+   1452,
+   15886,
+   2227,
+   4582,
+   6644,
+   6929,
+   1205,
+   6220,
+   799,
+   12415,
+   3409,
+   15968,
+   3877,
+   19859,
+   2109,
+   9689,
+   2141,
+   14742,
+   8830,
+   14480,
+   2599,
+   1817,
+   1238,
+   7771,
+   813,
+   19079,
+   4410,
+   5554,
+   2064,
+   3687,
+   2844,
+   17435,
+   2256,
+   16697,
+   4486,
+   16199,
+   5388,
+   8028,
+   2763,
+   3405,
+   2119,
+   17426,
+   5477,
+   13698,
+   2786,
+   19879,
+   2720,
+   9098,
+   3880,
+   18172,
+   4833,
+   17336,
+   12207,
+   5116,
+   996,
+   4935,
+   988,
+   9888,
+   3081,
+   6014,
+   5371,
+   15881,
+   1667,
+   8405,
+   1183,
+   15087,
+   2366,
+   19777,
+   7002,
+   11963,
+   1562,
+   7279,
+   1128,
+   16859,
+   1532,
+   15762,
+   5381,
+   14708,
+   2065,
+   20105,
+   2155,
+   17158,
+   8245,
+   17911,
+   6318,
+   5467,
+   1504,
+   4100,
+   2574,
+   17421,
+   6810,
+   5673,
+   2888,
+   16636,
+   3382,
+   8975,
+   1831,
+   20159,
+   4737,
+   19550,
+   7294,
+   6658,
+   2781,
+   11472,
+   3321,
+   19397,
+   5054,
+   18878,
+   4722,
+   16439,
+   2373,
+   20430,
+   4386,
+   11353,
+   26526,
+   11593,
+   3068,
+   2866,
+   1566,
+   5108,
+   1070,
+   9614,
+   4915,
+   4939,
+   3536,
+   7541,
+   878,
+   20717,
+   851,
+   6938,
+   4395,
+   16799,
+   7733,
+   10137,
+   1019,
+   9845,
+   964,
+   15494,
+   3955,
+   15459,
+   3430,
+   18863,
+   982,
+   20120,
+   963,
+   16876,
+   12887,
+   14334,
+   4200,
+   6599,
+   1220,
+   9222,
+   814,
+   16942,
+   5134,
+   5661,
+   4898,
+   5488,
+   1798,
+   20258,
+   3962,
+   17005,
+   6178,
+   17929,
+   5929,
+   9365,
+   3420,
+   7474,
+   1971,
+   19537,
+   5177,
+   19003,
+   3006,
+   16454,
+   3788,
+   16070,
+   2367,
+   8664,
+   2743,
+   9445,
+   26358,
+   10856,
+   1287,
+   3555,
+   1009,
+   5606,
+   3622,
+   19453,
+   5512,
+   12453,
+   797,
+   20634,
+   911,
+   15427,
+   3066,
+   17037,
+   10275,
+   18883,
+   2633,
+   3913,
+   1268,
+   19519,
+   3371,
+   18052,
+   5230,
+   19291,
+   1678,
+   19508,
+   3172,
+   18072,
+   10754,
+   16625,
+   6845,
+   3134,
+   2298,
+   10869,
+   2437,
+   15580,
+   6913,
+   12597,
+   3381,
+   11116,
+   3297,
+   16762,
+   2424,
+   18853,
+   6715,
+   17171,
+   9887,
+   12743,
+   2605,
+   8937,
+   3140,
+   19033,
+   7764,
+   18347,
+   3880,
+   20475,
+   3682,
+   19602,
+   3380,
+   13044,
+   19373,
+   10526,
+   23124
+};
+
+
+/* table used in 'high' rates: MR67 MR74 */
+#define VQ_SIZE_HIGHRATES 128
+static const Word32 table_gain_highrates[VQ_SIZE_HIGHRATES * 4] =
+{
+/*
+ * Note: every 4th value (qua_ener) contains the original values from IS641
+ * to ensure bit-exactness; however, they are not exactly the
+ * rounded value of (20*log10(g_fac))
+ */  /*
+ * g_pit,
+ * g_fac,
+ * qua_ener_MR122,
+ * qua_ener
+ */ 577,
+   662,
+   - 2692,
+   - 16214,
+   806,
+   1836,
+   - 1185,
+   - 7135,
+   3109,
+   1052,
+   - 2008,
+   - 12086,
+   4181,
+   1387,
+   - 1600,
+   - 9629,
+   2373,
+   1425,
+   - 1560,
+   - 9394,
+   3248,
+   1985,
+   - 1070,
+   - 6442,
+   1827,
+   2320,
+   - 840,
+   - 5056,
+   941,
+   3314,
+   - 313,
+   - 1885,
+   2351,
+   2977,
+   - 471,
+   - 2838,
+   3616,
+   2420,
+   - 777,
+   - 4681,
+   3451,
+   3096,
+   - 414,
+   - 2490,
+   2955,
+   4301,
+   72,
+   434,
+   1848,
+   4500,
+   139,
+   836,
+   3884,
+   5416,
+   413,
+   2484,
+   1187,
+   7210,
+   835,
+   5030,
+   3083,
+   9000,
+   1163,
+   7002,
+   7384,
+   883,
+   - 2267,
+   - 13647,
+   5962,
+   1506,
+   - 1478,
+   - 8900,
+   5155,
+   2134,
+   - 963,
+   - 5800,
+   7944,
+   2009,
+   - 1052,
+   - 6335,
+   6507,
+   2250,
+   - 885,
+   - 5327,
+   7670,
+   2752,
+   - 588,
+   - 3537,
+   5952,
+   3016,
+   - 452,
+   - 2724,
+   4898,
+   3764,
+   - 125,
+   - 751,
+   6989,
+   3588,
+   - 196,
+   - 1177,
+   8174,
+   3978,
+   - 43,
+   - 260,
+   6064,
+   4404,
+   107,
+   645,
+   7709,
+   5087,
+   320,
+   1928,
+   5523,
+   6021,
+   569,
+   3426,
+   7769,
+   7126,
+   818,
+   4926,
+   6060,
+   7938,
+   977,
+   5885,
+   5594,
+   11487,
+   1523,
+   9172,
+   10581,
+   1356,
+   - 1633,
+   - 9831,
+   9049,
+   1597,
+   - 1391,
+   - 8380,
+   9794,
+   2035,
+   - 1033,
+   - 6220,
+   8946,
+   2415,
+   - 780,
+   - 4700,
+   10296,
+   2584,
+   - 681,
+   - 4099,
+   9407,
+   2734,
+   - 597,
+   - 3595,
+   8700,
+   3218,
+   - 356,
+   - 2144,
+   9757,
+   3395,
+   - 277,
+   - 1669,
+   10177,
+   3892,
+   - 75,
+   - 454,
+   9170,
+   4528,
+   148,
+   891,
+   10152,
+   5004,
+   296,
+   1781,
+   9114,
+   5735,
+   497,
+   2993,
+   10500,
+   6266,
+   628,
+   3782,
+   10110,
+   7631,
+   919,
+   5534,
+   8844,
+   8727,
+   1117,
+   6728,
+   8956,
+   12496,
+   1648,
+   9921,
+   12924,
+   976,
+   - 2119,
+   - 12753,
+   11435,
+   1755,
+   - 1252,
+   - 7539,
+   12138,
+   2328,
+   - 835,
+   - 5024,
+   11388,
+   2368,
+   - 810,
+   - 4872,
+   10700,
+   3064,
+   - 429,
+   - 2580,
+   12332,
+   2861,
+   - 530,
+   - 3192,
+   11722,
+   3327,
+   - 307,
+   - 1848,
+   11270,
+   3700,
+   - 150,
+   - 904,
+   10861,
+   4413,
+   110,
+   663,
+   12082,
+   4533,
+   150,
+   902,
+   11283,
+   5205,
+   354,
+   2132,
+   11960,
+   6305,
+   637,
+   3837,
+   11167,
+   7534,
+   900,
+   5420,
+   12128,
+   8329,
+   1049,
+   6312,
+   10969,
+   10777,
+   1429,
+   8604,
+   10300,
+   17376,
+   2135,
+   12853,
+   13899,
+   1681,
+   - 1316,
+   - 7921,
+   12580,
+   2045,
+   - 1026,
+   - 6179,
+   13265,
+   2439,
+   - 766,
+   - 4610,
+   14033,
+   2989,
+   - 465,
+   - 2802,
+   13452,
+   3098,
+   - 413,
+   - 2482,
+   12396,
+   3658,
+   - 167,
+   - 1006,
+   13510,
+   3780,
+   - 119,
+   - 713,
+   12880,
+   4272,
+   62,
+   374,
+   13533,
+   4861,
+   253,
+   1523,
+   12667,
+   5457,
+   424,
+   2552,
+   13854,
+   6106,
+   590,
+   3551,
+   13031,
+   6483,
+   678,
+   4084,
+   13557,
+   7721,
+   937,
+   5639,
+   12957,
+   9311,
+   1213,
+   7304,
+   13714,
+   11551,
+   1532,
+   9221,
+   12591,
+   15206,
+   1938,
+   11667,
+   15113,
+   1540,
+   - 1445,
+   - 8700,
+   15072,
+   2333,
+   - 832,
+   - 5007,
+   14527,
+   2511,
+   - 723,
+   - 4352,
+   14692,
+   3199,
+   - 365,
+   - 2197,
+   15382,
+   3560,
+   - 207,
+   - 1247,
+   14133,
+   3960,
+   - 50,
+   - 300,
+   15102,
+   4236,
+   50,
+   298,
+   14332,
+   4824,
+   242,
+   1454,
+   14846,
+   5451,
+   422,
+   2542,
+   15306,
+   6083,
+   584,
+   3518,
+   14329,
+   6888,
+   768,
+   4623,
+   15060,
+   7689,
+   930,
+   5602,
+   14406,
+   9426,
+   1231,
+   7413,
+   15387,
+   9741,
+   1280,
+   7706,
+   14824,
+   14271,
+   1844,
+   11102,
+   13600,
+   24939,
+   2669,
+   16067,
+   16396,
+   1969,
+   - 1082,
+   - 6517,
+   16817,
+   2832,
+   - 545,
+   - 3283,
+   15713,
+   2843,
+   - 539,
+   - 3248,
+   16104,
+   3336,
+   - 303,
+   - 1825,
+   16384,
+   3963,
+   - 49,
+   - 294,
+   16940,
+   4579,
+   165,
+   992,
+   15711,
+   4599,
+   171,
+   1030,
+   16222,
+   5448,
+   421,
+   2537,
+   16832,
+   6382,
+   655,
+   3945,
+   15745,
+   7141,
+   821,
+   4944,
+   16326,
+   7469,
+   888,
+   5343,
+   16611,
+   8624,
+   1100,
+   6622,
+   17028,
+   10418,
+   1379,
+   8303,
+   15905,
+   11817,
+   1565,
+   9423,
+   16878,
+   14690,
+   1887,
+   11360,
+   16515,
+   20870,
+   2406,
+   14483,
+   18142,
+   2083,
+   - 999,
+   - 6013,
+   19401,
+   3178,
+   - 375,
+   - 2257,
+   17508,
+   3426,
+   - 264,
+   - 1589,
+   20054,
+   4027,
+   - 25,
+   - 151,
+   18069,
+   4249,
+   54,
+   326,
+   18952,
+   5066,
+   314,
+   1890,
+   17711,
+   5402,
+   409,
+   2461,
+   19835,
+   6192,
+   610,
+   3676,
+   17950,
+   7014,
+   795,
+   4784,
+   21318,
+   7877,
+   966,
+   5816,
+   17910,
+   9289,
+   1210,
+   7283,
+   19144,
+   9290,
+   1210,
+   7284,
+   20517,
+   11381,
+   1510,
+   9089,
+   18075,
+   14485,
+   1866,
+   11234,
+   19999,
+   17882,
+   2177,
+   13108,
+   18842,
+   32764,
+   3072,
+   18494
+};
+
+/* table used in 'low' rates: MR475, MR515, MR59 */
+#define VQ_SIZE_LOWRATES 64
+static const Word32 table_gain_lowrates[VQ_SIZE_LOWRATES * 4] =
+{
+/*
+ * g_pit,
+ * g_fac,
+ * qua_ener_MR122,
+ * qua_ener
+ */ 10813,
+   28753,
+   2879,
+   17333,
+   20480,
+   2785,
+   - 570,
+   - 3431,
+   18841,
+   6594,
+   703,
+   4235,
+   6225,
+   7413,
+   876,
+   5276,
+   17203,
+   10444,
+   1383,
+   8325,
+   21626,
+   1269,
+   - 1731,
+   - 10422,
+   21135,
+   4423,
+   113,
+   683,
+   11304,
+   1556,
+   - 1430,
+   - 8609,
+   19005,
+   12820,
+   1686,
+   10148,
+   17367,
+   2498,
+   - 731,
+   - 4398,
+   17858,
+   4833,
+   244,
+   1472,
+   9994,
+   2498,
+   - 731,
+   - 4398,
+   17530,
+   7864,
+   964,
+   5802,
+   14254,
+   1884,
+   - 1147,
+   - 6907,
+   15892,
+   3153,
+   - 387,
+   - 2327,
+   6717,
+   1802,
+   - 1213,
+   - 7303,
+   18186,
+   20193,
+   2357,
+   14189,
+   18022,
+   3031,
+   - 445,
+   - 2678,
+   16711,
+   5857,
+   528,
+   3181,
+   8847,
+   4014,
+   - 30,
+   - 180,
+   15892,
+   8970,
+   1158,
+   6972,
+   18022,
+   1392,
+   - 1594,
+   - 9599,
+   16711,
+   4096,
+   0,
+   0,
+   8192,
+   655,
+   - 2708,
+   - 16305,
+   15237,
+   13926,
+   1808,
+   10884,
+   14254,
+   3112,
+   - 406,
+   - 2444,
+   14090,
+   4669,
+   193,
+   1165,
+   5406,
+   2703,
+   - 614,
+   - 3697,
+   13434,
+   6553,
+   694,
+   4180,
+   12451,
+   901,
+   - 2237,
+   - 13468,
+   12451,
+   2662,
+   - 637,
+   - 3833,
+   3768,
+   655,
+   - 2708,
+   - 16305,
+   14745,
+   23511,
+   2582,
+   15543,
+   19169,
+   2457,
+   - 755,
+   - 4546,
+   20152,
+   5079,
+   318,
+   1913,
+   6881,
+   4096,
+   0,
+   0,
+   20480,
+   8560,
+   1089,
+   6556,
+   19660,
+   737,
+   - 2534,
+   - 15255,
+   19005,
+   4259,
+   58,
+   347,
+   7864,
+   2088,
+   - 995,
+   - 5993,
+   11468,
+   12288,
+   1623,
+   9771,
+   15892,
+   1474,
+   - 1510,
+   - 9090,
+   15728,
+   4628,
+   180,
+   1086,
+   9175,
+   1433,
+   - 1552,
+   - 9341,
+   16056,
+   7004,
+   793,
+   4772,
+   14827,
+   737,
+   - 2534,
+   - 15255,
+   15073,
+   2252,
+   - 884,
+   - 5321,
+   5079,
+   1228,
+   - 1780,
+   - 10714,
+   13271,
+   17326,
+   2131,
+   12827,
+   16547,
+   2334,
+   - 831,
+   - 5002,
+   15073,
+   5816,
+   518,
+   3118,
+   3932,
+   3686,
+   - 156,
+   - 938,
+   14254,
+   8601,
+   1096,
+   6598,
+   16875,
+   778,
+   - 2454,
+   - 14774,
+   15073,
+   3809,
+   - 107,
+   - 646,
+   6062,
+   614,
+   - 2804,
+   - 16879,
+   9338,
+   9256,
+   1204,
+   7251,
+   13271,
+   1761,
+   - 1247,
+   - 7508,
+   13271,
+   3522,
+   - 223,
+   - 1343,
+   2457,
+   1966,
+   - 1084,
+   - 6529,
+   11468,
+   5529,
+   443,
+   2668,
+   10485,
+   737,
+   - 2534,
+   - 15255,
+   11632,
+   3194,
+   - 367,
+   - 2212,
+   1474,
+   778,
+   - 2454,
+   - 14774
+};
+
+static const Word32 inter6[61] =
+{
+   29443,
+   28346,
+   25207,
+   20449,
+   14701,
+   8693,
+   3143,
+   - 1352,
+   - 4402,
+   - 5865,
+   - 5850,
+   - 4673,
+   - 2783,
+   - 672,
+   1211,
+   2536,
+   3130,
+   2991,
+   2259,
+   1170,
+   0,
+   - 1001,
+   - 1652,
+   - 1868,
+   - 1666,
+   - 1147,
+   - 464,
+   218,
+   756,
+   1060,
+   1099,
+   904,
+   550,
+   135,
+   - 245,
+   - 514,
+   - 634,
+   - 602,
+   - 451,
+   - 231,
+   0,
+   191,
+   308,
+   340,
+   296,
+   198,
+   78,
+   - 36,
+   - 120,
+   - 163,
+   - 165,
+   - 132,
+   - 79,
+   - 19,
+   34,
+   73,
+   91,
+   89,
+   70,
+   38,
+   0
+};
+
+/*
+ * window for non-MR122 modesm; uses 40 samples lookahead
+ * used only in BuildCNParam
+ */
+static const Word32 window_200_40[L_WINDOW] = {
+  2621,  2623,  2629,  2638,  2651,  2668,  2689,  2713,  2741,  2772,
+  2808,  2847,  2890,  2936,  2986,  3040,  3097,  3158,  3223,  3291,
+  3363,  3438,  3517,  3599,  3685,  3774,  3867,  3963,  4063,  4166,
+  4272,  4382,  4495,  4611,  4731,  4853,  4979,  5108,  5240,  5376,
+  5514,  5655,  5800,  5947,  6097,  6250,  6406,  6565,  6726,  6890,
+  7057,  7227,  7399,  7573,  7750,  7930,  8112,  8296,  8483,  8672,
+  8863,  9057,  9252,  9450,  9650,  9852, 10055, 10261, 10468, 10677,
+ 10888, 11101, 11315, 11531, 11748, 11967, 12187, 12409, 12632, 12856,
+ 13082, 13308, 13536, 13764, 13994, 14225, 14456, 14688, 14921, 15155,
+ 15389, 15624, 15859, 16095, 16331, 16568, 16805, 17042, 17279, 17516,
+ 17754, 17991, 18228, 18465, 18702, 18939, 19175, 19411, 19647, 19882,
+ 20117, 20350, 20584, 20816, 21048, 21279, 21509, 21738, 21967, 22194,
+ 22420, 22644, 22868, 23090, 23311, 23531, 23749, 23965, 24181, 24394,
+ 24606, 24816, 25024, 25231, 25435, 25638, 25839, 26037, 26234, 26428,
+ 26621, 26811, 26999, 27184, 27368, 27548, 27727, 27903, 28076, 28247,
+ 28415, 28581, 28743, 28903, 29061, 29215, 29367, 29515, 29661, 29804,
+ 29944, 30081, 30214, 30345, 30472, 30597, 30718, 30836, 30950, 31062,
+ 31170, 31274, 31376, 31474, 31568, 31659, 31747, 31831, 31911, 31988,
+ 32062, 32132, 32198, 32261, 32320, 32376, 32428, 32476, 32521, 32561,
+ 32599, 32632, 32662, 32688, 32711, 32729, 32744, 32755, 32763, 32767,
+ 32767, 32741, 32665, 32537, 32359, 32129, 31850, 31521, 31143, 30716,
+ 30242, 29720, 29151, 28538, 27879, 27177, 26433, 25647, 24821, 23957,
+ 23055, 22117, 21145, 20139, 19102, 18036, 16941, 15820, 14674, 13505,
+ 12315, 11106,  9879,  8637,  7381,  6114,  4838,  3554,  2264,   971};
+
+
+
+
+/* comparision optimization tables */
+/* definition of bad speech */
+static const UWord8 table_speech_bad[9] = {0, 0, 1, 1, 0, 0, 0, 1, 0};
+static const UWord8 table_SID[9] =       {0, 0, 0, 0, 1, 1, 1, 0, 0};
+static const UWord8 table_DTX[9] =       {0, 0, 0, 0, 1, 1, 1, 1, 0};
+static const UWord8 table_mute[9] =      {0, 0, 0, 0, 1, 0, 1, 1, 0};
+
+/* track start positions for fixed codebook routines */
+static const Word8 startPos[16] =
+   {
+      0,
+      2,
+      0,
+      3,
+      0,
+      2,
+      0,
+      3,
+      1,
+      3,
+      2,
+      4,
+      1,
+      4,
+      1,
+      4
+   };
+
+
+
+
+
+
+
+#endif
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/amr/rom_enc.h asterisk-1.8.3.2_com_amr/codecs/amr/rom_enc.h
--- asterisk-1.8.3.2_com_rtsp/codecs/amr/rom_enc.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/amr/rom_enc.h	2012-03-26 16:29:06.000000000 +0100
@@ -0,0 +1,14473 @@
+/*
+ * ===================================================================
+ *  TS 26.104
+ *  REL-5 V5.4.0 2004-03
+ *  REL-6 V6.1.0 2004-03
+ *  3GPP AMR Floating-point Speech Codec
+ * ===================================================================
+ *
+ */
+
+/*
+ * rom_enc.h
+ *
+ *
+ * Project:
+ *    AMR Floating-Point Codec
+ *
+ * Contains:
+ *    This file contains all the tables needed by AMR encoder functions.
+ *
+ */
+#ifndef _ROM_ENC_H_
+#define _ROM_ENC_H_
+
+
+#include "typedef.h"
+#include "sp_enc.h"
+
+#define M               10    /* Order of LP filter */
+#define MP1             (M+1) /* Order of LP filter + 1 */
+#define L_WINDOW        240   /* Window size in LP analysis */
+#define L_NEXT          40    /* Overhead in LP analysis */
+#define LTPG_MEM_SIZE   5     /* number of stored past LTP coding gains + 1 */
+#define N_FRAME         7     /* old pitch gains in average calculation */
+#define DTX_HIST_SIZE   8     /* DTX history size */
+#define L_TOTAL         320   /* Total size of speech buffer. */
+#define L_FRAME         160   /* Frame size */
+#define L_FRAME_BY2     80    /* Frame size divided by 2 */
+#define L_SUBFR         40    /* Subframe size */
+#define L_CODE          40    /* codevector length */
+#define PIT_MAX         143   /* Maximum pitch lag */
+#define PIT_MIN         20    /* Minimum pitch lag */
+#define PIT_MIN_MR122   18    /* Minimum pitch lag (MR122 mode) */
+#define L_INTERPOL      (10+1)/* Length of filter for interpolation */
+#define NPRED           4     /* number of prediction taps */
+#define SHARPMIN        0     /* Minimum value of pitch sharpening */
+#define MAX_PRM_SIZE    57    /* max. num. of params */
+#define L_INTER_SRCH    4     /* Length of filter for CL LTP search interpolation */
+#define GP_CLIP         0.95F /* Pitch gain clipping */
+#define UP_SAMP_MAX     6
+#define NB_TRACK        5     /* number of tracks */
+#define NB_TRACK_MR102  4     /* number of tracks mode mr102 */
+#define STEP            5     /* codebook step size */
+#define STEP_MR102      4     /* codebook step size mode mr102 */
+#define NC              M/2   /* Order of LP filter divided by 2 */
+
+#define SCALE_LSP_FREQ  (Float32)(4000.0/3.141592654)
+#define SCALE_FREQ_LSP  (Float32)(3.141592654/4000.0)
+#define SLOPE1_WGHT_LSF (Float32)((3.347-1.8)/(450.0-0.0))
+#define SLOPE2_WGHT_LSF (Float32)((1.8-1.0)/(1500.0-450.0))
+
+#define FRAME_LEN 160    /* Length (samples) of the input frame          */
+#define COMPLEN 9        /* Number of sub-bands used by VAD              */
+#define INV_COMPLEN 3641 /* 1.0/COMPLEN*2^15                             */
+#define LOOKAHEAD 40     /* length of the lookahead used by speech coder */
+
+#define UNITY 512        /* Scaling used with SNR calculation            */
+#define UNIRSHFT 6       /* = log2(MAX_16/UNITY)                         */
+
+#define TONE_THR 0.65F   /* Threshold for tone detection   */
+
+/* Constants for background spectrum update */
+#define ALPHA_UP1   (Float32)(1.0 - 0.95)  /* Normal update, upwards:   */
+#define ALPHA_DOWN1 (Float32)(1.0 - 0.936) /* Normal update, downwards  */
+#define ALPHA_UP2   (Float32)(1.0 - 0.985) /* Forced update, upwards    */
+#define ALPHA_DOWN2 (Float32)(1.0 - 0.943) /* Forced update, downwards  */
+#define ALPHA3      (Float32)(1.0 - 0.95)  /* Update downwards          */
+#define ALPHA4      (Float32)(1.0 - 0.9)   /* For stationary estimation */
+#define ALPHA5      (Float32)(1.0 - 0.5)   /* For stationary estimation */
+
+/* Constants for VAD threshold */
+#define VAD_THR_HIGH 1260 /* Highest threshold                 */
+#define VAD_THR_LOW  720  /* Lowest threshold                  */
+#define VAD_P1 0          /* Noise level for highest threshold */
+#define VAD_P2 6300       /* Noise level for lowest threshold  */
+#define VAD_SLOPE (float)(VAD_THR_LOW-VAD_THR_HIGH)/(float)(VAD_P2-VAD_P1)
+
+/* Parameters for background spectrum recovery function */
+#define STAT_COUNT 20         /* threshold of stationary detection counter         */
+#define STAT_COUNT_BY_2 10    /* threshold of stationary detection counter         */
+#define CAD_MIN_STAT_COUNT 5  /* threshold of stationary detection counter         */
+
+#define STAT_THR_LEVEL 184    /* Threshold level for stationarity detection        */
+#define STAT_THR 1000         /* Threshold for stationarity detection              */
+
+/* Limits for background noise estimate */
+#define NOISE_MIN 40          /* minimum */
+#define NOISE_MAX 16000       /* maximum */
+#define NOISE_INIT 150        /* initial */
+
+/* Constants for VAD hangover addition */
+#define HANG_NOISE_THR 100
+#define BURST_LEN_HIGH_NOISE 4
+#define HANG_LEN_HIGH_NOISE 7
+#define BURST_LEN_LOW_NOISE 5
+#define HANG_LEN_LOW_NOISE 4
+
+/* Thresholds for signal power */
+#define VAD_POW_LOW (Word32)15000/2    /* If input power is lower,                    */
+                                       /*     VAD is set to 0                         */
+#define POW_PITCH_THR (Word32)343040/2 /* If input power is lower, pitch              */
+                                       /*     detection is ignored                    */
+
+#define POW_COMPLEX_THR (Word32)15000/2/* If input power is lower, complex            */
+                                       /* flags  value for previous frame  is un-set  */
+/*
+ * VAD Constants
+ */
+
+/* Constants for the filter bank */
+#define LEVEL_SHIFT 0                     /* scaling                                  */
+#define COEFF3   (Float32)13363/32768     /* coefficient for the 3rd order filter     */
+#define COEFF5_1 (Float32)21955/32768     /* 1st coefficient the for 5th order filter */
+#define COEFF5_2 (Float32)6390/32768      /* 2nd coefficient the for 5th order filter */
+
+/* Constants for pitch detection */
+#define LTHRESH 4
+#define NTHRESH 4
+
+/* Constants for complex signal VAD  */
+#define CVAD_THRESH_ADAPT_HIGH  0.6F            /* threshold for adapt stopping high */
+#define CVAD_THRESH_ADAPT_LOW  0.5F             /* threshold for adapt stopping low */
+#define CVAD_THRESH_IN_NOISE  0.65F * 32768.0F  /* threshold going into speech on
+                                                   a short term basis */
+#define CVAD_THRESH_HANG  0.70F           /* threshold */
+#define CVAD_HANG_LIMIT  (Word16)(100)    /* 2 second estimation time */
+#define CVAD_HANG_LENGTH  (Word16)(250)   /* 5 second hangover */
+
+#define CVAD_LOWPOW_RESET 0.40F  /* init in low power segment */
+#define CVAD_MIN_CORR 0.40F      /* lowest adaptation value */
+
+#define CVAD_BURST 20                        /* speech burst length for speech reset */
+#define CVAD_ADAPT_SLOW 1.0F - 0.98F         /* threshold for slow adaption */
+#define CVAD_ADAPT_FAST 1.0F - 0.92F         /* threshold for fast adaption */
+#define CVAD_ADAPT_REALLY_FAST 1.0F - 0.80F  /* threshold for really fast adaption */
+
+/* track table for algebraic code book search (MR475, MR515) */
+static Word8 trackTable[4 * 5] =
+   {
+      /* subframe 1; track to code; -1 do not code this position */ 0,
+      1,
+      0,
+      1,
+      - 1,
+      /* subframe 2 */ 0,
+      - 1,
+      1,
+      0,
+      1,
+      /* subframe 3 */ 0,
+      1,
+      0,
+      - 1,
+      1,
+      /* subframe 4 */ 0,
+      1,
+      - 1,
+      0,
+      1
+   };
+static const Float32 gamma1[M] =
+{
+   0.9400024414063F,
+   0.8836059570313F,
+   0.8305969238281F,
+   0.78076171875F,
+   0.7339172363281F,
+   0.6898803710938F,
+   0.6484985351563F,
+   0.6095886230469F,
+   0.5730285644531F,
+   0.5386352539063F
+};
+
+/*
+ *  gamma1 for the 12k2 coder
+ */
+static const Float32 gamma1_12k2[M] =
+{
+   0.8999938964844F,
+   0.8099975585938F,
+   0.72900390625F,
+   0.6560974121094F,
+   0.5904846191406F,
+   0.5314331054688F,
+   0.478271484375F,
+   0.4304504394531F,
+   0.3873901367188F,
+   0.3486633300781F
+};
+static const Float32 gamma2[M] =
+{
+   0.6000061035156F,
+   0.3600158691406F,
+   0.2160034179688F,
+   0.1296081542969F,
+   0.0777587890625F,
+   0.04666137695313F,
+   0.02798461914063F,
+   0.01678466796875F,
+   0.01007080078125F,
+   0.00604248046875F
+};
+
+/* 1/6 resolution interpolation filter  (-3 dB at 3600 Hz)
+ * Note: the 1/3 resolution filter is simply a subsampled
+ *       version of the 1/6 resolution filter, i.e. it uses
+ *       every second coefficient:
+ *
+ *       inter_6(1/3)[k] = inter_6(1/3)[2*k], 0 <= k <= 3*L_INTER10
+ */
+static Float32 b60[UP_SAMP_MAX*(L_INTERPOL-1)+1] =
+{
+   0.898529F,
+   0.865051F,
+   0.769257F,
+   0.624054F,
+   0.448639F,
+   0.265289F,
+   0.0959167F,
+   - 0.0412598F,
+   - 0.134338F,
+   - 0.178986F,
+   - 0.178528F,
+   - 0.142609F,
+   - 0.0849304F,
+   - 0.0205078F,
+   0.0369568F,
+   0.0773926F,
+   0.0955200F,
+   0.0912781F,
+   0.0689392F,
+   0.0357056F,
+   0.000000F,
+   - 0.0305481F,
+   - 0.0504150F,
+   - 0.0570068F,
+   - 0.0508423F,
+   - 0.0350037F,
+   - 0.0141602F,
+   0.00665283F,
+   0.0230713F,
+   0.0323486F,
+   0.0335388F,
+   0.0275879F,
+   0.0167847F,
+   0.00411987F,
+   - 0.00747681F,
+   - 0.0156860F,
+   - 0.0193481F,
+   - 0.0183716F,
+   - 0.0137634F,
+   - 0.00704956F,
+   0.000000F,
+   0.00582886F,
+   0.00939941F,
+   0.0103760F,
+   0.00903320F,
+   0.00604248F,
+   0.00238037F,
+   - 0.00109863F,
+   - 0.00366211F,
+   - 0.00497437F,
+   - 0.00503540F,
+   - 0.00402832F,
+   - 0.00241089F,
+   - 0.000579834F,
+   0.00103760F,
+   0.00222778F,
+   0.00277710F,
+   0.00271606F,
+   0.00213623F,
+   0.00115967F,
+   0.000000F
+};
+
+/* same in fixed-point */
+static const Word32 inter6[61] =
+{
+   29443,
+   28346,
+   25207,
+   20449,
+   14701,
+   8693,
+   3143,
+   - 1352,
+   - 4402,
+   - 5865,
+   - 5850,
+   - 4673,
+   - 2783,
+   - 672,
+   1211,
+   2536,
+   3130,
+   2991,
+   2259,
+   1170,
+   0,
+   - 1001,
+   - 1652,
+   - 1868,
+   - 1666,
+   - 1147,
+   - 464,
+   218,
+   756,
+   1060,
+   1099,
+   904,
+   550,
+   135,
+   - 245,
+   - 514,
+   - 634,
+   - 602,
+   - 451,
+   - 231,
+   0,
+   191,
+   308,
+   340,
+   296,
+   198,
+   78,
+   - 36,
+   - 120,
+   - 163,
+   - 165,
+   - 132,
+   - 79,
+   - 19,
+   34,
+   73,
+   91,
+   89,
+   70,
+   38,
+   0
+};
+
+static const Word16 startPos1[2] =
+   {
+      1,
+      3
+   };
+
+static const Word16 startPos2[4] =
+   {
+      0,
+      1,
+      2,
+      4
+   };
+
+static const Word16 startPos[2 * 4 * 2] =
+   {
+      0,
+      2,
+      0,
+      3,
+      0,
+      2,
+      0,
+      3,
+      1,
+      3,
+      2,
+      4,
+      1,
+      4,
+      1,
+      4
+   };
+
+/* Scalar quantization tables of the pitch gain and the codebook gain. */
+#define NB_QUA_PITCH 16
+
+static const Float32 qua_gain_pitch[NB_QUA_PITCH] =
+{
+0.0F,
+0.20001220703125F,
+0.400146484375F,
+0.5F,
+0.5999755859375F,
+0.70001220703125F,
+0.75F,
+0.79998779296875F,
+0.8499755859375F,
+0.9000244140625F,
+0.95001220703125F,
+1.0F,
+1.04998779296875F,
+1.0999755859375F,
+1.1500244140625F,
+1.20001220703125F
+};
+
+static const Float32 qua_gain_pitch_MR122[NB_QUA_PITCH] =
+{
+0.0F,
+0.199951171875F,
+0.400146484375F,
+0.5F,
+0.599853515625F,
+0.699951171875F,
+0.75F,
+0.7998046875F,
+0.849853515625F,
+0.89990234375F,
+0.949951171875F,
+1.0F,
+1.0498046875F,
+1.099853515625F,
+1.14990234375F,
+1.199951171875F
+};
+
+#define NB_QUA_CODE 32
+static const Float32 gain_factor[NB_QUA_CODE] =
+{
+/* gain factor (g_fac) */
+   0.0776367F,
+   0.100586F,
+   0.130859F,
+   0.170410F,
+   0.204590F,
+   0.235352F,
+   0.270508F,
+   0.311035F,
+   0.357910F,
+   0.411133F,
+   0.473145F,
+   0.543945F,
+   0.625488F,
+   0.719238F,
+   0.827148F,
+   0.951172F,
+   1.09424F,
+   1.25830F,
+   1.44678F,
+   1.66406F,
+   1.91357F,
+   2.20068F,
+   2.53076F,
+   2.91016F,
+   3.34717F,
+   3.84912F,
+   4.42627F,
+   5.09033F,
+   6.10840F,
+   7.94092F,
+   10.3232F,
+   13.4204F
+};
+
+
+
+
+
+
+static const Word8 gray[8] =
+   {
+      0,
+      1,
+      3,
+      2,
+      6,
+      4,
+      5,
+      7
+   };
+
+/*
+ * grid[0] = 1.0;
+ * grid[61] = -1.0;
+ * for (i = 1; i < 61; i++)
+ *    grid[i] = (Float32)cos((6.283185307*i)/(2.0*60));
+ */
+static const Float32 grid[61] =
+{
+   1.00000F,
+   0.998630F,
+   0.994522F,
+   0.987688F,
+   0.978148F,
+   0.965926F,
+   0.951057F,
+   0.933580F,
+   0.913545F,
+   0.891007F,
+   0.866025F,
+   0.838671F,
+   0.809017F,
+   0.777146F,
+   0.743145F,
+   0.707107F,
+   0.669131F,
+   0.629320F,
+   0.587785F,
+   0.544639F,
+   0.500000F,
+   0.453990F,
+   0.406737F,
+   0.358368F,
+   0.309017F,
+   0.258819F,
+   0.207912F,
+   0.156434F,
+   0.104528F,
+   0.0523360F,
+   4.48966e-011F,
+   - 0.0523360F,
+   - 0.104528F,
+   - 0.156434F,
+   - 0.207912F,
+   - 0.258819F,
+   - 0.309017F,
+   - 0.358368F,
+   - 0.406737F,
+   - 0.453990F,
+   - 0.500000F,
+   - 0.544639F,
+   - 0.587785F,
+   - 0.629320F,
+   - 0.669131F,
+   - 0.707107F,
+   - 0.743145F,
+   - 0.777146F,
+   - 0.809017F,
+   - 0.838671F,
+   - 0.866025F,
+   - 0.891007F,
+   - 0.913545F,
+   - 0.933580F,
+   - 0.951057F,
+   - 0.965926F,
+   - 0.978148F,
+   - 0.987688F,
+   - 0.994522F,
+   - 0.998630F,
+   - 1.00000F
+};
+
+/*
+ * 1/6 resolution interpolation filter  (-3 dB at 3600 Hz)
+ * Note: The IS641 (7.4) 1/3 resolution filter is simply a subsampled
+ *       version of the 1/6 resolution filter, i.e. it uses
+ *       every second coefficient:
+ *
+ *       b24[k](1/3) = b24[2*k](1/6), 0 <= k <= 3*L_INTER_SRCH
+ */
+static const Float32 b24[UP_SAMP_MAX*L_INTER_SRCH+1] =
+{
+   0.900848F,
+   0.864136F,
+   0.760071F,
+   0.605408F,
+   0.424072F,
+   0.242462F,
+   0.0840759F,
+   - 0.0343933F,
+   - 0.105560F,
+   - 0.131348F,
+   - 0.121124F,
+   - 0.0884705F,
+   - 0.0476379F,
+   - 0.0102539F,
+   0.0162964F,
+   0.0296021F,
+   0.0312195F,
+   0.0251160F,
+   0.0157471F,
+   0.00671387F,
+   0.000000F,
+   - 0.00399780F,
+   - 0.00592041F,
+   - 0.00656128F,
+   0.000000F
+};
+
+/*
+ * Exponential Window coefficients used to weight the autocorrelation
+ * coefficients for 60 Hz bandwidth expansion of high pitched voice
+ * before Levinson-Durbin recursion to compute the LPC coefficients.
+ *
+ * lagwindow[i] =  exp( -0.5*(2*pi*F0*(i+1)/Fs)^2 ); i = 0,...,9
+ * F0 = 60 Hz, Fs = 8000 Hz
+ */
+static Float32 lag_wind[M] =
+{
+   0.99889028F,
+   0.99556851F,
+   0.99005681F,
+   0.98239160F,
+   0.97262347F,
+   0.96081644F,
+   0.94704735F,
+   0.93140495F,
+   0.91398895F,
+   0.89490914F
+};
+
+/* initialization table for lsp history in DTX */
+static const Float32 lsp_init_data[M] =
+   {
+      0.9595F,
+      0.8413F,
+      0.6549F,
+      0.4154F,
+      0.1423F,
+      - 0.1423F,
+      - 0.4154F,
+      - 0.6549F,
+      - 0.8413F,
+      - 0.9595F
+   };
+
+#define PAST_RQ_INIT_SIZE 8
+
+/* initalization table for MA predictor in dtx mode */
+static const Float32 past_rq_init[80] =
+{
+-62.9883F, -77.6367F, -107.178F, -154.785F, -160.156F, -188.721F, -173.584F, -122.559F,
+-65.4297F, -47.1191F, -0.488281F, 30.5176F, 29.7852F, -9.52148F, -2.19727F, 25.6348F,
+31.4941F, 69.0918F, 90.8203F, 140.381F, -67.627F, -79.1016F, -48.0957F, -118.896F,
+-108.643F, -88.3789F, -71.2891F, -6.5918F, 43.2129F, 132.568F, 83.4961F, 126.221F,
+125.977F, 31.7383F, 6.5918F, -25.3906F, -29.2969F, -34.1797F, -18.0664F, -13.6719F,
+-137.695F, -230.225F, -371.094F, -235.596F, -198.73F, -128.418F, -78.6133F, -0.488281F,
+38.8184F, 160.4F, -76.1719F, -69.3359F, -94.2383F, -145.752F, -120.361F, -128.418F,
+-102.051F, -55.9082F, 25.6348F, 109.619F, -135.986F, -212.402F, -262.451F, -224.365F,
+-231.934F, -183.594F, -173.096F, -77.1484F, 15.1367F, 118.652F, -76.6602F, -46.6309F,
+-49.5605F, -80.5664F, -39.0625F, -25.1465F, -12.4512F, 31.9824F, 82.5195F, 125.732F
+};
+
+/* LSF means ->normalize frequency domain */
+
+static const Float32 mean_lsf_3[10] =
+{
+   377.441F,
+	554.688F,
+	922.363F,
+	1339.84F,
+	1702.15F,
+	2046.39F,
+	2452.88F,
+	2741.46F,
+	3116.70F,
+	3348.14F,
+};
+
+static const Float32 mean_lsf_5[10] =
+{
+   337.891F,
+	507.080F,
+	834.961F,
+	1247.07F,
+	1646.00F,
+	1982.91F,
+	2407.96F,
+	2708.01F,
+	3104.00F,
+	3344.97F,
+};
+
+/* LSF prediction factors (not in MR122) */
+static const Float32 pred_fac[10] =
+{
+   0.291626F,
+   0.328644F,
+   0.383636F,
+   0.405640F,
+   0.438873F,
+   0.355560F,
+   0.323120F,
+   0.298065F,
+   0.262238F,
+   0.197876F
+};
+
+/* codebooks from IS641 */
+#define DICO1_SIZE_3  256
+#define DICO2_SIZE_3  512
+#define DICO3_SIZE_3  512
+static const Float32 dico1_lsf_3[] =
+{
+   	1.46484F,
+		20.0195F,
+		-31.9824F,
+		37.5977F,
+		-13.6719F,
+		-179.443F,
+		44.6777F,
+		-15.8691F,
+		-64.6973F,
+		2.19727F,
+		-51.2695F,
+		-88.1348F,
+		27.5879F,
+		175.293F,
+		443.604F,
+		246.582F,
+		296.387F,
+		384.033F,
+		209.229F,
+		325.439F,
+		555.664F,
+		201.904F,
+		382.813F,
+		471.924F,
+		175.049F,
+		485.596F,
+		538.574F,
+		204.590F,
+		286.133F,
+		445.068F,
+		176.025F,
+		244.141F,
+		525.879F,
+		69.8242F,
+		116.211F,
+		368.408F,
+		-60.3027F,
+		-129.639F,
+		56.1523F,
+		35.8887F,
+		-20.0195F,
+		138.916F,
+		6.34766F,
+		-43.2129F,
+		-230.469F,
+		-6.59180F,
+		-66.6504F,
+		168.945F,
+		-40.0391F,
+		-64.4531F,
+		-44.6777F,
+		54.6875F,
+		192.871F,
+		253.662F,
+		219.482F,
+		230.957F,
+		146.729F,
+		118.408F,
+		188.232F,
+		280.762F,
+		127.930F,
+		165.283F,
+		220.459F,
+		-34.1797F,
+		91.5527F,
+		189.941F,
+		100.098F,
+		165.039F,
+		104.736F,
+		73.4863F,
+		129.395F,
+		246.338F,
+		175.537F,
+		157.715F,
+		9.27734F,
+		55.1758F,
+		89.5996F,
+		9.76563F,
+		35.4004F,
+		-10.9863F,
+		-123.291F,
+		70.8008F,
+		29.5410F,
+		-29.5410F,
+		73.7305F,
+		31.0059F,
+		40.5273F,
+		-30.2734F,
+		-93.5059F,
+		-233.398F,
+		-87.4023F,
+		-111.084F,
+		-238.525F,
+		174.561F,
+		214.355F,
+		218.262F,
+		238.770F,
+		225.342F,
+		51.5137F,
+		116.455F,
+		66.4063F,
+		15.6250F,
+		45.8984F,
+		-19.0430F,
+		4.15039F,
+		-34.9121F,
+		-15.8691F,
+		9.27734F,
+		156.982F,
+		143.066F,
+		151.611F,
+		-32.7148F,
+		-104.004F,
+		-158.936F,
+		84.7168F,
+		133.057F,
+		688.477F,
+		290.039F,
+		665.527F,
+		596.191F,
+		34.6680F,
+		-19.5313F,
+		423.584F,
+		69.0918F,
+		31.7383F,
+		112.549F,
+		-63.9648F,
+		-97.4121F,
+		-279.541F,
+		-100.342F,
+		37.8418F,
+		104.980F,
+		80.3223F,
+		91.5527F,
+		190.186F,
+		12.9395F,
+		-55.1758F,
+		-33.9355F,
+		-31.4941F,
+		-57.6172F,
+		410.645F,
+		69.5801F,
+		181.641F,
+		323.975F,
+		180.176F,
+		170.166F,
+		406.250F,
+		76.1719F,
+		99.8535F,
+		64.9414F,
+		79.3457F,
+		175.781F,
+		32.9590F,
+		0.244141F,
+		53.9551F,
+		110.596F,
+		1.95313F,
+		49.5605F,
+		35.4004F,
+		72.9980F,
+		156.250F,
+		185.547F,
+		7.08008F,
+		114.258F,
+		155.762F,
+		25.1465F,
+		104.736F,
+		92.5293F,
+		102.539F,
+		232.910F,
+		227.539F,
+		323.730F,
+		295.410F,
+		307.129F,
+		171.875F,
+		247.070F,
+		281.250F,
+		-40.5273F,
+		-108.398F,
+		-64.9414F,
+		-77.1484F,
+		-31.7383F,
+		-91.7969F,
+		46.6309F,
+		281.006F,
+		464.844F,
+		-58.5938F,
+		-132.568F,
+		-307.617F,
+		-27.3438F,
+		65.4297F,
+		294.678F,
+		17.0898F,
+		259.277F,
+		386.475F,
+		67.8711F,
+		332.031F,
+		384.277F,
+		-62.9883F,
+		-66.4063F,
+		-187.500F,
+		4.63867F,
+		137.451F,
+		546.875F,
+		-0.732422F,
+		-64.6973F,
+		32.9590F,
+		-72.0215F,
+		-144.287F,
+		-94.7266F,
+		34.1797F,
+		86.4258F,
+		-50.2930F,
+		-63.4766F,
+		-123.047F,
+		-194.092F,
+		-105.713F,
+		-175.293F,
+		-322.021F,
+		26.6113F,
+		80.8105F,
+		234.863F,
+		-104.736F,
+		-21.2402F,
+		159.180F,
+		-72.2656F,
+		104.004F,
+		248.779F,
+		-58.3496F,
+		189.209F,
+		207.764F,
+		119.385F,
+		325.684F,
+		261.963F,
+		-81.5430F,
+		-81.0547F,
+		6.10352F,
+		132.568F,
+		294.434F,
+		441.162F,
+		79.5898F,
+		14.8926F,
+		177.490F,
+		141.113F,
+		207.275F,
+		343.018F,
+		-50.7813F,
+		-67.6270F,
+		80.3223F,
+		-37.1094F,
+		15.6250F,
+		163.330F,
+		-105.957F,
+		-165.527F,
+		-177.490F,
+		-110.840F,
+		-17.3340F,
+		61.2793F,
+		147.705F,
+		117.188F,
+		62.0117F,
+		-117.676F,
+		2.68555F,
+		243.164F,
+		-70.5566F,
+		96.4355F,
+		118.652F,
+		176.270F,
+		256.104F,
+		351.563F,
+		-7.32422F,
+		-77.1484F,
+		-191.895F,
+		-25.8789F,
+		-28.0762F,
+		-151.123F,
+		210.205F,
+		359.863F,
+		344.727F,
+		257.568F,
+		333.496F,
+		289.063F,
+		198.242F,
+		302.002F,
+		225.830F,
+		10.2539F,
+		-61.2793F,
+		-140.625F,
+		83.4961F,
+		34.4238F,
+		-110.840F,
+		-41.0156F,
+		-19.5313F,
+		331.787F,
+		-83.4961F,
+		-160.156F,
+		-430.420F,
+		24.4141F,
+		200.439F,
+		177.002F,
+		241.699F,
+		182.373F,
+		195.313F,
+		81.0547F,
+		107.422F,
+		138.672F,
+		161.865F,
+		92.5293F,
+		208.008F,
+		27.3438F,
+		40.2832F,
+		-90.0879F,
+		145.752F,
+		222.168F,
+		68.8477F,
+		-1.95313F,
+		203.613F,
+		312.744F,
+		-85.9375F,
+		139.648F,
+		169.678F,
+		112.793F,
+		548.340F,
+		440.918F,
+		84.2285F,
+		46.3867F,
+		335.449F,
+		101.563F,
+		223.389F,
+		528.809F,
+		41.0156F,
+		-20.0195F,
+		68.3594F,
+		-125.977F,
+		-108.887F,
+		205.078F,
+		11.4746F,
+		130.127F,
+		10.7422F,
+		-88.3789F,
+		-173.584F,
+		-279.053F,
+		5.37109F,
+		47.1191F,
+		359.375F,
+		-20.7520F,
+		56.8848F,
+		442.627F,
+		-15.1367F,
+		141.357F,
+		367.188F,
+		134.277F,
+		230.469F,
+		427.002F,
+		176.514F,
+		158.691F,
+		280.273F,
+		237.305F,
+		215.820F,
+		340.576F,
+		-103.760F,
+		156.982F,
+		0.000000F,
+		244.141F,
+		232.422F,
+		268.066F,
+		60.7910F,
+		353.027F,
+		164.063F,
+		-81.5430F,
+		-21.2402F,
+		530.273F,
+		-135.254F,
+		459.473F,
+		652.344F,
+		34.1797F,
+		445.801F,
+		452.393F,
+		224.609F,
+		427.002F,
+		632.324F,
+		262.695F,
+		471.924F,
+		497.559F,
+		-33.4473F,
+		-108.154F,
+		-379.639F,
+		309.814F,
+		286.621F,
+		114.258F,
+		-120.361F,
+		-29.7852F,
+		371.338F,
+		-110.107F,
+		252.197F,
+		296.387F,
+		117.676F,
+		413.818F,
+		272.949F,
+		198.975F,
+		158.447F,
+		93.7500F,
+		-108.887F,
+		-168.945F,
+		26.1230F,
+		-77.8809F,
+		-147.705F,
+		-28.8086F,
+		-50.5371F,
+		-123.291F,
+		128.174F,
+		-114.258F,
+		-2.92969F,
+		667.969F,
+		18.3105F,
+		472.168F,
+		318.604F,
+		214.844F,
+		575.684F,
+		553.467F,
+		313.721F,
+		384.521F,
+		489.258F,
+		-11.7188F,
+		-74.2188F,
+		-289.551F,
+		-106.201F,
+		-112.549F,
+		-61.2793F,
+		-89.3555F,
+		-98.6328F,
+		-133.545F,
+		-70.5566F,
+		-147.705F,
+		-145.752F,
+		-131.348F,
+		-197.754F,
+		-40.2832F,
+		-29.2969F,
+		0.732422F,
+		86.9141F,
+		156.006F,
+		302.979F,
+		366.699F,
+		23.4375F,
+		43.2129F,
+		183.105F,
+		-106.201F,
+		-142.822F,
+		-286.621F,
+		-86.9141F,
+		26.6113F,
+		-19.2871F,
+		-118.408F,
+		70.3125F,
+		489.502F,
+		2.19727F,
+		272.461F,
+		178.467F,
+		214.844F,
+		520.996F,
+		230.957F,
+		-64.6973F,
+		386.963F,
+		260.010F,
+		282.471F,
+		295.410F,
+		205.811F,
+		-121.582F,
+		-163.086F,
+		105.225F,
+		91.3086F,
+		78.3691F,
+		-55.9082F,
+		351.563F,
+		512.939F,
+		337.158F,
+		109.619F,
+		112.549F,
+		281.982F,
+		-25.6348F,
+		9.52148F,
+		-93.7500F,
+		-64.2090F,
+		89.5996F,
+		44.4336F,
+		-90.5762F,
+		-161.133F,
+		188.721F,
+		-45.8984F,
+		281.006F,
+		237.061F,
+		325.439F,
+		398.438F,
+		350.342F,
+		188.965F,
+		309.326F,
+		298.096F,
+		-117.676F,
+		-203.125F,
+		-363.525F,
+		-57.8613F,
+		-51.2695F,
+		209.961F,
+		217.285F,
+		394.287F,
+		259.766F,
+		115.234F,
+		259.277F,
+		291.016F,
+		45.1660F,
+		262.939F,
+		241.455F,
+		-138.672F,
+		-242.188F,
+		-416.016F,
+		-109.619F,
+		-220.215F,
+		-498.779F,
+		-34.6680F,
+		-92.0410F,
+		-111.816F,
+		-51.2695F,
+		-135.254F,
+		-251.221F,
+		-2.68555F,
+		276.611F,
+		552.979F,
+		-80.3223F,
+		-164.795F,
+		-218.018F,
+		-61.0352F,
+		160.400F,
+		289.795F,
+		126.709F,
+		368.652F,
+		434.326F,
+		126.953F,
+		131.592F,
+		342.529F,
+		128.662F,
+		346.924F,
+		317.871F,
+		-137.451F,
+		-212.646F,
+		-304.688F,
+		-35.8887F,
+		-113.037F,
+		214.600F,
+		-18.5547F,
+		569.824F,
+		693.359F,
+		137.451F,
+		628.174F,
+		582.275F,
+		154.297F,
+		470.215F,
+		712.891F,
+		175.537F,
+		493.896F,
+		449.219F,
+		-133.057F,
+		-176.514F,
+		270.508F,
+		31.4941F,
+		-30.5176F,
+		215.820F,
+		345.947F,
+		398.438F,
+		225.830F,
+		-22.9492F,
+		382.324F,
+		427.490F,
+		-83.2520F,
+		374.268F,
+		378.662F,
+		144.287F,
+		96.4355F,
+		-66.8945F,
+		-18.5547F,
+		239.502F,
+		691.162F,
+		37.3535F,
+		728.760F,
+		450.195F,
+		251.953F,
+		626.221F,
+		671.143F,
+		368.164F,
+		691.406F,
+		458.740F,
+		193.115F,
+		292.725F,
+		131.348F,
+		-46.3867F,
+		-110.596F,
+		363.525F,
+		-67.8711F,
+		-133.789F,
+		282.715F,
+		-59.8145F,
+		473.877F,
+		499.023F,
+		250.000F,
+		380.859F,
+		402.832F,
+		125.000F,
+		61.7676F,
+		113.770F,
+		-15.1367F,
+		-78.8574F,
+		281.006F,
+		-115.479F,
+		-91.7969F,
+		123.779F,
+		-105.713F,
+		336.914F,
+		527.832F,
+		219.482F,
+		474.365F,
+		352.783F,
+		32.7148F,
+		171.875F,
+		107.422F,
+		112.305F,
+		128.174F,
+		-6.83594F,
+		-109.863F,
+		68.1152F,
+		326.660F,
+		0.000000F,
+		237.061F,
+		61.5234F,
+		-108.643F,
+		-153.076F,
+		-241.943F,
+		-84.9609F,
+		-146.973F,
+		-347.656F,
+		97.1680F,
+		173.828F,
+		404.297F,
+		-26.1230F,
+		76.6602F,
+		-43.4570F,
+		22.7051F,
+		543.457F,
+		546.387F,
+		126.465F,
+		207.275F,
+		160.156F,
+		-112.793F,
+		-173.584F,
+		-109.131F,
+		42.4805F,
+		-8.30078F,
+		290.771F,
+		-29.0527F,
+		10.2539F,
+		245.361F,
+		-90.8203F,
+		66.8945F,
+		185.059F,
+		252.930F,
+		574.219F,
+		448.730F,
+		164.795F,
+		420.898F,
+		365.723F,
+		104.980F,
+		313.965F,
+		520.752F,
+		-31.4941F,
+		-107.178F,
+		0.000000F,
+		-91.0645F,
+		195.313F,
+		523.438F,
+		1.46484F,
+		387.451F,
+		604.980F,
+		116.699F,
+		145.508F,
+		519.531F,
+		-104.492F,
+		-179.688F,
+		367.432F,
+		93.9941F,
+		43.4570F,
+		239.258F,
+		33.9355F,
+		109.619F,
+		299.072F,
+		-128.418F,
+		-205.566F,
+		-239.746F,
+		35.4004F,
+		379.395F,
+		303.223F,
+		152.100F,
+		353.516F,
+		160.156F,
+		85.2051F,
+		248.047F,
+		361.816F,
+		7.56836F,
+		-68.3594F,
+		101.318F,
+		-77.1484F,
+		176.758F,
+		400.635F,
+		87.8906F,
+		258.301F,
+		135.742F,
+		-106.445F,
+		-87.4023F,
+		293.213F,
+		-86.6699F,
+		274.170F,
+		473.389F,
+		97.9004F,
+		386.719F,
+		548.828F,
+		-128.662F,
+		-247.070F,
+		86.6699F,
+		56.8848F,
+		58.1055F,
+		545.166F,
+		-134.277F,
+		-218.994F,
+		-156.006F,
+		-89.1113F,
+		-122.314F,
+		477.783F,
+		94.9707F,
+		454.102F,
+		395.752F,
+		39.5508F,
+		276.367F,
+		308.594F,
+		-57.8613F,
+		286.621F,
+		339.355F,
+		-156.250F,
+		-100.342F,
+		28.3203F,
+		-55.6641F,
+		413.574F,
+		561.035F,
+		400.146F,
+		533.691F,
+		553.467F,
+		137.207F,
+		310.791F,
+		648.926F,
+		78.8574F,
+		82.5195F,
+		433.105F,
+		141.113F,
+		270.264F,
+		208.008F,
+		5.37109F,
+		145.020F,
+		228.027F,
+		-34.9121F,
+		175.293F,
+		108.887F
+
+};
+static const Float32 dico2_lsf_3[] =
+{
+   12.2070F,
+   17.3340F,
+   -2.19727F,
+   -82.5195F,
+   -170.410F,
+   -343.506F,
+   24.9023F,
+   -33.6914F,
+   -200.195F,
+   -75.6836F,
+   -114.502F,
+   -280.029F,
+   101.074F,
+   16.3574F,
+   -65.1855F,
+   258.789F,
+   198.730F,
+   351.807F,
+   377.930F,
+   332.031F,
+   310.547F,
+   428.223F,
+   462.646F,
+   405.518F,
+   492.920F,
+   520.752F,
+   444.336F,
+   441.406F,
+   565.918F,
+   450.439F,
+   157.227F,
+   -22.7051F,
+   110.840F,
+   209.473F,
+   80.3223F,
+   -33.2031F,
+   119.385F,
+   -62.9883F,
+   -31.2500F,
+   -48.3398F,
+   -181.885F,
+   -10.0098F,
+   -12.6953F,
+   -64.6973F,
+   -240.479F,
+   84.4727F,
+   33.4473F,
+   116.943F,
+   -425.049F,
+   -182.617F,
+   -166.992F,
+   -283.936F,
+   -421.143F,
+   -89.5996F,
+   -218.506F,
+   -279.541F,
+   -191.406F,
+   -119.141F,
+   -230.957F,
+   -236.328F,
+   -20.7520F,
+   -95.2148F,
+   -177.002F,
+   52.4902F,
+   -83.0078F,
+   -41.7480F,
+   249.023F,
+   223.633F,
+   480.713F,
+   137.695F,
+   43.7012F,
+   182.129F,
+   161.621F,
+   238.525F,
+   423.340F,
+   216.553F,
+   151.855F,
+   223.145F,
+   229.248F,
+   208.984F,
+   284.424F,
+   75.4395F,
+   167.969F,
+   196.045F,
+   223.877F,
+   39.3066F,
+   139.160F,
+   28.8086F,
+   -4.88281F,
+   -69.0918F,
+   -199.219F,
+   -10.2539F,
+   49.8047F,
+   -299.805F,
+   -79.3457F,
+   -112.793F,
+   -235.107F,
+   -49.3164F,
+   -34.9121F,
+   -241.211F,
+   -118.164F,
+   -88.1348F,
+   -171.387F,
+   -238.770F,
+   -116.455F,
+   -73.7305F,
+   -192.871F,
+   -290.039F,
+   -24.4141F,
+   -191.895F,
+   -265.625F,
+   -257.324F,
+   -231.201F,
+   -411.133F,
+   -49.3164F,
+   -205.811F,
+   -190.918F,
+   -253.662F,
+   -336.426F,
+   -219.971F,
+   -152.344F,
+   -26.8555F,
+   -20.7520F,
+   86.9141F,
+   52.0020F,
+   -2.44141F,
+   -120.361F,
+   88.8672F,
+   188.965F,
+   103.760F,
+   200.684F,
+   116.943F,
+   -20.2637F,
+   135.986F,
+   126.953F,
+   -242.188F,
+   -380.859F,
+   -139.648F,
+   -147.217F,
+   -180.908F,
+   -6.34766F,
+   -122.559F,
+   -155.762F,
+   -220.459F,
+   51.0254F,
+   74.7070F,
+   35.8887F,
+   -77.1484F,
+   -144.775F,
+   -145.508F,
+   -20.7520F,
+   -51.5137F,
+   -54.9316F,
+   -224.121F,
+   -129.150F,
+   28.5645F,
+   56.8848F,
+   -107.178F,
+   -180.176F,
+   268.799F,
+   183.350F,
+   154.541F,
+   355.713F,
+   418.945F,
+   368.896F,
+   430.908F,
+   355.713F,
+   222.168F,
+   273.926F,
+   282.227F,
+   207.275F,
+   330.566F,
+   211.914F,
+   114.746F,
+   -212.646F,
+   -280.762F,
+   -438.477F,
+   -212.646F,
+   -210.205F,
+   -242.188F,
+   -28.8086F,
+   37.8418F,
+   51.7578F,
+   -256.592F,
+   -207.275F,
+   -147.949F,
+   -272.705F,
+   -451.416F,
+   -671.387F,
+   -248.779F,
+   -348.389F,
+   -456.299F,
+   90.3320F,
+   -44.9219F,
+   -101.074F,
+   234.131F,
+   120.361F,
+   25.3906F,
+   233.887F,
+   253.662F,
+   132.568F,
+   37.5977F,
+   159.424F,
+   49.0723F,
+   304.932F,
+   123.779F,
+   36.6211F,
+   161.865F,
+   122.803F,
+   56.1523F,
+   152.100F,
+   189.697F,
+   164.795F,
+   160.889F,
+   21.4844F,
+   -26.8555F,
+   205.811F,
+   59.5703F,
+   54.6875F,
+   93.2617F,
+   132.080F,
+   73.7305F,
+   176.758F,
+   105.713F,
+   162.598F,
+   284.668F,
+   179.199F,
+   83.2520F,
+   -33.6914F,
+   4.88281F,
+   -96.9238F,
+   -288.818F,
+   -103.516F,
+   -11.2305F,
+   -78.3691F,
+   -85.9375F,
+   -30.2734F,
+   325.439F,
+   249.268F,
+   263.672F,
+   63.9648F,
+   89.3555F,
+   176.514F,
+   225.098F,
+   69.0918F,
+   -134.521F,
+   7.56836F,
+   -155.273F,
+   -149.170F,
+   -168.213F,
+   -170.166F,
+   -101.318F,
+   -232.422F,
+   -190.186F,
+   -49.0723F,
+   -324.463F,
+   -145.996F,
+   -87.6465F,
+   -232.666F,
+   -313.721F,
+   40.5273F,
+   120.361F,
+   74.4629F,
+   53.9551F,
+   206.543F,
+   171.631F,
+   148.926F,
+   205.078F,
+   228.516F,
+   188.965F,
+   -176.514F,
+   -323.242F,
+   -307.861F,
+   -87.1582F,
+   -250.244F,
+   -338.867F,
+   -267.578F,
+   -335.938F,
+   -89.1113F,
+   -345.703F,
+   -459.229F,
+   -148.438F,
+   -438.965F,
+   -421.631F,
+   -164.551F,
+   -133.057F,
+   -286.377F,
+   -171.631F,
+   165.527F,
+   191.895F,
+   36.1328F,
+   -30.0293F,
+   169.922F,
+   314.453F,
+   157.227F,
+   85.4492F,
+   -2.44141F,
+   101.074F,
+   149.902F,
+   3.66211F,
+   33.4473F,
+   83.9844F,
+   -51.5137F,
+   -198.730F,
+   -369.141F,
+   -199.951F,
+   -95.4590F,
+   -227.051F,
+   -143.555F,
+   11.4746F,
+   -144.287F,
+   -219.238F,
+   -221.924F,
+   -267.822F,
+   -39.7949F,
+   -310.547F,
+   -284.912F,
+   -38.3301F,
+   -357.422F,
+   -372.314F,
+   -94.9707F,
+   -311.035F,
+   -290.039F,
+   -152.344F,
+   163.818F,
+   52.0020F,
+   110.840F,
+   30.2734F,
+   -66.8945F,
+   -128.174F,
+   -177.979F,
+   -121.094F,
+   -37.1094F,
+   -328.125F,
+   29.7852F,
+   32.9590F,
+   -709.229F,
+   -143.799F,
+   -96.1914F,
+   -421.875F,
+   107.666F,
+   -12.2070F,
+   360.352F,
+   220.703F,
+   192.139F,
+   77.1484F,
+   57.6172F,
+   -107.422F,
+   -84.7168F,
+   52.9785F,
+   100.830F,
+   -222.412F,
+   -223.877F,
+   29.5410F,
+   -111.084F,
+   -227.539F,
+   49.3164F,
+   -22.4609F,
+   -113.525F,
+   -91.5527F,
+   119.141F,
+   95.2148F,
+   115.723F,
+   213.867F,
+   177.979F,
+   77.1484F,
+   -443.115F,
+   -320.313F,
+   -163.330F,
+   21.2402F,
+   234.863F,
+   105.469F,
+   137.451F,
+   -60.7910F,
+   -258.301F,
+   61.0352F,
+   69.5801F,
+   269.775F,
+   278.564F,
+   104.248F,
+   169.922F,
+   -253.418F,
+   -406.250F,
+   -386.230F,
+   -231.445F,
+   84.4727F,
+   39.0625F,
+   -75.4395F,
+   -66.4063F,
+   -209.473F,
+   163.574F,
+   152.344F,
+   305.176F,
+   -230.469F,
+   -99.6094F,
+   -162.598F,
+   -147.949F,
+   -78.1250F,
+   -93.7500F,
+   -120.117F,
+   56.1523F,
+   15.8691F,
+   81.5430F,
+   -12.2070F,
+   -3.90625F,
+   -3.90625F,
+   -168.457F,
+   -341.064F,
+   437.256F,
+   418.945F,
+   341.553F,
+   604.980F,
+   503.662F,
+   342.773F,
+   303.955F,
+   359.131F,
+   348.145F,
+   -93.2617F,
+   -253.174F,
+   -0.488281F,
+   42.2363F,
+   -97.1680F,
+   279.541F,
+   364.014F,
+   494.141F,
+   439.697F,
+   188.477F,
+   311.035F,
+   367.676F,
+   348.877F,
+   423.584F,
+   488.525F,
+   263.428F,
+   297.363F,
+   310.791F,
+   -281.738F,
+   -451.904F,
+   -324.463F,
+   -197.266F,
+   -276.611F,
+   -267.578F,
+   -110.107F,
+   -252.197F,
+   -420.410F,
+   15.8691F,
+   141.113F,
+   -20.5078F,
+   -360.352F,
+   -594.238F,
+   -434.082F,
+   -186.768F,
+   -333.496F,
+   -120.605F,
+   -53.2227F,
+   -145.020F,
+   -227.295F,
+   82.2754F,
+   -57.6172F,
+   137.207F,
+   575.439F,
+   649.902F,
+   473.145F,
+   363.525F,
+   311.523F,
+   213.379F,
+   46.1426F,
+   87.4023F,
+   91.3086F,
+   -370.850F,
+   -556.885F,
+   -572.754F,
+   -236.084F,
+   -310.303F,
+   -511.475F,
+   -153.320F,
+   -290.039F,
+   -376.465F,
+   405.518F,
+   254.639F,
+   133.301F,
+   137.939F,
+   259.033F,
+   178.711F,
+   -15.6250F,
+   -204.102F,
+   -105.957F,
+   -106.445F,
+   -23.4375F,
+   49.5605F,
+   263.184F,
+   296.875F,
+   399.414F,
+   221.436F,
+   374.512F,
+   240.723F,
+   79.5898F,
+   235.596F,
+   206.299F,
+   34.6680F,
+   -20.5078F,
+   48.0957F,
+   114.746F,
+   580.811F,
+   383.301F,
+   276.611F,
+   114.746F,
+   296.387F,
+   96.4355F,
+   335.938F,
+   292.969F,
+   274.658F,
+   254.395F,
+   84.9609F,
+   -132.568F,
+   -301.270F,
+   -91.7969F,
+   -52.4902F,
+   -44.1895F,
+   117.432F,
+   -475.342F,
+   -395.752F,
+   -51.2695F,
+   -183.105F,
+   -289.307F,
+   95.2148F,
+   7.08008F,
+   -97.4121F,
+   6.59180F,
+   200.195F,
+   301.758F,
+   184.326F,
+   169.678F,
+   239.014F,
+   99.8535F,
+   -42.4805F,
+   292.236F,
+   252.686F,
+   222.656F,
+   331.055F,
+   450.684F,
+   -242.188F,
+   -350.830F,
+   118.164F,
+   -362.549F,
+   -415.039F,
+   50.7813F,
+   -100.586F,
+   293.945F,
+   349.609F,
+   -66.1621F,
+   218.750F,
+   279.297F,
+   -101.563F,
+   433.838F,
+   350.098F,
+   -414.063F,
+   -645.508F,
+   -49.8047F,
+   -436.768F,
+   -378.662F,
+   252.197F,
+   -404.297F,
+   -380.615F,
+   318.115F,
+   -305.908F,
+   -387.939F,
+   263.916F,
+   -163.330F,
+   -267.334F,
+   -16.1133F,
+   -166.504F,
+   78.1250F,
+   -84.2285F,
+   160.889F,
+   74.4629F,
+   260.986F,
+   -315.430F,
+   -196.289F,
+   -4.63867F,
+   -399.170F,
+   -315.186F,
+   7.08008F,
+   -410.889F,
+   -121.338F,
+   17.3340F,
+   -70.0684F,
+   -1.70898F,
+   -24.4141F,
+   -120.605F,
+   -234.863F,
+   -57.8613F,
+   208.008F,
+   459.229F,
+   424.805F,
+   -297.119F,
+   -338.623F,
+   55.4199F,
+   -161.133F,
+   73.7305F,
+   91.0645F,
+   23.4375F,
+   265.381F,
+   306.885F,
+   -262.207F,
+   -407.471F,
+   39.0625F,
+   118.408F,
+   506.836F,
+   438.965F,
+   -228.027F,
+   -53.7109F,
+   134.766F,
+   -145.508F,
+   -149.414F,
+   57.8613F,
+   82.0313F,
+   419.922F,
+   214.600F,
+   156.982F,
+   153.564F,
+   105.957F,
+   309.326F,
+   127.441F,
+   398.682F,
+   3.66211F,
+   59.5703F,
+   -107.666F,
+   360.107F,
+   175.049F,
+   44.9219F,
+   444.092F,
+   388.184F,
+   417.236F,
+   241.211F,
+   63.7207F,
+   228.760F,
+   510.986F,
+   572.510F,
+   371.094F,
+   522.217F,
+   453.613F,
+   392.090F,
+   -140.869F,
+   -141.357F,
+   -293.701F,
+   -233.398F,
+   32.9590F,
+   -119.141F,
+   -113.281F,
+   12.4512F,
+   -82.5195F,
+   -153.564F,
+   -84.9609F,
+   -176.514F,
+   279.785F,
+   506.104F,
+   352.051F,
+   535.156F,
+   357.910F,
+   222.412F,
+   -352.539F,
+   -383.789F,
+   -556.152F,
+   341.797F,
+   173.340F,
+   316.650F,
+   325.928F,
+   154.541F,
+   226.563F,
+   350.098F,
+   535.645F,
+   633.301F,
+   591.309F,
+   538.086F,
+   459.229F,
+   239.746F,
+   547.363F,
+   452.637F,
+   92.7734F,
+   193.359F,
+   279.541F,
+   -15.3809F,
+   -131.592F,
+   101.074F,
+   -61.5234F,
+   -235.352F,
+   -76.6602F,
+   -307.861F,
+   -166.748F,
+   -190.430F,
+   -202.881F,
+   -128.418F,
+   -245.361F,
+   -406.738F,
+   -277.100F,
+   -103.516F,
+   -393.311F,
+   -110.352F,
+   -72.9980F,
+   309.570F,
+   255.859F,
+   156.738F,
+   280.029F,
+   208.252F,
+   208.984F,
+   -164.795F,
+   -82.0313F,
+   33.9355F,
+   553.711F,
+   327.881F,
+   346.191F,
+   7.08008F,
+   187.500F,
+   194.580F,
+   -298.828F,
+   103.271F,
+   137.695F,
+   -321.777F,
+   -264.160F,
+   59.8145F,
+   -317.871F,
+   -198.242F,
+   139.893F,
+   -316.895F,
+   -394.775F,
+   157.715F,
+   -236.328F,
+   203.613F,
+   176.514F,
+   242.432F,
+   403.320F,
+   494.873F,
+   -46.6309F,
+   -199.463F,
+   105.469F,
+   161.621F,
+   14.6484F,
+   48.3398F,
+   152.832F,
+   243.408F,
+   324.707F,
+   402.344F,
+   479.248F,
+   314.697F,
+   -389.893F,
+   -22.7051F,
+   -10.9863F,
+   -265.625F,
+   9.03320F,
+   -20.5078F,
+   403.564F,
+   636.475F,
+   570.557F,
+   260.010F,
+   498.047F,
+   580.322F,
+   278.076F,
+   567.871F,
+   517.090F,
+   209.717F,
+   87.1582F,
+   368.652F,
+   162.109F,
+   299.561F,
+   268.311F,
+   116.943F,
+   332.031F,
+   222.656F,
+   463.135F,
+   428.223F,
+   492.920F,
+   285.156F,
+   466.064F,
+   435.547F,
+   97.4121F,
+   8.30078F,
+   62.5000F,
+   -144.775F,
+   -74.2188F,
+   -257.080F,
+   133.545F,
+   413.574F,
+   343.506F,
+   157.959F,
+   -24.1699F,
+   -83.2520F,
+   364.258F,
+   402.100F,
+   290.527F,
+   9.27734F,
+   -157.227F,
+   -51.7578F,
+   96.4355F,
+   206.543F,
+   54.1992F,
+   -171.875F,
+   -186.768F,
+   -174.805F,
+   -176.758F,
+   -479.492F,
+   -684.570F,
+   -36.6211F,
+   71.0449F,
+   -20.0195F,
+   301.025F,
+   356.201F,
+   245.850F,
+   -34.1797F,
+   -37.8418F,
+   37.3535F,
+   107.178F,
+   72.5098F,
+   382.813F,
+   -373.291F,
+   -100.098F,
+   -155.273F,
+   375.000F,
+   111.084F,
+   -57.8613F,
+   -324.219F,
+   -33.9355F,
+   -63.4766F,
+   129.639F,
+   135.254F,
+   211.914F,
+   65.6738F,
+   308.594F,
+   147.949F,
+   -56.8848F,
+   215.576F,
+   113.037F,
+   181.152F,
+   146.484F,
+   -29.2969F,
+   -17.8223F,
+   102.783F,
+   51.7578F,
+   -107.178F,
+   -14.1602F,
+   196.289F,
+   -313.965F,
+   -302.979F,
+   177.734F,
+   71.7773F,
+   -119.629F,
+   12.2070F,
+   -144.287F,
+   -220.947F,
+   -306.152F,
+   10.2539F,
+   -167.725F,
+   35.8887F,
+   -6.10352F,
+   66.6504F,
+   145.508F,
+   -75.9277F,
+   296.143F,
+   146.729F,
+   -184.082F,
+   207.275F,
+   142.578F,
+   104.736F,
+   148.193F,
+   143.311F,
+   -146.973F,
+   -40.5273F,
+   112.549F,
+   -194.336F,
+   -200.928F,
+   189.697F,
+   336.914F,
+   222.168F,
+   428.467F,
+   29.0527F,
+   345.947F,
+   237.305F,
+   -53.4668F,
+   -214.844F,
+   -389.648F,
+   -256.104F,
+   -246.582F,
+   106.934F,
+   -174.072F,
+   -336.670F,
+   19.0430F,
+   0.000000F,
+   -109.131F,
+   -287.842F,
+   -277.344F,
+   -322.021F,
+   -384.033F,
+   548.828F,
+   431.396F,
+   319.580F,
+   230.957F,
+   386.475F,
+   349.609F,
+   280.762F,
+   117.676F,
+   106.445F,
+   -114.502F,
+   -270.508F,
+   150.879F,
+   -109.131F,
+   -235.840F,
+   265.625F,
+   -305.664F,
+   -369.873F,
+   -27.8320F,
+   -269.531F,
+   -490.234F,
+   -141.357F,
+   51.2695F,
+   149.658F,
+   121.338F,
+   -482.178F,
+   -350.830F,
+   156.738F,
+   -309.814F,
+   -208.984F,
+   246.826F,
+   -401.855F,
+   -289.307F,
+   259.521F,
+   -379.639F,
+   -164.063F,
+   293.945F,
+   -413.086F,
+   -271.973F,
+   152.100F,
+   -239.014F,
+   -323.730F,
+   -311.768F,
+   131.592F,
+   -35.8887F,
+   218.262F,
+   -330.566F,
+   -218.994F,
+   -105.957F,
+   216.797F,
+   115.967F,
+   104.492F,
+   37.3535F,
+   -93.7500F,
+   82.5195F,
+   -364.258F,
+   -124.756F,
+   87.6465F,
+   -237.793F,
+   -272.217F,
+   -114.746F,
+   25.6348F,
+   -134.277F,
+   165.283F,
+   -228.760F,
+   -279.541F,
+   214.111F,
+   92.7734F,
+   -63.4766F,
+   51.2695F,
+   411.377F,
+   225.586F,
+   306.641F,
+   433.350F,
+   290.527F,
+   267.334F,
+   346.436F,
+   154.053F,
+   130.127F,
+   153.076F,
+   72.9980F,
+   -84.7168F,
+   -100.342F,
+   -130.371F,
+   157.959F,
+   -158.691F,
+   7.08008F,
+   -145.264F,
+   -92.2852F,
+   -333.740F,
+   381.592F,
+   342.285F,
+   273.682F,
+   357.666F,
+   265.869F,
+   344.238F,
+   158.203F,
+   -511.719F,
+   -266.113F,
+   -1.46484F,
+   75.9277F,
+   -47.3633F,
+   -212.158F,
+   -156.006F,
+   -202.881F,
+   101.563F,
+   -283.691F,
+   -298.828F,
+   329.346F,
+   -304.443F,
+   -229.736F,
+   442.627F,
+   -535.400F,
+   -485.107F,
+   110.596F,
+   -151.123F,
+   -333.740F,
+   -233.398F,
+   -392.090F,
+   -481.445F,
+   -367.920F,
+   -286.865F,
+   -258.057F,
+   -269.531F,
+   -92.0410F,
+   146.729F,
+   49.0723F,
+   458.008F,
+   201.416F,
+   91.3086F,
+   -104.980F,
+   -322.998F,
+   7.08008F,
+   -341.064F,
+   -304.932F,
+   -324.951F,
+   -245.850F,
+   -367.188F,
+   234.375F,
+   -342.041F,
+   -490.479F,
+   48.0957F,
+   -336.670F,
+   -475.830F,
+   -57.6172F,
+   -262.939F,
+   30.0293F,
+   103.027F,
+   150.146F,
+   309.814F,
+   133.301F,
+   -74.7070F,
+   372.559F,
+   220.703F,
+   291.504F,
+   436.523F,
+   287.354F,
+   -152.832F,
+   -215.820F,
+   -372.559F,
+   48.5840F,
+   187.012F,
+   367.188F,
+   -260.010F,
+   210.449F,
+   48.0957F,
+   -252.441F,
+   -432.861F,
+   -216.553F,
+   -195.313F,
+   35.4004F,
+   146.240F,
+   -276.855F,
+   -126.709F,
+   152.832F,
+   -294.189F,
+   -470.215F,
+   122.070F,
+   -222.168F,
+   -254.150F,
+   -340.576F,
+   -360.352F,
+   -382.568F,
+   -236.572F,
+   -127.686F,
+   205.566F,
+   8.30078F,
+   437.988F,
+   157.715F,
+   210.449F,
+   -294.678F,
+   -460.938F,
+   -244.629F,
+   -19.0430F,
+   -2.19727F,
+   -164.063F,
+   254.883F,
+   185.303F,
+   19.5313F,
+   -146.484F,
+   278.076F,
+   248.779F,
+   13.9160F,
+   488.281F,
+   347.168F,
+   -203.369F,
+   345.215F,
+   273.682F,
+   -293.457F,
+   397.949F,
+   307.617F,
+   -112.549F,
+   346.680F,
+   303.711F,
+   375.244F,
+   238.037F,
+   61.7676F,
+   -69.0918F,
+   79.1016F,
+   -87.6465F,
+   146.240F,
+   -47.6074F,
+   25.8789F,
+   143.555F,
+   15.1367F,
+   -143.311F,
+   -184.814F,
+   157.471F,
+   50.0488F,
+   12.4512F,
+   293.213F,
+   185.059F,
+   -295.166F,
+   164.307F,
+   -95.2148F,
+   -152.344F,
+   385.986F,
+   229.736F,
+   -36.8652F,
+   249.756F,
+   179.443F,
+   688.477F,
+   317.627F,
+   168.457F,
+   -73.7305F,
+   127.930F,
+   -24.1699F,
+   -219.727F,
+   -387.695F,
+   -290.283F,
+   264.648F,
+   61.2793F,
+   58.1055F,
+   491.699F,
+   437.500F,
+   246.582F,
+   303.955F,
+   398.682F,
+   425.049F,
+   -299.561F,
+   -375.977F,
+   -294.922F,
+   -151.611F,
+   111.328F,
+   -26.6113F,
+   9.76563F,
+   -15.8691F,
+   192.383F,
+   -196.533F,
+   -170.654F,
+   -329.590F,
+   -142.334F,
+   220.703F,
+   203.125F,
+   -195.557F,
+   129.883F,
+   145.020F,
+   481.445F,
+   343.750F,
+   329.834F,
+   -287.354F,
+   -458.984F,
+   -516.113F,
+   -188.721F,
+   138.672F,
+   231.445F,
+   -247.803F,
+   263.428F,
+   307.617F,
+   -271.240F,
+   117.676F,
+   -31.7383F,
+   434.082F,
+   254.883F,
+   190.430F,
+   -364.014F,
+   59.8145F,
+   222.656F,
+   -77.1484F,
+   -278.564F,
+   -223.877F,
+   -130.859F,
+   -352.051F,
+   -572.754F,
+   -191.650F,
+   -377.441F,
+   -485.352F,
+   -489.014F,
+   62.7441F,
+   221.924F,
+   -451.416F,
+   -154.541F,
+   -295.166F,
+   -375.488F,
+   -468.262F,
+   -257.324F,
+   392.090F,
+   546.631F,
+   384.766F,
+   -138.428F,
+   -366.211F,
+   -376.953F,
+   -312.256F,
+   47.6074F,
+   334.229F,
+   -199.463F,
+   71.5332F,
+   297.607F,
+   -128.174F,
+   153.809F,
+   292.236F,
+   -414.551F,
+   -592.041F,
+   -449.219F,
+   -73.9746F,
+   178.467F,
+   182.373F,
+   -285.400F,
+   -61.2793F,
+   65.6738F,
+   -231.934F,
+   -18.3105F,
+   411.133F,
+   -288.574F,
+   -110.596F,
+   245.361F,
+   -390.381F,
+   142.822F,
+   92.2852F,
+   -506.592F,
+   -139.404F,
+   -104.248F,
+   -129.150F,
+   -282.959F,
+   -285.889F,
+   -69.0918F,
+   -50.0488F,
+   -137.695F,
+   -194.336F,
+   304.199F,
+   175.049F,
+   555.908F,
+   226.318F,
+   131.592F,
+   -110.840F,
+   136.475F,
+   107.422F,
+   -175.049F,
+   356.445F,
+   394.287F,
+   -251.465F,
+   256.836F,
+   393.066F,
+   -285.400F,
+   -33.6914F,
+   206.787F,
+   55.1758F,
+   9.52148F,
+   -149.414F,
+   -305.420F,
+   -25.8789F,
+   -177.979F,
+   -158.936F,
+   236.328F,
+   317.871F,
+   -174.316F,
+   -155.273F,
+   421.631F,
+   86.1816F,
+   260.986F,
+   100.098F,
+   -194.824F,
+   -38.0859F,
+   268.311F,
+   -140.137F,
+   224.121F,
+   108.887F,
+   -319.824F,
+   247.070F,
+   113.770F,
+   343.750F,
+   388.428F,
+   186.768F,
+   348.877F,
+   336.914F,
+   428.955F,
+   475.830F,
+   477.539F,
+   580.566F,
+   385.254F,
+   499.756F,
+   524.414F,
+   223.633F,
+   23.9258F,
+   -1.70898F,
+   462.158F,
+   346.191F,
+   522.705F,
+   84.9609F,
+   343.018F,
+   385.498F,
+   37.1094F,
+   276.855F,
+   439.697F,
+   -65.1855F,
+   37.5977F,
+   340.576F,
+   -284.668F,
+   114.502F,
+   257.324F,
+   -278.809F,
+   -98.8770F,
+   -261.963F,
+   -327.393F,
+   -552.734F,
+   -385.986F,
+   -88.8672F,
+   212.158F,
+   416.504F,
+   -283.691F,
+   134.033F,
+   378.418F,
+   -299.072F,
+   -471.680F,
+   -406.738F,
+   -362.549F,
+   -482.666F,
+   -501.709F,
+   -421.631F,
+   -221.191F,
+   -23.9258F,
+   -463.135F,
+   56.8848F,
+   364.258F,
+   217.773F,
+   26.3672F,
+   -80.8105F,
+   -421.875F,
+   -285.645F,
+   -415.039F,
+   -258.789F,
+   483.398F,
+   437.012F,
+   -261.230F,
+   -425.049F,
+   -466.064F,
+   -2.68555F,
+   375.732F,
+   321.533F,
+   -390.625F,
+   22.9492F,
+   121.338F,
+   102.783F,
+   108.154F,
+   -48.0957F,
+   -385.254F,
+   -85.2051F,
+   -242.676F,
+   -146.240F,
+   -131.592F,
+   278.320F,
+   -235.596F,
+   -346.436F,
+   -31.4941F,
+   -327.393F,
+   42.7246F,
+   -109.131F,
+   -91.5527F,
+   320.068F,
+   501.709F,
+   -90.5762F,
+   -158.691F,
+   -74.9512F,
+   -261.963F,
+   147.705F,
+   89.1113F,
+   -502.197F,
+   -27.5879F,
+   104.980F,
+   159.180F,
+   223.145F,
+   236.084F,
+   -247.070F,
+   -387.207F,
+   -567.139F,
+   367.432F,
+   304.688F,
+   136.475F,
+   63.9648F,
+   -118.652F,
+   -97.9004F,
+   -421.631F,
+   327.637F,
+   377.441F,
+   12.2070F,
+   13.6719F,
+   105.469F,
+   -80.5664F,
+   29.0527F,
+   -147.461F,
+   -370.361F,
+   -263.672F,
+   -197.754F,
+   230.957F,
+   275.146F,
+   257.568F,
+   -341.797F,
+   -415.771F,
+   -417.969F,
+   -310.059F,
+   -171.875F,
+   -321.533F,
+   197.021F,
+   444.580F,
+   279.053F,
+   673.828F,
+   392.090F,
+   530.029F,
+   273.438F,
+   99.8535F,
+   -36.6211F,
+   -35.8887F,
+   98.6328F,
+   234.131F,
+   595.459F,
+   466.553F,
+   534.424F,
+   -221.191F,
+   -34.4238F,
+   -211.426F,
+   -220.703F,
+   -34.6680F,
+   -111.816F,
+   -135.986F,
+   -172.852F,
+   -409.912F,
+   -202.637F,
+   -349.365F,
+   -386.475F,
+   -449.707F,
+   -328.613F,
+   -265.137F,
+   -391.602F,
+   -66.4063F,
+   223.389F,
+   -291.992F,
+   188.477F,
+   257.813F,
+   -155.762F,
+   -301.270F,
+   -463.135F,
+   -122.070F,
+   -19.7754F,
+   -200.684F,
+   -314.697F,
+   -393.799F,
+   -179.443F,
+   -28.5645F,
+   191.650F,
+   41.0156F,
+   -266.113F,
+   276.611F,
+   225.098F,
+   -267.578F,
+   -182.129F,
+   337.891F,
+   70.0684F,
+   -133.545F,
+   -259.521F,
+   -335.938F,
+   -537.354F,
+   -293.945F,
+   -531.250F,
+   -383.301F,
+   -428.955F,
+   -368.896F,
+   -547.119F,
+   -188.232F,
+   -424.072F,
+   268.311F,
+   202.637F,
+   -387.695F,
+   176.758F,
+   303.467F,
+   -376.465F,
+   169.189F,
+   196.533F,
+   -412.598F,
+   -58.5938F,
+   406.494F,
+   -415.039F,
+   -0.976563F,
+   -163.086F,
+   524.658F,
+   199.219F,
+   254.395F,
+   -199.707F,
+   -449.463F,
+   5.37109F,
+   -186.523F,
+   -123.779F,
+   109.619F,
+   -281.006F,
+   -150.635F,
+   70.5566F,
+   -205.811F,
+   -389.648F,
+   -58.5938F,
+   121.582F,
+   -57.1289F,
+   -160.400F,
+   -183.594F,
+   117.188F,
+   409.668F,
+   -77.8809F,
+   -117.432F,
+   47.1191F,
+   -197.998F,
+   41.7480F,
+   -29.0527F,
+   -519.531F,
+   -49.3164F,
+   -207.031F,
+   419.189F,
+   278.320F,
+   415.039F
+
+};
+static const Float32 dico3_lsf_3[] =
+{
+   16.3574F,
+   -4.15039F,
+   16.1133F,
+   -2.92969F,
+   -412.598F,
+   -141.846F,
+   -25.3906F,
+   -66.4063F,
+   -262.695F,
+   -289.551F,
+   -450.439F,
+   -91.7969F,
+   -278.320F,
+   -226.074F,
+   -102.539F,
+   -14.1602F,
+   -63.2324F,
+   -160.156F,
+   -276.855F,
+   -135.010F,
+   436.523F,
+   299.561F,
+   111.084F,
+   31.4941F,
+   112.793F,
+   107.666F,
+   -58.5938F,
+   -128.906F,
+   205.078F,
+   125.488F,
+   31.7383F,
+   -18.3105F,
+   271.973F,
+   152.100F,
+   37.3535F,
+   52.7344F,
+   260.742F,
+   137.695F,
+   -1.46484F,
+   -67.3828F,
+   273.193F,
+   177.490F,
+   46.3867F,
+   -16.6016F,
+   171.875F,
+   74.7070F,
+   29.0527F,
+   -64.4531F,
+   80.3223F,
+   14.8926F,
+   -24.4141F,
+   38.0859F,
+   88.8672F,
+   30.0293F,
+   44.6777F,
+   -50.7813F,
+   -41.7480F,
+   -30.0293F,
+   53.7109F,
+   -15.8691F,
+   -74.7070F,
+   -15.1367F,
+   98.1445F,
+   4.15039F,
+   -161.133F,
+   -229.004F,
+   -64.9414F,
+   0.000000F,
+   93.9941F,
+   57.3730F,
+   67.3828F,
+   69.5801F,
+   78.1250F,
+   65.4297F,
+   -82.0313F,
+   -48.8281F,
+   -176.758F,
+   4.15039F,
+   -20.5078F,
+   93.0176F,
+   -132.813F,
+   104.736F,
+   120.605F,
+   126.709F,
+   -28.5645F,
+   70.3125F,
+   74.2188F,
+   80.3223F,
+   156.982F,
+   38.3301F,
+   171.143F,
+   124.023F,
+   292.969F,
+   152.588F,
+   194.336F,
+   148.438F,
+   243.652F,
+   102.783F,
+   120.117F,
+   154.297F,
+   293.945F,
+   190.430F,
+   108.887F,
+   32.2266F,
+   306.885F,
+   206.055F,
+   133.545F,
+   109.619F,
+   202.393F,
+   160.645F,
+   132.080F,
+   114.746F,
+   276.367F,
+   307.129F,
+   224.121F,
+   156.006F,
+   133.545F,
+   12.4512F,
+   103.271F,
+   68.1152F,
+   2.19727F,
+   95.7031F,
+   20.2637F,
+   22.9492F,
+   132.324F,
+   132.568F,
+   55.9082F,
+   -35.8887F,
+   -48.3398F,
+   31.4941F,
+   47.3633F,
+   -45.1660F,
+   -210.693F,
+   -322.510F,
+   -73.7305F,
+   7.32422F,
+   -145.752F,
+   -153.564F,
+   -4.63867F,
+   27.8320F,
+   -219.727F,
+   -263.916F,
+   113.770F,
+   86.1816F,
+   -362.061F,
+   -384.033F,
+   3.66211F,
+   -34.9121F,
+   -416.992F,
+   -502.686F,
+   -183.350F,
+   47.8516F,
+   -458.008F,
+   -504.639F,
+   -156.738F,
+   -62.9883F,
+   -570.068F,
+   -358.887F,
+   -109.863F,
+   -137.695F,
+   -142.578F,
+   -45.4102F,
+   -212.891F,
+   -101.074F,
+   -440.674F,
+   -241.211F,
+   -274.658F,
+   -319.824F,
+   -177.246F,
+   -275.635F,
+   6.83594F,
+   41.2598F,
+   -253.662F,
+   -210.938F,
+   -175.293F,
+   -60.0586F,
+   118.164F,
+   8.78906F,
+   -56.8848F,
+   -11.9629F,
+   64.6973F,
+   16.3574F,
+   70.5566F,
+   114.014F,
+   43.4570F,
+   132.568F,
+   197.754F,
+   131.836F,
+   20.5078F,
+   68.8477F,
+   164.063F,
+   171.631F,
+   -238.037F,
+   -189.697F,
+   31.4941F,
+   70.0684F,
+   -229.004F,
+   -55.4199F,
+   233.154F,
+   145.264F,
+   -394.775F,
+   -70.5566F,
+   204.102F,
+   158.447F,
+   -450.928F,
+   -52.4902F,
+   270.020F,
+   175.293F,
+   -496.582F,
+   -264.893F,
+   158.691F,
+   107.422F,
+   -512.939F,
+   -129.150F,
+   221.436F,
+   140.381F,
+   -490.967F,
+   -82.0313F,
+   163.574F,
+   49.8047F,
+   -583.252F,
+   -168.945F,
+   87.8906F,
+   33.4473F,
+   -526.367F,
+   -538.086F,
+   -2.19727F,
+   68.3594F,
+   -64.9414F,
+   29.0527F,
+   9.52148F,
+   47.1191F,
+   19.0430F,
+   -14.4043F,
+   -29.2969F,
+   55.1758F,
+   -238.037F,
+   -209.473F,
+   -190.674F,
+   -267.334F,
+   -151.123F,
+   -100.830F,
+   -110.107F,
+   -205.566F,
+   -296.875F,
+   -322.510F,
+   -198.486F,
+   -215.576F,
+   -335.938F,
+   -394.287F,
+   -96.1914F,
+   -104.492F,
+   -179.932F,
+   -271.729F,
+   -134.033F,
+   -192.871F,
+   -214.844F,
+   -238.037F,
+   -236.084F,
+   -156.738F,
+   -240.479F,
+   -216.309F,
+   -310.791F,
+   -332.275F,
+   -115.479F,
+   -196.289F,
+   -342.041F,
+   -343.506F,
+   39.0625F,
+   -64.6973F,
+   -224.365F,
+   -67.1387F,
+   -60.5469F,
+   -61.0352F,
+   -175.293F,
+   -92.7734F,
+   23.6816F,
+   -25.1465F,
+   -91.5527F,
+   -55.9082F,
+   -101.318F,
+   -47.1191F,
+   -32.9590F,
+   -135.498F,
+   153.320F,
+   88.1348F,
+   29.0527F,
+   52.7344F,
+   141.357F,
+   88.8672F,
+   95.4590F,
+   51.0254F,
+   154.785F,
+   127.441F,
+   -37.5977F,
+   -36.1328F,
+   128.418F,
+   94.9707F,
+   41.5039F,
+   8.05664F,
+   25.6348F,
+   65.1855F,
+   15.6250F,
+   92.7734F,
+   -366.943F,
+   -244.141F,
+   -7.32422F,
+   -90.0879F,
+   -261.230F,
+   14.1602F,
+   157.959F,
+   54.4434F,
+   -371.094F,
+   -71.0449F,
+   151.611F,
+   74.9512F,
+   -373.779F,
+   38.0859F,
+   186.035F,
+   98.6328F,
+   -495.361F,
+   34.4238F,
+   179.199F,
+   121.826F,
+   -451.416F,
+   -158.691F,
+   74.7070F,
+   125.000F,
+   -45.6543F,
+   -25.3906F,
+   -14.4043F,
+   106.934F,
+   32.7148F,
+   -56.1523F,
+   38.0859F,
+   -45.4102F,
+   -14.8926F,
+   -63.4766F,
+   -3.90625F,
+   2.44141F,
+   -138.916F,
+   -0.732422F,
+   -102.783F,
+   -72.5098F,
+   -421.143F,
+   -127.197F,
+   -84.4727F,
+   43.4570F,
+   -332.520F,
+   -14.4043F,
+   -10.7422F,
+   38.3301F,
+   -523.926F,
+   -112.549F,
+   -114.746F,
+   -85.2051F,
+   -529.785F,
+   -0.244141F,
+   -90.0879F,
+   -29.5410F,
+   -385.498F,
+   -91.0645F,
+   -219.727F,
+   -247.803F,
+   -272.705F,
+   -144.287F,
+   -149.658F,
+   -191.406F,
+   -136.963F,
+   29.7852F,
+   -18.3105F,
+   -109.619F,
+   -0.976563F,
+   -41.7480F,
+   -30.0293F,
+   -90.8203F,
+   46.8750F,
+   41.0156F,
+   -18.5547F,
+   -32.2266F,
+   61.5234F,
+   -26.1230F,
+   83.0078F,
+   51.2695F,
+   95.7031F,
+   124.268F,
+   66.4063F,
+   44.1895F,
+   -26.6113F,
+   35.4004F,
+   53.2227F,
+   29.0527F,
+   -101.563F,
+   -64.2090F,
+   118.408F,
+   64.6973F,
+   -44.1895F,
+   -1.95313F,
+   -69.8242F,
+   55.1758F,
+   -59.5703F,
+   -53.2227F,
+   16.8457F,
+   -70.8008F,
+   -38.5742F,
+   46.6309F,
+   -0.244141F,
+   -15.6250F,
+   -144.531F,
+   -21.9727F,
+   52.0020F,
+   -23.4375F,
+   62.2559F,
+   106.201F,
+   43.4570F,
+   -19.5313F,
+   -90.0879F,
+   -4.39453F,
+   -8.05664F,
+   -19.5313F,
+   -10.2539F,
+   101.318F,
+   34.1797F,
+   -54.1992F,
+   279.053F,
+   158.936F,
+   158.447F,
+   80.3223F,
+   187.256F,
+   135.742F,
+   60.7910F,
+   57.3730F,
+   231.445F,
+   100.830F,
+   107.910F,
+   68.1152F,
+   34.4238F,
+   82.7637F,
+   86.9141F,
+   135.986F,
+   -114.746F,
+   -41.5039F,
+   24.1699F,
+   57.8613F,
+   -138.916F,
+   -195.313F,
+   85.9375F,
+   137.939F,
+   68.8477F,
+   115.479F,
+   114.746F,
+   81.0547F,
+   -48.5840F,
+   -168.457F,
+   -313.477F,
+   -223.877F,
+   -47.1191F,
+   -104.004F,
+   -195.313F,
+   -273.926F,
+   -6.34766F,
+   -90.5762F,
+   -119.629F,
+   -47.1191F,
+   155.518F,
+   145.264F,
+   126.709F,
+   80.5664F,
+   99.6094F,
+   -28.0762F,
+   19.2871F,
+   2.92969F,
+   116.455F,
+   21.2402F,
+   -25.1465F,
+   -91.7969F,
+   -162.598F,
+   -84.7168F,
+   -67.6270F,
+   -71.0449F,
+   -124.512F,
+   -117.432F,
+   41.2598F,
+   72.5098F,
+   -202.393F,
+   -180.176F,
+   -50.0488F,
+   -41.7480F,
+   -78.1250F,
+   -131.836F,
+   80.0781F,
+   69.0918F,
+   -209.717F,
+   -233.887F,
+   107.910F,
+   -0.488281F,
+   135.742F,
+   167.480F,
+   31.7383F,
+   13.6719F,
+   337.646F,
+   247.070F,
+   184.326F,
+   104.248F,
+   149.414F,
+   180.908F,
+   153.320F,
+   135.010F,
+   -82.7637F,
+   -194.336F,
+   32.7148F,
+   67.6270F,
+   -154.541F,
+   -264.893F,
+   -0.488281F,
+   -60.0586F,
+   -214.844F,
+   -252.686F,
+   -392.334F,
+   -259.766F,
+   -242.676F,
+   -115.723F,
+   -277.832F,
+   -119.141F,
+   -101.074F,
+   -194.092F,
+   17.8223F,
+   -50.2930F,
+   -1.95313F,
+   -33.9355F,
+   107.178F,
+   49.8047F,
+   -42.9688F,
+   -141.113F,
+   5.61523F,
+   31.9824F,
+   -65.6738F,
+   -184.814F,
+   -46.6309F,
+   59.8145F,
+   -26.6113F,
+   -82.5195F,
+   27.3438F,
+   77.1484F,
+   29.2969F,
+   -99.1211F,
+   -28.8086F,
+   149.170F,
+   -43.9453F,
+   -45.4102F,
+   -157.471F,
+   28.0762F,
+   -42.2363F,
+   8.30078F,
+   -126.465F,
+   -119.385F,
+   -36.8652F,
+   14.8926F,
+   -142.334F,
+   -206.055F,
+   53.7109F,
+   -33.6914F,
+   -166.260F,
+   -249.023F,
+   95.4590F,
+   -4.15039F,
+   -145.996F,
+   -78.3691F,
+   38.3301F,
+   -72.0215F,
+   31.4941F,
+   37.8418F,
+   -226.074F,
+   -213.623F,
+   -240.967F,
+   69.5801F,
+   58.8379F,
+   -20.2637F,
+   -30.5176F,
+   -30.5176F,
+   151.367F,
+   145.752F,
+   105.469F,
+   22.4609F,
+   95.9473F,
+   19.0430F,
+   99.8535F,
+   14.8926F,
+   -95.9473F,
+   -180.420F,
+   -100.830F,
+   -182.617F,
+   20.2637F,
+   13.1836F,
+   88.1348F,
+   6.59180F,
+   -264.648F,
+   31.7383F,
+   -82.2754F,
+   -169.434F,
+   -382.080F,
+   72.5098F,
+   77.6367F,
+   -4.63867F,
+   -457.275F,
+   8.78906F,
+   12.4512F,
+   -77.3926F,
+   -567.139F,
+   -60.0586F,
+   56.3965F,
+   -20.5078F,
+   -562.988F,
+   -191.162F,
+   9.76563F,
+   -43.7012F,
+   -545.166F,
+   -227.051F,
+   -115.723F,
+   -112.793F,
+   -184.082F,
+   -20.9961F,
+   -70.3125F,
+   -152.832F,
+   -588.623F,
+   -111.084F,
+   -15.3809F,
+   41.7480F,
+   -268.311F,
+   -267.090F,
+   -6.34766F,
+   -34.9121F,
+   -291.260F,
+   -111.084F,
+   -99.1211F,
+   -93.0176F,
+   -147.705F,
+   -51.2695F,
+   -23.4375F,
+   -12.4512F,
+   -141.602F,
+   -116.211F,
+   -67.3828F,
+   -3.66211F,
+   -291.748F,
+   -154.785F,
+   -293.701F,
+   -215.088F,
+   -92.2852F,
+   -53.9551F,
+   -163.330F,
+   -232.422F,
+   145.020F,
+   43.4570F,
+   -98.3887F,
+   -165.039F,
+   186.279F,
+   79.8340F,
+   146.729F,
+   70.8008F,
+   41.9922F,
+   73.2422F,
+   49.5605F,
+   38.3301F,
+   -13.6719F,
+   -82.0313F,
+   86.9141F,
+   5.85938F,
+   -55.6641F,
+   -72.2656F,
+   -63.2324F,
+   -7.08008F,
+   -45.4102F,
+   64.2090F,
+   101.563F,
+   3.41797F,
+   -86.1816F,
+   91.0645F,
+   -2.92969F,
+   -52.7344F,
+   62.7441F,
+   23.4375F,
+   42.4805F,
+   13.9160F,
+   -372.559F,
+   -150.391F,
+   -232.910F,
+   -121.826F,
+   -121.338F,
+   -37.1094F,
+   -81.2988F,
+   30.5176F,
+   25.6348F,
+   48.8281F,
+   43.7012F,
+   -23.6816F,
+   -80.8105F,
+   -54.6875F,
+   186.768F,
+   170.166F,
+   185.547F,
+   62.5000F,
+   73.4863F,
+   14.4043F,
+   111.084F,
+   -20.7520F,
+   49.8047F,
+   70.3125F,
+   -125.488F,
+   58.5938F,
+   61.2793F,
+   -26.6113F,
+   62.5000F,
+   101.807F,
+   -8.30078F,
+   -100.830F,
+   24.6582F,
+   104.980F,
+   93.7500F,
+   38.0859F,
+   -7.56836F,
+   -2.44141F,
+   50.2930F,
+   104.004F,
+   143.799F,
+   35.4004F,
+   34.9121F,
+   17.3340F,
+   197.266F,
+   221.191F,
+   81.2988F,
+   85.2051F,
+   240.723F,
+   229.004F,
+   143.799F,
+   80.8105F,
+   317.383F,
+   201.172F,
+   45.6543F,
+   124.268F,
+   259.277F,
+   159.424F,
+   92.5293F,
+   113.770F,
+   356.934F,
+   228.760F,
+   97.9004F,
+   66.8945F,
+   192.139F,
+   210.205F,
+   64.6973F,
+   0.488281F,
+   148.682F,
+   135.010F,
+   6.83594F,
+   74.4629F,
+   226.074F,
+   83.0078F,
+   25.8789F,
+   94.2383F,
+   58.8379F,
+   -65.1855F,
+   -35.8887F,
+   54.9316F,
+   -43.4570F,
+   -130.371F,
+   84.7168F,
+   122.559F,
+   -156.982F,
+   -93.0176F,
+   96.9238F,
+   7.32422F,
+   -158.936F,
+   -178.955F,
+   -106.201F,
+   97.1680F,
+   -99.3652F,
+   -177.246F,
+   -118.164F,
+   -60.5469F,
+   -192.627F,
+   -223.145F,
+   -106.934F,
+   -116.211F,
+   -121.582F,
+   -95.2148F,
+   18.3105F,
+   -72.0215F,
+   -235.352F,
+   -144.043F,
+   -147.949F,
+   36.6211F,
+   -29.5410F,
+   -11.9629F,
+   -37.8418F,
+   -19.0430F,
+   228.271F,
+   134.277F,
+   94.9707F,
+   9.27734F,
+   -78.3691F,
+   31.0059F,
+   103.516F,
+   76.9043F,
+   -69.5801F,
+   -27.5879F,
+   69.0918F,
+   63.2324F,
+   160.645F,
+   49.5605F,
+   78.6133F,
+   118.652F,
+   220.459F,
+   123.291F,
+   182.617F,
+   101.807F,
+   149.170F,
+   103.271F,
+   135.498F,
+   125.000F,
+   58.3496F,
+   -20.2637F,
+   -141.113F,
+   -4.63867F,
+   -82.7637F,
+   -178.467F,
+   85.2051F,
+   3.17383F,
+   -228.027F,
+   -341.553F,
+   -27.8320F,
+   -87.8906F,
+   26.1230F,
+   168.945F,
+   44.4336F,
+   21.9727F,
+   -303.467F,
+   -375.488F,
+   -378.662F,
+   -177.002F,
+   -138.672F,
+   -220.459F,
+   -332.764F,
+   -128.174F,
+   -126.221F,
+   -208.252F,
+   -210.205F,
+   -245.117F,
+   -41.0156F,
+   -168.457F,
+   -203.857F,
+   15.3809F,
+   -33.4473F,
+   -135.742F,
+   -133.545F,
+   35.1563F,
+   -69.8242F,
+   -199.463F,
+   118.408F,
+   77.8809F,
+   -35.8887F,
+   -99.6094F,
+   128.418F,
+   60.0586F,
+   -84.7168F,
+   -105.957F,
+   72.5098F,
+   -6.83594F,
+   -70.8008F,
+   -114.990F,
+   -270.996F,
+   -313.721F,
+   -112.305F,
+   -87.6465F,
+   -241.211F,
+   -193.848F,
+   328.857F,
+   317.139F,
+   168.457F,
+   127.686F,
+   296.875F,
+   260.742F,
+   267.090F,
+   184.814F,
+   201.416F,
+   278.320F,
+   183.594F,
+   120.605F,
+   305.664F,
+   333.252F,
+   291.748F,
+   219.238F,
+   127.197F,
+   257.080F,
+   129.883F,
+   105.469F,
+   -81.5430F,
+   -52.7344F,
+   -76.4160F,
+   -64.2090F,
+   -39.0625F,
+   12.6953F,
+   -115.234F,
+   -37.8418F,
+   31.0059F,
+   33.2031F,
+   -92.7734F,
+   10.7422F,
+   207.764F,
+   100.098F,
+   -39.5508F,
+   -119.385F,
+   30.0293F,
+   -62.2559F,
+   -194.336F,
+   -162.842F,
+   266.113F,
+   223.877F,
+   192.627F,
+   120.361F,
+   341.064F,
+   292.236F,
+   136.230F,
+   49.3164F,
+   -12.4512F,
+   -28.8086F,
+   -83.4961F,
+   -171.143F,
+   20.2637F,
+   26.3672F,
+   -10.2539F,
+   -107.666F,
+   14.8926F,
+   23.1934F,
+   70.0684F,
+   62.5000F,
+   -6.59180F,
+   21.7285F,
+   127.930F,
+   129.639F,
+   85.6934F,
+   55.4199F,
+   144.531F,
+   133.057F,
+   170.166F,
+   37.8418F,
+   -40.0391F,
+   74.9512F,
+   155.762F,
+   66.8945F,
+   -119.385F,
+   -12.2070F,
+   184.082F,
+   58.5938F,
+   -40.5273F,
+   -30.2734F,
+   -28.3203F,
+   -141.357F,
+   -295.898F,
+   -15.3809F,
+   46.3867F,
+   -72.0215F,
+   -253.906F,
+   -316.406F,
+   35.8887F,
+   -91.7969F,
+   -43.2129F,
+   -27.5879F,
+   205.322F,
+   302.979F,
+   256.592F,
+   163.086F,
+   0.488281F,
+   71.5332F,
+   134.521F,
+   74.2188F,
+   -267.578F,
+   -232.666F,
+   -60.5469F,
+   91.7969F,
+   -183.105F,
+   -235.596F,
+   21.2402F,
+   125.977F,
+   -67.1387F,
+   -125.977F,
+   168.213F,
+   95.4590F,
+   -92.5293F,
+   -156.982F,
+   213.867F,
+   145.020F,
+   -95.2148F,
+   -247.314F,
+   -157.471F,
+   139.893F,
+   -26.1230F,
+   -138.672F,
+   -168.213F,
+   -201.660F,
+   -250.244F,
+   -6.59180F,
+   -80.0781F,
+   -49.5605F,
+   210.205F,
+   182.861F,
+   133.789F,
+   56.8848F,
+   -405.273F,
+   -254.639F,
+   110.107F,
+   26.3672F,
+   -161.133F,
+   -151.367F,
+   104.980F,
+   57.6172F,
+   5.12695F,
+   -96.6797F,
+   -282.715F,
+   -154.053F,
+   334.961F,
+   316.895F,
+   236.084F,
+   140.869F,
+   274.658F,
+   274.658F,
+   143.799F,
+   110.840F,
+   -78.8574F,
+   -211.182F,
+   -114.014F,
+   37.3535F,
+   -114.258F,
+   -170.654F,
+   -196.289F,
+   -124.268F,
+   -95.7031F,
+   -175.293F,
+   -49.8047F,
+   -8.54492F,
+   -147.217F,
+   -266.846F,
+   -138.428F,
+   -39.5508F,
+   -123.291F,
+   -245.117F,
+   -24.9023F,
+   85.4492F,
+   53.4668F,
+   54.6875F,
+   103.271F,
+   61.5234F,
+   96.4355F,
+   144.287F,
+   148.438F,
+   88.6230F,
+   -182.129F,
+   -23.4375F,
+   91.0645F,
+   41.9922F,
+   41.7480F,
+   72.0215F,
+   174.316F,
+   82.7637F,
+   56.8848F,
+   18.7988F,
+   26.1230F,
+   67.6270F,
+   38.3301F,
+   37.3535F,
+   -121.826F,
+   -86.9141F,
+   377.686F,
+   261.963F,
+   140.625F,
+   120.605F,
+   -71.2891F,
+   -82.7637F,
+   -123.047F,
+   -144.531F,
+   -220.459F,
+   -17.5781F,
+   -151.123F,
+   -117.432F,
+   -389.160F,
+   -272.705F,
+   -138.428F,
+   -62.0117F,
+   -193.604F,
+   -123.779F,
+   -137.695F,
+   -71.0449F,
+   -120.117F,
+   -129.883F,
+   122.559F,
+   136.719F,
+   -93.2617F,
+   104.248F,
+   146.484F,
+   56.1523F,
+   -55.4199F,
+   116.455F,
+   61.2793F,
+   18.3105F,
+   69.5801F,
+   205.566F,
+   198.486F,
+   116.211F,
+   -319.824F,
+   -325.439F,
+   45.4102F,
+   92.0410F,
+   -143.311F,
+   -223.877F,
+   156.982F,
+   93.0176F,
+   -289.551F,
+   -135.010F,
+   100.342F,
+   20.0195F,
+   -275.146F,
+   -200.195F,
+   -42.4805F,
+   -131.836F,
+   -147.461F,
+   29.0527F,
+   132.568F,
+   50.0488F,
+   -92.7734F,
+   160.400F,
+   221.924F,
+   138.428F,
+   27.3438F,
+   -72.7539F,
+   -91.3086F,
+   27.8320F,
+   -209.229F,
+   -61.2793F,
+   13.6719F,
+   38.8184F,
+   97.9004F,
+   84.2285F,
+   -8.30078F,
+   -34.1797F,
+   -27.0996F,
+   -148.193F,
+   10.0098F,
+   149.902F,
+   86.6699F,
+   -27.8320F,
+   -18.7988F,
+   115.723F,
+   141.113F,
+   13.6719F,
+   354.004F,
+   225.586F,
+   268.066F,
+   346.680F,
+   180.908F,
+   97.6563F,
+   60.0586F,
+   5.37109F,
+   143.555F,
+   76.4160F,
+   -29.5410F,
+   79.8340F,
+   202.881F,
+   115.234F,
+   -277.832F,
+   -148.438F,
+   208.984F,
+   134.766F,
+   -302.979F,
+   -261.719F,
+   155.762F,
+   146.484F,
+   -87.4023F,
+   62.0117F,
+   -81.2988F,
+   -73.9746F,
+   -157.715F,
+   180.420F,
+   87.4023F,
+   18.0664F,
+   299.316F,
+   407.959F,
+   298.096F,
+   207.275F,
+   547.119F,
+   396.484F,
+   239.990F,
+   155.273F,
+   449.463F,
+   360.596F,
+   182.861F,
+   93.7500F,
+   85.4492F,
+   64.2090F,
+   21.2402F,
+   31.2500F,
+   -464.355F,
+   -229.736F,
+   -35.1563F,
+   -15.6250F,
+   -423.340F,
+   -62.2559F,
+   70.3125F,
+   -7.56836F,
+   -645.508F,
+   -302.246F,
+   89.3555F,
+   57.3730F,
+   -401.123F,
+   -266.602F,
+   -328.125F,
+   -74.2188F,
+   -132.080F,
+   -262.451F,
+   -272.461F,
+   30.0293F,
+   -287.598F,
+   -61.5234F,
+   -199.219F,
+   -43.9453F,
+   -248.047F,
+   130.127F,
+   137.939F,
+   56.8848F,
+   -118.896F,
+   -104.980F,
+   -45.8984F,
+   81.5430F,
+   211.670F,
+   301.758F,
+   130.371F,
+   41.7480F,
+   -388.184F,
+   -392.334F,
+   155.029F,
+   153.809F,
+   -536.133F,
+   75.6836F,
+   225.586F,
+   100.586F,
+   -575.684F,
+   -80.0781F,
+   233.398F,
+   129.150F,
+   -644.287F,
+   -92.0410F,
+   153.809F,
+   67.8711F,
+   -635.254F,
+   77.3926F,
+   195.068F,
+   72.9980F,
+   -587.402F,
+   32.4707F,
+   83.0078F,
+   7.56836F,
+   -526.367F,
+   -358.398F,
+   31.9824F,
+   30.5176F,
+   -289.063F,
+   -119.629F,
+   -33.9355F,
+   11.2305F,
+   -181.641F,
+   109.131F,
+   217.529F,
+   137.695F,
+   16.3574F,
+   -110.107F,
+   157.715F,
+   147.461F,
+   -135.010F,
+   -104.736F,
+   -213.867F,
+   96.6797F,
+   39.5508F,
+   -16.1133F,
+   318.604F,
+   223.389F,
+   116.943F,
+   141.357F,
+   265.625F,
+   193.848F,
+   109.863F,
+   67.8711F,
+   138.184F,
+   79.1016F,
+   -258.057F,
+   -37.5977F,
+   36.1328F,
+   -43.2129F,
+   -621.338F,
+   41.0156F,
+   261.230F,
+   144.531F,
+   -573.975F,
+   -10.2539F,
+   199.951F,
+   84.2285F,
+   -572.266F,
+   -172.607F,
+   176.025F,
+   61.0352F,
+   -531.006F,
+   -365.479F,
+   -75.4395F,
+   29.7852F,
+   -19.0430F,
+   -17.8223F,
+   29.2969F,
+   42.2363F,
+   -0.976563F,
+   63.9648F,
+   -64.2090F,
+   -63.7207F,
+   -105.225F,
+   -15.6250F,
+   -98.8770F,
+   -178.711F,
+   -636.963F,
+   28.3203F,
+   -20.2637F,
+   -47.1191F,
+   -372.314F,
+   -230.469F,
+   -116.455F,
+   -177.002F,
+   -124.023F,
+   74.9512F,
+   41.5039F,
+   41.9922F,
+   203.125F,
+   101.807F,
+   203.125F,
+   167.480F,
+   -54.9316F,
+   43.2129F,
+   218.262F,
+   199.707F,
+   -117.676F,
+   -94.9707F,
+   312.256F,
+   253.662F,
+   -93.5059F,
+   49.0723F,
+   -85.4492F,
+   9.76563F,
+   178.223F,
+   155.029F,
+   55.1758F,
+   128.418F,
+   122.803F,
+   112.793F,
+   82.5195F,
+   97.1680F,
+   130.615F,
+   174.316F,
+   9.76563F,
+   -68.8477F,
+   361.816F,
+   359.131F,
+   264.893F,
+   178.467F,
+   381.104F,
+   261.719F,
+   221.924F,
+   169.189F,
+   346.436F,
+   312.988F,
+   217.041F,
+   214.600F,
+   281.494F,
+   177.734F,
+   289.551F,
+   205.078F,
+   -55.1758F,
+   275.879F,
+   231.689F,
+   168.213F,
+   -120.605F,
+   -240.723F,
+   -379.883F,
+   -31.2500F,
+   -138.672F,
+   -176.025F,
+   -174.072F,
+   -6.34766F,
+   77.3926F,
+   127.930F,
+   17.0898F,
+   32.9590F,
+   -98.8770F,
+   -211.182F,
+   -431.152F,
+   -159.180F,
+   -42.4805F,
+   -195.557F,
+   216.064F,
+   188.721F,
+   -37.3535F,
+   -22.2168F,
+   268.311F,
+   183.350F,
+   -123.535F,
+   -280.518F,
+   208.252F,
+   157.715F,
+   58.8379F,
+   190.918F,
+   126.709F,
+   131.592F,
+   452.393F,
+   415.039F,
+   268.799F,
+   166.992F,
+   -304.932F,
+   -362.793F,
+   -113.281F,
+   45.8984F,
+   -218.018F,
+   -343.994F,
+   -320.313F,
+   -83.2520F,
+   -32.9590F,
+   106.934F,
+   -42.7246F,
+   4.39453F,
+   271.240F,
+   238.281F,
+   77.8809F,
+   50.7813F,
+   -349.121F,
+   -431.641F,
+   20.2637F,
+   111.816F,
+   -129.395F,
+   -244.141F,
+   74.9512F,
+   31.4941F,
+   -205.078F,
+   -3.66211F,
+   -7.08008F,
+   -86.9141F,
+   -222.412F,
+   -225.586F,
+   -280.029F,
+   -59.0820F,
+   -29.0527F,
+   -128.906F,
+   31.0059F,
+   -32.4707F,
+   -185.791F,
+   -186.768F,
+   46.3867F,
+   -20.2637F,
+   -76.9043F,
+   218.506F,
+   127.441F,
+   56.3965F,
+   -54.1992F,
+   24.9023F,
+   -15.3809F,
+   -104.492F,
+   77.1484F,
+   170.654F,
+   92.5293F,
+   17.0898F,
+   6.10352F,
+   174.805F,
+   76.6602F,
+   -26.3672F,
+   123.779F,
+   213.379F,
+   138.184F,
+   58.1055F,
+   26.3672F,
+   229.736F,
+   126.709F,
+   47.6074F,
+   103.760F,
+   -14.6484F,
+   -104.248F,
+   62.7441F,
+   33.9355F,
+   -25.1465F,
+   -153.809F,
+   108.887F,
+   81.5430F,
+   90.3320F,
+   100.586F,
+   11.7188F,
+   -41.9922F,
+   -168.457F,
+   -69.0918F,
+   135.986F,
+   45.6543F,
+   -69.8242F,
+   38.5742F,
+   117.920F,
+   34.1797F,
+   65.9180F,
+   -83.9844F,
+   -154.053F,
+   225.586F,
+   141.357F,
+   -28.3203F,
+   32.2266F,
+   34.6680F,
+   113.770F,
+   -16.6016F,
+   -15.6250F,
+   56.1523F,
+   -35.4004F,
+   -73.7305F,
+   -132.324F,
+   -196.045F,
+   -222.656F,
+   248.535F,
+   179.932F,
+   -188.721F,
+   247.803F,
+   153.809F,
+   72.5098F,
+   -633.789F,
+   23.1934F,
+   108.643F,
+   82.0313F,
+   -518.066F,
+   119.873F,
+   124.512F,
+   46.6309F,
+   -305.908F,
+   39.3066F,
+   -0.488281F,
+   -79.1016F,
+   -354.004F,
+   -154.541F,
+   -173.828F,
+   -25.6348F,
+   -205.566F,
+   -62.0117F,
+   -100.342F,
+   24.4141F,
+   -156.250F,
+   -70.8008F,
+   246.582F,
+   186.279F,
+   -158.691F,
+   76.4160F,
+   285.400F,
+   178.223F,
+   34.1797F,
+   123.291F,
+   251.465F,
+   187.012F,
+   188.477F,
+   70.0684F,
+   260.498F,
+   200.928F,
+   120.850F,
+   182.861F,
+   74.4629F,
+   78.8574F,
+   -40.0391F,
+   112.793F,
+   19.0430F,
+   97.4121F,
+   -83.4961F,
+   -213.379F,
+   16.8457F,
+   145.752F,
+   -3.90625F,
+   151.367F,
+   151.611F,
+   82.2754F,
+   -33.6914F,
+   -108.398F,
+   -64.6973F,
+   53.2227F,
+   20.5078F,
+   -109.863F,
+   232.666F,
+   162.598F,
+   -54.1992F,
+   -196.045F,
+   132.080F,
+   147.461F,
+   -224.854F,
+   -335.938F,
+   59.5703F,
+   28.3203F,
+   -205.322F,
+   -176.514F,
+   153.809F,
+   143.555F,
+   34.1797F,
+   161.865F,
+   71.7773F,
+   89.8438F,
+   228.271F,
+   255.371F,
+   215.088F,
+   185.303F,
+   426.270F,
+   357.422F,
+   223.633F,
+   153.320F,
+   106.445F,
+   235.107F,
+   68.6035F,
+   0.244141F,
+   -29.0527F,
+   18.0664F,
+   132.324F,
+   52.0020F,
+   0.244141F,
+   -138.428F,
+   73.4863F,
+   58.8379F,
+   63.4766F,
+   106.201F,
+   54.1992F,
+   96.6797F,
+   228.516F,
+   233.643F,
+   270.508F,
+   171.631F,
+   124.512F,
+   123.535F,
+   197.266F,
+   116.699F,
+   146.729F,
+   169.434F,
+   234.375F,
+   151.367F,
+   237.305F,
+   180.908F,
+   239.258F,
+   146.484F,
+   203.613F,
+   175.049F,
+   187.256F,
+   166.992F,
+   156.982F,
+   237.305F,
+   228.271F,
+   155.762F,
+   122.314F,
+   161.377F,
+   175.781F,
+   207.764F,
+   -25.6348F,
+   -154.297F,
+   -73.9746F,
+   -28.5645F,
+   -104.736F,
+   31.7383F,
+   192.627F,
+   107.910F,
+   -127.441F,
+   -45.8984F,
+   171.875F,
+   91.0645F,
+   -185.303F,
+   10.2539F,
+   198.730F,
+   127.686F,
+   -129.639F,
+   -277.588F,
+   91.0645F,
+   141.113F,
+   -166.504F,
+   -293.701F,
+   -111.084F,
+   69.5801F,
+   -283.936F,
+   -385.010F,
+   -268.066F,
+   10.7422F,
+   19.7754F,
+   -20.0195F,
+   173.828F,
+   88.6230F,
+   116.455F,
+   60.0586F,
+   232.910F,
+   151.855F,
+   391.602F,
+   395.996F,
+   311.768F,
+   217.529F,
+   343.994F,
+   209.717F,
+   225.586F,
+   217.773F,
+   188.965F,
+   254.150F,
+   231.201F,
+   278.809F,
+   9.76563F,
+   -133.301F,
+   -18.3105F,
+   70.3125F,
+   -150.391F,
+   -25.8789F,
+   -170.166F,
+   -6.34766F,
+   -41.2598F,
+   -39.0625F,
+   -217.529F,
+   -180.420F,
+   -68.1152F,
+   -93.7500F,
+   -251.221F,
+   -85.4492F,
+   434.814F,
+   319.336F,
+   255.371F,
+   199.219F,
+   385.742F,
+   374.268F,
+   359.375F,
+   287.598F,
+   367.432F,
+   262.695F,
+   296.875F,
+   219.482F,
+   217.285F,
+   220.703F,
+   137.695F,
+   159.668F,
+   224.609F,
+   168.945F,
+   249.268F,
+   208.984F,
+   -120.361F,
+   32.2266F,
+   43.2129F,
+   123.291F,
+   17.3340F,
+   47.6074F,
+   -6.83594F,
+   23.6816F,
+   111.328F,
+   85.6934F,
+   -40.0391F,
+   21.4844F,
+   107.178F,
+   67.8711F,
+   -9.76563F,
+   85.4492F,
+   340.576F,
+   231.689F,
+   57.1289F,
+   -23.1934F,
+   -196.533F,
+   -115.234F,
+   9.27734F,
+   -39.7949F,
+   89.5996F,
+   -23.9258F,
+   119.385F,
+   127.686F,
+   250.244F,
+   287.598F,
+   295.898F,
+   221.191F,
+   77.8809F,
+   320.801F,
+   198.730F,
+   112.549F,
+   -30.0293F,
+   -132.568F,
+   -196.289F,
+   109.131F,
+   -182.617F,
+   -79.1016F,
+   -218.994F,
+   -275.146F,
+   -179.932F,
+   -122.314F,
+   -192.627F,
+   -174.072F,
+   174.561F,
+   189.697F,
+   302.490F,
+   225.098F,
+   475.830F,
+   473.389F,
+   333.984F,
+   211.182F,
+   178.223F,
+   214.844F,
+   185.059F,
+   94.7266F,
+   -212.646F,
+   110.840F,
+   4.15039F,
+   -61.2793F,
+   -93.0176F,
+   -197.754F,
+   -386.475F,
+   58.3496F,
+   -127.197F,
+   -235.840F,
+   -193.359F,
+   63.2324F,
+   -217.285F,
+   -331.543F,
+   -187.988F,
+   -17.8223F,
+   40.5273F,
+   85.2051F,
+   -51.7578F,
+   78.8574F,
+   -205.078F,
+   -73.4863F,
+   115.479F,
+   106.201F,
+   -165.771F,
+   -113.281F,
+   177.734F,
+   85.6934F,
+   -38.0859F,
+   -48.5840F,
+   162.842F,
+   105.469F,
+   7.08008F,
+   -61.5234F,
+   101.318F,
+   117.188F,
+   -178.467F,
+   -92.5293F,
+   35.4004F,
+   136.475F,
+   -128.906F,
+   -154.053F,
+   -282.715F,
+   -38.8184F,
+   108.643F,
+   66.6504F,
+   30.0293F,
+   156.006F,
+   91.0645F,
+   -30.7617F,
+   195.313F,
+   138.672F,
+   20.5078F,
+   -39.5508F,
+   175.781F,
+   173.828F,
+   -202.637F,
+   -130.859F,
+   -45.1660F,
+   54.1992F,
+   99.6094F,
+   110.352F,
+   122.314F,
+   188.232F,
+   -218.994F,
+   -330.811F,
+   -16.3574F,
+   107.910F,
+   -193.359F,
+   -343.262F,
+   138.184F,
+   146.973F,
+   40.7715F,
+   -79.5898F,
+   124.268F,
+   80.5664F,
+   -23.1934F,
+   -152.832F,
+   -178.223F,
+   -83.9844F,
+   407.227F,
+   297.119F,
+   190.186F,
+   111.084F,
+   321.289F,
+   202.148F,
+   142.578F,
+   175.537F,
+   98.6328F,
+   -7.56836F,
+   247.314F,
+   192.627F,
+   21.7285F,
+   26.1230F,
+   217.529F,
+   134.033F,
+   212.646F,
+   385.986F,
+   223.877F,
+   163.818F,
+   211.426F,
+   361.084F,
+   314.697F,
+   208.496F,
+   95.4590F,
+   260.742F,
+   273.926F,
+   198.242F,
+   19.0430F,
+   -137.207F,
+   84.2285F,
+   137.451F,
+   104.736F,
+   -25.1465F,
+   101.807F,
+   192.139F,
+   -29.7852F,
+   -106.689F,
+   100.342F,
+   192.383F,
+   -222.900F,
+   -101.807F,
+   146.973F,
+   184.082F,
+   -55.1758F,
+   -3.90625F,
+   36.8652F,
+   185.547F,
+   -170.898F,
+   28.8086F,
+   -25.3906F,
+   -3.41797F,
+   -275.391F,
+   11.7188F,
+   69.3359F,
+   95.9473F,
+   -95.2148F,
+   -102.295F,
+   -156.006F,
+   -28.3203F,
+   -222.168F,
+   74.7070F,
+   77.1484F,
+   -3.17383F,
+   294.678F,
+   240.234F,
+   200.439F,
+   163.330F,
+   -291.748F,
+   -169.189F,
+   34.1797F,
+   -52.0020F,
+   -215.820F,
+   -101.563F,
+   -48.5840F,
+   -136.230F,
+   -150.391F,
+   59.8145F,
+   -98.6328F,
+   -162.109F,
+   63.9648F,
+   13.6719F,
+   -150.635F,
+   -176.758F,
+   -20.7520F,
+   -119.873F,
+   -78.1250F,
+   -160.156F,
+   -139.160F,
+   -202.881F,
+   -31.4941F,
+   -128.906F,
+   -367.676F,
+   -15.3809F,
+   -89.5996F,
+   -93.9941F,
+   -87.4023F,
+   -78.3691F,
+   0.976563F,
+   12.4512F,
+   -89.3555F,
+   -52.2461F,
+   77.8809F,
+   124.756F,
+   35.6445F,
+   163.818F,
+   -4.15039F,
+   -71.0449F,
+   -26.8555F,
+   113.281F,
+   -33.9355F,
+   -121.094F,
+   -49.3164F,
+   53.7109F,
+   -76.1719F,
+   -154.053F,
+   -161.133F,
+   -17.8223F,
+   -159.912F,
+   -200.195F,
+   -161.621F,
+   -159.424F,
+   -314.453F,
+   -209.229F,
+   -104.980F,
+   -232.666F,
+   -234.131F,
+   -64.4531F,
+   -11.9629F,
+   -114.258F,
+   -17.5781F,
+   -93.0176F,
+   -85.4492F,
+   -137.451F,
+   -47.1191F,
+   -99.3652F,
+   13.4277F,
+   -99.6094F,
+   -196.045F,
+   2.68555F,
+   -75.4395F,
+   158.447F,
+   45.8984F,
+   -48.3398F,
+   -125.000F,
+   112.549F,
+   -19.2871F,
+   -111.816F,
+   -321.777F,
+   -64.2090F,
+   -32.7148F,
+   -127.686F,
+   -404.541F,
+   -106.201F,
+   -120.850F,
+   -186.768F,
+   13.9160F,
+   -84.7168F,
+   -101.074F,
+   105.957F,
+   -278.564F,
+   -59.0820F,
+   -162.109F,
+   -209.229F,
+   8.30078F,
+   -16.6016F,
+   -172.607F,
+   -82.5195F
+
+};
+#define MR515_3_SIZE  128
+
+/* third codebook for MR475, MR515 */
+static const Float32 mr515_3_lsf[] =
+{
+   102.295F,
+   39.7949F,
+   -7.32422F,
+   -63.9648F,
+   -111.084F,
+   -192.627F,
+   -349.121F,
+   -176.025F,
+   245.605F,
+   162.109F,
+   65.6738F,
+   6.10352F,
+   151.123F,
+   63.4766F,
+   44.6777F,
+   23.4375F,
+   -236.328F,
+   -331.543F,
+   -94.7266F,
+   32.9590F,
+   -169.189F,
+   203.857F,
+   111.328F,
+   37.5977F,
+   269.775F,
+   171.631F,
+   138.916F,
+   88.6230F,
+   396.729F,
+   323.730F,
+   240.479F,
+   182.617F,
+   -53.7109F,
+   53.4668F,
+   18.5547F,
+   -50.7813F,
+   -355.225F,
+   -405.762F,
+   11.9629F,
+   36.3770F,
+   -235.352F,
+   -41.9922F,
+   -183.594F,
+   -82.0313F,
+   152.588F,
+   51.0254F,
+   -61.0352F,
+   -16.1133F,
+   -248.291F,
+   -204.590F,
+   -0.488281F,
+   77.3926F,
+   -529.297F,
+   -362.549F,
+   -33.6914F,
+   30.0293F,
+   -458.008F,
+   -512.451F,
+   -127.197F,
+   20.7520F,
+   -236.084F,
+   -89.3555F,
+   -169.678F,
+   -215.088F,
+   -224.854F,
+   -246.826F,
+   -186.279F,
+   -231.689F,
+   -30.2734F,
+   -62.5000F,
+   -85.9375F,
+   -161.133F,
+   43.4570F,
+   113.037F,
+   86.4258F,
+   74.2188F,
+   -425.781F,
+   -144.287F,
+   -68.8477F,
+   19.2871F,
+   -549.072F,
+   42.7246F,
+   211.670F,
+   121.826F,
+   -33.6914F,
+   -43.9453F,
+   -44.1895F,
+   -5.12695F,
+   -559.326F,
+   -302.979F,
+   -112.305F,
+   -126.953F,
+   -188.232F,
+   110.107F,
+   -2.44141F,
+   -75.1953F,
+   66.1621F,
+   -15.8691F,
+   0.976563F,
+   52.2461F,
+   -68.1152F,
+   -106.201F,
+   -10.4980F,
+   -84.9609F,
+   -163.574F,
+   8.54492F,
+   -15.8691F,
+   -51.5137F,
+   196.777F,
+   130.615F,
+   20.7520F,
+   72.5098F,
+   13.9160F,
+   58.3496F,
+   176.270F,
+   120.361F,
+   54.9316F,
+   161.377F,
+   205.078F,
+   133.545F,
+   -131.836F,
+   -91.7969F,
+   3.41797F,
+   85.2051F,
+   114.502F,
+   176.025F,
+   80.8105F,
+   39.5508F,
+   -132.813F,
+   -183.594F,
+   -15.1367F,
+   -2.44141F,
+   97.1680F,
+   -21.4844F,
+   176.758F,
+   171.143F,
+   -4.63867F,
+   -130.127F,
+   -22.9492F,
+   146.729F,
+   33.2031F,
+   -17.3340F,
+   -166.260F,
+   -182.373F,
+   -40.5273F,
+   -83.9844F,
+   63.7207F,
+   -12.2070F,
+   39.3066F,
+   -12.6953F,
+   118.408F,
+   82.2754F,
+   -408.936F,
+   12.2070F,
+   46.3867F,
+   -22.7051F,
+   -557.129F,
+   -56.3965F,
+   -47.3633F,
+   -20.0195F,
+   -23.1934F,
+   -145.264F,
+   -37.5977F,
+   31.2500F,
+   218.262F,
+   122.314F,
+   143.555F,
+   111.572F,
+   -84.2285F,
+   50.2930F,
+   29.7852F,
+   26.8555F,
+   -154.053F,
+   -55.4199F,
+   -138.916F,
+   0.732422F,
+   99.6094F,
+   58.3496F,
+   96.9238F,
+   55.1758F,
+   -48.0957F,
+   -0.488281F,
+   31.2500F,
+   119.873F,
+   312.744F,
+   220.703F,
+   71.2891F,
+   52.4902F,
+   131.348F,
+   74.7070F,
+   63.2324F,
+   124.268F,
+   -165.283F,
+   -255.615F,
+   3.17383F,
+   78.3691F,
+   -165.771F,
+   -143.555F,
+   -87.4023F,
+   -51.7578F,
+   -136.230F,
+   59.3262F,
+   157.715F,
+   116.943F,
+   118.652F,
+   83.4961F,
+   154.785F,
+   129.883F,
+   26.1230F,
+   195.801F,
+   80.8105F,
+   33.2031F,
+   -27.3438F,
+   -97.1680F,
+   -251.709F,
+   -69.8242F,
+   -79.5898F,
+   -172.119F,
+   70.3125F,
+   66.4063F,
+   317.139F,
+   279.297F,
+   287.598F,
+   209.961F,
+   -103.271F,
+   29.5410F,
+   -93.9941F,
+   -36.1328F,
+   -72.0215F,
+   -73.7305F,
+   -203.613F,
+   -199.951F,
+   3.90625F,
+   -5.85938F,
+   -49.0723F,
+   -116.211F,
+   135.498F,
+   22.2168F,
+   -59.8145F,
+   71.7773F,
+   -9.27734F,
+   -92.5293F,
+   -234.863F,
+   -298.096F,
+   -290.771F,
+   -370.605F,
+   -66.6504F,
+   -96.4355F,
+   -95.2148F,
+   -247.314F,
+   -157.471F,
+   139.893F,
+   -449.951F,
+   -251.465F,
+   123.291F,
+   114.258F,
+   181.641F,
+   231.201F,
+   148.682F,
+   120.361F,
+   -168.213F,
+   -286.133F,
+   -153.320F,
+   -32.9590F,
+   -250.488F,
+   47.6074F,
+   100.342F,
+   47.8516F,
+   386.230F,
+   280.029F,
+   140.381F,
+   82.2754F,
+   -302.490F,
+   -189.697F,
+   -158.203F,
+   -34.6680F,
+   145.264F,
+   201.416F,
+   236.084F,
+   179.443F,
+   -294.434F,
+   -236.816F,
+   -19.7754F,
+   -83.4961F,
+   -181.885F,
+   3.17383F,
+   -17.5781F,
+   91.5527F,
+   110.840F,
+   4.63867F,
+   343.506F,
+   224.854F,
+   -402.100F,
+   -41.9922F,
+   210.205F,
+   137.207F,
+   226.563F,
+   375.244F,
+   259.521F,
+   180.664F,
+   -603.516F,
+   -232.422F,
+   64.4531F,
+   20.0195F,
+   -122.559F,
+   -235.596F,
+   -325.684F,
+   30.0293F,
+   211.670F,
+   301.758F,
+   130.371F,
+   41.7480F,
+   -566.406F,
+   -112.305F,
+   190.430F,
+   88.6230F,
+   -290.527F,
+   -150.635F,
+   61.5234F,
+   -14.8926F,
+   -42.4805F,
+   8.30078F,
+   246.826F,
+   192.383F,
+   -569.580F,
+   60.3027F,
+   103.271F,
+   37.3535F,
+   -3.90625F,
+   -86.6699F,
+   63.9648F,
+   109.619F,
+   -384.766F,
+   -261.963F,
+   -132.813F,
+   -90.5762F,
+   -150.146F,
+   -74.4629F,
+   256.592F,
+   196.533F,
+   167.725F,
+   128.906F,
+   1.46484F,
+   -44.4336F,
+   228.271F,
+   213.623F,
+   244.629F,
+   197.510F,
+   48.5840F,
+   62.7441F,
+   30.7617F,
+   18.5547F,
+   -142.578F,
+   -277.832F,
+   146.240F,
+   135.742F,
+   -269.775F,
+   -339.600F,
+   -388.428F,
+   -126.709F,
+   -238.525F,
+   -323.486F,
+   26.3672F,
+   84.7168F,
+   -176.270F,
+   -238.037F,
+   89.1113F,
+   24.6582F,
+   -35.4004F,
+   166.260F,
+   60.7910F,
+   -37.3535F,
+   0.000000F,
+   -81.5430F,
+   -139.160F,
+   38.8184F,
+   100.586F,
+   69.5801F,
+   -82.0313F,
+   -150.635F,
+   -232.666F,
+   -235.840F,
+   216.553F,
+   168.213F,
+   -305.420F,
+   20.5078F,
+   -45.1660F,
+   -97.1680F,
+   -144.531F,
+   105.713F,
+   254.883F,
+   159.424F,
+   20.7520F,
+   80.3223F,
+   -9.76563F,
+   88.1348F,
+   -105.713F,
+   -172.119F,
+   113.770F,
+   140.137F,
+   -37.5977F,
+   159.668F,
+   144.531F,
+   70.8008F,
+   -40.7715F,
+   17.5781F,
+   85.2051F,
+   42.7246F,
+   164.551F,
+   72.5098F,
+   238.525F,
+   175.781F,
+   301.514F,
+   293.945F,
+   184.814F,
+   119.141F,
+   -97.6563F,
+   -65.6738F,
+   131.348F,
+   90.8203F,
+   -329.590F,
+   -338.623F,
+   -291.504F,
+   -22.2168F,
+   308.105F,
+   213.867F,
+   189.209F,
+   170.898F,
+   -146.240F,
+   -9.27734F,
+   -104.980F,
+   -176.270F,
+   482.422F,
+   397.949F,
+   241.943F,
+   148.438F,
+   27.0996F,
+   67.3828F,
+   -55.1758F,
+   -23.4375F,
+   -231.201F,
+   -94.7266F,
+   -2.68555F,
+   -1.70898F,
+   -73.9746F,
+   -129.639F,
+   -204.834F,
+   82.5195F,
+   423.340F,
+   417.480F,
+   343.018F,
+   247.314F,
+   -125.977F,
+   -208.740F,
+   -157.471F,
+   51.2695F,
+   -167.969F,
+   -101.563F,
+   125.244F,
+   56.1523F,
+   -200.684F,
+   -155.518F,
+   -279.785F,
+   -78.1250F,
+   -232.422F,
+   -160.645F,
+   -169.434F,
+   44.6777F,
+   -27.8320F,
+   -152.100F,
+   199.707F,
+   164.551F,
+   -46.6309F,
+   -49.8047F,
+   178.467F,
+   155.029F,
+   12.4512F,
+   298.096F,
+   215.576F,
+   140.625F,
+   -232.910F,
+   -105.225F,
+   201.660F,
+   145.996F,
+   -83.4961F,
+   -184.326F,
+   -219.727F,
+   -99.3652F,
+   -274.902F,
+   -86.4258F,
+   -50.2930F,
+   -125.000F,
+   -133.545F,
+   -197.754F,
+   -87.1582F,
+   -151.367F,
+   16.1133F,
+   125.732F,
+   -17.8223F,
+   -100.098F,
+   -212.891F,
+   -230.713F,
+   -352.539F,
+   -299.561F,
+   46.6309F,
+   -4.15039F,
+   -132.813F,
+   -56.3965F,
+   -375.977F,
+   -132.813F,
+   -219.971F,
+   -216.309F
+
+};
+#define MR795_1_SIZE  512
+
+/* first codebook for MR795 */
+static const Float32 mr795_1_lsf[] =
+{
+   -217.285F,
+   -378.418F,
+   -620.361F,
+   -199.951F,
+   -236.816F,
+   42.7246F,
+   -201.660F,
+   -301.270F,
+   -186.035F,
+   -146.240F,
+   -5.37109F,
+   154.785F,
+   -197.998F,
+   -240.967F,
+   -220.215F,
+   -78.8574F,
+   49.5605F,
+   6.34766F,
+   -93.5059F,
+   -57.3730F,
+   -190.674F,
+   -97.4121F,
+   308.105F,
+   221.191F,
+   -227.539F,
+   -341.553F,
+   -336.914F,
+   -152.344F,
+   22.7051F,
+   21.2402F,
+   -101.074F,
+   -131.592F,
+   -168.701F,
+   9.03320F,
+   154.541F,
+   124.512F,
+   -94.4824F,
+   -116.211F,
+   -324.707F,
+   97.4121F,
+   16.1133F,
+   64.2090F,
+   -99.3652F,
+   -11.9629F,
+   -81.7871F,
+   -101.807F,
+   254.150F,
+   455.322F,
+   -190.186F,
+   -265.869F,
+   -351.563F,
+   -182.129F,
+   -209.473F,
+   203.125F,
+   -141.846F,
+   -185.303F,
+   -90.5762F,
+   -164.307F,
+   -123.535F,
+   509.766F,
+   -136.719F,
+   -154.785F,
+   -287.842F,
+   66.1621F,
+   58.8379F,
+   3.41797F,
+   -106.934F,
+   -59.5703F,
+   -96.9238F,
+   113.037F,
+   293.457F,
+   255.615F,
+   -147.949F,
+   -194.580F,
+   -351.074F,
+   -12.4512F,
+   -78.8574F,
+   117.432F,
+   -54.6875F,
+   -142.578F,
+   -128.662F,
+   120.605F,
+   215.088F,
+   166.504F,
+   -105.713F,
+   -74.7070F,
+   -244.629F,
+   135.254F,
+   160.889F,
+   54.1992F,
+   41.7480F,
+   -39.0625F,
+   -86.1816F,
+   166.260F,
+   438.965F,
+   382.080F,
+   -208.008F,
+   -288.330F,
+   -413.818F,
+   -82.0313F,
+   -162.598F,
+   27.8320F,
+   -141.846F,
+   -184.570F,
+   -181.641F,
+   -47.6074F,
+   91.5527F,
+   121.338F,
+   -113.525F,
+   -196.289F,
+   -268.066F,
+   37.5977F,
+   68.8477F,
+   -31.9824F,
+   -12.2070F,
+   -46.6309F,
+   -175.537F,
+   78.8574F,
+   178.711F,
+   376.465F,
+   -176.270F,
+   -199.951F,
+   -342.773F,
+   25.6348F,
+   -61.0352F,
+   45.1660F,
+   -43.4570F,
+   -122.559F,
+   -181.152F,
+   78.3691F,
+   124.512F,
+   271.240F,
+   -78.8574F,
+   -138.428F,
+   -235.840F,
+   31.0059F,
+   118.164F,
+   82.5195F,
+   -39.0625F,
+   12.6953F,
+   -82.5195F,
+   178.711F,
+   333.740F,
+   379.395F,
+   -152.832F,
+   -195.801F,
+   -414.063F,
+   -69.8242F,
+   -143.066F,
+   165.039F,
+   -169.678F,
+   -83.7402F,
+   -90.3320F,
+   -119.629F,
+   72.0215F,
+   462.158F,
+   -153.809F,
+   -140.137F,
+   -247.559F,
+   -19.5313F,
+   157.471F,
+   -16.8457F,
+   -1.46484F,
+   -77.6367F,
+   -88.8672F,
+   190.918F,
+   354.004F,
+   253.418F,
+   -76.4160F,
+   -178.955F,
+   -340.576F,
+   29.2969F,
+   14.6484F,
+   116.455F,
+   -64.4531F,
+   -142.822F,
+   -30.0293F,
+   173.584F,
+   303.955F,
+   154.541F,
+   -22.2168F,
+   -86.6699F,
+   -248.047F,
+   188.232F,
+   185.059F,
+   63.7207F,
+   61.7676F,
+   19.7754F,
+   -115.723F,
+   227.051F,
+   540.771F,
+   419.922F,
+   -197.266F,
+   -268.311F,
+   -469.971F,
+   -136.719F,
+   -190.918F,
+   41.2598F,
+   -196.289F,
+   -262.207F,
+   -45.8984F,
+   -152.832F,
+   -13.4277F,
+   343.018F,
+   -169.434F,
+   -174.805F,
+   -291.504F,
+   -161.133F,
+   86.4258F,
+   80.3223F,
+   -125.488F,
+   -13.4277F,
+   -132.568F,
+   89.3555F,
+   252.197F,
+   288.574F,
+   -160.645F,
+   -234.131F,
+   -331.299F,
+   -13.4277F,
+   -44.9219F,
+   22.7051F,
+   -147.705F,
+   -69.8242F,
+   -161.621F,
+   98.6328F,
+   109.619F,
+   201.904F,
+   -69.8242F,
+   -85.4492F,
+   -308.350F,
+   153.320F,
+   74.7070F,
+   55.4199F,
+   -3.90625F,
+   35.8887F,
+   -152.100F,
+   45.4102F,
+   225.342F,
+   523.926F,
+   -164.551F,
+   -217.285F,
+   -392.090F,
+   -108.154F,
+   -55.6641F,
+   82.7637F,
+   -90.0879F,
+   -192.871F,
+   -99.8535F,
+   56.3965F,
+   20.9961F,
+   358.643F,
+   -109.375F,
+   -141.846F,
+   -259.033F,
+   145.020F,
+   109.863F,
+   -43.2129F,
+   -30.2734F,
+   -41.5039F,
+   -109.131F,
+   163.818F,
+   282.959F,
+   342.773F,
+   -116.211F,
+   -162.842F,
+   -368.896F,
+   -18.7988F,
+   -33.6914F,
+   174.805F,
+   -43.2129F,
+   -90.8203F,
+   -93.0176F,
+   110.107F,
+   228.027F,
+   223.389F,
+   -61.0352F,
+   -105.469F,
+   -200.684F,
+   66.4063F,
+   202.148F,
+   108.887F,
+   6.34766F,
+   4.63867F,
+   -7.56836F,
+   170.410F,
+   413.086F,
+   529.297F,
+   -157.715F,
+   -238.525F,
+   -469.727F,
+   -43.7012F,
+   -115.479F,
+   65.4297F,
+   -92.5293F,
+   -181.885F,
+   -168.701F,
+   2.68555F,
+   31.0059F,
+   252.197F,
+   -119.141F,
+   -223.877F,
+   -201.416F,
+   14.8926F,
+   78.8574F,
+   32.9590F,
+   35.8887F,
+   -35.4004F,
+   -167.480F,
+   167.236F,
+   191.895F,
+   410.645F,
+   -123.535F,
+   -207.031F,
+   -316.650F,
+   8.54492F,
+   21.9727F,
+   54.1992F,
+   -5.61523F,
+   -84.4727F,
+   -163.574F,
+   111.084F,
+   144.287F,
+   314.209F,
+   -49.5605F,
+   -144.775F,
+   -265.137F,
+   159.180F,
+   85.9375F,
+   106.689F,
+   9.52148F,
+   15.3809F,
+   -111.572F,
+   205.322F,
+   308.838F,
+   513.916F,
+   -126.953F,
+   -215.332F,
+   -386.719F,
+   -80.0781F,
+   -173.584F,
+   346.924F,
+   -145.508F,
+   -83.4961F,
+   -17.0898F,
+   51.0254F,
+   42.2363F,
+   470.703F,
+   -103.271F,
+   -145.996F,
+   -224.854F,
+   102.783F,
+   147.705F,
+   -9.27734F,
+   -0.488281F,
+   -59.8145F,
+   -31.0059F,
+   218.750F,
+   480.713F,
+   277.100F,
+   -92.5293F,
+   -126.465F,
+   -385.498F,
+   42.2363F,
+   28.8086F,
+   183.838F,
+   -13.4277F,
+   -93.0176F,
+   -12.6953F,
+   240.479F,
+   249.268F,
+   183.838F,
+   -0.488281F,
+   -71.0449F,
+   -217.529F,
+   183.838F,
+   242.188F,
+   103.271F,
+   64.4531F,
+   31.9824F,
+   -47.8516F,
+   218.506F,
+   555.176F,
+   620.850F,
+   -155.029F,
+   -265.625F,
+   -610.107F,
+   -129.150F,
+   -239.746F,
+   128.418F,
+   -186.523F,
+   -202.637F,
+   -133.789F,
+   -106.445F,
+   77.1484F,
+   146.240F,
+   -164.795F,
+   -229.492F,
+   -182.129F,
+   -13.9160F,
+   57.6172F,
+   -2.68555F,
+   -49.0723F,
+   -19.7754F,
+   -194.824F,
+   3.90625F,
+   206.299F,
+   380.371F,
+   -179.932F,
+   -240.479F,
+   -295.898F,
+   -114.258F,
+   4.15039F,
+   70.8008F,
+   -68.1152F,
+   -142.578F,
+   -170.898F,
+   44.6777F,
+   200.684F,
+   172.119F,
+   -64.6973F,
+   -120.117F,
+   -289.795F,
+   102.783F,
+   37.1094F,
+   114.258F,
+   -95.2148F,
+   40.5273F,
+   -65.4297F,
+   9.52148F,
+   378.418F,
+   456.055F,
+   -155.029F,
+   -235.840F,
+   -383.545F,
+   -110.596F,
+   -120.117F,
+   222.168F,
+   -69.3359F,
+   -250.732F,
+   -18.3105F,
+   -44.1895F,
+   -32.4707F,
+   452.148F,
+   -108.643F,
+   -152.344F,
+   -286.621F,
+   102.539F,
+   89.5996F,
+   -11.9629F,
+   -94.9707F,
+   -51.7578F,
+   -41.2598F,
+   172.607F,
+   261.963F,
+   294.922F,
+   -131.592F,
+   -173.340F,
+   -353.760F,
+   20.2637F,
+   -39.7949F,
+   118.164F,
+   -57.6172F,
+   -132.568F,
+   -86.6699F,
+   82.5195F,
+   286.865F,
+   198.730F,
+   -60.0586F,
+   -75.4395F,
+   -233.887F,
+   147.949F,
+   185.547F,
+   14.6484F,
+   40.5273F,
+   -1.95313F,
+   -39.7949F,
+   -74.7070F,
+   451.416F,
+   625.732F,
+   -182.373F,
+   -250.244F,
+   -435.303F,
+   -102.295F,
+   -108.887F,
+   51.0254F,
+   -175.293F,
+   -138.184F,
+   -130.371F,
+   -123.535F,
+   169.189F,
+   209.229F,
+   -113.037F,
+   -170.166F,
+   -264.160F,
+   79.3457F,
+   105.225F,
+   -50.2930F,
+   -3.66211F,
+   -1.95313F,
+   -186.279F,
+   133.057F,
+   224.365F,
+   370.605F,
+   -149.170F,
+   -191.162F,
+   -320.557F,
+   62.5000F,
+   -13.4277F,
+   50.7813F,
+   -40.2832F,
+   -84.9609F,
+   -161.621F,
+   78.3691F,
+   166.016F,
+   227.051F,
+   -79.5898F,
+   -104.736F,
+   -232.178F,
+   118.164F,
+   108.887F,
+   139.160F,
+   -48.0957F,
+   17.5781F,
+   -17.8223F,
+   221.924F,
+   355.225F,
+   425.049F,
+   -137.451F,
+   -179.932F,
+   -481.934F,
+   -30.2734F,
+   -101.563F,
+   175.293F,
+   -116.699F,
+   -98.6328F,
+   -76.6602F,
+   -3.90625F,
+   108.887F,
+   399.414F,
+   -134.521F,
+   -131.104F,
+   -183.105F,
+   -14.1602F,
+   155.762F,
+   52.2461F,
+   13.4277F,
+   -45.1660F,
+   -66.1621F,
+   280.273F,
+   317.627F,
+   295.898F,
+   -117.920F,
+   -163.818F,
+   -308.594F,
+   28.5645F,
+   69.5801F,
+   132.568F,
+   -49.8047F,
+   -95.4590F,
+   -27.0996F,
+   125.244F,
+   375.488F,
+   208.496F,
+   -27.8320F,
+   -46.3867F,
+   -238.770F,
+   214.111F,
+   145.264F,
+   113.281F,
+   63.4766F,
+   63.4766F,
+   -75.9277F,
+   182.617F,
+   557.373F,
+   541.016F,
+   -126.221F,
+   -230.713F,
+   -530.029F,
+   -79.5898F,
+   -172.852F,
+   92.2852F,
+   -198.242F,
+   -168.701F,
+   -56.6406F,
+   -136.719F,
+   167.725F,
+   343.994F,
+   -178.711F,
+   -168.457F,
+   -204.102F,
+   -87.6465F,
+   157.471F,
+   94.2383F,
+   -64.6973F,
+   15.1367F,
+   -165.527F,
+   35.4004F,
+   401.367F,
+   294.922F,
+   -135.498F,
+   -241.211F,
+   -301.025F,
+   -19.0430F,
+   3.41797F,
+   27.8320F,
+   -79.8340F,
+   -87.4023F,
+   -119.385F,
+   95.7031F,
+   165.283F,
+   170.166F,
+   -49.0723F,
+   -57.6172F,
+   -278.320F,
+   169.189F,
+   109.619F,
+   43.4570F,
+   -59.3262F,
+   62.5000F,
+   -105.713F,
+   149.170F,
+   338.135F,
+   599.609F,
+   -149.414F,
+   -219.971F,
+   -357.422F,
+   -74.9512F,
+   -4.15039F,
+   121.826F,
+   -76.9043F,
+   -162.842F,
+   -62.0117F,
+   62.5000F,
+   104.492F,
+   357.178F,
+   -118.652F,
+   -103.027F,
+   -257.813F,
+   159.912F,
+   90.3320F,
+   4.39453F,
+   -24.9023F,
+   -45.1660F,
+   -67.3828F,
+   184.326F,
+   385.254F,
+   325.928F,
+   -119.141F,
+   -147.217F,
+   -346.191F,
+   44.4336F,
+   -22.7051F,
+   212.402F,
+   -17.8223F,
+   -111.816F,
+   -84.9609F,
+   203.857F,
+   210.449F,
+   233.643F,
+   -68.8477F,
+   -81.2988F,
+   -182.129F,
+   133.545F,
+   204.834F,
+   104.492F,
+   66.6504F,
+   -21.7285F,
+   3.17383F,
+   229.492F,
+   416.992F,
+   628.906F,
+   -102.051F,
+   -264.648F,
+   -429.199F,
+   -10.7422F,
+   -87.4023F,
+   63.2324F,
+   -121.338F,
+   -156.982F,
+   -136.719F,
+   24.1699F,
+   135.986F,
+   234.619F,
+   -102.783F,
+   -187.012F,
+   -223.877F,
+   72.0215F,
+   79.5898F,
+   44.9219F,
+   42.7246F,
+   3.66211F,
+   -152.832F,
+   129.883F,
+   214.355F,
+   483.643F,
+   -108.154F,
+   -187.500F,
+   -311.279F,
+   53.9551F,
+   38.0859F,
+   65.4297F,
+   9.52148F,
+   -88.6230F,
+   -123.291F,
+   169.678F,
+   188.477F,
+   278.320F,
+   -39.5508F,
+   -112.061F,
+   -222.656F,
+   173.096F,
+   108.398F,
+   160.645F,
+   6.10352F,
+   73.9746F,
+   -76.1719F,
+   309.570F,
+   344.238F,
+   418.701F,
+   -72.5098F,
+   -187.012F,
+   -448.242F,
+   -64.2090F,
+   -26.3672F,
+   261.230F,
+   -99.1211F,
+   -3.17383F,
+   -31.4941F,
+   13.9160F,
+   106.934F,
+   667.480F,
+   -91.3086F,
+   -118.896F,
+   -203.857F,
+   74.2188F,
+   169.922F,
+   40.0391F,
+   25.3906F,
+   -57.3730F,
+   1.22070F,
+   393.311F,
+   463.867F,
+   341.553F,
+   -55.9082F,
+   -142.090F,
+   -323.486F,
+   98.8770F,
+   46.8750F,
+   199.463F,
+   -21.2402F,
+   -106.934F,
+   27.0996F,
+   250.977F,
+   292.725F,
+   242.432F,
+   16.6016F,
+   -42.7246F,
+   -228.027F,
+   252.197F,
+   272.705F,
+   110.107F,
+   116.699F,
+   48.8281F,
+   -60.5469F,
+   519.287F,
+   658.203F,
+   498.535F,
+   -203.857F,
+   -322.998F,
+   -520.264F,
+   -195.068F,
+   -168.945F,
+   113.770F,
+   -198.242F,
+   -251.953F,
+   -114.502F,
+   -151.855F,
+   70.3125F,
+   224.609F,
+   -171.143F,
+   -205.322F,
+   -261.230F,
+   -100.342F,
+   125.000F,
+   1.95313F,
+   -95.2148F,
+   -22.2168F,
+   -181.641F,
+   -7.32422F,
+   254.639F,
+   283.447F,
+   -200.684F,
+   -280.273F,
+   -282.227F,
+   -71.7773F,
+   -11.2305F,
+   26.8555F,
+   -100.342F,
+   -91.3086F,
+   -165.527F,
+   52.2461F,
+   129.639F,
+   163.086F,
+   -99.1211F,
+   -102.539F,
+   -291.504F,
+   118.896F,
+   56.6406F,
+   73.9746F,
+   -77.6367F,
+   22.2168F,
+   -115.234F,
+   30.0293F,
+   300.781F,
+   596.924F,
+   -176.270F,
+   -232.422F,
+   -364.990F,
+   -180.176F,
+   -164.795F,
+   325.195F,
+   -132.568F,
+   -147.949F,
+   -51.5137F,
+   -23.1934F,
+   -23.9258F,
+   368.164F,
+   -134.033F,
+   -125.488F,
+   -291.260F,
+   115.479F,
+   51.5137F,
+   17.8223F,
+   -70.3125F,
+   -27.3438F,
+   -94.9707F,
+   131.104F,
+   325.195F,
+   307.129F,
+   -138.428F,
+   -184.326F,
+   -377.197F,
+   17.3340F,
+   -69.0918F,
+   154.297F,
+   -41.5039F,
+   -117.432F,
+   -120.361F,
+   166.260F,
+   244.629F,
+   199.463F,
+   -86.9141F,
+   -80.8105F,
+   -214.111F,
+   102.295F,
+   172.363F,
+   84.4727F,
+   58.8379F,
+   -8.30078F,
+   -79.5898F,
+   92.0410F,
+   476.074F,
+   459.717F,
+   -177.490F,
+   -262.451F,
+   -396.729F,
+   -56.8848F,
+   -132.568F,
+   28.3203F,
+   -127.930F,
+   -196.777F,
+   -142.822F,
+   -17.8223F,
+   116.699F,
+   177.979F,
+   -70.3125F,
+   -225.830F,
+   -279.053F,
+   42.2363F,
+   109.131F,
+   -12.6953F,
+   16.6016F,
+   -55.9082F,
+   -147.949F,
+   109.619F,
+   129.150F,
+   438.721F,
+   -144.287F,
+   -213.623F,
+   -332.764F,
+   44.6777F,
+   -35.1563F,
+   79.1016F,
+   -25.1465F,
+   -110.352F,
+   -162.598F,
+   152.100F,
+   119.141F,
+   287.109F,
+   -58.1055F,
+   -124.756F,
+   -245.117F,
+   79.5898F,
+   134.766F,
+   111.816F,
+   33.2031F,
+   26.3672F,
+   -77.8809F,
+   152.832F,
+   327.881F,
+   459.717F,
+   -119.629F,
+   -157.715F,
+   -422.363F,
+   -45.4102F,
+   -109.619F,
+   240.234F,
+   -180.176F,
+   -18.5547F,
+   -41.5039F,
+   -134.277F,
+   184.326F,
+   625.000F,
+   -121.094F,
+   -124.512F,
+   -231.201F,
+   51.2695F,
+   169.434F,
+   -12.6953F,
+   20.5078F,
+   -78.6133F,
+   -48.5840F,
+   266.113F,
+   396.729F,
+   298.828F,
+   -91.7969F,
+   -147.217F,
+   -340.820F,
+   83.7402F,
+   18.0664F,
+   154.297F,
+   -42.7246F,
+   -122.559F,
+   -7.81250F,
+   237.305F,
+   325.195F,
+   179.199F,
+   12.6953F,
+   -72.0215F,
+   -271.729F,
+   260.010F,
+   224.121F,
+   39.0625F,
+   95.9473F,
+   26.1230F,
+   -96.9238F,
+   296.387F,
+   646.729F,
+   425.049F,
+   -154.297F,
+   -293.213F,
+   -461.670F,
+   -175.537F,
+   -67.6270F,
+   86.1816F,
+   -158.936F,
+   -214.844F,
+   -29.7852F,
+   -51.5137F,
+   51.0254F,
+   326.660F,
+   -137.207F,
+   -174.316F,
+   -258.545F,
+   -50.7813F,
+   94.7266F,
+   38.8184F,
+   -78.1250F,
+   -14.8926F,
+   -134.521F,
+   71.5332F,
+   266.602F,
+   352.295F,
+   -158.203F,
+   -211.182F,
+   -305.908F,
+   -11.9629F,
+   -34.9121F,
+   74.4629F,
+   -97.9004F,
+   -55.4199F,
+   -142.822F,
+   136.963F,
+   129.883F,
+   226.318F,
+   -28.5645F,
+   -108.154F,
+   -290.039F,
+   123.779F,
+   106.445F,
+   71.2891F,
+   -19.2871F,
+   56.8848F,
+   -111.816F,
+   163.818F,
+   250.244F,
+   584.961F,
+   -154.541F,
+   -205.566F,
+   -372.314F,
+   -75.1953F,
+   -69.8242F,
+   156.250F,
+   -91.0645F,
+   -151.611F,
+   -99.3652F,
+   102.051F,
+   61.7676F,
+   318.604F,
+   -76.9043F,
+   -141.846F,
+   -277.588F,
+   139.648F,
+   167.236F,
+   -68.6035F,
+   14.8926F,
+   -16.6016F,
+   -90.5762F,
+   241.943F,
+   268.799F,
+   365.723F,
+   -120.361F,
+   -166.748F,
+   -332.520F,
+   -11.4746F,
+   40.0391F,
+   171.875F,
+   -62.5000F,
+   -76.6602F,
+   -65.4297F,
+   154.053F,
+   231.689F,
+   256.836F,
+   -28.8086F,
+   -84.9609F,
+   -203.369F,
+   16.6016F,
+   288.086F,
+   138.672F,
+   37.1094F,
+   28.5645F,
+   8.30078F,
+   271.729F,
+   464.355F,
+   546.631F,
+   -146.729F,
+   -234.131F,
+   -416.504F,
+   -34.9121F,
+   -119.385F,
+   117.188F,
+   -81.0547F,
+   -159.912F,
+   -140.137F,
+   13.1836F,
+   86.1816F,
+   291.016F,
+   -112.793F,
+   -159.180F,
+   -194.336F,
+   36.6211F,
+   134.033F,
+   27.3438F,
+   47.6074F,
+   -27.0996F,
+   -125.732F,
+   165.771F,
+   270.508F,
+   402.100F,
+   -136.230F,
+   -182.861F,
+   -297.119F,
+   -2.19727F,
+   66.4063F,
+   83.2520F,
+   -12.9395F,
+   -64.6973F,
+   -130.615F,
+   119.385F,
+   205.811F,
+   316.895F,
+   -29.2969F,
+   -117.676F,
+   -251.953F,
+   154.297F,
+   132.568F,
+   99.6094F,
+   43.7012F,
+   74.7070F,
+   -128.418F,
+   274.414F,
+   357.422F,
+   547.852F,
+   -101.807F,
+   -191.895F,
+   -381.348F,
+   -54.6875F,
+   -93.7500F,
+   333.008F,
+   -92.0410F,
+   -112.061F,
+   -6.10352F,
+   93.9941F,
+   119.385F,
+   530.762F,
+   -81.0547F,
+   -158.936F,
+   -202.393F,
+   132.813F,
+   135.010F,
+   14.8926F,
+   5.37109F,
+   -27.5879F,
+   -21.7285F,
+   275.391F,
+   421.143F,
+   372.070F,
+   -52.7344F,
+   -91.0645F,
+   -403.564F,
+   39.3066F,
+   77.1484F,
+   221.680F,
+   -40.2832F,
+   -54.1992F,
+   -16.3574F,
+   332.520F,
+   286.865F,
+   192.627F,
+   17.8223F,
+   -61.5234F,
+   -187.256F,
+   180.176F,
+   227.539F,
+   150.391F,
+   88.3789F,
+   60.0586F,
+   -30.7617F,
+   192.139F,
+   647.949F,
+   739.014F,
+   -168.701F,
+   -270.020F,
+   -534.668F,
+   -137.939F,
+   -143.555F,
+   127.930F,
+   -144.043F,
+   -239.014F,
+   -119.629F,
+   -64.2090F,
+   96.9238F,
+   239.746F,
+   -140.869F,
+   -204.346F,
+   -230.713F,
+   -5.37109F,
+   106.201F,
+   -11.9629F,
+   -46.3867F,
+   -28.8086F,
+   -153.564F,
+   -21.4844F,
+   302.734F,
+   369.385F,
+   -155.273F,
+   -256.592F,
+   -248.779F,
+   -71.0449F,
+   46.1426F,
+   63.2324F,
+   -62.7441F,
+   -114.746F,
+   -153.564F,
+   35.4004F,
+   230.713F,
+   218.262F,
+   -79.5898F,
+   -88.8672F,
+   -267.090F,
+   132.568F,
+   63.4766F,
+   153.809F,
+   -49.3164F,
+   46.1426F,
+   -51.0254F,
+   87.1582F,
+   336.670F,
+   510.498F,
+   -138.916F,
+   -262.451F,
+   -353.760F,
+   -174.316F,
+   -58.3496F,
+   224.365F,
+   -102.539F,
+   -172.119F,
+   -20.5078F,
+   -26.6113F,
+   -27.8320F,
+   587.646F,
+   -100.830F,
+   -129.150F,
+   -287.354F,
+   117.676F,
+   89.8438F,
+   31.9824F,
+   -45.4102F,
+   -17.5781F,
+   -31.9824F,
+   210.205F,
+   306.396F,
+   297.852F,
+   -149.170F,
+   -160.645F,
+   -327.393F,
+   55.4199F,
+   -29.5410F,
+   154.053F,
+   -42.9688F,
+   -119.385F,
+   -53.2227F,
+   181.885F,
+   286.865F,
+   233.643F,
+   -78.3691F,
+   -36.1328F,
+   -228.516F,
+   163.818F,
+   235.840F,
+   52.7344F,
+   83.0078F,
+   -0.732422F,
+   -34.9121F,
+   114.502F,
+   451.172F,
+   594.971F,
+   -177.979F,
+   -234.619F,
+   -410.889F,
+   -52.0020F,
+   -62.0117F,
+   78.3691F,
+   -124.756F,
+   -106.934F,
+   -127.197F,
+   -30.7617F,
+   177.002F,
+   220.459F,
+   -83.0078F,
+   -167.236F,
+   -251.953F,
+   77.1484F,
+   117.188F,
+   4.88281F,
+   5.61523F,
+   -21.7285F,
+   -134.521F,
+   86.1816F,
+   256.592F,
+   436.768F,
+   -132.813F,
+   -184.814F,
+   -333.008F,
+   72.7539F,
+   -6.10352F,
+   106.445F,
+   -24.4141F,
+   -95.7031F,
+   -126.709F,
+   114.014F,
+   184.082F,
+   263.184F,
+   -51.2695F,
+   -97.1680F,
+   -263.184F,
+   151.367F,
+   160.645F,
+   153.809F,
+   8.05664F,
+   35.8887F,
+   -43.4570F,
+   224.854F,
+   411.865F,
+   468.994F,
+   -79.3457F,
+   -128.906F,
+   -482.910F,
+   0.488281F,
+   -69.5801F,
+   222.168F,
+   -90.5762F,
+   -119.629F,
+   -56.1523F,
+   0.000000F,
+   145.752F,
+   490.723F,
+   -121.094F,
+   -96.4355F,
+   -203.613F,
+   9.03320F,
+   230.713F,
+   59.8145F,
+   44.1895F,
+   -39.0625F,
+   -35.1563F,
+   361.572F,
+   335.205F,
+   331.299F,
+   -86.6699F,
+   -146.729F,
+   -310.059F,
+   72.7539F,
+   78.6133F,
+   164.063F,
+   -47.1191F,
+   -82.0313F,
+   18.7988F,
+   265.869F,
+   374.268F,
+   225.098F,
+   43.2129F,
+   -9.52148F,
+   -274.658F,
+   243.164F,
+   190.674F,
+   130.859F,
+   111.328F,
+   89.3555F,
+   -105.469F,
+   345.459F,
+   595.703F,
+   556.396F,
+   -113.770F,
+   -185.059F,
+   -567.627F,
+   -73.9746F,
+   -124.268F,
+   94.4824F,
+   -177.490F,
+   -135.986F,
+   16.1133F,
+   -35.4004F,
+   156.982F,
+   304.688F,
+   -132.813F,
+   -165.039F,
+   -223.633F,
+   -54.9316F,
+   210.449F,
+   143.555F,
+   -37.1094F,
+   9.76563F,
+   -130.127F,
+   103.271F,
+   347.412F,
+   380.371F,
+   -139.648F,
+   -205.811F,
+   -279.541F,
+   -31.2500F,
+   20.7520F,
+   112.549F,
+   -58.1055F,
+   -62.7441F,
+   -142.578F,
+   147.705F,
+   182.617F,
+   210.205F,
+   5.85938F,
+   -49.3164F,
+   -343.994F,
+   194.580F,
+   118.896F,
+   73.9746F,
+   -44.1895F,
+   88.8672F,
+   -44.4336F,
+   150.391F,
+   336.426F,
+   718.262F,
+   -120.605F,
+   -208.008F,
+   -351.807F,
+   -71.2891F,
+   14.8926F,
+   198.242F,
+   -20.5078F,
+   -176.514F,
+   -44.4336F,
+   135.498F,
+   129.883F,
+   367.676F,
+   -89.1113F,
+   -120.361F,
+   -258.057F,
+   200.684F,
+   143.555F,
+   2.68555F,
+   -3.41797F,
+   -4.39453F,
+   -56.1523F,
+   244.385F,
+   342.041F,
+   354.248F,
+   -115.723F,
+   -138.916F,
+   -315.430F,
+   73.7305F,
+   15.1367F,
+   259.277F,
+   -17.0898F,
+   -91.7969F,
+   -54.1992F,
+   239.746F,
+   237.793F,
+   280.518F,
+   -47.8516F,
+   -57.1289F,
+   -194.092F,
+   116.943F,
+   268.066F,
+   121.826F,
+   88.3789F,
+   14.1602F,
+   17.0898F,
+   280.029F,
+   505.127F,
+   697.510F,
+   -118.896F,
+   -214.355F,
+   -445.313F,
+   17.8223F,
+   -70.3125F,
+   84.9609F,
+   -87.4023F,
+   -122.070F,
+   -124.023F,
+   48.5840F,
+   176.025F,
+   303.223F,
+   -19.0430F,
+   -170.166F,
+   -194.092F,
+   88.1348F,
+   130.859F,
+   47.8516F,
+   91.3086F,
+   26.8555F,
+   -179.443F,
+   206.787F,
+   256.592F,
+   462.891F,
+   -89.3555F,
+   -174.072F,
+   -288.574F,
+   76.9043F,
+   78.1250F,
+   104.736F,
+   17.5781F,
+   -52.4902F,
+   -109.863F,
+   185.303F,
+   216.309F,
+   332.764F,
+   -7.32422F,
+   -104.492F,
+   -203.613F,
+   210.205F,
+   153.076F,
+   194.336F,
+   28.8086F,
+   114.258F,
+   -68.1152F,
+   330.811F,
+   459.717F,
+   462.158F,
+   -45.8984F,
+   -156.738F,
+   -393.555F,
+   15.3809F,
+   -42.7246F,
+   292.480F,
+   -102.051F,
+   -51.5137F,
+   12.4512F,
+   101.074F,
+   143.311F,
+   635.010F,
+   -57.1289F,
+   -135.986F,
+   -209.473F,
+   103.516F,
+   217.041F,
+   54.1992F,
+   33.2031F,
+   -24.6582F,
+   20.2637F,
+   344.971F,
+   556.152F,
+   337.646F,
+   -20.5078F,
+   -108.643F,
+   -339.111F,
+   101.074F,
+   76.4160F,
+   255.127F,
+   7.08008F,
+   -83.7402F,
+   15.8691F,
+   378.906F,
+   402.100F,
+   239.258F,
+   44.6777F,
+   -22.2168F,
+   -202.393F,
+   310.791F,
+   344.971F,
+   87.8906F,
+   135.010F,
+   66.4063F,
+   -26.1230F,
+   387.451F,
+   768.799F,
+   635.498F
+
+};
+
+/*
+ * Quantization tables for split_MQ of 2 sets of LSFs in a 20 ms frame.
+ */
+#define DICO1_SIZE_5 128
+#define DICO2_SIZE_5 256
+#define DICO3_SIZE_5 256
+#define DICO4_SIZE_5 256
+#define DICO5_SIZE_5 64
+static const Float32 dico1_lsf_5[DICO1_SIZE_5 * 4] =
+{
+   -110.107F,
+   -260.010F,
+   -129.150F,
+   -318.604F,
+   -109.863F,
+   -184.570F,
+   -121.338F,
+   -210.693F,
+   -93.7500F,
+   -151.123F,
+   -100.830F,
+   -163.330F,
+   -77.3926F,
+   -131.348F,
+   -80.8105F,
+   -135.742F,
+   -101.074F,
+   -124.023F,
+   -103.516F,
+   -92.2852F,
+   -66.8945F,
+   -79.1016F,
+   -105.957F,
+   -149.902F,
+   -55.1758F,
+   -122.070F,
+   -56.6406F,
+   -125.488F,
+   -64.2090F,
+   -92.0410F,
+   -72.7539F,
+   -100.098F,
+   -36.8652F,
+   -173.340F,
+   -42.4805F,
+   -199.707F,
+   -36.3770F,
+   -100.586F,
+   -38.0859F,
+   -104.736F,
+   -70.3125F,
+   -112.793F,
+   -45.4102F,
+   -49.5605F,
+   -41.5039F,
+   -73.7305F,
+   -46.6309F,
+   -78.3691F,
+   -31.9824F,
+   -35.8887F,
+   -72.5098F,
+   -96.4355F,
+   -55.6641F,
+   -52.2461F,
+   -59.8145F,
+   -46.8750F,
+   -16.3574F,
+   -77.1484F,
+   -17.3340F,
+   -79.8340F,
+   -25.3906F,
+   -50.0488F,
+   -22.9492F,
+   -44.6777F,
+   -34.9121F,
+   -9.27734F,
+   -47.1191F,
+   -23.1934F,
+   3.90625F,
+   -18.5547F,
+   -30.2734F,
+   -60.5469F,
+   5.61523F,
+   -57.8613F,
+   5.85938F,
+   -59.5703F,
+   4.39453F,
+   -33.2031F,
+   10.7422F,
+   -27.0996F,
+   -8.05664F,
+   -5.85938F,
+   -6.10352F,
+   0.000000F,
+   36.3770F,
+   4.63867F,
+   5.61523F,
+   -34.9121F,
+   38.5742F,
+   -41.2598F,
+   42.4805F,
+   -44.1895F,
+   32.4707F,
+   -13.4277F,
+   40.2832F,
+   -6.34766F,
+   27.0996F,
+   20.5078F,
+   23.9258F,
+   18.3105F,
+   21.2402F,
+   44.6777F,
+   -28.0762F,
+   -2.68555F,
+   -1.95313F,
+   31.7383F,
+   2.68555F,
+   41.5039F,
+   62.0117F,
+   18.7988F,
+   50.0488F,
+   4.15039F,
+   44.6777F,
+   27.3438F,
+   63.9648F,
+   47.3633F,
+   49.3164F,
+   70.0684F,
+   23.1934F,
+   46.1426F,
+   -10.2539F,
+   -25.6348F,
+   57.1289F,
+   43.7012F,
+   9.52148F,
+   45.4102F,
+   39.7949F,
+   84.2285F,
+   81.0547F,
+   48.5840F,
+   72.9980F,
+   39.3066F,
+   -13.1836F,
+   69.5801F,
+   -19.0430F,
+   68.6035F,
+   -32.4707F,
+   34.4238F,
+   -44.4336F,
+   27.0996F,
+   60.7910F,
+   83.2520F,
+   66.1621F,
+   88.8672F,
+   22.7051F,
+   98.3887F,
+   18.3105F,
+   95.4590F,
+   22.4609F,
+   124.512F,
+   -33.6914F,
+   53.7109F,
+   -45.1660F,
+   -7.08008F,
+   -8.30078F,
+   88.1348F,
+   -28.0762F,
+   78.1250F,
+   0.732422F,
+   135.254F,
+   24.1699F,
+   69.8242F,
+   53.2227F,
+   144.287F,
+   -59.8145F,
+   99.1211F,
+   -65.4297F,
+   110.596F,
+   0.000000F,
+   141.602F,
+   6.10352F,
+   147.949F,
+   67.1387F,
+   129.883F,
+   36.1328F,
+   109.863F,
+   -17.8223F,
+   180.420F,
+   -69.5801F,
+   126.465F,
+   -70.3125F,
+   22.9492F,
+   -49.5605F,
+   164.551F,
+   -34.1797F,
+   -18.0664F,
+   50.0488F,
+   174.316F,
+   -27.8320F,
+   72.9980F,
+   42.9688F,
+   225.342F,
+   44.4336F,
+   135.986F,
+   58.5938F,
+   172.119F,
+   -3.90625F,
+   125.244F,
+   118.408F,
+   144.775F,
+   71.5332F,
+   93.7500F,
+   110.107F,
+   150.635F,
+   -9.27734F,
+   12.2070F,
+   137.451F,
+   129.150F,
+   73.9746F,
+   51.0254F,
+   112.061F,
+   88.6230F,
+   105.713F,
+   110.352F,
+   109.863F,
+   110.840F,
+   89.5996F,
+   147.949F,
+   116.455F,
+   180.908F,
+   105.469F,
+   86.1816F,
+   89.8438F,
+   65.1855F,
+   88.1348F,
+   174.805F,
+   66.6504F,
+   142.334F,
+   110.596F,
+   40.5273F,
+   124.512F,
+   41.9922F,
+   49.0723F,
+   153.564F,
+   66.8945F,
+   46.6309F,
+   138.672F,
+   156.006F,
+   73.7305F,
+   72.7539F,
+   154.785F,
+   94.4824F,
+   156.982F,
+   85.4492F,
+   143.311F,
+   136.719F,
+   149.414F,
+   137.939F,
+   146.484F,
+   192.383F,
+   118.896F,
+   164.063F,
+   125.000F,
+   247.803F,
+   78.3691F,
+   81.2988F,
+   87.1582F,
+   208.496F,
+   -30.5176F,
+   100.830F,
+   115.723F,
+   173.828F,
+   4.15039F,
+   -36.8652F,
+   137.695F,
+   69.5801F,
+   65.9180F,
+   -58.8379F,
+   237.061F,
+   217.041F,
+   119.385F,
+   53.7109F,
+   124.512F,
+   218.750F,
+   134.033F,
+   225.586F,
+   79.8340F,
+   201.416F,
+   70.8008F,
+   222.412F,
+   131.836F,
+   270.508F,
+   38.5742F,
+   196.533F,
+   48.5840F,
+   233.643F,
+   124.756F,
+   178.223F,
+   24.4141F,
+   213.379F,
+   3.17383F,
+   193.115F,
+   106.201F,
+   154.297F,
+   165.039F,
+   237.305F,
+   60.7910F,
+   219.727F,
+   114.014F,
+   297.363F,
+   190.674F,
+   262.207F,
+   142.822F,
+   191.650F,
+   -5.61523F,
+   163.330F,
+   65.1855F,
+   254.639F,
+   151.123F,
+   264.648F,
+   150.146F,
+   279.541F,
+   151.855F,
+   220.947F,
+   223.633F,
+   256.104F,
+   19.5313F,
+   80.8105F,
+   142.578F,
+   262.451F,
+   21.7285F,
+   156.006F,
+   241.211F,
+   234.619F,
+   187.988F,
+   175.781F,
+   194.824F,
+   170.654F,
+   120.117F,
+   109.131F,
+   219.482F,
+   153.076F,
+   66.1621F,
+   290.039F,
+   177.002F,
+   325.439F,
+   21.2402F,
+   147.217F,
+   203.125F,
+   391.357F,
+   150.391F,
+   275.146F,
+   217.285F,
+   367.432F,
+   244.141F,
+   282.227F,
+   211.426F,
+   246.338F,
+   242.920F,
+   201.904F,
+   280.518F,
+   209.473F,
+   199.463F,
+   354.004F,
+   188.721F,
+   322.266F,
+   122.070F,
+   339.111F,
+   76.1719F,
+   281.494F,
+   -4.88281F,
+   264.648F,
+   15.6250F,
+   313.232F,
+   0.488281F,
+   286.133F,
+   97.4121F,
+   456.299F,
+   125.488F,
+   416.504F,
+   122.559F,
+   399.414F,
+   216.309F,
+   371.582F,
+   101.563F,
+   146.484F,
+   276.123F,
+   329.590F,
+   311.279F,
+   339.355F,
+   217.041F,
+   438.232F,
+   223.145F,
+   431.152F,
+   55.4199F,
+   288.818F,
+   305.176F,
+   445.801F,
+   123.291F,
+   452.637F,
+   224.365F,
+   574.463F,
+   -48.5840F,
+   105.225F,
+   37.1094F,
+   423.584F,
+   -52.0020F,
+   -6.83594F,
+   95.7031F,
+   325.684F,
+   -37.3535F,
+   -12.6953F,
+   238.770F,
+   281.006F,
+   -78.8574F,
+   -97.6563F,
+   198.486F,
+   415.771F,
+   -33.2031F,
+   20.5078F,
+   353.760F,
+   491.943F,
+   -80.8105F,
+   -34.9121F,
+   -33.4473F,
+   291.016F,
+   -62.5000F,
+   130.371F,
+   -38.3301F,
+   251.709F,
+   -74.9512F,
+   -107.178F,
+   132.324F,
+   178.467F,
+   -80.3223F,
+   -102.539F,
+   -23.6816F,
+   150.391F,
+   -88.3789F,
+   -41.0156F,
+   -78.6133F,
+   89.3555F,
+   -60.3027F,
+   -26.8555F,
+   -51.5137F,
+   21.7285F,
+   -47.8516F,
+   -75.4395F,
+   4.88281F,
+   14.4043F,
+   -88.8672F,
+   -113.037F,
+   -69.8242F,
+   21.7285F,
+   -82.0313F,
+   42.7246F,
+   -105.469F,
+   34.4238F,
+   -92.5293F,
+   -46.3867F,
+   -105.957F,
+   -47.8516F,
+   -19.2871F,
+   36.6211F,
+   -67.8711F,
+   -55.4199F,
+   -68.3594F,
+   40.5273F,
+   -135.498F,
+   -103.027F,
+   -37.8418F,
+   132.080F,
+   -89.3555F,
+   13.1836F,
+   -7.08008F,
+   -20.2637F,
+   -73.4863F,
+   -188.965F,
+   45.4102F,
+   153.320F,
+   -96.9238F,
+   -64.4531F,
+   59.0820F,
+   71.5332F,
+   -48.0957F,
+   -142.822F,
+   30.2734F,
+   100.098F,
+   12.9395F,
+   -32.4707F,
+   2.44141F,
+   83.0078F,
+   -139.160F,
+   -260.010F,
+   15.8691F,
+   -108.887F,
+   16.6016F,
+   -120.361F,
+   93.5059F,
+   228.760F,
+   -87.1582F,
+   -173.584F,
+   -87.6465F,
+   -61.0352F,
+   -165.283F,
+   -260.742F,
+   71.2891F,
+   -6.34766F,
+   88.6230F,
+   1.46484F,
+   148.193F,
+   320.557F,
+   -31.0059F,
+   -2.44141F,
+   369.385F,
+   460.449F,
+   174.072F,
+   237.305F,
+   358.643F,
+   532.471F,
+   352.295F,
+   492.188F
+
+};
+static const Float32 dico2_lsf_5[DICO2_SIZE_5 * 4] =
+{
+   -398.193F,
+   -390.625F,
+   -438.477F,
+   -559.082F,
+   -250.732F,
+   -432.129F,
+   -268.555F,
+   -494.385F,
+   -311.768F,
+   -338.867F,
+   -333.740F,
+   -374.512F,
+   -231.201F,
+   -356.689F,
+   -237.305F,
+   -372.070F,
+   -243.896F,
+   -298.340F,
+   -249.023F,
+   -286.133F,
+   -198.975F,
+   -240.967F,
+   -242.188F,
+   -334.717F,
+   -296.875F,
+   -245.605F,
+   -314.697F,
+   -267.090F,
+   -181.641F,
+   -309.570F,
+   -184.326F,
+   -315.674F,
+   -210.449F,
+   -225.342F,
+   -220.947F,
+   -240.234F,
+   -165.527F,
+   -256.592F,
+   -167.236F,
+   -256.348F,
+   -265.381F,
+   -240.479F,
+   -259.277F,
+   -165.771F,
+   -241.455F,
+   -156.494F,
+   -275.146F,
+   -238.281F,
+   -186.035F,
+   -159.668F,
+   -217.285F,
+   -196.777F,
+   -203.369F,
+   -266.357F,
+   -172.363F,
+   -153.564F,
+   -151.611F,
+   -196.777F,
+   -156.250F,
+   -198.242F,
+   -189.209F,
+   -154.785F,
+   -190.186F,
+   -132.568F,
+   -243.164F,
+   -137.939F,
+   -262.451F,
+   -141.602F,
+   -133.301F,
+   -149.170F,
+   -139.648F,
+   -151.123F,
+   -185.547F,
+   -70.8008F,
+   -214.600F,
+   -128.418F,
+   -200.928F,
+   -112.793F,
+   -194.092F,
+   -61.7676F,
+   -135.010F,
+   -101.318F,
+   -143.799F,
+   -107.178F,
+   -130.127F,
+   -83.0078F,
+   -168.945F,
+   -228.271F,
+   -123.291F,
+   -188.477F,
+   -171.387F,
+   -276.123F,
+   -64.2090F,
+   -74.7070F,
+   -237.061F,
+   -117.920F,
+   -108.643F,
+   -18.0664F,
+   -135.498F,
+   -133.789F,
+   -149.902F,
+   -31.4941F,
+   -169.189F,
+   -57.1289F,
+   -96.6797F,
+   -60.0586F,
+   -115.967F,
+   -61.0352F,
+   -64.6973F,
+   -98.6328F,
+   -91.7969F,
+   -125.488F,
+   -101.807F,
+   -124.512F,
+   -73.2422F,
+   -76.4160F,
+   -81.5430F,
+   -162.109F,
+   -113.037F,
+   -198.730F,
+   -94.2383F,
+   -171.875F,
+   -82.2754F,
+   -150.146F,
+   -57.1289F,
+   -49.0723F,
+   -56.8848F,
+   -58.3496F,
+   -40.7715F,
+   -138.428F,
+   -49.5605F,
+   -151.123F,
+   -35.8887F,
+   -101.318F,
+   -28.0762F,
+   -85.9375F,
+   -40.5273F,
+   -183.105F,
+   -41.7480F,
+   -185.791F,
+   -65.9180F,
+   -214.600F,
+   -64.4531F,
+   -220.459F,
+   -89.5996F,
+   -181.641F,
+   10.4980F,
+   -115.967F,
+   3.41797F,
+   -159.424F,
+   10.4980F,
+   -163.574F,
+   2.68555F,
+   -109.375F,
+   -14.4043F,
+   -127.197F,
+   -30.7617F,
+   -29.0527F,
+   -37.8418F,
+   -149.658F,
+   -10.2539F,
+   -210.693F,
+   -6.59180F,
+   -227.295F,
+   33.2031F,
+   -117.920F,
+   44.6777F,
+   -114.258F,
+   13.4277F,
+   -72.7539F,
+   13.4277F,
+   -74.2188F,
+   76.4160F,
+   -148.682F,
+   76.4160F,
+   -175.781F,
+   78.6133F,
+   -40.7715F,
+   24.4141F,
+   -132.080F,
+   -0.732422F,
+   -29.0527F,
+   -27.0996F,
+   -45.6543F,
+   56.8848F,
+   -57.6172F,
+   63.4766F,
+   -57.1289F,
+   6.34766F,
+   -40.2832F,
+   32.7148F,
+   -10.9863F,
+   -9.76563F,
+   -134.033F,
+   87.8906F,
+   -49.5605F,
+   92.2852F,
+   -94.7266F,
+   109.863F,
+   -93.5059F,
+   67.1387F,
+   4.88281F,
+   44.4336F,
+   -25.1465F,
+   60.0586F,
+   -27.0996F,
+   105.225F,
+   9.03320F,
+   112.793F,
+   -35.6445F,
+   118.896F,
+   -38.3301F,
+   -69.3359F,
+   -14.4043F,
+   122.803F,
+   -44.9219F,
+   5.85938F,
+   12.9395F,
+   -0.732422F,
+   13.1836F,
+   29.7852F,
+   63.2324F,
+   81.2988F,
+   16.1133F,
+   118.164F,
+   25.3906F,
+   106.445F,
+   16.6016F,
+   47.6074F,
+   28.3203F,
+   46.3867F,
+   50.2930F,
+   65.6738F,
+   -2.19727F,
+   117.676F,
+   85.9375F,
+   93.2617F,
+   69.5801F,
+   97.4121F,
+   67.6270F,
+   110.352F,
+   62.5000F,
+   16.8457F,
+   45.4102F,
+   3.17383F,
+   72.5098F,
+   -3.17383F,
+   63.2324F,
+   -23.1934F,
+   7.32422F,
+   13.6719F,
+   96.1914F,
+   47.8516F,
+   103.760F,
+   50.0488F,
+   111.328F,
+   68.6035F,
+   140.869F,
+   3.66211F,
+   46.6309F,
+   91.5527F,
+   70.8008F,
+   99.3652F,
+   140.625F,
+   -13.6719F,
+   55.4199F,
+   132.813F,
+   98.8770F,
+   0.000000F,
+   134.033F,
+   -22.4609F,
+   128.906F,
+   -55.9082F,
+   85.6934F,
+   -59.8145F,
+   82.5195F,
+   -88.3789F,
+   106.201F,
+   40.7715F,
+   128.662F,
+   -18.3105F,
+   73.7305F,
+   22.2168F,
+   201.172F,
+   31.4941F,
+   146.240F,
+   121.094F,
+   165.771F,
+   45.4102F,
+   182.861F,
+   37.3535F,
+   179.932F,
+   -68.6035F,
+   146.484F,
+   -84.9609F,
+   150.146F,
+   -57.6172F,
+   187.744F,
+   10.0098F,
+   215.088F,
+   9.27734F,
+   217.285F,
+   -53.7109F,
+   205.322F,
+   -87.1582F,
+   215.576F,
+   -95.9473F,
+   220.459F,
+   -154.785F,
+   115.723F,
+   -108.398F,
+   207.520F,
+   -42.7246F,
+   165.527F,
+   -120.361F,
+   59.0820F,
+   -126.709F,
+   191.650F,
+   -174.316F,
+   142.090F,
+   -132.080F,
+   89.3555F,
+   -132.568F,
+   105.957F,
+   -145.752F,
+   122.070F,
+   -186.768F,
+   54.1992F,
+   -171.387F,
+   223.877F,
+   -181.396F,
+   234.863F,
+   -212.158F,
+   122.314F,
+   -219.482F,
+   133.789F,
+   -92.5293F,
+   48.8281F,
+   -106.201F,
+   38.3301F,
+   -199.951F,
+   52.2461F,
+   -210.205F,
+   38.3301F,
+   -149.902F,
+   9.76563F,
+   -154.297F,
+   22.9492F,
+   -215.576F,
+   -13.1836F,
+   -180.908F,
+   125.977F,
+   -122.314F,
+   72.7539F,
+   -149.902F,
+   -41.7480F,
+   -212.402F,
+   -39.3066F,
+   -211.182F,
+   -5.61523F,
+   -199.707F,
+   22.7051F,
+   -247.803F,
+   -65.1855F,
+   -161.621F,
+   -87.6465F,
+   -134.033F,
+   0.488281F,
+   -107.910F,
+   -29.5410F,
+   -92.0410F,
+   0.000000F,
+   -55.4199F,
+   8.05664F,
+   -101.074F,
+   -30.7617F,
+   -31.4941F,
+   51.7578F,
+   -228.027F,
+   8.30078F,
+   -264.160F,
+   -68.8477F,
+   -273.193F,
+   -65.4297F,
+   -173.340F,
+   -201.416F,
+   -102.539F,
+   -46.6309F,
+   -262.695F,
+   -226.563F,
+   -223.877F,
+   -22.7051F,
+   -153.320F,
+   -87.4023F,
+   23.6816F,
+   1.70898F,
+   -50.2930F,
+   -95.9473F,
+   -24.6582F,
+   5.85938F,
+   -49.5605F,
+   9.27734F,
+   -41.0156F,
+   20.2637F,
+   -146.240F,
+   -103.271F,
+   -68.1152F,
+   104.004F,
+   -170.898F,
+   28.8086F,
+   -18.3105F,
+   50.2930F,
+   -239.502F,
+   -164.307F,
+   -166.016F,
+   101.807F,
+   -89.5996F,
+   9.03320F,
+   -68.1152F,
+   115.723F,
+   -31.4941F,
+   -77.6367F,
+   77.8809F,
+   72.2656F,
+   -152.832F,
+   -9.52148F,
+   83.7402F,
+   146.973F,
+   -169.922F,
+   -9.52148F,
+   -73.9746F,
+   229.492F,
+   25.3906F,
+   56.8848F,
+   -92.7734F,
+   33.4473F,
+   -8.78906F,
+   65.6738F,
+   -18.3105F,
+   -52.2461F,
+   29.2969F,
+   10.4980F,
+   -129.150F,
+   -116.455F,
+   112.061F,
+   40.0391F,
+   -49.3164F,
+   -55.9082F,
+   -11.9629F,
+   -40.7715F,
+   148.682F,
+   193.359F,
+   23.9258F,
+   -53.7109F,
+   223.389F,
+   36.1328F,
+   71.5332F,
+   69.0918F,
+   212.158F,
+   22.2168F,
+   140.381F,
+   96.1914F,
+   79.5898F,
+   -19.0430F,
+   175.049F,
+   16.3574F,
+   89.1113F,
+   -78.8574F,
+   150.391F,
+   -8.78906F,
+   178.467F,
+   6.59180F,
+   151.123F,
+   58.1055F,
+   154.297F,
+   66.6504F,
+   109.375F,
+   24.1699F,
+   195.557F,
+   116.211F,
+   212.158F,
+   66.6504F,
+   167.236F,
+   15.6250F,
+   192.627F,
+   17.5781F,
+   249.268F,
+   52.9785F,
+   193.604F,
+   112.061F,
+   179.199F,
+   87.8906F,
+   157.715F,
+   117.188F,
+   87.8906F,
+   78.6133F,
+   104.736F,
+   113.281F,
+   155.762F,
+   104.980F,
+   184.570F,
+   88.6230F,
+   244.141F,
+   98.6328F,
+   166.748F,
+   128.906F,
+   146.973F,
+   150.146F,
+   159.912F,
+   100.830F,
+   230.957F,
+   167.725F,
+   228.760F,
+   146.973F,
+   220.703F,
+   147.461F,
+   135.498F,
+   179.932F,
+   191.895F,
+   161.621F,
+   114.014F,
+   159.668F,
+   88.3789F,
+   143.799F,
+   226.807F,
+   173.340F,
+   121.582F,
+   116.699F,
+   101.318F,
+   102.539F,
+   169.189F,
+   215.576F,
+   198.486F,
+   166.748F,
+   190.674F,
+   225.830F,
+   222.900F,
+   229.248F,
+   177.246F,
+   178.711F,
+   119.873F,
+   208.252F,
+   129.639F,
+   231.445F,
+   179.199F,
+   235.107F,
+   76.9043F,
+   197.266F,
+   185.791F,
+   184.326F,
+   279.297F,
+   185.547F,
+   159.912F,
+   262.695F,
+   201.660F,
+   258.057F,
+   266.357F,
+   204.590F,
+   244.873F,
+   197.266F,
+   255.615F,
+   276.611F,
+   160.889F,
+   268.799F,
+   242.188F,
+   256.348F,
+   262.207F,
+   262.451F,
+   237.061F,
+   169.434F,
+   299.316F,
+   257.324F,
+   139.404F,
+   205.322F,
+   215.820F,
+   342.773F,
+   336.670F,
+   267.578F,
+   263.672F,
+   210.205F,
+   300.537F,
+   179.443F,
+   313.477F,
+   185.547F,
+   310.547F,
+   241.943F,
+   333.740F,
+   257.080F,
+   306.885F,
+   170.898F,
+   256.348F,
+   130.371F,
+   241.211F,
+   110.596F,
+   308.594F,
+   146.240F,
+   278.320F,
+   165.771F,
+   395.752F,
+   198.975F,
+   337.891F,
+   127.197F,
+   321.533F,
+   95.9473F,
+   381.836F,
+   196.533F,
+   353.516F,
+   167.480F,
+   260.742F,
+   158.203F,
+   213.623F,
+   74.9512F,
+   264.404F,
+   88.1348F,
+   255.615F,
+   77.3926F,
+   345.947F,
+   235.352F,
+   164.795F,
+   139.404F,
+   281.250F,
+   19.2871F,
+   271.973F,
+   -11.4746F,
+   373.535F,
+   75.9277F,
+   420.166F,
+   76.6602F,
+   284.668F,
+   168.213F,
+   125.488F,
+   -22.9492F,
+   85.2051F,
+   68.8477F,
+   344.727F,
+   80.0781F,
+   250.244F,
+   118.896F,
+   -15.8691F,
+   13.9160F,
+   196.533F,
+   236.816F,
+   8.78906F,
+   15.1367F,
+   187.744F,
+   -64.2090F,
+   193.115F,
+   -84.4727F,
+   155.518F,
+   170.654F,
+   -33.4473F,
+   151.367F,
+   130.371F,
+   132.080F,
+   -179.443F,
+   47.3633F,
+   173.584F,
+   73.2422F,
+   -65.4297F,
+   -210.693F,
+   226.074F,
+   187.744F,
+   -172.852F,
+   -104.492F,
+   123.535F,
+   42.4805F,
+   -217.773F,
+   -153.809F,
+   106.201F,
+   133.545F,
+   -350.342F,
+   -62.9883F,
+   151.611F,
+   114.990F,
+   -248.535F,
+   -333.984F,
+   -95.9473F,
+   127.197F,
+   -224.609F,
+   -167.480F,
+   -6.10352F,
+   4.88281F,
+   -239.746F,
+   -282.227F,
+   83.0078F,
+   2.19727F,
+   -380.371F,
+   -277.100F,
+   -85.9375F,
+   11.7188F,
+   -385.498F,
+   -98.1445F,
+   -216.553F,
+   1.46484F,
+   -282.227F,
+   -216.797F,
+   -133.789F,
+   -85.9375F,
+   -401.123F,
+   -285.156F,
+   -38.8184F,
+   148.926F,
+   -494.141F,
+   -235.107F,
+   -54.9316F,
+   47.1191F,
+   -404.297F,
+   -478.516F,
+   -59.8145F,
+   -120.361F,
+   -235.352F,
+   -410.156F,
+   -228.516F,
+   -155.029F,
+   -317.139F,
+   -425.781F,
+   -338.867F,
+   -147.461F,
+   -375.977F,
+   -203.857F,
+   -341.064F,
+   -32.9590F,
+   -387.695F,
+   -70.8008F,
+   -407.715F,
+   -173.828F,
+   -490.967F,
+   -398.438F,
+   -406.006F,
+   -6.59180F,
+   -551.270F,
+   -197.998F,
+   -282.471F,
+   44.9219F,
+   -308.838F,
+   46.1426F,
+   -333.740F,
+   143.066F,
+   -490.967F,
+   49.0723F,
+   -192.871F,
+   173.828F,
+   -295.410F,
+   0.732422F,
+   -252.197F,
+   197.266F,
+   -305.420F,
+   202.637F,
+   -27.0996F,
+   155.029F,
+   -399.414F,
+   109.131F,
+   -113.037F,
+   -231.689F,
+   -108.643F,
+   -226.563F,
+   -123.047F,
+   -283.691F,
+   -122.314F,
+   -295.654F,
+   35.1563F,
+   -85.6934F,
+   -90.8203F,
+   -256.836F,
+   -69.0918F,
+   -258.545F,
+   -68.1152F,
+   -274.170F,
+   -140.381F,
+   -351.074F,
+   -143.311F,
+   -394.043F,
+   -228.271F,
+   -240.234F,
+   55.9082F,
+   168.457F,
+   -224.854F,
+   -175.537F,
+   -98.3887F,
+   332.520F,
+   -167.236F,
+   -113.525F,
+   213.379F,
+   96.9238F,
+   -124.268F,
+   -11.2305F,
+   77.3926F,
+   325.684F,
+   -118.408F,
+   111.328F,
+   198.486F,
+   107.178F,
+   -100.342F,
+   82.7637F,
+   219.238F,
+   260.498F,
+   -103.760F,
+   11.2305F,
+   351.807F,
+   121.338F,
+   -221.924F,
+   -195.313F,
+   357.666F,
+   255.371F,
+   -62.0117F,
+   -78.3691F,
+   349.121F,
+   284.424F,
+   16.6016F,
+   85.4492F,
+   252.441F,
+   162.598F,
+   90.3320F,
+   2.68555F,
+   320.068F,
+   192.871F,
+   34.9121F,
+   56.6406F,
+   254.150F,
+   381.348F,
+   -27.8320F,
+   161.865F,
+   394.531F,
+   263.184F,
+   110.840F,
+   141.357F,
+   311.279F,
+   253.906F,
+   -18.5547F,
+   221.924F,
+   183.594F,
+   260.498F,
+   37.3535F,
+   125.000F,
+   84.9609F,
+   296.387F,
+   149.902F,
+   93.9941F,
+   449.951F,
+   197.266F,
+   65.6738F,
+   252.441F,
+   49.5605F,
+   265.137F,
+   159.180F,
+   248.291F,
+   435.303F,
+   275.879F,
+   104.736F,
+   323.975F,
+   94.4824F,
+   337.891F,
+   -11.9629F,
+   288.818F,
+   -17.5781F,
+   296.631F,
+   -101.563F,
+   244.385F,
+   132.813F,
+   427.002F,
+   -85.9375F,
+   298.584F,
+   -122.559F,
+   292.725F,
+   -143.799F,
+   138.916F,
+   -55.4199F,
+   397.949F,
+   -34.6680F,
+   385.254F,
+   -56.1523F,
+   418.701F,
+   -174.316F,
+   314.453F,
+   -204.590F,
+   341.309F,
+   276.123F,
+   331.299F,
+   -50.7813F,
+   300.781F,
+   106.689F,
+   235.596F,
+   -226.807F,
+   199.707F,
+   197.998F,
+   344.238F,
+   209.717F,
+   367.920F,
+   40.0391F,
+   295.898F,
+   338.623F,
+   437.744F,
+   118.164F,
+   457.520F,
+   111.328F,
+   503.662F,
+   243.164F,
+   285.645F,
+   323.730F,
+   342.285F,
+   321.289F,
+   332.031F,
+   277.100F,
+   308.105F,
+   301.270F,
+   395.020F,
+   332.275F,
+   431.641F,
+   346.924F,
+   299.561F,
+   386.719F,
+   328.857F,
+   208.496F,
+   164.063F,
+   411.377F,
+   382.324F,
+   278.076F,
+   310.059F,
+   492.188F,
+   445.557F,
+   432.861F,
+   385.986F,
+   374.023F,
+   356.445F,
+   363.037F,
+   230.957F,
+   405.029F,
+   249.268F,
+   425.781F,
+   295.898F,
+   339.844F,
+   238.525F,
+   432.617F,
+   283.447F,
+   445.801F,
+   284.180F,
+   419.434F,
+   348.877F,
+   481.689F,
+   388.428F,
+   289.307F,
+   210.938F,
+   520.508F,
+   259.033F,
+   439.209F,
+   198.730F,
+   448.730F,
+   184.814F,
+   513.672F,
+   321.045F,
+   501.465F,
+   307.129F,
+   515.869F,
+   223.389F,
+   569.092F,
+   227.051F,
+   358.154F,
+   280.029F,
+   632.324F,
+   351.318F,
+   548.096F,
+   425.781F,
+   510.254F,
+   395.508F,
+   575.684F,
+   354.980F,
+   650.879F,
+   367.676F,
+   458.008F,
+   448.486F,
+   505.371F,
+   482.178F,
+   424.561F,
+   385.010F,
+   166.504F,
+   314.697F,
+   386.719F,
+   499.268F,
+   354.980F,
+   512.207F,
+   609.863F,
+   489.258F,
+   661.865F,
+   504.395F,
+   177.246F,
+   387.695F,
+   672.852F,
+   570.313F,
+   55.6641F,
+   206.787F,
+   599.609F,
+   405.029F,
+   8.78906F,
+   73.4863F,
+   474.121F,
+   477.783F,
+   -108.887F,
+   -23.4375F,
+   525.879F,
+   340.820F,
+   374.268F,
+   268.799F,
+   3.41797F,
+   148.438F,
+   -225.342F,
+   -178.711F,
+   337.646F,
+   483.887F,
+   328.369F,
+   232.422F,
+   -166.016F,
+   78.3691F,
+   312.744F,
+   309.570F,
+   -389.160F,
+   89.1113F,
+   229.736F,
+   230.957F,
+   -424.072F,
+   -200.684F,
+   579.590F,
+   680.420F,
+   444.580F,
+   680.664F
+
+};
+static const Float32 dico3_lsf_5[DICO3_SIZE_5 * 4] =
+{
+   -442.383F,
+   -555.420F,
+   -458.740F,
+   -619.385F,
+   -400.391F,
+   -451.172F,
+   -413.818F,
+   -489.258F,
+   -297.852F,
+   -466.797F,
+   -298.096F,
+   -514.160F,
+   -380.615F,
+   -387.695F,
+   -384.033F,
+   -379.883F,
+   -291.748F,
+   -394.287F,
+   -298.828F,
+   -421.631F,
+   -331.787F,
+   -281.006F,
+   -394.531F,
+   -475.586F,
+   -311.035F,
+   -339.600F,
+   -318.604F,
+   -342.529F,
+   -392.334F,
+   -287.842F,
+   -409.180F,
+   -320.068F,
+   -352.295F,
+   -360.840F,
+   -333.740F,
+   -219.238F,
+   -306.641F,
+   -258.545F,
+   -324.951F,
+   -276.855F,
+   -239.746F,
+   -276.611F,
+   -280.518F,
+   -367.188F,
+   -263.672F,
+   -319.336F,
+   -249.023F,
+   -288.818F,
+   -239.258F,
+   -362.793F,
+   -236.084F,
+   -364.990F,
+   -241.211F,
+   -225.098F,
+   -255.615F,
+   -262.939F,
+   -204.590F,
+   -287.842F,
+   -209.473F,
+   -298.340F,
+   -276.123F,
+   -254.150F,
+   -259.766F,
+   -187.256F,
+   -212.891F,
+   -282.471F,
+   -171.143F,
+   -214.844F,
+   -172.363F,
+   -221.191F,
+   -188.965F,
+   -248.047F,
+   -141.113F,
+   -263.672F,
+   -195.557F,
+   -360.840F,
+   -144.287F,
+   -271.240F,
+   -144.531F,
+   -279.785F,
+   -174.072F,
+   -338.867F,
+   -156.250F,
+   -335.938F,
+   -145.752F,
+   -258.545F,
+   -101.563F,
+   -220.459F,
+   -167.480F,
+   -203.125F,
+   -161.377F,
+   -172.852F,
+   -108.398F,
+   -211.914F,
+   -119.629F,
+   -224.854F,
+   -91.3086F,
+   -189.453F,
+   -151.123F,
+   -285.645F,
+   -142.822F,
+   -134.033F,
+   -187.744F,
+   -194.092F,
+   -106.201F,
+   -160.889F,
+   -129.395F,
+   -180.908F,
+   -121.582F,
+   -204.346F,
+   -87.1582F,
+   -145.752F,
+   -68.1152F,
+   -212.646F,
+   -59.3262F,
+   -216.553F,
+   -68.8477F,
+   -162.354F,
+   -68.3594F,
+   -162.842F,
+   -40.2832F,
+   -136.719F,
+   -96.1914F,
+   -220.459F,
+   -88.3789F,
+   -100.098F,
+   -109.375F,
+   -142.334F,
+   -99.8535F,
+   -140.137F,
+   -76.4160F,
+   -87.1582F,
+   -155.518F,
+   -133.789F,
+   -139.160F,
+   -106.445F,
+   -218.750F,
+   -123.047F,
+   -93.2617F,
+   -184.814F,
+   -14.1602F,
+   -117.432F,
+   -40.2832F,
+   -150.879F,
+   -46.6309F,
+   -91.3086F,
+   -57.1289F,
+   -93.2617F,
+   -54.1992F,
+   -166.748F,
+   -6.10352F,
+   -117.188F,
+   -102.051F,
+   -87.6465F,
+   -178.223F,
+   -86.1816F,
+   -79.1016F,
+   -38.3301F,
+   -105.469F,
+   -78.6133F,
+   -96.1914F,
+   -73.9746F,
+   -69.3359F,
+   -25.3906F,
+   -146.729F,
+   -70.5566F,
+   -135.742F,
+   -47.8516F,
+   -143.555F,
+   -36.6211F,
+   -160.889F,
+   -148.438F,
+   -115.479F,
+   -5.85938F,
+   -16.6016F,
+   -109.375F,
+   -115.723F,
+   -1.95313F,
+   -123.535F,
+   -10.9863F,
+   -182.617F,
+   -44.9219F,
+   -206.055F,
+   -61.5234F,
+   -219.971F,
+   -22.2168F,
+   -142.578F,
+   -23.6816F,
+   -159.180F,
+   33.6914F,
+   -186.523F,
+   -31.9824F,
+   -165.527F,
+   -2.92969F,
+   -163.574F,
+   40.2832F,
+   -63.2324F,
+   -0.732422F,
+   -205.078F,
+   -26.1230F,
+   -221.924F,
+   9.03320F,
+   -242.188F,
+   10.7422F,
+   -208.496F,
+   -101.318F,
+   -204.834F,
+   3.17383F,
+   -244.385F,
+   -66.1621F,
+   -250.488F,
+   -75.4395F,
+   -194.824F,
+   -116.699F,
+   -203.125F,
+   -119.141F,
+   -230.225F,
+   41.0156F,
+   -271.484F,
+   -94.4824F,
+   -289.307F,
+   -24.6582F,
+   -288.818F,
+   -9.76563F,
+   -229.736F,
+   -77.1484F,
+   -251.465F,
+   -187.988F,
+   -254.883F,
+   -152.588F,
+   -263.916F,
+   -131.348F,
+   -298.828F,
+   -72.9980F,
+   -320.313F,
+   -106.445F,
+   -292.236F,
+   -161.865F,
+   -284.912F,
+   -39.3066F,
+   -296.875F,
+   -168.457F,
+   -302.002F,
+   -202.881F,
+   -349.609F,
+   -175.781F,
+   -342.529F,
+   -120.361F,
+   -219.238F,
+   -180.664F,
+   -225.098F,
+   -195.557F,
+   -269.043F,
+   -98.1445F,
+   -385.498F,
+   -235.352F,
+   -259.033F,
+   -155.762F,
+   -309.814F,
+   -351.074F,
+   -365.967F,
+   -228.027F,
+   -366.699F,
+   -218.506F,
+   -390.137F,
+   -137.695F,
+   -420.654F,
+   -175.049F,
+   -147.949F,
+   -145.752F,
+   -284.668F,
+   -264.893F,
+   -334.229F,
+   -114.258F,
+   -475.098F,
+   -364.502F,
+   -448.730F,
+   -232.666F,
+   -471.680F,
+   -227.295F,
+   -365.967F,
+   -45.8984F,
+   -399.170F,
+   -102.783F,
+   -355.713F,
+   -82.5195F,
+   -353.516F,
+   -5.37109F,
+   -474.121F,
+   -103.027F,
+   -489.746F,
+   -60.7910F,
+   -121.094F,
+   -27.8320F,
+   -466.309F,
+   -184.326F,
+   -314.697F,
+   42.4805F,
+   -354.248F,
+   -26.6113F,
+   -117.676F,
+   -62.7441F,
+   -298.096F,
+   -124.023F,
+   -394.775F,
+   36.8652F,
+   -413.574F,
+   50.7813F,
+   -159.668F,
+   26.1230F,
+   -403.076F,
+   7.08008F,
+   -278.564F,
+   68.1152F,
+   -296.631F,
+   74.7070F,
+   -299.805F,
+   -123.535F,
+   -178.223F,
+   -42.7246F,
+   -301.758F,
+   -24.6582F,
+   -236.572F,
+   134.521F,
+   -212.402F,
+   67.8711F,
+   -200.928F,
+   76.9043F,
+   -137.451F,
+   91.7969F,
+   -256.592F,
+   55.6641F,
+   -123.779F,
+   68.3594F,
+   -146.240F,
+   68.6035F,
+   -185.059F,
+   61.7676F,
+   -74.4629F,
+   92.5293F,
+   -184.326F,
+   -32.7148F,
+   -149.170F,
+   161.133F,
+   -201.172F,
+   130.859F,
+   -199.463F,
+   157.715F,
+   -100.830F,
+   11.9629F,
+   -83.2520F,
+   43.2129F,
+   -110.596F,
+   128.418F,
+   -117.676F,
+   143.799F,
+   -17.3340F,
+   82.7637F,
+   -160.400F,
+   64.4531F,
+   -59.5703F,
+   72.0215F,
+   -57.8613F,
+   76.9043F,
+   -94.4824F,
+   138.916F,
+   -123.535F,
+   -2.19727F,
+   -92.0410F,
+   3.41797F,
+   -39.0625F,
+   161.377F,
+   -52.7344F,
+   9.76563F,
+   -75.1953F,
+   -11.2305F,
+   23.1934F,
+   52.2461F,
+   -59.0820F,
+   40.7715F,
+   -20.9961F,
+   46.8750F,
+   -13.6719F,
+   6.59180F,
+   -18.5547F,
+   7.56836F,
+   8.78906F,
+   75.4395F,
+   -25.8789F,
+   -44.4336F,
+   -27.5879F,
+   18.0664F,
+   -107.666F,
+   -5.37109F,
+   5.61523F,
+   33.9355F,
+   19.7754F,
+   -2.68555F,
+   10.7422F,
+   3.66211F,
+   -21.2402F,
+   -33.4473F,
+   -28.8086F,
+   -50.5371F,
+   -38.5742F,
+   -14.1602F,
+   66.4063F,
+   -22.4609F,
+   -38.0859F,
+   -107.666F,
+   1.95313F,
+   -33.2031F,
+   31.2500F,
+   -53.9551F,
+   24.6582F,
+   -53.2227F,
+   9.76563F,
+   -48.0957F,
+   -18.5547F,
+   -111.328F,
+   2.19727F,
+   -108.643F,
+   8.05664F,
+   -103.271F,
+   55.1758F,
+   14.6484F,
+   17.8223F,
+   -54.1992F,
+   38.0859F,
+   -97.4121F,
+   68.3594F,
+   -77.6367F,
+   59.8145F,
+   -83.2520F,
+   40.5273F,
+   -121.826F,
+   82.7637F,
+   -46.3867F,
+   79.8340F,
+   -53.4668F,
+   79.3457F,
+   -33.4473F,
+   -21.7285F,
+   -145.508F,
+   24.4141F,
+   -153.076F,
+   35.1563F,
+   -165.283F,
+   118.896F,
+   6.83594F,
+   61.5234F,
+   -95.4590F,
+   52.2461F,
+   -10.0098F,
+   68.8477F,
+   -6.83594F,
+   24.1699F,
+   -69.8242F,
+   80.8105F,
+   11.9629F,
+   112.061F,
+   -94.7266F,
+   137.939F,
+   -90.0879F,
+   106.445F,
+   6.83594F,
+   82.0313F,
+   -2.19727F,
+   96.9238F,
+   -40.7715F,
+   150.879F,
+   8.30078F,
+   145.508F,
+   -4.15039F,
+   136.963F,
+   -34.1797F,
+   72.9980F,
+   19.2871F,
+   127.441F,
+   30.5176F,
+   49.5605F,
+   0.488281F,
+   59.5703F,
+   70.3125F,
+   62.2559F,
+   51.5137F,
+   42.7246F,
+   20.0195F,
+   145.508F,
+   45.6543F,
+   126.221F,
+   26.3672F,
+   93.0176F,
+   62.2559F,
+   89.1113F,
+   72.5098F,
+   121.338F,
+   85.9375F,
+   79.8340F,
+   -20.0195F,
+   6.10352F,
+   51.2695F,
+   90.5762F,
+   59.8145F,
+   63.7207F,
+   0.732422F,
+   133.057F,
+   109.619F,
+   34.1797F,
+   71.7773F,
+   10.7422F,
+   72.0215F,
+   51.7578F,
+   84.7168F,
+   59.5703F,
+   120.605F,
+   80.8105F,
+   128.906F,
+   49.0723F,
+   74.9512F,
+   85.2051F,
+   100.342F,
+   149.658F,
+   69.3359F,
+   149.902F,
+   100.830F,
+   113.281F,
+   78.6133F,
+   152.344F,
+   96.9238F,
+   23.6816F,
+   48.8281F,
+   -39.0625F,
+   93.7500F,
+   36.3770F,
+   88.3789F,
+   120.850F,
+   128.174F,
+   65.6738F,
+   142.822F,
+   8.05664F,
+   119.873F,
+   -29.5410F,
+   105.713F,
+   104.248F,
+   149.170F,
+   121.582F,
+   125.977F,
+   41.7480F,
+   108.154F,
+   121.338F,
+   162.598F,
+   107.422F,
+   67.1387F,
+   138.184F,
+   140.381F,
+   35.6445F,
+   156.006F,
+   37.8418F,
+   163.574F,
+   -8.05664F,
+   42.2363F,
+   51.7578F,
+   169.922F,
+   -40.5273F,
+   146.729F,
+   -46.6309F,
+   169.678F,
+   -119.385F,
+   122.803F,
+   42.7246F,
+   181.152F,
+   52.2461F,
+   116.211F,
+   90.8203F,
+   264.404F,
+   141.113F,
+   129.395F,
+   143.066F,
+   189.697F,
+   103.760F,
+   213.379F,
+   76.9043F,
+   205.322F,
+   91.3086F,
+   207.031F,
+   -40.2832F,
+   137.939F,
+   8.54492F,
+   241.943F,
+   -9.52148F,
+   259.277F,
+   80.3223F,
+   173.828F,
+   191.895F,
+   205.078F,
+   157.471F,
+   194.092F,
+   161.377F,
+   165.039F,
+   139.404F,
+   224.121F,
+   154.297F,
+   263.428F,
+   164.307F,
+   199.463F,
+   77.6367F,
+   94.7266F,
+   213.379F,
+   247.070F,
+   137.695F,
+   207.031F,
+   214.844F,
+   151.367F,
+   135.986F,
+   116.943F,
+   163.818F,
+   110.596F,
+   168.945F,
+   114.258F,
+   205.078F,
+   156.738F,
+   206.055F,
+   157.471F,
+   123.535F,
+   104.492F,
+   218.994F,
+   138.428F,
+   204.346F,
+   94.4824F,
+   234.863F,
+   121.826F,
+   168.701F,
+   136.963F,
+   229.248F,
+   226.074F,
+   191.162F,
+   72.2656F,
+   192.871F,
+   65.4297F,
+   250.977F,
+   129.395F,
+   213.379F,
+   80.3223F,
+   133.789F,
+   34.9121F,
+   164.795F,
+   71.0449F,
+   122.803F,
+   16.1133F,
+   254.150F,
+   87.6465F,
+   191.895F,
+   23.6816F,
+   196.533F,
+   8.05664F,
+   204.346F,
+   114.746F,
+   124.756F,
+   11.9629F,
+   266.602F,
+   79.8340F,
+   286.621F,
+   78.8574F,
+   0.732422F,
+   59.0820F,
+   212.891F,
+   115.723F,
+   168.213F,
+   104.736F,
+   324.463F,
+   165.527F,
+   254.395F,
+   151.367F,
+   270.752F,
+   162.109F,
+   78.3691F,
+   47.1191F,
+   217.041F,
+   231.934F,
+   281.494F,
+   213.379F,
+   218.018F,
+   155.029F,
+   214.111F,
+   210.449F,
+   231.445F,
+   222.900F,
+   315.674F,
+   162.354F,
+   322.266F,
+   156.006F,
+   243.408F,
+   193.604F,
+   342.285F,
+   251.465F,
+   287.109F,
+   247.070F,
+   270.996F,
+   234.131F,
+   344.238F,
+   225.830F,
+   342.529F,
+   223.389F,
+   132.568F,
+   210.449F,
+   272.461F,
+   298.340F,
+   203.857F,
+   290.527F,
+   203.857F,
+   290.527F,
+   234.131F,
+   280.273F,
+   280.029F,
+   335.938F,
+   317.383F,
+   291.260F,
+   345.459F,
+   300.537F,
+   325.928F,
+   327.393F,
+   182.129F,
+   266.602F,
+   417.725F,
+   313.232F,
+   339.111F,
+   261.963F,
+   325.684F,
+   382.324F,
+   281.494F,
+   360.107F,
+   401.611F,
+   277.588F,
+   445.557F,
+   297.852F,
+   257.813F,
+   337.402F,
+   371.338F,
+   422.363F,
+   398.438F,
+   377.197F,
+   395.508F,
+   376.465F,
+   208.740F,
+   389.648F,
+   211.182F,
+   406.982F,
+   169.189F,
+   216.064F,
+   418.945F,
+   370.850F,
+   284.912F,
+   316.406F,
+   539.307F,
+   429.688F,
+   476.563F,
+   364.502F,
+   493.164F,
+   361.816F,
+   374.512F,
+   455.566F,
+   413.574F,
+   490.234F,
+   382.324F,
+   182.617F,
+   429.932F,
+   201.416F,
+   71.7773F,
+   339.844F,
+   264.648F,
+   502.441F,
+   151.611F,
+   321.045F,
+   89.1113F,
+   314.209F,
+   48.3398F,
+   250.977F,
+   119.141F,
+   343.750F,
+   60.7910F,
+   98.3887F,
+   247.559F,
+   381.104F,
+   79.1016F,
+   88.6230F,
+   401.611F,
+   254.883F,
+   47.1191F,
+   89.5996F,
+   496.582F,
+   453.857F,
+   -61.2793F,
+   141.357F,
+   183.105F,
+   242.676F,
+   -59.3262F,
+   7.32422F,
+   323.486F,
+   214.600F,
+   -6.83594F,
+   -41.2598F,
+   152.344F,
+   223.877F,
+   -110.596F,
+   38.8184F,
+   45.4102F,
+   334.473F,
+   -149.902F,
+   1.46484F,
+   131.104F,
+   95.7031F,
+   -22.9492F,
+   -71.0449F,
+   190.674F,
+   55.9082F,
+   -31.2500F,
+   -72.7539F,
+   59.8145F,
+   119.873F,
+   -171.143F,
+   -158.203F,
+   237.305F,
+   192.627F,
+   -122.314F,
+   -156.250F,
+   43.4570F,
+   62.2559F,
+   -89.1113F,
+   -95.2148F,
+   -62.2559F,
+   77.3926F,
+   -233.887F,
+   -71.7773F,
+   -46.6309F,
+   55.6641F,
+   -189.209F,
+   -109.131F,
+   38.3301F,
+   -57.8613F,
+   -160.400F,
+   -175.781F,
+   -99.3652F,
+   22.4609F,
+   -28.5645F,
+   -149.170F,
+   81.5430F,
+   -56.1523F,
+   -165.771F,
+   -264.648F,
+   -35.1563F,
+   -77.3926F,
+   -219.971F,
+   -210.205F,
+   -180.176F,
+   -87.8906F,
+   -20.7520F,
+   -177.490F,
+   -21.9727F,
+   -192.139F,
+   24.4141F,
+   -5.37109F,
+   -95.4590F,
+   -64.2090F,
+   -13.6719F,
+   -17.8223F,
+   -82.2754F,
+   -184.082F,
+   1.22070F,
+   -46.1426F,
+   -172.363F,
+   -152.344F,
+   21.7285F,
+   -83.9844F,
+   -32.9590F,
+   -271.729F,
+   -86.1816F,
+   -57.8613F,
+   -166.992F,
+   -277.100F,
+   -67.1387F,
+   -269.043F,
+   -65.6738F,
+   -293.701F,
+   37.1094F,
+   35.4004F,
+   -176.270F,
+   -300.781F,
+   11.9629F,
+   19.5313F,
+   -304.688F,
+   -189.453F,
+   -60.5469F,
+   95.4590F,
+   -178.711F,
+   -133.545F,
+   114.502F,
+   53.2227F,
+   -62.2559F,
+   -210.938F,
+   16.8457F,
+   89.3555F,
+   -40.5273F,
+   -118.408F,
+   -167.969F,
+   46.6309F,
+   -295.898F,
+   -291.992F,
+   -41.5039F,
+   -41.2598F,
+   -319.336F,
+   -398.193F,
+   78.3691F,
+   114.746F,
+   -346.436F,
+   -303.467F,
+   -15.6250F,
+   66.4063F,
+   -332.275F,
+   -60.5469F,
+   120.117F,
+   137.939F,
+   -176.025F,
+   -148.682F,
+   47.6074F,
+   118.408F,
+   -139.893F,
+   -32.4707F,
+   104.248F,
+   49.3164F,
+   -41.7480F,
+   -28.8086F,
+   48.5840F,
+   140.381F,
+   0.488281F,
+   -7.56836F,
+   169.434F,
+   184.326F,
+   -333.496F,
+   -9.52148F,
+   134.766F,
+   135.986F,
+   -119.385F,
+   66.1621F,
+   166.016F,
+   131.104F,
+   3.17383F,
+   -110.596F,
+   208.740F,
+   232.910F,
+   -32.4707F,
+   -12.6953F,
+   -19.7754F,
+   180.176F,
+   -285.400F,
+   155.518F,
+   257.568F,
+   258.545F,
+   -23.1934F,
+   165.039F,
+   307.373F,
+   263.916F,
+   119.385F,
+   74.4629F,
+   -109.619F,
+   232.910F,
+   -130.371F,
+   243.164F,
+   -236.572F,
+   211.426F,
+   -258.301F,
+   258.545F,
+   -315.918F,
+   150.879F,
+   -345.703F,
+   150.635F,
+   -111.816F,
+   333.496F,
+   -38.8184F,
+   444.580F,
+   -188.965F,
+   -128.906F,
+   -3.41797F,
+   270.996F,
+   -293.457F,
+   -219.971F,
+   -188.477F,
+   105.713F,
+   -306.641F,
+   -306.396F,
+   -246.826F,
+   -73.7305F,
+   -146.973F,
+   -142.822F,
+   -185.303F,
+   -395.020F,
+   -185.547F,
+   -378.174F,
+   -205.078F,
+   -468.994F,
+   -199.219F,
+   -131.592F,
+   -431.885F,
+   -545.654F,
+   -55.4199F,
+   -8.78906F,
+   -496.582F,
+   -447.021F,
+   -514.404F,
+   -274.902F,
+   -603.271F,
+   -443.359F,
+   -358.887F,
+   61.5234F,
+   -659.424F,
+   -101.318F,
+   -139.404F,
+   -114.014F,
+   368.408F,
+   379.395F,
+   532.227F,
+   482.178F,
+   567.871F,
+   493.164F
+
+
+};
+static const Float32 dico4_lsf_5[DICO4_SIZE_5 * 4] =
+{
+   -453.369F,
+   -410.400F,
+   -453.369F,
+   -428.467F,
+   -501.953F,
+   -280.762F,
+   -520.996F,
+   -403.809F,
+   -395.264F,
+   -268.311F,
+   -416.016F,
+   -276.123F,
+   -328.369F,
+   -392.578F,
+   -331.787F,
+   -399.902F,
+   -326.660F,
+   -315.674F,
+   -323.486F,
+   -308.838F,
+   -406.250F,
+   -402.588F,
+   -363.037F,
+   -207.764F,
+   -328.613F,
+   -447.266F,
+   -344.971F,
+   -534.180F,
+   -312.988F,
+   -166.260F,
+   -435.791F,
+   -402.588F,
+   -235.840F,
+   -264.160F,
+   -288.818F,
+   -409.180F,
+   -257.324F,
+   -261.963F,
+   -278.809F,
+   -282.715F,
+   -294.678F,
+   -181.641F,
+   -311.035F,
+   -243.408F,
+   -228.027F,
+   -337.646F,
+   -226.318F,
+   -345.703F,
+   -246.582F,
+   -318.604F,
+   -191.162F,
+   -233.154F,
+   -256.104F,
+   -219.727F,
+   -242.432F,
+   -199.463F,
+   -179.932F,
+   -200.928F,
+   -237.305F,
+   -290.283F,
+   -180.176F,
+   -267.090F,
+   -180.176F,
+   -281.738F,
+   -191.406F,
+   -195.557F,
+   -197.754F,
+   -191.895F,
+   -217.773F,
+   -126.953F,
+   -244.141F,
+   -199.707F,
+   -157.227F,
+   -235.596F,
+   -140.869F,
+   -215.332F,
+   -132.080F,
+   -169.434F,
+   -163.818F,
+   -223.877F,
+   -145.264F,
+   -156.738F,
+   -157.715F,
+   -150.146F,
+   -233.398F,
+   -151.611F,
+   -225.830F,
+   -125.732F,
+   -177.490F,
+   -117.920F,
+   -198.975F,
+   -118.408F,
+   -205.078F,
+   -141.113F,
+   -107.422F,
+   -174.072F,
+   -141.113F,
+   -79.3457F,
+   -160.400F,
+   -163.574F,
+   -94.2383F,
+   -139.160F,
+   -107.666F,
+   -162.598F,
+   -125.488F,
+   -192.139F,
+   -95.7031F,
+   -129.150F,
+   -127.441F,
+   -110.596F,
+   -118.896F,
+   -103.271F,
+   -150.391F,
+   -142.822F,
+   -150.635F,
+   -38.3301F,
+   -161.621F,
+   -65.4297F,
+   -166.016F,
+   -84.9609F,
+   -78.6133F,
+   -78.8574F,
+   -154.297F,
+   -108.398F,
+   -74.2188F,
+   -104.980F,
+   -81.0547F,
+   -111.816F,
+   -67.6270F,
+   -114.258F,
+   -160.889F,
+   -193.604F,
+   -77.8809F,
+   -155.273F,
+   -55.4199F,
+   -135.254F,
+   -91.0645F,
+   -84.7168F,
+   -81.5430F,
+   -51.2695F,
+   -111.328F,
+   -46.8750F,
+   -129.395F,
+   -59.0820F,
+   -52.7344F,
+   -48.3398F,
+   -89.3555F,
+   -90.3320F,
+   -82.5195F,
+   -39.3066F,
+   -99.8535F,
+   -182.617F,
+   -26.1230F,
+   -92.7734F,
+   -71.7773F,
+   -156.982F,
+   -54.4434F,
+   -162.354F,
+   -57.1289F,
+   -180.908F,
+   -34.4238F,
+   -121.094F,
+   -31.7383F,
+   -124.512F,
+   -33.9355F,
+   -79.8340F,
+   -41.9922F,
+   -74.4629F,
+   -74.7070F,
+   -141.602F,
+   -40.0391F,
+   -64.2090F,
+   -63.9648F,
+   -41.9922F,
+   -16.3574F,
+   -98.1445F,
+   7.56836F,
+   -89.3555F,
+   -2.44141F,
+   -106.445F,
+   -20.9961F,
+   -128.662F,
+   17.3340F,
+   -92.0410F,
+   -5.37109F,
+   -148.682F,
+   -2.92969F,
+   -165.527F,
+   -16.3574F,
+   -77.8809F,
+   15.3809F,
+   -46.6309F,
+   8.54492F,
+   -44.1895F,
+   -9.52148F,
+   -59.0820F,
+   30.7617F,
+   -40.7715F,
+   -34.1797F,
+   -132.813F,
+   37.8418F,
+   -72.5098F,
+   42.4805F,
+   -72.5098F,
+   9.27734F,
+   -1.95313F,
+   28.5645F,
+   -92.7734F,
+   48.0957F,
+   -110.352F,
+   58.5938F,
+   -127.441F,
+   54.4434F,
+   -25.1465F,
+   26.8555F,
+   -45.6543F,
+   21.2402F,
+   -37.8418F,
+   41.2598F,
+   -11.4746F,
+   38.3301F,
+   6.34766F,
+   -20.2637F,
+   -24.4141F,
+   31.2500F,
+   19.5313F,
+   51.0254F,
+   -15.1367F,
+   1.46484F,
+   1.70898F,
+   5.37109F,
+   1.22070F,
+   77.6367F,
+   -4.88281F,
+   60.5469F,
+   -10.9863F,
+   -48.8281F,
+   -15.3809F,
+   38.0859F,
+   -16.8457F,
+   61.0352F,
+   -44.6777F,
+   90.0879F,
+   -30.7617F,
+   -27.5879F,
+   -18.5547F,
+   -34.6680F,
+   -29.7852F,
+   -15.6250F,
+   -62.0117F,
+   -7.56836F,
+   8.54492F,
+   -43.2129F,
+   -17.3340F,
+   -1.70898F,
+   41.7480F,
+   22.7051F,
+   6.59180F,
+   26.3672F,
+   51.7578F,
+   -80.5664F,
+   -51.0254F,
+   -30.0293F,
+   -17.0898F,
+   -68.1152F,
+   23.1934F,
+   -23.4375F,
+   4.88281F,
+   -45.8984F,
+   -14.8926F,
+   -76.6602F,
+   21.2402F,
+   -73.2422F,
+   -19.0430F,
+   -86.4258F,
+   -32.7148F,
+   2.68555F,
+   29.7852F,
+   -34.1797F,
+   29.7852F,
+   -67.1387F,
+   37.1094F,
+   -71.5332F,
+   34.1797F,
+   -20.0195F,
+   33.6914F,
+   -78.3691F,
+   -27.0996F,
+   -117.188F,
+   -38.0859F,
+   -87.6465F,
+   18.5547F,
+   -62.0117F,
+   -9.76563F,
+   -155.029F,
+   -23.4375F,
+   -127.441F,
+   19.2871F,
+   -123.779F,
+   1.95313F,
+   -65.4297F,
+   73.9746F,
+   -131.592F,
+   16.6016F,
+   -108.887F,
+   14.8926F,
+   -127.441F,
+   74.7070F,
+   27.0996F,
+   46.1426F,
+   -106.201F,
+   29.7852F,
+   -92.5293F,
+   40.5273F,
+   -139.404F,
+   -97.1680F,
+   -154.297F,
+   -18.0664F,
+   -182.373F,
+   -23.1934F,
+   -111.084F,
+   47.3633F,
+   -232.422F,
+   20.2637F,
+   -194.824F,
+   46.8750F,
+   -184.326F,
+   46.8750F,
+   -190.674F,
+   -39.5508F,
+   -151.123F,
+   57.1289F,
+   -161.865F,
+   -72.5098F,
+   -119.141F,
+   -26.6113F,
+   -235.352F,
+   -32.2266F,
+   -204.590F,
+   -16.6016F,
+   -205.811F,
+   14.1602F,
+   -271.484F,
+   -20.9961F,
+   -196.533F,
+   -72.9980F,
+   -230.469F,
+   -61.7676F,
+   -189.941F,
+   -12.2070F,
+   -235.596F,
+   -134.033F,
+   -85.9375F,
+   -23.9258F,
+   -242.188F,
+   -83.7402F,
+   -272.705F,
+   -76.9043F,
+   -272.705F,
+   -74.9512F,
+   -281.982F,
+   -91.3086F,
+   -155.518F,
+   -56.1523F,
+   -284.668F,
+   -10.4980F,
+   -317.139F,
+   -24.4141F,
+   -225.830F,
+   -95.9473F,
+   -311.035F,
+   -146.484F,
+   -168.213F,
+   -31.7383F,
+   -361.084F,
+   -76.1719F,
+   -322.510F,
+   -62.0117F,
+   -357.422F,
+   -107.910F,
+   -315.430F,
+   -149.658F,
+   -307.861F,
+   -122.803F,
+   -366.455F,
+   -89.8438F,
+   -322.754F,
+   6.34766F,
+   -349.609F,
+   -16.1133F,
+   -425.537F,
+   -39.3066F,
+   -401.367F,
+   -114.014F,
+   -429.688F,
+   -133.789F,
+   -340.088F,
+   -138.672F,
+   -379.883F,
+   -212.646F,
+   -364.990F,
+   -252.441F,
+   -338.623F,
+   -139.404F,
+   -468.018F,
+   -128.906F,
+   -435.303F,
+   -30.0293F,
+   -463.135F,
+   -56.3965F,
+   -501.465F,
+   -78.8574F,
+   -500.977F,
+   -221.191F,
+   -482.422F,
+   -138.428F,
+   -468.018F,
+   -151.367F,
+   -499.756F,
+   -241.455F,
+   -262.939F,
+   -90.3320F,
+   -495.850F,
+   -171.875F,
+   -574.951F,
+   -182.861F,
+   -668.945F,
+   -265.869F,
+   -466.064F,
+   38.8184F,
+   -491.211F,
+   60.5469F,
+   -152.832F,
+   -30.0293F,
+   -571.045F,
+   -234.863F,
+   -163.330F,
+   -99.6094F,
+   -336.670F,
+   -286.621F,
+   -110.352F,
+   -88.8672F,
+   -254.883F,
+   -179.443F,
+   -32.2266F,
+   44.6777F,
+   -395.508F,
+   -183.594F,
+   -133.545F,
+   -74.9512F,
+   -189.697F,
+   -307.861F,
+   -23.9258F,
+   10.0098F,
+   -214.844F,
+   -266.357F,
+   -62.7441F,
+   23.6816F,
+   -391.113F,
+   -447.510F,
+   7.56836F,
+   -6.34766F,
+   -157.227F,
+   -136.963F,
+   -43.9453F,
+   -133.301F,
+   -93.9941F,
+   -267.334F,
+   -100.098F,
+   -195.801F,
+   -101.074F,
+   -201.904F,
+   -111.572F,
+   -236.816F,
+   -119.629F,
+   -270.752F,
+   -52.4902F,
+   -223.633F,
+   -35.1563F,
+   -228.760F,
+   -120.361F,
+   -309.814F,
+   -126.221F,
+   -367.920F,
+   44.1895F,
+   24.6582F,
+   -81.0547F,
+   -217.041F,
+   -204.102F,
+   -228.760F,
+   -136.475F,
+   -104.736F,
+   -153.564F,
+   -133.545F,
+   -44.6777F,
+   -82.2754F,
+   -133.057F,
+   -20.0195F,
+   -61.0352F,
+   -69.8242F,
+   1.22070F,
+   -32.2266F,
+   -84.9609F,
+   -61.5234F,
+   -71.5332F,
+   -115.234F,
+   -38.5742F,
+   24.4141F,
+   -7.08008F,
+   48.0957F,
+   -57.6172F,
+   -103.516F,
+   -210.205F,
+   -52.0020F,
+   -34.1797F,
+   -1.70898F,
+   -104.248F,
+   -108.154F,
+   45.6543F,
+   -23.6816F,
+   -166.992F,
+   -179.688F,
+   -71.5332F,
+   62.9883F,
+   -89.8438F,
+   -37.1094F,
+   -36.6211F,
+   95.7031F,
+   -148.682F,
+   42.7246F,
+   -34.6680F,
+   72.9980F,
+   -33.6914F,
+   37.1094F,
+   -29.0527F,
+   80.3223F,
+   -118.652F,
+   -12.6953F,
+   71.5332F,
+   48.3398F,
+   -44.6777F,
+   28.5645F,
+   42.7246F,
+   80.8105F,
+   -14.1602F,
+   -66.8945F,
+   56.3965F,
+   73.2422F,
+   -70.3125F,
+   80.5664F,
+   -74.4629F,
+   90.8203F,
+   -27.0996F,
+   99.8535F,
+   -2.19727F,
+   103.271F,
+   20.2637F,
+   62.5000F,
+   16.3574F,
+   89.5996F,
+   -4.63867F,
+   60.5469F,
+   22.2168F,
+   27.5879F,
+   -8.54492F,
+   99.1211F,
+   -46.6309F,
+   37.5977F,
+   58.1055F,
+   72.2656F,
+   1.22070F,
+   48.0957F,
+   34.4238F,
+   53.9551F,
+   76.4160F,
+   48.3398F,
+   51.5137F,
+   102.783F,
+   59.5703F,
+   81.5430F,
+   21.4844F,
+   104.004F,
+   -59.3262F,
+   110.840F,
+   49.3164F,
+   134.766F,
+   -1.22070F,
+   98.3887F,
+   71.0449F,
+   45.1660F,
+   53.4668F,
+   73.4863F,
+   61.2793F,
+   33.6914F,
+   31.2500F,
+   16.8457F,
+   48.0957F,
+   70.3125F,
+   -34.1797F,
+   -14.8926F,
+   45.8984F,
+   88.1348F,
+   48.0957F,
+   145.996F,
+   107.910F,
+   66.6504F,
+   70.8008F,
+   34.9121F,
+   115.234F,
+   117.676F,
+   38.3301F,
+   90.3320F,
+   101.318F,
+   78.3691F,
+   90.8203F,
+   93.9941F,
+   98.1445F,
+   134.766F,
+   37.8418F,
+   5.85938F,
+   134.277F,
+   64.2090F,
+   -2.68555F,
+   5.12695F,
+   87.8906F,
+   55.4199F,
+   35.8887F,
+   -62.0117F,
+   103.516F,
+   23.6816F,
+   89.3555F,
+   -3.17383F,
+   91.5527F,
+   34.4238F,
+   109.619F,
+   56.6406F,
+   96.6797F,
+   123.779F,
+   115.723F,
+   66.4063F,
+   171.143F,
+   79.1016F,
+   88.3789F,
+   -11.4746F,
+   143.311F,
+   36.1328F,
+   132.568F,
+   16.8457F,
+   97.6563F,
+   -12.4512F,
+   136.963F,
+   14.4043F,
+   53.7109F,
+   -2.44141F,
+   85.9375F,
+   35.8887F,
+   50.2930F,
+   51.5137F,
+   159.424F,
+   45.1660F,
+   137.451F,
+   72.5098F,
+   137.939F,
+   69.3359F,
+   145.020F,
+   29.5410F,
+   187.012F,
+   46.8750F,
+   97.1680F,
+   28.8086F,
+   156.738F,
+   105.957F,
+   56.8848F,
+   64.4531F,
+   117.432F,
+   114.014F,
+   31.4941F,
+   -40.2832F,
+   170.654F,
+   58.3496F,
+   21.9727F,
+   6.34766F,
+   83.4961F,
+   115.723F,
+   -13.4277F,
+   6.59180F,
+   94.7266F,
+   22.9492F,
+   -41.9922F,
+   0.000000F,
+   177.002F,
+   92.5293F,
+   -14.6484F,
+   82.2754F,
+   90.3320F,
+   113.525F,
+   23.1934F,
+   77.8809F,
+   196.777F,
+   145.264F,
+   19.0430F,
+   63.4766F,
+   121.338F,
+   207.764F,
+   51.2695F,
+   136.719F,
+   111.816F,
+   140.137F,
+   -113.281F,
+   49.3164F,
+   121.338F,
+   152.588F,
+   -49.3164F,
+   37.1094F,
+   11.7188F,
+   173.828F,
+   -4.88281F,
+   138.184F,
+   24.4141F,
+   174.561F,
+   111.084F,
+   114.258F,
+   100.342F,
+   147.705F,
+   77.8809F,
+   157.715F,
+   47.6074F,
+   150.146F,
+   97.9004F,
+   131.348F,
+   166.016F,
+   180.420F,
+   49.0723F,
+   162.842F,
+   105.957F,
+   232.910F,
+   110.840F,
+   103.760F,
+   157.715F,
+   119.873F,
+   147.949F,
+   166.260F,
+   101.563F,
+   124.023F,
+   121.338F,
+   200.684F,
+   104.004F,
+   198.975F,
+   161.133F,
+   157.959F,
+   153.320F,
+   174.805F,
+   170.166F,
+   113.770F,
+   150.879F,
+   111.572F,
+   167.236F,
+   112.305F,
+   89.1113F,
+   75.4395F,
+   176.025F,
+   138.428F,
+   204.102F,
+   146.729F,
+   148.682F,
+   73.2422F,
+   201.416F,
+   112.061F,
+   230.225F,
+   167.725F,
+   166.260F,
+   130.127F,
+   223.389F,
+   145.996F,
+   144.287F,
+   59.3262F,
+   213.867F,
+   110.107F,
+   213.379F,
+   102.539F,
+   191.895F,
+   77.3926F,
+   178.711F,
+   53.7109F,
+   225.098F,
+   77.3926F,
+   270.508F,
+   89.5996F,
+   129.639F,
+   113.770F,
+   250.977F,
+   158.447F,
+   257.080F,
+   150.146F,
+   252.441F,
+   135.010F,
+   202.393F,
+   146.973F,
+   249.268F,
+   195.068F,
+   226.318F,
+   196.045F,
+   214.355F,
+   186.279F,
+   195.068F,
+   121.094F,
+   335.205F,
+   188.721F,
+   142.822F,
+   187.988F,
+   196.045F,
+   227.051F,
+   268.311F,
+   193.604F,
+   298.340F,
+   210.449F,
+   295.166F,
+   218.506F,
+   250.244F,
+   177.490F,
+   188.477F,
+   206.299F,
+   286.133F,
+   272.217F,
+   211.670F,
+   249.268F,
+   202.637F,
+   247.314F,
+   205.322F,
+   222.168F,
+   123.535F,
+   171.631F,
+   302.490F,
+   262.939F,
+   151.367F,
+   199.951F,
+   291.992F,
+   264.404F,
+   281.982F,
+   263.916F,
+   278.809F,
+   221.436F,
+   377.686F,
+   273.682F,
+   319.580F,
+   158.203F,
+   327.881F,
+   149.414F,
+   362.305F,
+   241.211F,
+   361.084F,
+   228.760F,
+   240.479F,
+   324.219F,
+   233.154F,
+   327.393F,
+   104.736F,
+   222.168F,
+   205.322F,
+   326.660F,
+   137.695F,
+   287.842F,
+   100.586F,
+   282.227F,
+   348.389F,
+   322.266F,
+   350.098F,
+   324.707F,
+   156.250F,
+   185.547F,
+   421.387F,
+   344.238F,
+   46.3867F,
+   135.498F,
+   261.963F,
+   245.361F,
+   104.004F,
+   62.7441F,
+   204.834F,
+   239.258F,
+   57.3730F,
+   56.3965F,
+   371.094F,
+   284.912F,
+   26.6113F,
+   71.5332F,
+   247.559F,
+   383.057F,
+   74.4629F,
+   34.6680F,
+   280.273F,
+   131.592F,
+   -71.0449F,
+   -26.3672F,
+   296.143F,
+   237.305F,
+   5.37109F,
+   -52.7344F,
+   162.842F,
+   202.148F,
+   -117.676F,
+   106.934F,
+   110.596F,
+   349.365F,
+   -141.846F,
+   -103.027F,
+   192.627F,
+   94.4824F,
+   -87.4023F,
+   -110.840F,
+   42.4805F,
+   190.430F,
+   -8.78906F,
+   -90.8203F,
+   95.2148F,
+   -32.7148F,
+   -153.564F,
+   39.0625F,
+   -74.7070F,
+   183.350F,
+   -307.129F,
+   -80.8105F,
+   43.2129F,
+   127.441F,
+   -60.5469F,
+   140.137F,
+   -61.2793F,
+   156.006F,
+   -129.639F,
+   99.3652F,
+   -145.508F,
+   96.1914F,
+   -102.295F,
+   192.627F,
+   -150.635F,
+   195.557F,
+   -240.723F,
+   97.4121F,
+   -209.229F,
+   177.490F,
+   -1.70898F,
+   126.465F,
+   -171.631F,
+   75.6836F,
+   -279.053F,
+   -5.85938F,
+   -244.629F,
+   70.0684F,
+   -234.375F,
+   88.6230F,
+   -317.139F,
+   76.1719F,
+   -374.512F,
+   59.8145F,
+   -380.127F,
+   74.4629F,
+   6.83594F,
+   37.3535F,
+   -209.717F,
+   -42.7246F,
+   -8.05664F,
+   81.0547F,
+   -341.309F,
+   -37.5977F,
+   51.7578F,
+   100.098F,
+   -144.775F,
+   -48.0957F,
+   -266.602F,
+   -171.875F,
+   -220.703F,
+   -15.8691F,
+   68.8477F,
+   89.5996F,
+   -224.121F,
+   -167.480F,
+   84.2285F,
+   22.7051F,
+   -62.9883F,
+   -87.1582F,
+   169.922F,
+   157.227F,
+   -169.189F,
+   -6.83594F,
+   109.375F,
+   120.361F,
+   -66.6504F,
+   47.1191F,
+   128.662F,
+   133.301F,
+   -59.3262F,
+   -125.244F,
+   93.7500F,
+   -33.2031F,
+   66.6504F,
+   -86.1816F,
+   125.000F,
+   -34.6680F,
+   131.104F,
+   -48.3398F,
+   229.736F,
+   183.105F,
+   20.2637F,
+   60.5469F,
+   141.113F,
+   210.205F,
+   -13.6719F,
+   144.531F,
+   205.566F,
+   10.7422F,
+   217.773F,
+   5.85938F,
+   8.05664F,
+   217.285F,
+   -3.90625F,
+   239.746F,
+   202.881F,
+   341.309F,
+   374.756F,
+   463.379F,
+   418.945F,
+   335.938F,
+   475.586F,
+   357.666F
+};
+static const Float32 dico5_lsf_5[DICO5_SIZE_5 * 4] =
+{
+   -244.629F,
+   -226.807F,
+   -267.578F,
+   -293.701F,
+   -156.494F,
+   -227.295F,
+   -147.461F,
+   -234.619F,
+   -190.186F,
+   -164.307F,
+   -203.857F,
+   -192.383F,
+   -101.563F,
+   -162.109F,
+   -111.816F,
+   -187.012F,
+   -159.180F,
+   -127.197F,
+   -161.621F,
+   -120.850F,
+   -249.756F,
+   -124.268F,
+   -249.756F,
+   -104.492F,
+   -108.398F,
+   -134.766F,
+   -89.8438F,
+   -109.619F,
+   -116.943F,
+   -51.5137F,
+   -257.324F,
+   -220.459F,
+   -77.1484F,
+   -60.7910F,
+   -138.916F,
+   -144.287F,
+   -138.916F,
+   -67.1387F,
+   -132.080F,
+   -46.6309F,
+   -174.805F,
+   -45.8984F,
+   -205.566F,
+   -64.4531F,
+   -81.2988F,
+   -60.5469F,
+   -77.6367F,
+   -55.6641F,
+   -67.1387F,
+   0.244141F,
+   -138.428F,
+   -55.6641F,
+   -28.0762F,
+   -53.9551F,
+   -58.1055F,
+   -91.3086F,
+   -48.0957F,
+   -123.779F,
+   -54.1992F,
+   -141.357F,
+   -62.9883F,
+   -105.469F,
+   -14.8926F,
+   -59.5703F,
+   -84.2285F,
+   0.488281F,
+   -82.5195F,
+   9.52148F,
+   -52.4902F,
+   -41.2598F,
+   -14.1602F,
+   0.000000F,
+   -13.6719F,
+   -1.46484F,
+   -49.5605F,
+   -31.9824F,
+   0.244141F,
+   -45.4102F,
+   -1.22070F,
+   -51.5137F,
+   1.46484F,
+   -92.7734F,
+   2.68555F,
+   -102.051F,
+   -28.3203F,
+   31.9824F,
+   -32.7148F,
+   27.5879F,
+   21.7285F,
+   -0.976563F,
+   17.3340F,
+   -0.488281F,
+   -4.63867F,
+   -46.8750F,
+   63.9648F,
+   5.85938F,
+   46.1426F,
+   36.8652F,
+   -32.4707F,
+   -26.6113F,
+   45.4102F,
+   -37.3535F,
+   40.5273F,
+   -53.4668F,
+   9.03320F,
+   33.9355F,
+   47.1191F,
+   41.7480F,
+   82.2754F,
+   30.2734F,
+   38.5742F,
+   -14.8926F,
+   34.4238F,
+   55.1758F,
+   -3.17383F,
+   46.3867F,
+   56.3965F,
+   8.30078F,
+   86.4258F,
+   26.6113F,
+   77.1484F,
+   49.0723F,
+   59.5703F,
+   40.0391F,
+   80.5664F,
+   -20.7520F,
+   95.2148F,
+   -20.5078F,
+   62.0117F,
+   79.8340F,
+   62.7441F,
+   81.7871F,
+   119.873F,
+   35.8887F,
+   116.211F,
+   25.6348F,
+   13.1836F,
+   18.7988F,
+   106.689F,
+   90.3320F,
+   102.783F,
+   76.6602F,
+   109.619F,
+   83.4961F,
+   80.3223F,
+   30.7617F,
+   164.307F,
+   71.2891F,
+   139.404F,
+   94.7266F,
+   59.3262F,
+   47.1191F,
+   159.424F,
+   78.1250F,
+   151.611F,
+   68.3594F,
+   47.3633F,
+   92.7734F,
+   126.221F,
+   141.846F,
+   10.9863F,
+   78.8574F,
+   27.0996F,
+   103.027F,
+   119.385F,
+   96.4355F,
+   179.199F,
+   130.371F,
+   151.855F,
+   133.301F,
+   118.652F,
+   122.559F,
+   77.6367F,
+   139.648F,
+   46.1426F,
+   134.277F,
+   93.9941F,
+   103.027F,
+   -38.3301F,
+   37.3535F,
+   -30.5176F,
+   93.2617F,
+   -48.0957F,
+   94.2383F,
+   -64.2090F,
+   81.5430F,
+   55.6641F,
+   170.166F,
+   -45.8984F,
+   0.244141F,
+   12.4512F,
+   72.5098F,
+   -123.779F,
+   52.0020F,
+   -91.7969F,
+   96.9238F,
+   -5.85938F,
+   62.2559F,
+   -133.545F,
+   21.7285F,
+   -122.559F,
+   -22.9492F,
+   94.4824F,
+   43.7012F,
+   -151.367F,
+   16.6016F,
+   -166.992F,
+   27.3438F,
+   -156.738F,
+   -85.4492F,
+   -63.4766F,
+   41.9922F,
+   -106.934F,
+   -79.1016F,
+   64.4531F,
+   158.203F,
+   -235.352F,
+   -0.976563F,
+   -273.682F,
+   1.70898F,
+   -32.7148F,
+   32.7148F,
+   -276.611F,
+   -74.7070F,
+   34.9121F,
+   23.4375F,
+   -102.539F,
+   -121.338F,
+   -298.096F,
+   -85.4492F,
+   -372.803F,
+   -167.236F,
+   -39.3066F,
+   17.5781F,
+   213.135F,
+   168.701F,
+   178.711F,
+   69.0918F,
+   224.854F,
+   86.1816F,
+   81.5430F,
+   115.967F,
+   267.334F,
+   200.439F,
+   210.938F,
+   127.930F,
+   205.811F,
+   121.338F,
+   174.316F,
+   173.584F,
+   192.383F,
+   183.105F,
+   262.695F,
+   174.316F,
+   293.945F,
+   183.838F,
+
+};
+
+/* Table for MR475 gain */
+#define MR475_VQ_SIZE 256
+
+/* The table contains the following data:
+ *
+ *    g_pitch(0)         // for sub-
+ *    g_fac(0)           // frame 0 and 2
+ *    g_pitch(1)         // for sub-
+ *    g_fac(1)           // frame 1 and 3
+ *
+ */
+static const Float32 table_gain_MR475[MR475_VQ_SIZE * 4] =
+{
+0.049561F, 0.031250F,
+0.033081F, 0.034180F,
+0.175354F, 0.277100F,
+0.138306F, 0.830566F,
+0.126160F, 0.137451F,
+0.773743F, 0.157959F,
+0.252197F, 0.438965F,
+0.341858F, 1.290283F,
+0.469299F, 0.091309F,
+0.227966F, 0.107666F,
+0.666016F, 0.644043F,
+0.720642F, 0.608887F,
+1.250610F, 0.194580F,
+0.318481F, 0.164795F,
+0.410400F, 2.039551F,
+0.322388F, 0.414063F,
+0.090820F, 0.104492F,
+0.359009F, 0.110352F,
+0.325439F, 0.994141F,
+0.218689F, 0.309570F,
+0.150696F, 0.219971F,
+0.970093F, 0.245361F,
+0.914429F, 0.798584F,
+0.630554F, 1.186035F,
+0.221863F, 0.493408F,
+0.158447F, 0.203857F,
+0.754395F, 1.194336F,
+0.744995F, 0.416016F,
+0.819824F, 0.391602F,
+0.556519F, 0.571533F,
+0.242188F, 0.375488F,
+0.334412F, 2.425781F,
+0.231628F, 0.101807F,
+0.082947F, 0.101074F,
+0.222168F, 0.383057F,
+0.487976F, 0.864502F,
+0.696106F, 0.157471F,
+0.521973F, 0.155029F,
+0.247559F, 0.336182F,
+1.013672F, 1.495117F,
+0.697021F, 0.170898F,
+0.122498F, 0.148193F,
+0.757751F, 0.385254F,
+0.678650F, 1.136230F,
+0.834961F, 0.416992F,
+0.731812F, 0.300049F,
+0.488037F, 1.781494F,
+0.807556F, 1.395264F,
+0.148193F, 0.282959F,
+0.126526F, 0.473877F,
+0.379517F, 1.494385F,
+0.216431F, 0.440430F,
+0.544739F, 0.439941F,
+0.529724F, 0.385742F,
+0.850525F, 0.873047F,
+0.812561F, 1.522705F,
+0.374878F, 0.275879F,
+0.365845F, 0.423340F,
+0.863098F, 1.138184F,
+0.687927F, 0.810791F,
+0.746216F, 0.378662F,
+0.850281F, 0.736084F,
+0.310120F, 2.554688F,
+0.576416F, 1.637207F,
+0.103088F, 0.166748F,
+0.087646F, 0.318848F,
+0.440186F, 0.960205F,
+0.249146F, 0.662354F,
+0.475647F, 0.171875F,
+0.919800F, 0.195801F,
+0.384460F, 1.272461F,
+0.264709F, 1.307861F,
+0.407471F, 0.132080F,
+0.369995F, 0.152832F,
+0.833191F, 0.903320F,
+0.701782F, 0.587891F,
+0.986084F, 0.174805F,
+0.743225F, 0.183350F,
+0.492249F, 2.804932F,
+0.385376F, 0.550781F,
+0.272583F, 0.121094F,
+0.445129F, 0.127686F,
+0.623352F, 0.935791F,
+0.512329F, 0.741455F,
+0.512878F, 0.235840F,
+0.868408F, 0.458984F,
+0.531189F, 1.320557F,
+1.000671F, 1.187256F,
+0.452881F, 0.483154F,
+0.371643F, 0.300293F,
+0.571960F, 1.073730F,
+0.888550F, 0.821045F,
+0.827576F, 0.701416F,
+0.803406F, 0.357666F,
+0.337769F, 0.409668F,
+0.801880F, 3.606201F,
+0.447876F, 0.146484F,
+0.080444F, 0.133789F,
+0.259521F, 0.864014F,
+0.613037F, 0.577148F,
+0.646179F, 0.151855F,
+0.798828F, 0.163330F,
+0.862183F, 0.860840F,
+0.307556F, 2.388672F,
+0.936157F, 0.151123F,
+0.190125F, 0.144043F,
+1.003540F, 0.735596F,
+0.948608F, 1.017578F,
+0.948303F, 0.393311F,
+0.940247F, 0.299805F,
+0.977966F, 2.270264F,
+0.459839F, 1.214844F,
+0.121460F, 0.296143F,
+0.698669F, 0.282471F,
+0.763672F, 1.347412F,
+0.578308F, 0.645508F,
+0.470947F, 0.496582F,
+0.810547F, 0.546631F,
+0.977234F, 1.243408F,
+0.492310F, 1.650635F,
+0.615417F, 0.344971F,
+0.305298F, 0.572998F,
+0.764343F, 1.458740F,
+0.923218F, 0.707764F,
+1.114746F, 0.558838F,
+0.966003F, 0.616943F,
+0.992737F, 2.503418F,
+0.894226F, 2.763428F,
+0.109680F, 0.082275F,
+0.190125F, 0.096924F,
+0.214233F, 0.714844F,
+0.280273F, 0.651855F,
+0.458923F, 0.153320F,
+0.696716F, 0.160156F,
+0.362915F, 0.594482F,
+0.399414F, 1.798584F,
+0.502808F, 0.202393F,
+0.244141F, 0.210693F,
+0.612305F, 0.608398F,
+0.980042F, 0.866943F,
+1.111084F, 0.257324F,
+0.372498F, 0.354980F,
+0.359131F, 1.928711F,
+1.144531F, 0.846680F,
+0.113770F, 0.132813F,
+0.561401F, 0.166748F,
+0.709412F, 1.015625F,
+0.280396F, 0.401367F,
+0.192749F, 0.282471F,
+0.973694F, 0.625000F,
+0.753723F, 0.911377F,
+1.063232F, 1.284180F,
+0.372681F, 0.489258F,
+0.178040F, 0.425293F,
+1.005066F, 1.283447F,
+1.024597F, 0.410156F,
+1.050110F, 0.429443F,
+0.291321F, 0.788818F,
+0.450806F, 1.473389F,
+0.875366F, 2.444336F,
+0.246277F, 0.107910F,
+0.255981F, 0.111816F,
+0.562378F, 0.547363F,
+0.453308F, 1.029541F,
+0.784912F, 0.195557F,
+0.682739F, 0.201416F,
+0.771973F, 0.508789F,
+0.790771F, 1.600098F,
+0.580139F, 0.243164F,
+0.404602F, 0.240479F,
+0.643127F, 0.610840F,
+0.933167F, 1.222168F,
+0.769165F, 0.501709F,
+0.945068F, 0.403564F,
+0.988403F, 1.689697F,
+0.868591F, 1.413574F,
+0.160278F, 0.202148F,
+0.342712F, 0.411621F,
+0.833923F, 1.410645F,
+0.223877F, 0.379395F,
+0.690491F, 0.642822F,
+0.596313F, 0.356201F,
+0.854675F, 1.155518F,
+0.970276F, 1.535889F,
+0.383179F, 0.456543F,
+0.482788F, 0.557861F,
+1.036255F, 1.115967F,
+1.011719F, 0.939697F,
+0.930664F, 0.564209F,
+0.977966F, 0.791992F,
+0.882507F, 4.347656F,
+0.723083F, 0.674561F,
+0.120911F, 0.343506F,
+0.085449F, 0.213867F,
+0.264587F, 0.865967F,
+0.268005F, 1.027832F,
+0.329895F, 0.166016F,
+1.065735F, 0.190674F,
+0.396790F, 1.249512F,
+0.493835F, 1.874268F,
+0.448914F, 0.193848F,
+0.508606F, 0.288574F,
+0.918030F, 0.771484F,
+0.911133F, 0.741943F,
+1.246399F, 0.214844F,
+0.887756F, 0.208008F,
+0.752991F, 3.590820F,
+0.421387F, 0.468750F,
+0.257874F, 0.227783F,
+0.501587F, 0.265381F,
+0.650574F, 0.997070F,
+0.615356F, 1.106689F,
+0.166931F, 0.205078F,
+1.260803F, 0.263916F,
+1.019958F, 1.456543F,
+0.968811F, 1.117676F,
+0.663513F, 0.628418F,
+0.230286F, 0.284668F,
+0.886169F, 0.987305F,
+1.263367F, 0.641357F,
+0.928894F, 0.667480F,
+0.932251F, 0.533691F,
+0.381897F, 0.787598F,
+0.801086F, 4.755859F,
+0.439209F, 0.227051F,
+0.150269F, 0.395020F,
+0.275574F, 0.754883F,
+0.845459F, 1.044189F,
+0.638428F, 0.203369F,
+1.058289F, 0.197754F,
+1.030945F, 0.558838F,
+0.948853F, 2.006104F,
+0.830261F, 0.411133F,
+0.195129F, 0.447754F,
+0.973389F, 0.688477F,
+0.965088F, 1.300537F,
+1.037964F, 0.595215F,
+1.024658F, 0.323730F,
+0.956482F, 1.991211F,
+0.715698F, 2.088867F,
+0.229614F, 0.501221F,
+0.583679F, 0.321533F,
+0.827698F, 1.657715F,
+0.746277F, 0.472656F,
+0.499268F, 0.866699F,
+0.810974F, 0.434082F,
+0.994812F, 1.611084F,
+0.994324F, 1.894043F,
+0.520081F, 0.622803F,
+0.440979F, 0.645752F,
+1.115051F, 1.828369F,
+1.030579F, 0.548828F,
+1.091431F, 0.704102F,
+1.053772F, 0.812500F,
+0.574768F, 4.922363F,
+0.673950F, 2.031250F,
+0.078491F, 0.151367F,
+0.087341F, 0.142334F,
+0.365784F, 0.558838F,
+0.242798F, 0.885254F,
+0.313965F, 0.183594F,
+0.818420F, 0.202637F,
+0.338928F, 0.698242F,
+0.718018F, 1.442383F,
+0.655334F, 0.136719F,
+0.332397F, 0.137695F,
+0.813049F, 0.734375F,
+0.729126F, 0.899170F,
+1.213806F, 0.194824F,
+0.599670F, 0.177734F,
+0.833923F, 2.135742F,
+0.451111F, 0.745361F,
+0.153503F, 0.189941F,
+0.369263F, 0.203369F,
+0.394836F, 1.238770F,
+0.506897F, 0.601318F,
+0.374817F, 0.455322F,
+0.934326F, 0.308105F,
+0.879395F, 1.110107F,
+0.833923F, 1.102295F,
+0.191467F, 0.728271F,
+0.151306F, 0.307373F,
+0.920898F, 1.134521F,
+0.938843F, 0.636475F,
+0.884521F, 0.583984F,
+0.760620F, 0.619385F,
+0.460144F, 0.719971F,
+0.787903F, 2.944336F,
+0.333740F, 0.166992F,
+0.191711F, 0.176270F,
+0.310120F, 0.311035F,
+0.777100F, 1.025391F,
+0.933960F, 0.166260F,
+0.477234F, 0.144531F,
+0.398804F, 0.493408F,
+1.005737F, 2.133057F,
+0.815674F, 0.215332F,
+0.329407F, 0.219482F,
+0.894531F, 0.531738F,
+0.899719F, 1.031982F,
+0.870972F, 0.316895F,
+0.850159F, 0.495361F,
+0.944641F, 1.826660F,
+0.965271F, 1.116211F,
+0.153870F, 0.491455F,
+0.308960F, 0.440430F,
+0.314880F, 1.606934F,
+0.435181F, 0.878174F,
+0.666504F, 0.393311F,
+0.715881F, 0.416992F,
+1.031677F, 0.843506F,
+0.992920F, 1.621094F,
+0.567993F, 0.245850F,
+0.571838F, 0.514160F,
+1.170776F, 1.229736F,
+0.759338F, 1.042236F,
+0.971619F, 0.325195F,
+0.937317F, 0.857422F,
+0.726196F, 3.452393F,
+0.982727F, 1.673340F,
+0.122681F, 0.179932F,
+0.230652F, 0.210205F,
+0.699097F, 0.703125F,
+0.217529F, 0.864258F,
+0.552795F, 0.302979F,
+0.756287F, 0.218750F,
+0.521606F, 1.130127F,
+0.705627F, 1.410156F,
+0.496155F, 0.143799F,
+0.501587F, 0.143555F,
+1.143066F, 0.916748F,
+0.791809F, 0.768799F,
+0.960022F, 0.185059F,
+1.015259F, 0.184082F,
+0.929077F, 2.719238F,
+0.968689F, 0.539063F,
+0.285217F, 0.148926F,
+0.623657F, 0.165527F,
+0.931213F, 1.012207F,
+0.349670F, 0.812256F,
+0.511292F, 0.407715F,
+1.212280F, 0.566650F,
+0.942993F, 1.345459F,
+0.857788F, 1.338135F,
+0.349609F, 0.705078F,
+0.462646F, 0.328613F,
+0.877930F, 1.300049F,
+0.990967F, 0.964355F,
+0.922729F, 0.914063F,
+0.934204F, 0.350342F,
+0.890930F, 0.993652F,
+0.750793F, 3.832031F,
+0.464905F, 0.414795F,
+0.132446F, 0.215820F,
+0.272156F, 1.114990F,
+1.104370F, 0.807129F,
+0.777710F, 0.198975F,
+0.911011F, 0.221436F,
+0.916504F, 1.045166F,
+0.947144F, 2.042969F,
+1.098267F, 0.265381F,
+0.143921F, 0.211182F,
+0.993713F, 0.924561F,
+0.956970F, 1.122070F,
+0.998291F, 0.374512F,
+1.012207F, 0.539551F,
+1.027405F, 2.367432F,
+0.972229F, 1.101807F,
+0.200012F, 0.264893F,
+0.588562F, 0.533936F,
+0.730774F, 1.481445F,
+0.561462F, 1.089355F,
+0.546570F, 0.397705F,
+0.627991F, 0.747559F,
+1.005920F, 1.258545F,
+0.943970F, 1.725098F,
+0.834839F, 0.620850F,
+0.321838F, 0.555908F,
+1.022095F, 1.516846F,
+1.016541F, 0.832031F,
+1.239258F, 0.821045F,
+1.140625F, 0.484619F,
+0.864990F, 3.141357F,
+0.924927F, 3.833740F,
+0.273010F, 0.249023F,
+0.102600F, 0.216309F,
+0.263123F, 1.050049F,
+0.546387F, 0.892822F,
+0.359680F, 0.280029F,
+0.710876F, 0.354492F,
+0.969604F, 0.543701F,
+0.279663F, 1.622070F,
+0.422913F, 0.294189F,
+0.379639F, 0.195068F,
+0.757751F, 0.832275F,
+0.974609F, 0.946533F,
+1.212097F, 0.514893F,
+0.591370F, 0.522705F,
+0.899780F, 2.155762F,
+0.883789F, 0.634521F,
+0.110901F, 0.302246F,
+0.474304F, 0.198486F,
+1.164490F, 1.076660F,
+0.338989F, 0.503906F,
+0.225037F, 0.694336F,
+1.064148F, 0.550781F,
+1.019104F, 1.095215F,
+0.988708F, 1.315430F,
+0.489990F, 0.674561F,
+0.207825F, 0.517334F,
+1.063599F, 1.337158F,
+0.836060F, 0.680176F,
+1.213318F, 0.664063F,
+0.555298F, 0.947266F,
+1.109131F, 1.179932F,
+1.058105F, 2.980225F,
+0.312256F, 0.243164F,
+0.301208F, 0.241211F,
+0.603516F, 0.752197F,
+0.367065F, 1.311279F,
+0.969299F, 0.406982F,
+0.513000F, 0.288818F,
+0.920837F, 0.577637F,
+1.207092F, 1.709473F,
+0.730164F, 0.381348F,
+0.444275F, 0.275391F,
+1.028992F, 0.374023F,
+0.962036F, 1.313721F,
+0.897705F, 0.504150F,
+1.227112F, 0.526123F,
+1.047241F, 2.012939F,
+1.093201F, 1.542480F,
+0.333679F, 0.367188F,
+0.250244F, 0.628418F,
+1.063293F, 1.662598F,
+0.346252F, 0.705078F,
+1.015381F, 0.825684F,
+0.547791F, 0.447021F,
+1.230408F, 1.156494F,
+1.193237F, 1.780762F,
+0.406372F, 0.678955F,
+0.700195F, 0.810791F,
+1.183899F, 1.233887F,
+1.152222F, 1.152832F,
+1.003357F, 0.579346F,
+1.246948F, 1.070801F,
+0.692932F, 6.476074F,
+0.707581F, 0.749023F,
+0.174927F, 0.382324F,
+0.311768F, 0.261230F,
+0.586792F, 1.199951F,
+0.301453F, 0.863281F,
+0.460266F, 0.214355F,
+1.264465F, 0.207764F,
+0.423462F, 1.072998F,
+1.025330F, 1.887939F,
+0.618713F, 0.248779F,
+0.600891F, 0.235352F,
+0.945679F, 0.965576F,
+0.943542F, 0.837402F,
+1.151306F, 0.239746F,
+1.228027F, 0.235107F,
+1.030029F, 3.146240F,
+0.874878F, 1.025391F,
+0.402771F, 0.297852F,
+0.562866F, 0.198730F,
+1.034058F, 1.253418F,
+0.345520F, 1.195801F,
+0.334961F, 0.438965F,
+1.236450F, 0.967285F,
+1.037903F, 1.508301F,
+1.094299F, 1.447510F,
+0.571594F, 0.834961F,
+0.456177F, 0.481201F,
+1.192444F, 1.263916F,
+1.159851F, 0.733887F,
+1.004272F, 0.924805F,
+0.980835F, 0.577881F,
+0.528809F, 0.669678F,
+0.576477F, 6.435059F,
+0.662598F, 0.314209F,
+0.216980F, 0.246338F,
+0.342163F, 0.884277F,
+1.187317F, 1.345703F,
+0.760071F, 0.194580F,
+1.259399F, 0.222412F,
+0.941589F, 0.748535F,
+1.039856F, 2.508545F,
+1.152527F, 0.642822F,
+0.238831F, 0.309570F,
+1.191345F, 0.822998F,
+1.101807F, 1.276855F,
+1.177429F, 0.409668F,
+1.190674F, 0.774414F,
+1.103027F, 2.625488F,
+1.014709F, 1.671143F,
+0.191284F, 0.561035F,
+0.663391F, 0.594971F,
+0.950928F, 1.687744F,
+0.768860F, 0.825439F,
+0.678467F, 0.804932F,
+1.023071F, 0.591797F,
+1.150696F, 1.639404F,
+1.048035F, 2.413818F,
+0.777771F, 0.635986F,
+0.545471F, 0.766602F,
+1.161682F, 1.895508F,
+1.119812F, 0.947266F,
+1.249695F, 0.898926F,
+1.196411F, 0.825195F,
+0.796143F, 4.729736F,
+0.642456F, 5.645508F,
+
+};
+
+/*
+ *    g_pitch        ,
+ *    g_fac          , (g_code = g_code0*g_fac),
+ */
+/* table used in 'high' rates: MR67 MR74 MR102 */
+#define VQ_SIZE_HIGHRATES 128
+static const Float32 table_highrates[VQ_SIZE_HIGHRATES * 2] =
+{
+   /*g_pit,    g_fac,   */
+   0.0352173F,   0.161621F,
+   0.0491943F,   0.448242F,
+   0.189758F,   0.256836F,
+   0.255188F,   0.338623F,
+   0.144836F,   0.347900F,
+   0.198242F,   0.484619F,
+   0.111511F,   0.566406F,
+   0.0574341F,   0.809082F,
+   0.143494F,   0.726807F,
+   0.220703F,   0.590820F,
+   0.210632F,   0.755859F,
+   0.180359F,   1.05005F,
+   0.112793F,   1.09863F,
+   0.237061F,   1.32227F,
+   0.0724487F,   1.76025F,
+   0.188171F,   2.19727F,
+   0.450684F,   0.215576F,
+   0.363892F,   0.367676F,
+   0.314636F,   0.520996F,
+   0.484863F,   0.490479F,
+   0.397156F,   0.549316F,
+   0.468140F,   0.671875F,
+   0.363281F,   0.736328F,
+   0.298950F,   0.918945F,
+   0.426575F,   0.875977F,
+   0.498901F,   0.971191F,
+   0.370117F,   1.07520F,
+   0.470520F,   1.24194F,
+   0.337097F,   1.46997F,
+   0.474182F,   1.73975F,
+   0.369873F,   1.93799F,
+   0.341431F,   2.80444F,
+   0.645813F,   0.331055F,
+   0.552307F,   0.389893F,
+   0.597778F,   0.496826F,
+   0.546021F,   0.589600F,
+   0.628418F,   0.630859F,
+   0.574158F,   0.667480F,
+   0.531006F,   0.785645F,
+   0.595520F,   0.828857F,
+   0.621155F,   0.950195F,
+   0.559692F,   1.10547F,
+   0.619629F,   1.22168F,
+   0.556274F,   1.40015F,
+   0.640869F,   1.52979F,
+   0.617065F,   1.86304F,
+   0.539795F,   2.13062F,
+   0.546631F,   3.05078F,
+   0.788818F,   0.238281F,
+   0.697937F,   0.428467F,
+   0.740845F,   0.568359F,
+   0.695068F,   0.578125F,
+   0.653076F,   0.748047F,
+   0.752686F,   0.698486F,
+   0.715454F,   0.812256F,
+   0.687866F,   0.903320F,
+   0.662903F,   1.07739F,
+   0.737427F,   1.10669F,
+   0.688660F,   1.27075F,
+   0.729980F,   1.53931F,
+   0.681580F,   1.83936F,
+   0.740234F,   2.03345F,
+   0.669495F,   2.63110F,
+   0.628662F,   4.24219F,
+   0.848328F,   0.410400F,
+   0.767822F,   0.499268F,
+   0.809631F,   0.595459F,
+   0.856506F,   0.729736F,
+   0.821045F,   0.756348F,
+   0.756592F,   0.893066F,
+   0.824585F,   0.922852F,
+   0.786133F,   1.04297F,
+   0.825989F,   1.18677F,
+   0.773132F,   1.33228F,
+   0.845581F,   1.49072F,
+   0.795349F,   1.58276F,
+   0.827454F,   1.88501F,
+   0.790833F,   2.27319F,
+   0.837036F,   2.82007F,
+   0.768494F,   3.71240F,
+   0.922424F,   0.375977F,
+   0.919922F,   0.569580F,
+   0.886658F,   0.613037F,
+   0.896729F,   0.781006F,
+   0.938843F,   0.869141F,
+   0.862610F,   0.966797F,
+   0.921753F,   1.03418F,
+   0.874756F,   1.17773F,
+   0.906128F,   1.33081F,
+   0.934204F,   1.48511F,
+   0.874573F,   1.68164F,
+   0.919189F,   1.87720F,
+   0.879272F,   2.30127F,
+   0.939148F,   2.37817F,
+   0.904785F,   3.48413F,
+   0.830078F,   6.08862F,
+   1.00073F,   0.480713F,
+   1.02643F,   0.691406F,
+   0.959045F,   0.694092F,
+   0.982910F,   0.814453F,
+   1.00000F,   0.967529F,
+   1.03394F,   1.11792F,
+   0.958923F,   1.12280F,
+   0.990112F,   1.33008F,
+   1.02734F,   1.55811F,
+   0.960999F,   1.74341F,
+   0.996460F,   1.82349F,
+   1.01385F,   2.10547F,
+   1.03931F,   2.54346F,
+   0.970764F,   2.88501F,
+   1.03015F,   3.58643F,
+   1.00800F,   5.09521F,
+   1.10730F,   0.508545F,
+   1.18414F,   0.775879F,
+   1.06860F,   0.836426F,
+   1.22400F,   0.983154F,
+   1.10284F,   1.03735F,
+   1.15674F,   1.23682F,
+   1.08099F,   1.31885F,
+   1.21063F,   1.51172F,
+   1.09558F,   1.71240F,
+   1.30115F,   1.92310F,
+   1.09314F,   2.26782F,
+   1.16846F,   2.26807F,
+   1.25226F,   2.77856F,
+   1.10321F,   3.53638F,
+   1.22064F,   4.36572F,
+   1.15002F,   7.99902F
+};
+
+
+/* table used in 'low' rates: MR475, MR515, MR59 */
+#define VQ_SIZE_LOWRATES 64
+static const Float32 table_lowrates[VQ_SIZE_LOWRATES * 2] =
+{
+   /*g_pit,    g_fac */
+   0.659973F,   7.01978F,
+   1.25000F,   0.679932F,
+   1.14996F,   1.60986F,
+   0.379944F,   1.80981F,
+   1.04999F,   2.54980F,
+   1.31995F,   0.309814F,
+   1.28998F,   1.07983F,
+   0.689941F,   0.379883F,
+   1.15997F,   3.12988F,
+   1.06000F,   0.609863F,
+   1.08997F,   1.17993F,
+   0.609985F,   0.609863F,
+   1.06995F,   1.91992F,
+   0.869995F,   0.459961F,
+   0.969971F,   0.769775F,
+   0.409973F,   0.439941F,
+   1.10999F,   4.92993F,
+   1.09998F,   0.739990F,
+   1.01996F,   1.42993F,
+   0.539978F,   0.979980F,
+   0.969971F,   2.18994F,
+   1.09998F,   0.339844F,
+   1.01996F,   1.00000F,
+   0.500000F,   0.159912F,
+   0.929993F,   3.39990F,
+   0.869995F,   0.759766F,
+   0.859985F,   1.13989F,
+   0.329956F,   0.659912F,
+   0.819946F,   1.59985F,
+   0.759949F,   0.219971F,
+   0.759949F,   0.649902F,
+   0.229980F,   0.159912F,
+   0.899963F,   5.73999F,
+   1.16998F,   0.599854F,
+   1.22998F,   1.23999F,
+   0.419983F,   1.00000F,
+   1.25000F,   2.08984F,
+   1.19995F,   0.179932F,
+   1.15997F,   1.03979F,
+   0.479980F,   0.509766F,
+   0.699951F,   3.00000F,
+   0.969971F,   0.359863F,
+   0.959961F,   1.12988F,
+   0.559998F,   0.349854F,
+   0.979980F,   1.70996F,
+   0.904968F,   0.179932F,
+   0.919983F,   0.549805F,
+   0.309998F,   0.299805F,
+   0.809998F,   4.22998F,
+   1.00995F,   0.569824F,
+   0.919983F,   1.41992F,
+   0.239990F,   0.899902F,
+   0.869995F,   2.09985F,
+   1.02997F,   0.189941F,
+   0.919983F,   0.929932F,
+   0.369995F,   0.149902F,
+   0.569946F,   2.25977F,
+   0.809998F,   0.429932F,
+   0.809998F,   0.859863F,
+   0.149963F,   0.479980F,
+   0.699951F,   1.34985F,
+   0.639954F,   0.179932F,
+   0.709961F,   0.779785F,
+   0.0899658F,   0.189941F
+};
+
+
+#define DTX_VQ_SIZE 47
+static const Word32 qua_gain_code_MR122[NB_QUA_CODE+VQ_SIZE_HIGHRATES+VQ_SIZE_LOWRATES+(MR475_VQ_SIZE*2)+DTX_VQ_SIZE+1] =
+{
+      - 3776,
+      - 3394,
+      - 3005,
+      - 2615,
+      - 2345,
+      - 2138,
+      - 1932,
+      - 1726,
+      - 1518,
+      - 1314,
+      - 1106,
+      - 900,
+      - 694,
+      - 487,
+      - 281,
+      - 75,
+      133,
+      339,
+      545,
+      752,
+      958,
+      1165,
+      1371,
+      1577,
+      1784,
+      1991,
+      2197,
+      2404,
+      2673,
+      3060,
+      3448,
+      3836,
+      /* high_rates */
+      - 2692,
+      - 1185,
+      - 2008,
+      - 1600,
+      - 1560,
+      - 1070,
+      - 840,
+      - 313,
+      - 471,
+      - 777,
+      - 414,
+      72,
+      139,
+      413,
+      835,
+      1163,
+      - 2267,
+      - 1478,
+      - 963,
+      - 1052,
+      - 885,
+      - 588,
+      - 452,
+      - 125,
+      - 196,
+      - 43,
+      107,
+      320,
+      569,
+      818,
+      977,
+      1523,
+      - 1633,
+      - 1391,
+      - 1033,
+      - 780,
+      - 681,
+      - 597,
+      - 356,
+      - 277,
+      - 75,
+      148,
+      296,
+      497,
+      628,
+      919,
+      1117,
+      1648,
+      - 2119,
+      - 1252,
+      - 835,
+      - 810,
+      - 429,
+      - 530,
+      - 307,
+      - 150,
+      110,
+      150,
+      354,
+      637,
+      900,
+      1049,
+      1429,
+      2135,
+      - 1316,
+      - 1026,
+      - 766,
+      - 465,
+      - 413,
+      - 167,
+      - 119,
+      62,
+      253,
+      424,
+      590,
+      678,
+      937,
+      1213,
+      1532,
+      1938,
+      - 1445,
+      - 832,
+      - 723,
+      - 365,
+      - 207,
+      - 50,
+      50,
+      242,
+      422,
+      584,
+      768,
+      930,
+      1231,
+      1280,
+      1844,
+      2669,
+      - 1082,
+      - 545,
+      - 539,
+      - 303,
+      - 49,
+      165,
+      171,
+      421,
+      655,
+      821,
+      888,
+      1100,
+      1379,
+      1565,
+      1887,
+      2406,
+      - 999,
+      - 375,
+      - 264,
+      - 25,
+      54,
+      314,
+      409,
+      610,
+      795,
+      966,
+      1210,
+      1210,
+      1510,
+      1866,
+      2177,
+      3072,
+      /* low_rates */
+      2879,
+      - 570,
+      703,
+      876,
+      1383,
+      - 1731,
+      113,
+      - 1430,
+      1686,
+      - 731,
+      244,
+      - 731,
+      964,
+      - 1147,
+      - 387,
+      - 1213,
+      2357,
+      - 445,
+      528,
+      - 30,
+      1158,
+      - 1594,
+      0,
+      - 2708,
+      1808,
+      - 406,
+      193,
+      - 614,
+      694,
+      - 2237,
+      - 637,
+      - 2708,
+      2582,
+      - 755,
+      318,
+      0,
+      1089,
+      - 2534,
+      58,
+      - 995,
+      1623,
+      - 1510,
+      180,
+      - 1552,
+      793,
+      - 2534,
+      - 884,
+      - 1780,
+      2131,
+      - 831,
+      518,
+      - 156,
+      1096,
+      - 2454,
+      - 107,
+      - 2804,
+      1204,
+      - 1247,
+      - 223,
+      - 1084,
+      443,
+      - 2534,
+      - 367,
+      - 2454,
+      /* MR475 */
+      - 5120,
+      - 4988,
+      - 1896,
+      - 274,
+      - 2932,
+      - 2726,
+      - 1216,
+      376,
+      - 3536,
+      - 3293,
+      - 650,
+      - 733,
+      - 2418,
+      - 2664,
+      1053,
+      - 1303,
+      - 3337,
+      - 3256,
+      - 9,
+      - 1732,
+      - 2237,
+      - 2076,
+      - 332,
+      252,
+      - 1044,
+      - 2350,
+      262,
+      - 1296,
+      - 1385,
+      - 827,
+      - 1447,
+      1309,
+      - 3375,
+      - 3386,
+      - 1418,
+      - 215,
+      - 2731,
+      - 2754,
+      - 1610,
+      594,
+      - 2610,
+      - 2821,
+      - 1409,
+      189,
+      - 1292,
+      - 1779,
+      853,
+      492,
+      - 1865,
+      - 1103,
+      593,
+      - 1211,
+      - 1213,
+      - 1407,
+      - 201,
+      621,
+      - 1903,
+      - 1270,
+      191,
+      - 310,
+      - 1435,
+      - 453,
+      1386,
+      728,
+      - 2646,
+      - 1689,
+      - 60,
+      - 609,
+      - 2602,
+      - 2409,
+      356,
+      396,
+      - 2991,
+      - 2775,
+      - 150,
+      - 785,
+      - 2577,
+      - 2506,
+      1524,
+      - 881,
+      - 3119,
+      - 3041,
+      - 98,
+      - 442,
+      - 2134,
+      - 1151,
+      411,
+      254,
+      - 1075,
+      - 1777,
+      105,
+      - 291,
+      - 524,
+      - 1519,
+      - 1318,
+      1895,
+      - 2838,
+      - 2972,
+      - 216,
+      - 812,
+      - 2785,
+      - 2677,
+      - 221,
+      1286,
+      - 2792,
+      - 2863,
+      - 454,
+      26,
+      - 1379,
+      - 1780,
+      1211,
+      287,
+      - 1798,
+      - 1868,
+      440,
+      - 647,
+      - 1034,
+      - 892,
+      322,
+      740,
+      - 1572,
+      - 823,
+      558,
+      - 511,
+      - 860,
+      - 714,
+      1356,
+      1502,
+      - 3690,
+      - 3448,
+      - 496,
+      - 632,
+      - 2770,
+      - 2706,
+      - 768,
+      867,
+      - 2360,
+      - 2301,
+      - 734,
+      - 211,
+      - 2005,
+      - 1530,
+      970,
+      - 246,
+      - 2982,
+      - 2646,
+      23,
+      - 1349,
+      - 1868,
+      - 694,
+      - 137,
+      369,
+      - 1056,
+      - 1263,
+      369,
+      - 1317,
+      - 1249,
+      - 351,
+      572,
+      1320,
+      - 3289,
+      - 3237,
+      - 890,
+      43,
+      - 2411,
+      - 2367,
+      - 998,
+      694,
+      - 2089,
+      - 2105,
+      - 728,
+      296,
+      - 1019,
+      - 1341,
+      775,
+      511,
+      - 2362,
+      - 1311,
+      508,
+      - 1432,
+      - 653,
+      - 1525,
+      214,
+      634,
+      - 1158,
+      - 862,
+      162,
+      - 92,
+      - 846,
+      - 345,
+      2171,
+      - 582,
+      - 1579,
+      - 2279,
+      - 213,
+      40,
+      - 2653,
+      - 2448,
+      329,
+      928,
+      - 2424,
+      - 1836,
+      - 383,
+      - 441,
+      - 2272,
+      - 2320,
+      1888,
+      - 1119,
+      - 2186,
+      - 1960,
+      - 4,
+      150,
+      - 2341,
+      - 1968,
+      555,
+      164,
+      - 686,
+      - 1856,
+      - 19,
+      - 656,
+      - 597,
+      - 928,
+      - 353,
+      2304,
+      - 2190,
+      - 1372,
+      - 416,
+      64,
+      - 2353,
+      - 2394,
+      - 860,
+      1028,
+      - 1313,
+      - 1187,
+      - 551,
+      388,
+      - 767,
+      - 1666,
+      1017,
+      1088,
+      - 1020,
+      - 1676,
+      747,
+      - 1107,
+      - 211,
+      - 1233,
+      704,
+      943,
+      - 700,
+      - 646,
+      891,
+      - 886,
+      - 518,
+      - 307,
+      2354,
+      1047,
+      - 2789,
+      - 2880,
+      - 860,
+      - 180,
+      - 2504,
+      - 2358,
+      - 531,
+      541,
+      - 2940,
+      - 2929,
+      - 456,
+      - 157,
+      - 2416,
+      - 2552,
+      1121,
+      - 434,
+      - 2454,
+      - 2353,
+      316,
+      - 752,
+      - 1162,
+      - 1739,
+      154,
+      144,
+      - 469,
+      - 1743,
+      186,
+      - 668,
+      - 795,
+      - 708,
+      - 485,
+      1595,
+      - 2644,
+      - 2564,
+      - 1725,
+      37,
+      - 2651,
+      - 2858,
+      - 1044,
+      1119,
+      - 2269,
+      - 2240,
+      - 933,
+      47,
+      - 1698,
+      - 1038,
+      890,
+      162,
+      - 1049,
+      - 1211,
+      701,
+      - 192,
+      - 1379,
+      - 1292,
+      - 251,
+      714,
+      - 2073,
+      - 983,
+      305,
+      61,
+      - 1660,
+      - 227,
+      1830,
+      760,
+      - 2534,
+      - 2304,
+      - 520,
+      - 216,
+      - 1764,
+      - 2245,
+      181,
+      508,
+      - 2865,
+      - 2868,
+      - 128,
+      - 389,
+      - 2492,
+      - 2500,
+      1478,
+      - 913,
+      - 2813,
+      - 2657,
+      18,
+      - 307,
+      - 1326,
+      - 839,
+      438,
+      430,
+      - 516,
+      - 1644,
+      388,
+      - 54,
+      - 133,
+      - 1550,
+      - 9,
+      1985,
+      - 1300,
+      - 2265,
+      161,
+      - 317,
+      - 2385,
+      - 2227,
+      65,
+      1055,
+      - 1960,
+      - 2297,
+      - 116,
+      170,
+      - 1451,
+      - 912,
+      1273,
+      143,
+      - 1963,
+      - 927,
+      581,
+      126,
+      - 1362,
+      - 430,
+      340,
+      806,
+      - 704,
+      - 868,
+      615,
+      - 272,
+      - 291,
+      - 1070,
+      1691,
+      1985,
+      - 2054,
+      - 2262,
+      72,
+      - 168,
+      - 1881,
+      - 1532,
+      - 900,
+      715,
+      - 1808,
+      - 2415,
+      - 271,
+      - 81,
+      - 981,
+      - 959,
+      1135,
+      - 672,
+      - 1768,
+      - 2389,
+      109,
+      - 1013,
+      - 539,
+      - 881,
+      134,
+      405,
+      - 582,
+      - 974,
+      429,
+      - 569,
+      - 605,
+      - 80,
+      244,
+      1613,
+      - 2089,
+      - 2101,
+      - 421,
+      400,
+      - 1328,
+      - 1835,
+      - 811,
+      792,
+      - 1424,
+      - 1905,
+      - 1453,
+      403,
+      - 1012,
+      - 949,
+      1033,
+      640,
+      - 1480,
+      - 686,
+      751,
+      - 516,
+      - 283,
+      - 1190,
+      215,
+      852,
+      - 572,
+      - 310,
+      310,
+      210,
+      - 806,
+      101,
+      2760,
+      - 427,
+      - 1420,
+      - 1983,
+      269,
+      - 217,
+      - 2275,
+      - 2321,
+      104,
+      939,
+      - 2055,
+      - 2137,
+      - 52,
+      - 262,
+      - 2110,
+      - 2139,
+      1693,
+      37,
+      - 1789,
+      - 2387,
+      334,
+      264,
+      - 1216,
+      - 49,
+      607,
+      546,
+      - 267,
+      - 1081,
+      346,
+      - 457,
+      - 116,
+      - 810,
+      - 592,
+      2750,
+      - 1710,
+      - 2070,
+      - 182,
+      439,
+      - 2418,
+      - 2221,
+      - 428,
+      1359,
+      - 653,
+      - 1732,
+      - 288,
+      361,
+      - 1318,
+      - 378,
+      1426,
+      759,
+      - 854,
+      - 767,
+      773,
+      - 283,
+      - 321,
+      - 775,
+      730,
+      1302,
+      - 669,
+      - 393,
+      945,
+      - 80,
+      - 158,
+      - 284,
+      2295,
+      2557,
+      /* dtx */
+      - 1921,
+      - 1878,
+      - 1836,
+      - 1793,
+      - 1751,
+      - 1708,
+      - 1666,
+      - 1623,
+      - 1581,
+      - 1538,
+      - 1495,
+      - 1453,
+      - 1410,
+      - 1368,
+      - 1325,
+      - 1283,
+      - 1240,
+      - 1198,
+      - 1155,
+      - 1113,
+      - 1070,
+      - 1028,
+      - 985,
+      - 943,
+      - 900,
+      - 858,
+      - 815,
+      - 773,
+      - 730,
+      - 688,
+      - 645,
+      - 602,
+      - 560,
+      - 517,
+      - 475,
+      - 432,
+      - 390,
+      - 347,
+      - 305,
+      - 262,
+      - 220,
+      - 177,
+      - 135,
+      - 92,
+      - 50,
+      - 7,
+      0,
+      /* init value */
+      - 2381
+};
+
+
+static const Word32 qua_gain_code[NB_QUA_CODE+VQ_SIZE_HIGHRATES+VQ_SIZE_LOWRATES+(MR475_VQ_SIZE*2)+DTX_VQ_SIZE+3] =
+{
+      - 22731,
+      - 20428,
+      - 18088,
+      - 15739,
+      - 14113,
+      - 12867,
+      - 11629,
+      - 10387,
+      - 9139,
+      - 7906,
+      - 6656,
+      - 5416,
+      - 4173,
+      - 2931,
+      - 1688,
+      - 445,
+      801,
+      2044,
+      3285,
+      4530,
+      5772,
+      7016,
+      8259,
+      9501,
+      10745,
+      11988,
+      13231,
+      14474,
+      16096,
+      18429,
+      20763,
+      23097,
+      /* high rates */
+      - 16214,
+      - 7135,
+      - 12086,
+      - 9629,
+      - 9394,
+      - 6442,
+      - 5056,
+      - 1885,
+      - 2838,
+      - 4681,
+      - 2490,
+      434,
+      836,
+      2484,
+      5030,
+      7002,
+      - 13647,
+      - 8900,
+      - 5800,
+      - 6335,
+      - 5327,
+      - 3537,
+      - 2724,
+      - 751,
+      - 1177,
+      - 260,
+      645,
+      1928,
+      3426,
+      4926,
+      5885,
+      9172,
+      - 9831,
+      - 8380,
+      - 6220,
+      - 4700,
+      - 4099,
+      - 3595,
+      - 2144,
+      - 1669,
+      - 454,
+      891,
+      1781,
+      2993,
+      3782,
+      5534,
+      6728,
+      9921,
+      - 12753,
+      - 7539,
+      - 5024,
+      - 4872,
+      - 2580,
+      - 3192,
+      - 1848,
+      - 904,
+      663,
+      902,
+      2132,
+      3837,
+      5420,
+      6312,
+      8604,
+      12853,
+      - 7921,
+      - 6179,
+      - 4610,
+      - 2802,
+      - 2482,
+      - 1006,
+      - 713,
+      374,
+      1523,
+      2552,
+      3551,
+      4084,
+      5639,
+      7304,
+      9221,
+      11667,
+      - 8700,
+      - 5007,
+      - 4352,
+      - 2197,
+      - 1247,
+      - 300,
+      298,
+      1454,
+      2542,
+      3518,
+      4623,
+      5602,
+      7413,
+      7706,
+      11102,
+      16067,
+      - 6517,
+      - 3283,
+      - 3248,
+      - 1825,
+      - 294,
+      992,
+      1030,
+      2537,
+      3945,
+      4944,
+      5343,
+      6622,
+      8303,
+      9423,
+      11360,
+      14483,
+      - 6013,
+      - 2257,
+      - 1589,
+      - 151,
+      326,
+      1890,
+      2461,
+      3676,
+      4784,
+      5816,
+      7283,
+      7284,
+      9089,
+      11234,
+      13108,
+      18494,
+      /* low_rates */
+      17333,
+      - 3431,
+      4235,
+      5276,
+      8325,
+      - 10422,
+      683,
+      - 8609,
+      10148,
+      - 4398,
+      1472,
+      - 4398,
+      5802,
+      - 6907,
+      - 2327,
+      - 7303,
+      14189,
+      - 2678,
+      3181,
+      - 180,
+      6972,
+      - 9599,
+      0,
+      - 16305,
+      10884,
+      - 2444,
+      1165,
+      - 3697,
+      4180,
+      - 13468,
+      - 3833,
+      - 16305,
+      15543,
+      - 4546,
+      1913,
+      0,
+      6556,
+      - 15255,
+      347,
+      - 5993,
+      9771,
+      - 9090,
+      1086,
+      - 9341,
+      4772,
+      - 15255,
+      - 5321,
+      - 10714,
+      12827,
+      - 5002,
+      3118,
+      - 938,
+      6598,
+      - 14774,
+      - 646,
+      - 16879,
+      7251,
+      - 7508,
+      - 1343,
+      - 6529,
+      2668,
+      - 15255,
+      - 2212,
+      - 14774,
+      /* MR475 */
+      - 30825,
+      - 30028,
+      - 11416,
+      - 1652,
+      - 17651,
+      - 16414,
+      - 7323,
+      2266,
+      - 21289,
+      - 19823,
+      - 3914,
+      - 4413,
+      - 14560,
+      - 16037,
+      6338,
+      - 7842,
+      - 20089,
+      - 19604,
+      - 53,
+      - 10430,
+      - 13469,
+      - 12497,
+      - 2001,
+      1517,
+      - 6283,
+      - 14145,
+      1579,
+      - 7801,
+      - 8339,
+      - 4977,
+      - 8713,
+      7881,
+      - 20321,
+      - 20385,
+      - 8535,
+      - 1296,
+      - 16442,
+      - 16581,
+      - 9696,
+      3577,
+      - 15714,
+      - 16981,
+      - 8484,
+      1135,
+      - 7780,
+      - 10708,
+      5136,
+      2962,
+      - 11229,
+      - 6643,
+      3572,
+      - 7294,
+      - 7304,
+      - 8473,
+      - 1208,
+      3739,
+      - 11455,
+      - 7646,
+      1150,
+      - 1866,
+      - 8638,
+      - 2726,
+      8342,
+      4384,
+      - 15933,
+      - 10167,
+      - 362,
+      - 3665,
+      - 15663,
+      - 14504,
+      2142,
+      2387,
+      - 18006,
+      - 16707,
+      - 905,
+      - 4726,
+      - 15513,
+      - 15088,
+      9173,
+      - 5305,
+      - 18778,
+      - 18307,
+      - 591,
+      - 2661,
+      - 12849,
+      - 6927,
+      2472,
+      1527,
+      - 6470,
+      - 10701,
+      632,
+      - 1754,
+      - 3155,
+      - 9145,
+      - 7938,
+      11408,
+      - 17085,
+      - 17891,
+      - 1301,
+      - 4889,
+      - 16764,
+      - 16117,
+      - 1333,
+      7744,
+      - 16808,
+      - 17234,
+      - 2732,
+      154,
+      - 8300,
+      - 10715,
+      7291,
+      1731,
+      - 10824,
+      - 11244,
+      2652,
+      - 3894,
+      - 6227,
+      - 5372,
+      1937,
+      4457,
+      - 9466,
+      - 4954,
+      3358,
+      - 3075,
+      - 5176,
+      - 4297,
+      8162,
+      9040,
+      - 22215,
+      - 20758,
+      - 2986,
+      - 3807,
+      - 16679,
+      - 16291,
+      - 4626,
+      5220,
+      - 14210,
+      - 13852,
+      - 4420,
+      - 1271,
+      - 12073,
+      - 9212,
+      5842,
+      - 1481,
+      - 17956,
+      - 15933,
+      137,
+      - 8120,
+      - 11244,
+      - 4180,
+      - 826,
+      2224,
+      - 6359,
+      - 7605,
+      2219,
+      - 7927,
+      - 7518,
+      - 2111,
+      3447,
+      7949,
+      - 19803,
+      - 19487,
+      - 5360,
+      259,
+      - 14515,
+      - 14253,
+      - 6011,
+      4180,
+      - 12577,
+      - 12676,
+      - 4384,
+      1784,
+      - 6135,
+      - 8071,
+      4665,
+      3078,
+      - 14220,
+      - 7896,
+      3060,
+      - 8621,
+      - 3931,
+      - 9182,
+      1285,
+      3816,
+      - 6974,
+      - 5192,
+      975,
+      - 554,
+      - 5091,
+      - 2075,
+      13071,
+      - 3502,
+      - 9504,
+      - 13719,
+      - 1280,
+      244,
+      - 15972,
+      - 14740,
+      1981,
+      5587,
+      - 14593,
+      - 11054,
+      - 2308,
+      - 2656,
+      - 13678,
+      - 13966,
+      11370,
+      - 6739,
+      - 13158,
+      - 11799,
+      - 27,
+      901,
+      - 14092,
+      - 11849,
+      3344,
+      989,
+      - 4132,
+      - 11176,
+      - 114,
+      - 3951,
+      - 3596,
+      - 5586,
+      - 2124,
+      13869,
+      - 13187,
+      - 8262,
+      - 2502,
+      384,
+      - 14166,
+      - 14416,
+      - 5176,
+      6192,
+      - 7906,
+      - 7147,
+      - 3320,
+      2336,
+      - 4615,
+      - 10032,
+      6125,
+      6551,
+      - 6144,
+      - 10092,
+      4495,
+      - 6666,
+      - 1273,
+      - 7423,
+      4241,
+      5680,
+      - 4212,
+      - 3891,
+      5366,
+      - 5337,
+      - 3121,
+      - 1847,
+      14175,
+      6302,
+      - 16793,
+      - 17341,
+      - 5176,
+      - 1085,
+      - 15076,
+      - 14199,
+      - 3195,
+      3257,
+      - 17698,
+      - 17635,
+      - 2746,
+      - 946,
+      - 14548,
+      - 15365,
+      6748,
+      - 2615,
+      - 14774,
+      - 14166,
+      1904,
+      - 4525,
+      - 6998,
+      - 10472,
+      928,
+      865,
+      - 2821,
+      - 10493,
+      1122,
+      - 4019,
+      - 4785,
+      - 4261,
+      - 2922,
+      9604,
+      - 15920,
+      - 15438,
+      - 10388,
+      222,
+      - 15959,
+      - 17204,
+      - 6283,
+      6737,
+      - 13658,
+      - 13488,
+      - 5618,
+      280,
+      - 10222,
+      - 6248,
+      5358,
+      977,
+      - 6319,
+      - 7294,
+      4218,
+      - 1156,
+      - 8300,
+      - 7780,
+      - 1514,
+      4296,
+      - 12479,
+      - 5917,
+      1839,
+      367,
+      - 9992,
+      - 1369,
+      11020,
+      4578,
+      - 15255,
+      - 13873,
+      - 3133,
+      - 1298,
+      - 10621,
+      - 13518,
+      1087,
+      3057,
+      - 17250,
+      - 17265,
+      - 774,
+      - 2339,
+      - 15006,
+      - 15053,
+      8896,
+      - 5497,
+      - 16938,
+      - 15998,
+      107,
+      - 1850,
+      - 7980,
+      - 5053,
+      2639,
+      2590,
+      - 3108,
+      - 9898,
+      2333,
+      - 323,
+      - 800,
+      - 9329,
+      - 57,
+      11948,
+      - 7827,
+      - 13638,
+      967,
+      - 1906,
+      - 14361,
+      - 13410,
+      392,
+      6353,
+      - 11799,
+      - 13831,
+      - 698,
+      1024,
+      - 8736,
+      - 5489,
+      7665,
+      861,
+      - 11816,
+      - 5582,
+      3495,
+      761,
+      - 8201,
+      - 2588,
+      2045,
+      4850,
+      - 4240,
+      - 5223,
+      3705,
+      - 1636,
+      - 1754,
+      - 6443,
+      10180,
+      11952,
+      - 12365,
+      - 13618,
+      433,
+      - 1009,
+      - 11322,
+      - 9225,
+      - 5421,
+      4302,
+      - 10883,
+      - 14537,
+      - 1633,
+      - 489,
+      - 5904,
+      - 5771,
+      6831,
+      - 4047,
+      - 10643,
+      - 14383,
+      656,
+      - 6097,
+      - 3245,
+      - 5305,
+      809,
+      2438,
+      - 3502,
+      - 5862,
+      2584,
+      - 3429,
+      - 3642,
+      - 482,
+      1471,
+      9712,
+      - 12577,
+      - 12649,
+      - 2533,
+      2410,
+      - 7996,
+      - 11047,
+      - 4882,
+      4768,
+      - 8575,
+      - 11470,
+      - 8747,
+      2427,
+      - 6092,
+      - 5713,
+      6222,
+      3854,
+      - 8911,
+      - 4132,
+      4521,
+      - 3108,
+      - 1704,
+      - 7162,
+      1293,
+      5132,
+      - 3445,
+      - 1866,
+      1868,
+      1264,
+      - 4855,
+      608,
+      16615,
+      - 2571,
+      - 8552,
+      - 11940,
+      1620,
+      - 1308,
+      - 13699,
+      - 13976,
+      626,
+      5652,
+      - 12374,
+      - 12868,
+      - 312,
+      - 1579,
+      - 12703,
+      - 12877,
+      10194,
+      222,
+      - 10773,
+      - 14372,
+      2009,
+      1590,
+      - 7323,
+      - 296,
+      3655,
+      3289,
+      - 1605,
+      - 6506,
+      2082,
+      - 2752,
+      - 696,
+      - 4878,
+      - 3567,
+      16558,
+      - 10297,
+      - 12462,
+      - 1094,
+      2640,
+      - 14560,
+      - 13370,
+      - 2577,
+      8180,
+      - 3931,
+      - 10430,
+      - 1733,
+      2173,
+      - 7938,
+      - 2274,
+      8585,
+      4567,
+      - 5141,
+      - 4619,
+      4655,
+      - 1707,
+      - 1931,
+      - 4666,
+      4396,
+      7837,
+      - 4026,
+      - 2364,
+      5687,
+      - 482,
+      - 948,
+      - 1709,
+      13820,
+      15394,
+      /* dtx */
+      - 11560,
+      - 11304,
+      - 11048,
+      - 10792,
+      - 10536,
+      - 10280,
+      - 10024,
+      - 9768,
+      - 9512,
+      - 9256,
+      - 9000,
+      - 8744,
+      - 8488,
+      - 8232,
+      - 7976,
+      - 7720,
+      - 7464,
+      - 7208,
+      - 6952,
+      - 6696,
+      - 6440,
+      - 6184,
+      - 5928,
+      - 5672,
+      - 5416,
+      - 5160,
+      - 4904,
+      - 4648,
+      - 4392,
+      - 4136,
+      - 3880,
+      - 3624,
+      - 3368,
+      - 3112,
+      - 2856,
+      - 2600,
+      - 2344,
+      - 2088,
+      - 1832,
+      - 1576,
+      - 1320,
+      - 1064,
+      - 808,
+      - 552,
+      - 296,
+      - 40,
+      0,
+      /* init value */
+      - 14336,
+      /* min */
+      - 32767,
+      /* max */
+      18284
+
+};
+/*
+ * LP analysis is performed twice per frame using two different asymmetric windows.
+ * The second window has its weight concentrated at the fourth subframe
+ * and it consists of two parts:
+ * the first part is half a Hamming window and
+ * the second part is a quarter of a cosine function cycle.
+ */
+static const Float32 window_200_40[240] =
+{
+   0.0800000F,
+   0.0800570F,
+   0.0802281F,
+   0.0805132F,
+   0.0809123F,
+   0.0814251F,
+   0.0820517F,
+   0.0827919F,
+   0.0836454F,
+   0.0846121F,
+   0.0856917F,
+   0.0868840F,
+   0.0881886F,
+   0.0896053F,
+   0.0911337F,
+   0.0927733F,
+   0.0945239F,
+   0.0963849F,
+   0.0983560F,
+   0.100437F,
+   0.102626F,
+   0.104924F,
+   0.107330F,
+   0.109843F,
+   0.112463F,
+   0.115189F,
+   0.118020F,
+   0.120956F,
+   0.123996F,
+   0.127139F,
+   0.130384F,
+   0.133731F,
+   0.137178F,
+   0.140726F,
+   0.144372F,
+   0.148117F,
+   0.151959F,
+   0.155897F,
+   0.159930F,
+   0.164058F,
+   0.168278F,
+   0.172591F,
+   0.176995F,
+   0.181489F,
+   0.186072F,
+   0.190743F,
+   0.195500F,
+   0.200343F,
+   0.205270F,
+   0.210280F,
+   0.215372F,
+   0.220544F,
+   0.225795F,
+   0.231125F,
+   0.236531F,
+   0.242012F,
+   0.247567F,
+   0.253195F,
+   0.258893F,
+   0.264662F,
+   0.270499F,
+   0.276402F,
+   0.282371F,
+   0.288404F,
+   0.294499F,
+   0.300655F,
+   0.306871F,
+   0.313144F,
+   0.319473F,
+   0.325857F,
+   0.332295F,
+   0.338783F,
+   0.345322F,
+   0.351909F,
+   0.358543F,
+   0.365221F,
+   0.371943F,
+   0.378707F,
+   0.385510F,
+   0.392352F,
+   0.399231F,
+   0.406144F,
+   0.413091F,
+   0.420069F,
+   0.427077F,
+   0.434112F,
+   0.441175F,
+   0.448261F,
+   0.455371F,
+   0.462501F,
+   0.469650F,
+   0.476817F,
+   0.484000F,
+   0.491197F,
+   0.498405F,
+   0.505624F,
+   0.512852F,
+   0.520086F,
+   0.527325F,
+   0.534567F,
+   0.541811F,
+   0.549054F,
+   0.556295F,
+   0.563532F,
+   0.570763F,
+   0.577986F,
+   0.585201F,
+   0.592403F,
+   0.599593F,
+   0.606768F,
+   0.613927F,
+   0.621067F,
+   0.628187F,
+   0.635285F,
+   0.642360F,
+   0.649409F,
+   0.656431F,
+   0.663424F,
+   0.670387F,
+   0.677317F,
+   0.684213F,
+   0.691073F,
+   0.697896F,
+   0.704680F,
+   0.711423F,
+   0.718124F,
+   0.724780F,
+   0.731390F,
+   0.737953F,
+   0.744467F,
+   0.750930F,
+   0.757341F,
+   0.763698F,
+   0.770000F,
+   0.776245F,
+   0.782430F,
+   0.788556F,
+   0.794620F,
+   0.800622F,
+   0.806558F,
+   0.812428F,
+   0.818231F,
+   0.823965F,
+   0.829628F,
+   0.835220F,
+   0.840738F,
+   0.846182F,
+   0.851550F,
+   0.856840F,
+   0.862052F,
+   0.867184F,
+   0.872235F,
+   0.877204F,
+   0.882089F,
+   0.886889F,
+   0.891603F,
+   0.896230F,
+   0.900769F,
+   0.905218F,
+   0.909577F,
+   0.913844F,
+   0.918018F,
+   0.922098F,
+   0.926084F,
+   0.929974F,
+   0.933767F,
+   0.937463F,
+   0.941060F,
+   0.944558F,
+   0.947955F,
+   0.951251F,
+   0.954446F,
+   0.957537F,
+   0.960525F,
+   0.963409F,
+   0.966187F,
+   0.968860F,
+   0.971427F,
+   0.973886F,
+   0.976238F,
+   0.978482F,
+   0.980617F,
+   0.982643F,
+   0.984559F,
+   0.986365F,
+   0.988060F,
+   0.989644F,
+   0.991117F,
+   0.992478F,
+   0.993726F,
+   0.994862F,
+   0.995885F,
+   0.996796F,
+   0.997592F,
+   0.998276F,
+   0.998846F,
+   0.999301F,
+   0.999644F,
+   0.999872F,
+   0.999986F,
+   1.00000F,
+   0.999219F,
+   0.996878F,
+   0.992981F,
+   0.987533F,
+   0.980544F,
+   0.972023F,
+   0.961985F,
+   0.950444F,
+   0.937420F,
+   0.922932F,
+   0.907002F,
+   0.889657F,
+   0.870923F,
+   0.850828F,
+   0.829406F,
+   0.806688F,
+   0.782711F,
+   0.757511F,
+   0.731129F,
+   0.703605F,
+   0.674983F,
+   0.645307F,
+   0.614623F,
+   0.582980F,
+   0.550426F,
+   0.517013F,
+   0.482792F,
+   0.447818F,
+   0.412145F,
+   0.375828F,
+   0.338924F,
+   0.301491F,
+   0.263587F,
+   0.225272F,
+   0.186605F,
+   0.147647F,
+   0.108458F,
+   0.0690994F,
+   0.0296333F
+};
+
+/*
+ * LP analysis is performed twice per frame using two different asymmetric windows.
+ * The second window has its weight concentrated at the fourth subframe
+ * and it consists of two parts:
+ * the first part is half a Hamming window and
+ * the second part is a quarter of a cosine function cycle.
+ */
+static const Float32 window_232_8[240] =
+{
+   0.0800000F,
+   0.0800424F,
+   0.0801694F,
+   0.0803812F,
+   0.0806775F,
+   0.0810585F,
+   0.0815240F,
+   0.0820739F,
+   0.0827082F,
+   0.0834267F,
+   0.0842292F,
+   0.0851157F,
+   0.0860859F,
+   0.0871398F,
+   0.0882770F,
+   0.0894975F,
+   0.0908009F,
+   0.0921870F,
+   0.0936556F,
+   0.0952064F,
+   0.0968391F,
+   0.0985534F,
+   0.100349F,
+   0.102226F,
+   0.104183F,
+   0.106220F,
+   0.108338F,
+   0.110534F,
+   0.112810F,
+   0.115165F,
+   0.117598F,
+   0.120108F,
+   0.122696F,
+   0.125361F,
+   0.128102F,
+   0.130919F,
+   0.133812F,
+   0.136779F,
+   0.139820F,
+   0.142935F,
+   0.146123F,
+   0.149384F,
+   0.152717F,
+   0.156121F,
+   0.159596F,
+   0.163140F,
+   0.166754F,
+   0.170437F,
+   0.174188F,
+   0.178007F,
+   0.181892F,
+   0.185843F,
+   0.189859F,
+   0.193939F,
+   0.198084F,
+   0.202291F,
+   0.206561F,
+   0.210892F,
+   0.215283F,
+   0.219734F,
+   0.224245F,
+   0.228813F,
+   0.233439F,
+   0.238121F,
+   0.242859F,
+   0.247652F,
+   0.252498F,
+   0.257397F,
+   0.262349F,
+   0.267351F,
+   0.272404F,
+   0.277506F,
+   0.282656F,
+   0.287854F,
+   0.293098F,
+   0.298388F,
+   0.303722F,
+   0.309100F,
+   0.314520F,
+   0.319981F,
+   0.325484F,
+   0.331025F,
+   0.336606F,
+   0.342223F,
+   0.347877F,
+   0.353567F,
+   0.359290F,
+   0.365048F,
+   0.370837F,
+   0.376657F,
+   0.382508F,
+   0.388387F,
+   0.394295F,
+   0.400229F,
+   0.406189F,
+   0.412174F,
+   0.418182F,
+   0.424213F,
+   0.430265F,
+   0.436337F,
+   0.442428F,
+   0.448537F,
+   0.454663F,
+   0.460805F,
+   0.466961F,
+   0.473131F,
+   0.479313F,
+   0.485507F,
+   0.491710F,
+   0.497922F,
+   0.504142F,
+   0.510369F,
+   0.516601F,
+   0.522837F,
+   0.529077F,
+   0.535318F,
+   0.541561F,
+   0.547803F,
+   0.554043F,
+   0.560281F,
+   0.566516F,
+   0.572745F,
+   0.578969F,
+   0.585185F,
+   0.591393F,
+   0.597591F,
+   0.603779F,
+   0.609955F,
+   0.616119F,
+   0.622268F,
+   0.628402F,
+   0.634520F,
+   0.640620F,
+   0.646702F,
+   0.652764F,
+   0.658805F,
+   0.664825F,
+   0.670822F,
+   0.676794F,
+   0.682741F,
+   0.688662F,
+   0.694556F,
+   0.700421F,
+   0.706257F,
+   0.712062F,
+   0.717835F,
+   0.723576F,
+   0.729282F,
+   0.734954F,
+   0.740590F,
+   0.746189F,
+   0.751750F,
+   0.757272F,
+   0.762755F,
+   0.768196F,
+   0.773595F,
+   0.778951F,
+   0.784263F,
+   0.789530F,
+   0.794751F,
+   0.799925F,
+   0.805051F,
+   0.810129F,
+   0.815156F,
+   0.820133F,
+   0.825059F,
+   0.829932F,
+   0.834751F,
+   0.839517F,
+   0.844227F,
+   0.848881F,
+   0.853478F,
+   0.858018F,
+   0.862499F,
+   0.866920F,
+   0.871282F,
+   0.875582F,
+   0.879820F,
+   0.883996F,
+   0.888109F,
+   0.892157F,
+   0.896141F,
+   0.900059F,
+   0.903911F,
+   0.907696F,
+   0.911413F,
+   0.915061F,
+   0.918641F,
+   0.922151F,
+   0.925590F,
+   0.928958F,
+   0.932255F,
+   0.935480F,
+   0.938632F,
+   0.941710F,
+   0.944714F,
+   0.947644F,
+   0.950499F,
+   0.953278F,
+   0.955981F,
+   0.958607F,
+   0.961157F,
+   0.963628F,
+   0.966022F,
+   0.968338F,
+   0.970574F,
+   0.972731F,
+   0.974809F,
+   0.976806F,
+   0.978723F,
+   0.980559F,
+   0.982314F,
+   0.983988F,
+   0.985579F,
+   0.987089F,
+   0.988516F,
+   0.989861F,
+   0.991123F,
+   0.992302F,
+   0.993398F,
+   0.994410F,
+   0.995338F,
+   0.996183F,
+   0.996943F,
+   0.997619F,
+   0.998212F,
+   0.998719F,
+   0.999143F,
+   0.999481F,
+   0.999735F,
+   0.999905F,
+   0.999989F,
+   1.00000F,
+   0.979530F,
+   0.918958F,
+   0.820763F,
+   0.688967F,
+   0.528964F,
+   0.347305F,
+   0.151428F
+};
+
+/*
+ * LP analysis is performed twice per frame using two different asymmetric windows.
+ * The first window has its weight concentrated at the second subframe
+ * and it consists of two halves of Hamming windows with different sizes
+ */
+static const Float32 window_160_80[240] =
+{
+   0.0800000F,
+   0.0800898F,
+   0.0803591F,
+   0.0808079F,
+   0.0814359F,
+   0.0822430F,
+   0.0832287F,
+   0.0843928F,
+   0.0857347F,
+   0.0872539F,
+   0.0889499F,
+   0.0908220F,
+   0.0928695F,
+   0.0950914F,
+   0.0974871F,
+   0.100056F,
+   0.102796F,
+   0.105707F,
+   0.108787F,
+   0.112036F,
+   0.115451F,
+   0.119033F,
+   0.122779F,
+   0.126688F,
+   0.130758F,
+   0.134988F,
+   0.139376F,
+   0.143920F,
+   0.148619F,
+   0.153471F,
+   0.158473F,
+   0.163625F,
+   0.168924F,
+   0.174367F,
+   0.179953F,
+   0.185680F,
+   0.191545F,
+   0.197546F,
+   0.203681F,
+   0.209947F,
+   0.216342F,
+   0.222863F,
+   0.229508F,
+   0.236274F,
+   0.243159F,
+   0.250160F,
+   0.257273F,
+   0.264498F,
+   0.271829F,
+   0.279266F,
+   0.286804F,
+   0.294441F,
+   0.302174F,
+   0.310000F,
+   0.317916F,
+   0.325918F,
+   0.334004F,
+   0.342170F,
+   0.350414F,
+   0.358731F,
+   0.367119F,
+   0.375575F,
+   0.384095F,
+   0.392676F,
+   0.401314F,
+   0.410007F,
+   0.418750F,
+   0.427540F,
+   0.436375F,
+   0.445250F,
+   0.454162F,
+   0.463107F,
+   0.472083F,
+   0.481085F,
+   0.490109F,
+   0.499154F,
+   0.508214F,
+   0.517287F,
+   0.526369F,
+   0.535456F,
+   0.544544F,
+   0.553631F,
+   0.562713F,
+   0.571786F,
+   0.580846F,
+   0.589891F,
+   0.598915F,
+   0.607917F,
+   0.616893F,
+   0.625838F,
+   0.634750F,
+   0.643625F,
+   0.652460F,
+   0.661250F,
+   0.669993F,
+   0.678686F,
+   0.687324F,
+   0.695905F,
+   0.704425F,
+   0.712881F,
+   0.721269F,
+   0.729586F,
+   0.737830F,
+   0.745996F,
+   0.754082F,
+   0.762084F,
+   0.770000F,
+   0.777826F,
+   0.785559F,
+   0.793196F,
+   0.800734F,
+   0.808171F,
+   0.815502F,
+   0.822727F,
+   0.829840F,
+   0.836841F,
+   0.843726F,
+   0.850492F,
+   0.857137F,
+   0.863658F,
+   0.870053F,
+   0.876319F,
+   0.882454F,
+   0.888455F,
+   0.894320F,
+   0.900047F,
+   0.905633F,
+   0.911076F,
+   0.916375F,
+   0.921527F,
+   0.926529F,
+   0.931381F,
+   0.936080F,
+   0.940624F,
+   0.945012F,
+   0.949242F,
+   0.953312F,
+   0.957221F,
+   0.960967F,
+   0.964549F,
+   0.967964F,
+   0.971213F,
+   0.974293F,
+   0.977204F,
+   0.979944F,
+   0.982513F,
+   0.984909F,
+   0.987131F,
+   0.989178F,
+   0.991050F,
+   0.992746F,
+   0.994265F,
+   0.995607F,
+   0.996771F,
+   0.997757F,
+   0.998564F,
+   0.999192F,
+   0.999641F,
+   0.999910F,
+   1.00000F,
+   1.00000F,
+   0.999636F,
+   0.998546F,
+   0.996730F,
+   0.994193F,
+   0.990937F,
+   0.986968F,
+   0.982292F,
+   0.976917F,
+   0.970851F,
+   0.964104F,
+   0.956687F,
+   0.948610F,
+   0.939887F,
+   0.930532F,
+   0.920560F,
+   0.909986F,
+   0.898826F,
+   0.887100F,
+   0.874824F,
+   0.862019F,
+   0.848705F,
+   0.834903F,
+   0.820635F,
+   0.805922F,
+   0.790790F,
+   0.775260F,
+   0.759359F,
+   0.743111F,
+   0.726542F,
+   0.709677F,
+   0.692545F,
+   0.675171F,
+   0.657584F,
+   0.639810F,
+   0.621879F,
+   0.603818F,
+   0.585657F,
+   0.567423F,
+   0.549146F,
+   0.530854F,
+   0.512577F,
+   0.494343F,
+   0.476182F,
+   0.458121F,
+   0.440190F,
+   0.422416F,
+   0.404829F,
+   0.387455F,
+   0.370323F,
+   0.353458F,
+   0.336889F,
+   0.320641F,
+   0.304740F,
+   0.289210F,
+   0.274078F,
+   0.259365F,
+   0.245097F,
+   0.231295F,
+   0.217981F,
+   0.205176F,
+   0.192900F,
+   0.181174F,
+   0.170014F,
+   0.159440F,
+   0.149468F,
+   0.140113F,
+   0.131390F,
+   0.123313F,
+   0.115896F,
+   0.109149F,
+   0.103083F,
+   0.0977077F,
+   0.0930321F,
+   0.0890632F,
+   0.0858073F,
+   0.0832696F,
+   0.0814541F,
+   0.0803637F,
+   0.0800000F
+};
+
+/* correlation weights	*/
+static const Float32 corrweight[251] =
+{
+   0.624805F,
+   0.625813F,
+   0.626820F,
+   0.627827F,
+   0.628834F,
+   0.630024F,
+   0.631031F,
+   0.632221F,
+   0.633229F,
+   0.634419F,
+   0.635426F,
+   0.636616F,
+   0.637623F,
+   0.638813F,
+   0.640034F,
+   0.641224F,
+   0.642415F,
+   0.643605F,
+   0.644826F,
+   0.646016F,
+   0.647206F,
+   0.648427F,
+   0.649617F,
+   0.651021F,
+   0.652211F,
+   0.653615F,
+   0.654805F,
+   0.656209F,
+   0.657430F,
+   0.658834F,
+   0.660207F,
+   0.661611F,
+   0.663015F,
+   0.664418F,
+   0.665822F,
+   0.667226F,
+   0.668630F,
+   0.670217F,
+   0.671621F,
+   0.673208F,
+   0.674612F,
+   0.676229F,
+   0.677816F,
+   0.679434F,
+   0.681021F,
+   0.682607F,
+   0.684225F,
+   0.685812F,
+   0.687613F,
+   0.689230F,
+   0.691031F,
+   0.692831F,
+   0.694632F,
+   0.696432F,
+   0.698233F,
+   0.700034F,
+   0.702017F,
+   0.703818F,
+   0.705832F,
+   0.707816F,
+   0.709616F,
+   0.711814F,
+   0.713828F,
+   0.715812F,
+   0.718009F,
+   0.720237F,
+   0.722221F,
+   0.724631F,
+   0.726829F,
+   0.729026F,
+   0.731437F,
+   0.733818F,
+   0.736229F,
+   0.738609F,
+   0.741234F,
+   0.743614F,
+   0.746208F,
+   0.748833F,
+   0.751610F,
+   0.754234F,
+   0.757012F,
+   0.760033F,
+   0.762810F,
+   0.765831F,
+   0.768822F,
+   0.772027F,
+   0.775018F,
+   0.778222F,
+   0.781610F,
+   0.785028F,
+   0.788415F,
+   0.792016F,
+   0.795618F,
+   0.799219F,
+   0.803034F,
+   0.807031F,
+   0.811029F,
+   0.815027F,
+   0.819239F,
+   0.823634F,
+   0.828028F,
+   0.832636F,
+   0.837428F,
+   0.842219F,
+   0.847224F,
+   0.852412F,
+   0.857814F,
+   0.863216F,
+   0.869015F,
+   0.874813F,
+   0.881039F,
+   0.887417F,
+   0.894040F,
+   0.901028F,
+   0.908231F,
+   0.915616F,
+   0.923429F,
+   0.931639F,
+   0.940214F,
+   0.960021F,
+   1.00000F,
+   1.00000F,
+   1.00000F,
+   1.00000F,
+   1.00000F,
+   1.00000F,
+   1.00000F,
+   0.960021F,
+   0.940214F,
+   0.931639F,
+   0.923429F,
+   0.915616F,
+   0.908231F,
+   0.901028F,
+   0.894040F,
+   0.887417F,
+   0.881039F,
+   0.874813F,
+   0.869015F,
+   0.863216F,
+   0.857814F,
+   0.852412F,
+   0.847224F,
+   0.842219F,
+   0.837428F,
+   0.832636F,
+   0.828028F,
+   0.823634F,
+   0.819239F,
+   0.815027F,
+   0.811029F,
+   0.807031F,
+   0.803034F,
+   0.799219F,
+   0.795618F,
+   0.792016F,
+   0.788415F,
+   0.785028F,
+   0.781610F,
+   0.778222F,
+   0.775018F,
+   0.772027F,
+   0.768822F,
+   0.765831F,
+   0.762810F,
+   0.760033F,
+   0.757012F,
+   0.754234F,
+   0.751610F,
+   0.748833F,
+   0.746208F,
+   0.743614F,
+   0.741234F,
+   0.738609F,
+   0.736229F,
+   0.733818F,
+   0.731437F,
+   0.729026F,
+   0.726829F,
+   0.724631F,
+   0.722221F,
+   0.720237F,
+   0.718009F,
+   0.715812F,
+   0.713828F,
+   0.711814F,
+   0.709616F,
+   0.707816F,
+   0.705832F,
+   0.703818F,
+   0.702017F,
+   0.700034F,
+   0.698233F,
+   0.696432F,
+   0.694632F,
+   0.692831F,
+   0.691031F,
+   0.689230F,
+   0.687613F,
+   0.685812F,
+   0.684225F,
+   0.682607F,
+   0.681021F,
+   0.679434F,
+   0.677816F,
+   0.676229F,
+   0.674612F,
+   0.673208F,
+   0.671621F,
+   0.670217F,
+   0.668630F,
+   0.667226F,
+   0.665822F,
+   0.664418F,
+   0.663015F,
+   0.661611F,
+   0.660207F,
+   0.658834F,
+   0.657430F,
+   0.656209F,
+   0.654805F,
+   0.653615F,
+   0.652211F,
+   0.651021F,
+   0.649617F,
+   0.648427F,
+   0.647206F,
+   0.646016F,
+   0.644826F,
+   0.643605F,
+   0.642415F,
+   0.641224F,
+   0.640034F,
+   0.638813F,
+   0.637623F,
+   0.636616F,
+   0.635426F,
+   0.634419F,
+   0.633229F,
+   0.632221F,
+   0.631031F,
+   0.630024F,
+   0.628834F,
+   0.627827F,
+   0.626820F,
+   0.625813F,
+   0.624805F,
+   0.623615F,
+   0.622608F,
+   0.621632F,
+   0.620624F
+};
+
+
+const struct
+{
+   Word8 max_frac_lag; /* lag up to which fractional lags are used */
+   Word8 flag3; /* enable 1/3 instead of 1/6 fract. resolution */
+   Word8 first_frac; /* first fractional to check */
+   Word8 last_frac; /* last fractional to check */
+   Word8 delta_int_low; /* integer lag below TO to start search from */
+   Word8 delta_int_range; /* integer range around T0 */
+   Word8 delta_frc_low; /* fractional below T0 */
+   Word8 delta_frc_range; /* fractional range around T0 */
+   Word8 pit_min; /* minimum pitch */
+
+} static mode_dep_parm[8] =
+{
+   /*
+    * MR475
+    */
+   {
+      84, 1, - 2, 2, 5, 10, 5, 9, PIT_MIN
+   },
+   /*
+    * MR515
+    */
+   {
+      84, 1, - 2, 2, 5, 10, 5, 9, PIT_MIN
+   },
+   /*
+    * MR59
+    */
+   {
+      84, 1, - 2, 2, 3, 6, 5, 9, PIT_MIN
+   },
+   /*
+    * MR67
+    */
+   {
+      84, 1, - 2, 2, 3, 6, 5, 9, PIT_MIN
+   },
+   /*
+    * MR74
+    */
+   {
+      84, 1, - 2, 2, 3, 6, 5, 9, PIT_MIN
+   },
+   /*
+    * MR795
+    */
+   {
+      84, 1, - 2, 2, 3, 6, 10, 19, PIT_MIN
+   },
+   /*
+    * MR102
+    */
+   {
+      84, 1, - 2, 2, 3, 6, 5, 9, PIT_MIN
+   },
+   /*
+    * MR122
+    */
+   {
+      94, 0, - 3, 3, 3, 6, 5, 9, PIT_MIN_MR122
+   }
+};
+
+/* table used inbase 2 logharithm computation */
+static const Word32 log2_table[33] =
+{
+   0,
+   1455,
+   2866,
+   4236,
+   5568,
+   6863,
+   8124,
+   9352,
+   10549,
+   11716,
+   12855,
+   13967,
+   15054,
+   16117,
+   17156,
+   18172,
+   19167,
+   20142,
+   21097,
+   22033,
+   22951,
+   23852,
+   24735,
+   25603,
+   26455,
+   27291,
+   28113,
+   28922,
+   29716,
+   30497,
+   31266,
+   32023,
+   32767
+};
+
+/* table used in 2 to the power computation */
+static const Word32 pow2_table[33] =
+{
+   16384,
+   16743,
+   17109,
+   17484,
+   17867,
+   18258,
+   18658,
+   19066,
+   19484,
+   19911,
+   20347,
+   20792,
+   21247,
+   21713,
+   22188,
+   22674,
+   23170,
+   23678,
+   24196,
+   24726,
+   25268,
+   25821,
+   26386,
+   26964,
+   27554,
+   28158,
+   28774,
+   29405,
+   30048,
+   30706,
+   31379,
+   32066,
+   32767
+};
+
+
+#endif
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/amr/sp_dec.c asterisk-1.8.3.2_com_amr/codecs/amr/sp_dec.c
--- asterisk-1.8.3.2_com_rtsp/codecs/amr/sp_dec.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/amr/sp_dec.c	2012-03-26 16:29:06.000000000 +0100
@@ -0,0 +1,6122 @@
+/*
+ * ===================================================================
+ *  TS 26.104
+ *  REL-5 V5.4.0 2004-03
+ *  REL-6 V6.1.0 2004-03
+ *  3GPP AMR Floating-point Speech Codec
+ * ===================================================================
+ *
+ */
+
+/*
+ * sp_dec.c
+ *
+ *
+ * Project:
+ *    AMR Floating-Point Codec
+ *
+ * Contains:
+ *    This module contains all the functions needed decoding AMR
+ *    encoder parameters to 16-bit speech samples
+ *
+ */
+/*
+ * include files
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <memory.h>
+#include <math.h>
+#include "sp_dec.h"
+#include "rom_dec.h"
+
+/*
+ * Declare structure types
+ */
+enum DTXStateType
+{
+   SPEECH = 0, DTX, DTX_MUTE
+};
+
+/*
+ * Decoder memory structure
+ */
+typedef struct
+{
+   /* history vector of past synthesis speech energy */
+   Word32 frameEnergyHist[L_ENERGYHIST];
+
+
+   /* state flags */
+   Word16 bgHangover;   /* counter; number of frames after last speech frame */
+
+
+}Bgn_scdState;
+typedef struct
+{
+   Word32 hangCount;   /* counter; */
+   /* history vector of past synthesis speech energy */
+   Word32 cbGainHistory[L_CBGAINHIST];
+   Word16 hangVar;   /* counter; */
+
+}Cb_gain_averageState;
+typedef struct
+{
+   Word32 lsp_meanSave[M];   /* Averaged LSPs saved for efficiency  */
+
+
+}lsp_avgState;
+typedef struct
+{
+   Word32 past_r_q[M];   /* Past quantized prediction error, Q15 */
+   Word32 past_lsf_q[M];   /* Past dequantized lsfs, Q15 */
+
+
+}D_plsfState;
+typedef struct
+{
+   Word32 pbuf[5];
+   Word32 past_gain_pit;
+   Word32 prev_gp;
+
+
+}ec_gain_pitchState;
+typedef struct
+{
+   Word32 gbuf[5];
+   Word32 past_gain_code;
+   Word32 prev_gc;
+
+
+}ec_gain_codeState;
+typedef struct
+{
+   /*
+    * normal MA predictor memory, Q10
+    * (contains 20*log10(quaErr))
+    */
+   Word32 past_qua_en[4];
+
+
+   /*
+    * MA predictor memory for MR122 mode, Q10
+    * (contains log2(quaErr))
+    */
+   Word32 past_qua_en_MR122[4];
+
+
+}gc_predState;
+typedef struct
+{
+   Word32 gainMem[PHDGAINMEMSIZE];
+   Word32 prevCbGain;
+   Word32 prevState;
+   Word16 lockFull;
+   Word16 onset;
+
+
+}ph_dispState;
+typedef struct
+{
+   enum DTXStateType dtxGlobalState;   /* contains previous state */
+
+   Word32 log_en;
+   Word32 old_log_en;
+   Word32 pn_seed_rx;
+   Word32 lsp[M];
+   Word32 lsp_old[M];
+   Word32 lsf_hist[M * DTX_HIST_SIZE];
+   Word32 lsf_hist_mean[M * DTX_HIST_SIZE];
+   Word32 log_en_hist[DTX_HIST_SIZE];
+   Word32 true_sid_period_inv;
+   Word16 since_last_sid;
+   Word16 lsf_hist_ptr;
+   Word16 log_pg_mean;
+   Word16 log_en_hist_ptr;
+   Word16 log_en_adjust;
+   Word16 dtxHangoverCount;
+   Word16 decAnaElapsedCount;
+   Word16 sid_frame;
+   Word16 valid_data;
+   Word16 dtxHangoverAdded;
+
+
+   /* updated in main decoder */
+   Word16 data_updated;   /* marker to know if CNI data is ever renewed */
+
+
+}dtx_decState;
+typedef struct
+{
+   Word32 past_gain;
+
+
+}agcState;
+typedef struct
+{
+   /* Excitation vector */
+   Word32 old_exc[L_SUBFR + PIT_MAX + L_INTERPOL];
+   Word32 *exc;
+   Word32 lsp_old[M];
+
+
+   /* Filter's memory */
+   Word32 mem_syn[M];
+
+
+   /* pitch sharpening */
+   Word32 sharp;
+   Word32 old_T0;
+
+
+   /* Variable holding received ltpLag, used in background noise and BFI */
+   Word32 T0_lagBuff;
+
+
+   /* Variables for the source characteristic detector (SCD) */
+   Word32 inBackgroundNoise;
+   Word32 voicedHangover;
+   Word32 ltpGainHistory[9];
+
+
+   /* Memories for bad frame handling */
+   Word32 excEnergyHist[9];
+   Word16 prev_bf;
+   Word16 prev_pdf;
+   Word16 state;
+   Word16 nodataSeed;
+
+
+   Bgn_scdState * background_state;
+   Cb_gain_averageState * Cb_gain_averState;
+   lsp_avgState * lsp_avg_st;
+   D_plsfState * lsfState;
+   ec_gain_pitchState * ec_gain_p_st;
+   ec_gain_codeState * ec_gain_c_st;
+   gc_predState * pred_state;
+   ph_dispState * ph_disp_st;
+   dtx_decState * dtxDecoderState;
+}Decoder_amrState;
+typedef struct
+{
+   Word32 res2[L_SUBFR];
+   Word32 mem_syn_pst[M];
+   Word32 synth_buf[M + L_FRAME];
+   Word32 preemph_state_mem_pre;
+   agcState * agc_state;
+}Post_FilterState;
+typedef struct
+{
+   Word32 y2_hi;
+   Word32 y2_lo;
+   Word32 y1_hi;
+   Word32 y1_lo;
+   Word32 x0;
+   Word32 x1;
+
+
+}Post_ProcessState;
+typedef struct
+{
+   Decoder_amrState * decoder_amrState;
+   Post_FilterState * post_state;
+   Post_ProcessState * postHP_state;
+}Speech_Decode_FrameState;
+
+
+/*
+ * CodAmrReset
+ *
+ *
+ * Parameters:
+ *    state             B: state structure
+ *    mode              I: AMR mode
+ *
+ * Function:
+ *    Resets state memory
+ *
+ * Returns:
+ *    void
+ */
+static void Decoder_amr_reset( Decoder_amrState *state, enum Mode mode )
+{
+   Word32 i;
+
+   /* Cb_gain_average_reset */
+   memset(state->Cb_gain_averState->cbGainHistory, 0, L_CBGAINHIST << 2);
+   state->Cb_gain_averState->hangVar = 0;
+   state->Cb_gain_averState->hangCount= 0;
+
+   /* Initialize static pointer */
+   state->exc = state->old_exc + PIT_MAX + L_INTERPOL;
+
+   /* Static vectors to zero */
+   memset( state->old_exc, 0, ( PIT_MAX + L_INTERPOL )<<2 );
+
+   if ( mode != MRDTX )
+      memset( state->mem_syn, 0, M <<2 );
+
+   /* initialize pitch sharpening */
+   state->sharp = SHARPMIN;
+   state->old_T0 = 40;
+
+   /* Initialize state->lsp_old [] */
+   if ( mode != MRDTX ) {
+      state->lsp_old[0] = 30000;
+      state->lsp_old[1] = 26000;
+      state->lsp_old[2] = 21000;
+      state->lsp_old[3] = 15000;
+      state->lsp_old[4] = 8000;
+      state->lsp_old[5] = 0;
+      state->lsp_old[6] = -8000;
+      state->lsp_old[7] = -15000;
+      state->lsp_old[8] = -21000;
+      state->lsp_old[9] = -26000;
+   }
+
+   /* Initialize memories of bad frame handling */
+   state->prev_bf = 0;
+   state->prev_pdf = 0;
+   state->state = 0;
+   state->T0_lagBuff = 40;
+   state->inBackgroundNoise = 0;
+   state->voicedHangover = 0;
+
+   if ( mode != MRDTX )
+      memset( state->excEnergyHist, 0, 9 <<2 );
+   memset( state->ltpGainHistory, 0, 9 <<2 );
+
+   if ( mode != MRDTX ) {
+      state->lsp_avg_st->lsp_meanSave[0] = 1384;
+      state->lsp_avg_st->lsp_meanSave[1] = 2077;
+      state->lsp_avg_st->lsp_meanSave[2] = 3420;
+      state->lsp_avg_st->lsp_meanSave[3] = 5108;
+      state->lsp_avg_st->lsp_meanSave[4] = 6742;
+      state->lsp_avg_st->lsp_meanSave[5] = 8122;
+      state->lsp_avg_st->lsp_meanSave[6] = 9863;
+      state->lsp_avg_st->lsp_meanSave[7] = 11092;
+      state->lsp_avg_st->lsp_meanSave[8] = 12714;
+      state->lsp_avg_st->lsp_meanSave[9] = 13701;
+   }
+   memset( state->lsfState->past_r_q, 0, M <<2 );
+
+   /* Past dequantized lsfs */
+   state->lsfState->past_lsf_q[0] = 1384;
+   state->lsfState->past_lsf_q[1] = 2077;
+   state->lsfState->past_lsf_q[2] = 3420;
+   state->lsfState->past_lsf_q[3] = 5108;
+   state->lsfState->past_lsf_q[4] = 6742;
+   state->lsfState->past_lsf_q[5] = 8122;
+   state->lsfState->past_lsf_q[6] = 9863;
+   state->lsfState->past_lsf_q[7] = 11092;
+   state->lsfState->past_lsf_q[8] = 12714;
+   state->lsfState->past_lsf_q[9] = 13701;
+
+   for ( i = 0; i < 5; i++ )
+      state->ec_gain_p_st->pbuf[i] = 1640;
+   state->ec_gain_p_st->past_gain_pit = 0;
+   state->ec_gain_p_st->prev_gp = 16384;
+
+   for ( i = 0; i < 5; i++ )
+      state->ec_gain_c_st->gbuf[i] = 1;
+   state->ec_gain_c_st->past_gain_code = 0;
+   state->ec_gain_c_st->prev_gc = 1;
+
+   if ( mode != MRDTX ) {
+      for ( i = 0; i < NPRED; i++ ) {
+         state->pred_state->past_qua_en[i] = MIN_ENERGY;
+         state->pred_state->past_qua_en_MR122[i] = MIN_ENERGY_MR122;
+      }
+   }
+   state->nodataSeed = 21845;
+
+   /* Static vectors to zero */
+   memset( state->background_state->frameEnergyHist, 0, L_ENERGYHIST <<2 );
+
+   /* Initialize hangover handling */
+   state->background_state->bgHangover = 0;
+
+   /* phDispReset */
+   memset( state->ph_disp_st->gainMem, 0, PHDGAINMEMSIZE <<2 );
+   state->ph_disp_st->prevState = 0;
+   state->ph_disp_st->prevCbGain = 0;
+   state->ph_disp_st->lockFull = 0;
+   state->ph_disp_st->onset = 0;   /* assume no onset in start */
+
+   if ( mode != MRDTX ) {
+      state->dtxDecoderState->since_last_sid = 0;
+      state->dtxDecoderState->true_sid_period_inv = 8192;
+      state->dtxDecoderState->log_en = 3500;
+      state->dtxDecoderState->old_log_en = 3500;
+
+      /* low level noise for better performance in  DTX handover cases*/
+      state->dtxDecoderState->pn_seed_rx = PN_INITIAL_SEED;
+
+      /* Initialize state->lsp [] */
+      state->dtxDecoderState->lsp[0] = 30000;
+      state->dtxDecoderState->lsp[1] = 26000;
+      state->dtxDecoderState->lsp[2] = 21000;
+      state->dtxDecoderState->lsp[3] = 15000;
+      state->dtxDecoderState->lsp[4] = 8000;
+      state->dtxDecoderState->lsp[5] = 0;
+      state->dtxDecoderState->lsp[6] = -8000;
+      state->dtxDecoderState->lsp[7] = -15000;
+      state->dtxDecoderState->lsp[8] = -21000;
+      state->dtxDecoderState->lsp[9] = -26000;
+
+      /* Initialize state->lsp_old [] */
+      state->dtxDecoderState->lsp_old[0] = 30000;
+      state->dtxDecoderState->lsp_old[1] = 26000;
+      state->dtxDecoderState->lsp_old[2] = 21000;
+      state->dtxDecoderState->lsp_old[3] = 15000;
+      state->dtxDecoderState->lsp_old[4] = 8000;
+      state->dtxDecoderState->lsp_old[5] = 0;
+      state->dtxDecoderState->lsp_old[6] = -8000;
+      state->dtxDecoderState->lsp_old[7] = -15000;
+      state->dtxDecoderState->lsp_old[8] = -21000;
+      state->dtxDecoderState->lsp_old[9] = -26000;
+      state->dtxDecoderState->lsf_hist_ptr = 0;
+      state->dtxDecoderState->log_pg_mean = 0;
+      state->dtxDecoderState->log_en_hist_ptr = 0;
+
+      /* initialize decoder lsf history */
+      state->dtxDecoderState->lsf_hist[0] = 1384;
+      state->dtxDecoderState->lsf_hist[1] = 2077;
+      state->dtxDecoderState->lsf_hist[2] = 3420;
+      state->dtxDecoderState->lsf_hist[3] = 5108;
+      state->dtxDecoderState->lsf_hist[4] = 6742;
+      state->dtxDecoderState->lsf_hist[5] = 8122;
+      state->dtxDecoderState->lsf_hist[6] = 9863;
+      state->dtxDecoderState->lsf_hist[7] = 11092;
+      state->dtxDecoderState->lsf_hist[8] = 12714;
+      state->dtxDecoderState->lsf_hist[9] = 13701;
+
+      for ( i = 1; i < DTX_HIST_SIZE; i++ ) {
+         memcpy( &state->dtxDecoderState->lsf_hist[M * i], &state->
+               dtxDecoderState->lsf_hist[0], M <<2 );
+      }
+      memset( state->dtxDecoderState->lsf_hist_mean, 0, M * DTX_HIST_SIZE <<2 );
+
+      /* initialize decoder log frame energy */
+      for ( i = 0; i < DTX_HIST_SIZE; i++ ) {
+         state->dtxDecoderState->log_en_hist[i] = state->dtxDecoderState->log_en
+         ;
+      }
+      state->dtxDecoderState->log_en_adjust = 0;
+      state->dtxDecoderState->dtxHangoverCount = DTX_HANG_CONST;
+      state->dtxDecoderState->decAnaElapsedCount = 31;
+      state->dtxDecoderState->sid_frame = 0;
+      state->dtxDecoderState->valid_data = 0;
+      state->dtxDecoderState->dtxHangoverAdded = 0;
+      state->dtxDecoderState->dtxGlobalState = DTX;
+      state->dtxDecoderState->data_updated = 0;
+   }
+   return;
+}
+
+
+/*
+ * rx_dtx_handler
+ *
+ *
+ * Parameters:
+ *    st->dtxGlobalState      I: DTX state
+ *    st->since_last_sid      B: Frames after last SID frame
+ *    st->data_updated        I: SID update flag
+ *    st->decAnaElapsedCount  B: state machine that synch with the GSMEFR txDtx machine
+ *    st->dtxHangoverAdded    B: DTX hangover
+ *    st->sid_frame           O: SID frame indicator
+ *    st->valid_data          O: Vaild data indicator
+ *    frame_type              O: Frame type
+ *
+ * Function:
+ *    Find the new DTX state
+ *
+ * Returns:
+ *    DTXStateType            DTX, DTX_MUTE or SPEECH
+ */
+static enum DTXStateType rx_dtx_handler( dtx_decState *st, enum RXFrameType frame_type )
+{
+   enum DTXStateType newState;
+   enum DTXStateType encState;
+
+   /* DTX if SID frame or previously in DTX{_MUTE} and (NO_RX OR BAD_SPEECH) */
+   if ( table_SID[frame_type] | ( ( st->dtxGlobalState != SPEECH ) &
+         table_speech_bad[frame_type] ) ) {
+      newState = DTX;
+
+      /* stay in mute for these input types */
+      if ( ( st->dtxGlobalState == DTX_MUTE ) & table_mute[frame_type] ) {
+         newState = DTX_MUTE;
+      }
+
+      /*
+       * evaluate if noise parameters are too old
+       * since_last_sid is reset when CN parameters have been updated
+       */
+      st->since_last_sid += 1;
+
+      /* no update of sid parameters in DTX for a long while */
+      if ((frame_type != RX_SID_UPDATE) & ( st->since_last_sid > DTX_MAX_EMPTY_THRESH )) {
+         newState = DTX_MUTE;
+      }
+   }
+   else {
+      newState = SPEECH;
+      st->since_last_sid = 0;
+   }
+
+   /*
+    * reset the decAnaElapsed Counter when receiving CNI data the first
+    * time, to robustify counter missmatch after handover
+    * this might delay the bwd CNI analysis in the new decoder slightly.
+    */
+   if ( ( st->data_updated == 0 ) & ( frame_type == RX_SID_UPDATE ) ) {
+      st->decAnaElapsedCount = 0;
+   }
+
+   /*
+    * update the SPE-SPD DTX hangover synchronization
+    * to know when SPE has added dtx hangover
+    */
+   st->decAnaElapsedCount += 1;
+   st->dtxHangoverAdded = 0;
+   encState = SPEECH;
+
+   if ( table_DTX[frame_type] ) {
+      encState = DTX;
+      if( ( frame_type == RX_NO_DATA ) & ( newState == SPEECH ) ) {
+         encState = SPEECH;
+      }
+   }
+
+   if ( encState == SPEECH ) {
+      st->dtxHangoverCount = DTX_HANG_CONST;
+   }
+   else {
+      if ( st->decAnaElapsedCount > DTX_ELAPSED_FRAMES_THRESH ) {
+         st->dtxHangoverAdded = 1;
+         st->decAnaElapsedCount = 0;
+         st->dtxHangoverCount = 0;
+      }
+      else if ( st->dtxHangoverCount == 0 ) {
+         st->decAnaElapsedCount = 0;
+      }
+      else {
+         st->dtxHangoverCount -= 1;
+      }
+   }
+
+   if ( newState != SPEECH ) {
+      /*
+       * DTX or DTX_MUTE
+       * CN data is not in a first SID, first SIDs are marked as SID_BAD
+       * but will do backwards analysis if a hangover period has been added
+       * according to the state machine above
+       */
+      st->sid_frame = 0;
+      st->valid_data = 0;
+
+      if ( frame_type == RX_SID_FIRST ) {
+         st->sid_frame = 1;
+      }
+      else if ( frame_type == RX_SID_UPDATE ) {
+         st->sid_frame = 1;
+         st->valid_data = 1;
+      }
+      else if ( frame_type == RX_SID_BAD ) {
+         st->sid_frame = 1;
+
+         /* use old data */
+         st->dtxHangoverAdded = 0;
+      }
+   }
+
+   /* newState is used by both SPEECH AND DTX synthesis routines */
+   return newState;
+}
+
+
+/*
+ * Lsf_lsp
+ *
+ *
+ * Parameters:
+ *    lsf               I: vector of LSFs
+ *    lsp               O: vector of LSPs
+ *
+ * Function:
+ *    Transformation lsf to lsp, order M
+ *
+ * Returns:
+ *    void
+ */
+static void Lsf_lsp( Word32 lsf[], Word32 lsp[] )
+{
+   Word32 i, ind, offset, tmp;
+
+
+   for ( i = 0; i < M; i++ ) {
+      /* ind = b8-b15 of lsf[i] */
+      ind = lsf[i] >> 8;
+
+      /* offset = b0-b7  of lsf[i] */
+      offset = lsf[i] & 0x00ff;
+
+      /* lsp[i] = table[ind]+ ((table[ind+1]-table[ind])*offset) / 256 */
+      tmp = ( ( cos_table[ind+1]-cos_table[ind] )*offset ) << 1;
+      lsp[i] = cos_table[ind] + ( tmp >> 9 );
+   }
+   return;
+}
+
+
+/*
+ * D_plsf_3
+ *
+ *
+ * Parameters:
+ *    st->past_lsf_q    I: Past dequantized LFSs
+ *    st->past_r_q      B: past quantized residual
+ *    mode              I: AMR mode
+ *    bfi               B: bad frame indicator
+ *    indice            I: quantization indices of 3 submatrices, Q0
+ *    lsp1_q            O: quantized 1st LSP vector
+ *
+ * Function:
+ *    Decodes the LSP parameters using the received quantization indices.
+ *    1st order MA prediction and split by 3 vector quantization (split-VQ)
+ *
+ * Returns:
+ *    void
+ */
+static void D_plsf_3( D_plsfState *st, enum Mode mode, Word16 bfi, Word16 *
+      indice, Word32 *lsp1_q )
+{
+   Word32 lsf1_r[M], lsf1_q[M];
+   Word32 i, index, temp;
+   const Word32 *p_cb1, *p_cb2, *p_cb3, *p_dico;
+
+
+   /* if bad frame */
+   if ( bfi != 0 ) {
+      /* use the past LSFs slightly shifted towards their mean */
+      for ( i = 0; i < M; i++ ) {
+         /* lsfi_q[i] = ALPHA*past_lsf_q[i] + ONE_ALPHA*meanLsf[i]; */
+         lsf1_q[i] = ( ( st->past_lsf_q[i] * ALPHA ) >> 15 ) + ( ( mean_lsf_3[i]
+               * ONE_ALPHA ) >> 15 );
+      }
+
+      /* estimate past quantized residual to be used in next frame */
+      if ( mode != MRDTX ) {
+         for ( i = 0; i < M; i++ ) {
+            /* temp  = meanLsf[i] +  pastR2_q[i] * pred_fac; */
+            temp = mean_lsf_3[i] + ( ( st->past_r_q[i] * pred_fac[i] ) >> 15 );
+            st->past_r_q[i] = lsf1_q[i] - temp;
+         }
+      }
+      else {
+         for ( i = 0; i < M; i++ ) {
+            /* temp  = meanLsf[i] +  pastR2_q[i]; */
+            temp = mean_lsf_3[i] + st->past_r_q[i];
+            st->past_r_q[i] = lsf1_q[i] - temp;
+         }
+      }
+   }
+
+   /* if good LSFs received */
+   else {
+      if ( ( mode == MR475 ) | ( mode == MR515 ) ) {
+         /* MR475, MR515 */
+         p_cb1 = dico1_lsf_3;
+         p_cb2 = dico2_lsf_3;
+         p_cb3 = mr515_3_lsf;
+      }
+      else if ( mode == MR795 ) {
+         /* MR795 */
+         p_cb1 = mr795_1_lsf;
+         p_cb2 = dico2_lsf_3;
+         p_cb3 = dico3_lsf_3;
+      }
+      else {
+         /* MR59, MR67, MR74, MR102, MRDTX */
+         p_cb1 = dico1_lsf_3;
+         p_cb2 = dico2_lsf_3;
+         p_cb3 = dico3_lsf_3;
+      }
+
+      /* decode prediction residuals from 3 received indices */
+      index = *indice++;
+      p_dico = &p_cb1[index + index + index];
+      index = *indice++;
+      lsf1_r[0] = *p_dico++;
+      lsf1_r[1] = *p_dico++;
+      lsf1_r[2] = *p_dico++;
+
+      if ( ( mode == MR475 ) | ( mode == MR515 ) ) {
+         /* MR475, MR515 only using every second entry */
+         index = index << 1;
+      }
+      p_dico = &p_cb2[index + index + index];
+      index = *indice++;
+      lsf1_r[3] = *p_dico++;
+      lsf1_r[4] = *p_dico++;
+      lsf1_r[5] = *p_dico++;
+      p_dico = &p_cb3[index << 2];
+      lsf1_r[6] = *p_dico++;
+      lsf1_r[7] = *p_dico++;
+      lsf1_r[8] = *p_dico++;
+      lsf1_r[9] = *p_dico++;
+
+      /* Compute quantized LSFs and update the past quantized residual */
+      if ( mode != MRDTX ) {
+         for ( i = 0; i < M; i++ ) {
+            lsf1_q[i] = lsf1_r[i] + ( mean_lsf_3[i] + ( ( st->past_r_q[i] *
+                  pred_fac[i] ) >> 15 ) );
+         }
+         memcpy( st->past_r_q, lsf1_r, M <<2 );
+      }
+      else {
+         for ( i = 0; i < M; i++ ) {
+            lsf1_q[i] = lsf1_r[i] + ( mean_lsf_3[i] + st->past_r_q[i] );
+         }
+         memcpy( st->past_r_q, lsf1_r, M <<2 );
+      }
+   }
+
+   /* verification that LSFs has minimum distance of LSF_GAP Hz */
+   temp = LSF_GAP;
+
+   for ( i = 0; i < M; i++ ) {
+      if ( lsf1_q[i] < temp ) {
+         lsf1_q[i] = temp;
+      }
+      temp = lsf1_q[i] + LSF_GAP;
+   }
+   memcpy( st->past_lsf_q, lsf1_q, M <<2 );
+
+   /*  convert LSFs to the cosine domain */
+   Lsf_lsp( lsf1_q, lsp1_q );
+   return;
+}
+
+
+/*
+ * pseudonoise
+ *
+ *
+ * Parameters:
+ *    shift_reg         B: Old CN generator shift register state
+ *    no_bits           I: Number of bits
+ *
+ * Function:
+ *    pseudonoise
+ *
+ * Returns:
+ *    noise_bits
+ */
+static Word32 pseudonoise( Word32 *shift_reg, Word32 no_bits )
+{
+   Word32 noise_bits, Sn, i;
+   Word32 s_reg;
+
+
+   s_reg = *shift_reg;
+   noise_bits = 0;
+
+   for ( i = 0; i < no_bits; i++ ) {
+      /* State n == 31 */
+      Sn = s_reg & 0x00000001L;
+
+      /* State n == 3 */
+      if ( s_reg & 0x10000000L ) {
+         Sn = Sn ^ 0x1L;
+      }
+      else {
+         Sn = Sn ^ 0x0L;
+      }
+      noise_bits = ( noise_bits << 1 ) | ( s_reg & 1 );
+      s_reg = s_reg >> 1;
+
+      if ( Sn & 1 ) {
+         s_reg = s_reg | 0x40000000L;
+      }
+   }
+   *shift_reg = s_reg;
+   return noise_bits;
+}
+
+
+/*
+ * Lsp_lsf
+ *
+ *
+ * Parameters:
+ *    lsp               I: LSP vector (range: -1<=val<1)
+ *    lsf               O: LSF vector Old CN generator shift register state
+ *
+ * Function:
+ *    Transformation lsp to lsf, LPC order M
+ *    lsf[i] = arccos(lsp[i])/(2*pi)
+ *
+ * Returns:
+ *    void
+ */
+static void Lsp_lsf( Word32 lsp[], Word32 lsf[] )
+{
+   Word32 i, ind = 63;   /* begin at end of table -1 */
+
+
+   for ( i = M - 1; i >= 0; i-- ) {
+      /* find value in table that is just greater than lsp[i] */
+      while ( cos_table[ind] < lsp[i] ) {
+         ind--;
+      }
+      lsf[i] = ( ( ( ( lsp[i] - cos_table[ind] ) * acos_slope[ind] ) + 0x800 )
+            >> 12 ) + ( ind << 8 );
+   }
+   return;
+}
+
+
+/*
+ * Reorder_lsf
+ *
+ *
+ * Parameters:
+ *    lsf            B: vector of LSFs (range: 0<=val<=0.5)
+ *    min_dist       I: minimum required distance
+ *
+ * Function:
+ *    Make sure that the LSFs are properly ordered and to keep a certain minimum
+ *    distance between adjacent LSFs. LPC order = M.
+ *
+ * Returns:
+ *    void
+ */
+static void Reorder_lsf( Word32 *lsf, Word32 min_dist )
+{
+   Word32 lsf_min, i;
+
+
+   lsf_min = min_dist;
+
+   for ( i = 0; i < M; i++ ) {
+      if ( lsf[i] < lsf_min ) {
+         lsf[i] = lsf_min;
+      }
+      lsf_min = lsf[i] + min_dist;
+   }
+}
+
+/* VC5.0 Global optimization does not work with this function */
+#if _MSC_VER == 1100
+#pragma optimize( "g", off )
+#endif
+/*
+ * Get_lsp_pol
+ *
+ *
+ * Parameters:
+ *    lsp               I: line spectral frequencies
+ *    f                 O: polynomial F1(z) or F2(z)
+ *
+ * Function:
+ *    Find the polynomial F1(z) or F2(z) from the LSPs.
+ *
+ *    F1(z) = product ( 1 - 2 lsp[i] z^-1 + z^-2 )
+ *             i=0,2,4,6,8
+ *    F2(z) = product   ( 1 - 2 lsp[i] z^-1 + z^-2 )
+ *             i=1,3,5,7,9
+ *
+ *    where lsp[] is the LSP vector in the cosine domain.
+ *
+ *    The expansion is performed using the following recursion:
+ *
+ *    f[0] = 1
+ *    b = -2.0 * lsp[0]
+ *    f[1] = b
+ *    for i=2 to 5 do
+ *       b = -2.0 * lsp[2*i-2];
+ *       f[i] = b*f[i-1] + 2.0*f[i-2];
+ *       for j=i-1 down to 2 do
+ *          f[j] = f[j] + b*f[j-1] + f[j-2];
+ *       f[1] = f[1] + b;
+ *
+ * Returns:
+ *    void
+ */
+static void Get_lsp_pol( Word32 *lsp, Word32 *f )
+{
+   volatile Word32 f0, f1, f2, f3, f4, f5;
+   Word32 l1, l2, l3, l4;
+
+
+   /* f[0] = 1.0; */
+   f0 = 16777216L;
+
+   /* f1 = *lsp * -1024; */
+   f1 = -lsp[0] << 10;
+   l1 = lsp[2];
+   l2 = lsp[4];
+   l3 = lsp[6];
+   l4 = lsp[8];
+   f2 = f0 << 1;
+   f2 -= ( ( ( f1 >> 16 ) * l1 ) + ( ( ( f1 & 0xFFFE ) * l1 ) >> 16 ) ) << 2;
+   f1 -= l1 << 10;
+   f3 = f1 << 1;
+   f3 -= ( ( ( f2 >> 16 ) * l2 ) + ( ( ( f2 & 0xFFFE ) * l2 ) >> 16 ) ) << 2;
+   f2 += f0;
+   f2 -= ( ( ( f1 >> 16 ) * l2 ) + ( ( ( f1 & 0xFFFE ) * l2 ) >> 16 ) ) << 2;
+   f1 -= l2 << 10;
+   f4 = f2 << 1;
+   f4 -= ( ( ( f3 >> 16 ) * l3 ) + ( ( ( f3 & 0xFFFE ) * l3 ) >> 16 ) ) << 2;
+   f3 += f1;
+   f3 -= ( ( ( f2 >> 16 ) * l3 ) + ( ( ( f2 & 0xFFFE ) * l3 ) >> 16 ) ) << 2;
+   f2 += f0;
+   f2 -= ( ( ( f1 >> 16 ) * l3 ) + ( ( ( f1 & 0xFFFE ) * l3 ) >> 16 ) ) << 2;
+   f1 -= l3 << 10;
+   f5 = f3 << 1;
+   f5 -= ( ( ( f4 >> 16 ) * l4 ) + ( ( ( f4 & 0xFFFE ) * l4 ) >> 16 ) ) << 2;
+   f4 += f2;
+   f4 -= ( ( ( f3 >> 16 ) * l4 ) + ( ( ( f3 & 0xFFFE ) * l4 ) >> 16 ) ) << 2;
+   f3 += f1;
+   f3 -= ( ( ( f2 >> 16 ) * l4 ) + ( ( ( f2 & 0xFFFE ) * l4 ) >> 16 ) ) << 2;
+   f2 += f0;
+   f2 -= ( ( ( f1 >> 16 ) * l4 ) + ( ( ( f1 & 0xFFFE ) * l4 ) >> 16 ) ) << 2;
+   f1 -= l4 << 10;
+   f[0] = f0;
+   f[1] = f1;
+   f[2] = f2;
+   f[3] = f3;
+   f[4] = f4;
+   f[5] = f5;
+   return;
+}
+#if _MSC_VER == 1100
+#pragma optimize( "", on )
+#endif
+
+
+/*
+ * Lsp_Az
+ *
+ *
+ * Parameters:
+ *    lsp                 I: Line spectral frequencies
+ *    a                   O: Predictor coefficients
+ *
+ * Function:
+ *    Converts from the line spectral pairs (LSP) to LP coefficients,
+ *    for a 10th order filter.
+ *
+ *    Find the coefficients of F1(z) and F2(z)
+ *    Multiply F1(z) by 1+z^{-1} and F2(z) by 1-z^{-1}
+ *    A(z) = ( F1(z) + F2(z) ) / 2
+ *
+ * Returns:
+ *    void
+ */
+static void Lsp_Az( Word32 lsp[], Word32 a[] )
+{
+   Word32 f1[6], f2[6];
+   Word32 T0, i, j;
+
+
+   Get_lsp_pol( &lsp[0], f1 );
+   Get_lsp_pol( &lsp[1], f2 );
+
+   for ( i = 5; i > 0; i-- ) {
+      f1[i] += f1[i - 1];
+      f2[i] -= f2[i - 1];
+   }
+   a[0] = 4096;
+
+   for ( i = 1, j = 10; i <= 5; i++, j-- ) {
+      T0 = f1[i] + f2[i];
+      a[i] = (Word16)(T0 >> 13);  /* emulate fixed point bug */
+      if ( ( T0 & 4096 ) != 0 ) {
+         a[i]++;
+      }
+      T0 = f1[i] - f2[i];
+      a[j] = (Word16)(T0 >> 13);   /* emulate fixed point bug */
+
+      if ( ( T0 & 4096 ) != 0 ) {
+         a[j]++;
+      }
+   }
+   return;
+}
+
+
+/*
+ * A_Refl
+ *
+ *
+ * Parameters:
+ *    a                 I: Directform coefficients
+ *    refl              O: Reflection coefficients
+ *
+ * Function:
+ *    Converts from the directform coefficients to reflection coefficients
+ *
+ * Returns:
+ *    void
+ */
+static void A_Refl( Word32 a[], Word32 refl[] )
+{
+   /* local variables */
+   int normShift;
+   Word32 aState[M], bState[M];
+   Word32 normProd, acc, temp, mult, scale, i, j;
+
+
+   /* initialize states */
+   memcpy( aState, a, M <<2 );
+
+   /* backward Levinson recursion */
+   for ( i = M - 1; i >= 0; i-- ) {
+      if ( labs( aState[i] ) >= 4096 ) {
+         goto ExitRefl;
+      }
+      refl[i] = aState[i] << 3;
+      temp = ( refl[i] * refl[i] ) << 1;
+      acc = ( MAX_32 - temp );
+      normShift=0;
+      if (acc != 0){
+         temp = acc;
+         while (!(temp & 0x40000000))
+         {
+            normShift++;
+            temp = temp << 1;
+         }
+      }
+      else{
+         normShift = 0;
+      }
+      scale = 15 - normShift;
+      acc = ( acc << normShift );
+      temp = ( acc + ( Word32 )0x00008000L );
+
+      if ( temp > 0 ) {
+         normProd = temp >> 16;
+         mult = 0x20000000L / normProd;
+      }
+      else
+         mult = 16384;
+
+      for ( j = 0; j < i; j++ ) {
+         acc = aState[j] << 16;
+         acc -= ( refl[i] * aState[i - j - 1] ) << 1;
+         temp = ( acc + ( Word32 )0x00008000L ) >> 16;
+         temp = ( mult * temp ) << 1;
+
+         if ( scale > 0 ) {
+            if ( ( temp & ( ( Word32 )1 << ( scale - 1 ) ) ) != 0 ) {
+               temp = ( temp >> scale ) + 1;
+            }
+            else
+               temp = ( temp >> scale );
+         }
+         else
+            temp = ( temp >> scale );
+
+         if ( labs( temp ) > 32767 ) {
+            goto ExitRefl;
+         }
+         bState[j] = temp;
+      }
+      memcpy( aState, bState, i <<2 );
+   }
+   return;
+ExitRefl:
+   memset( refl, 0, M <<2 );
+}
+
+
+/*
+ * Log2_norm
+ *
+ *
+ * Parameters:
+ *    x                 I: input value
+ *    exp               I: exponent
+ *    exponent          O: Integer part of Log2. (range: 0<=val<=30)
+ *    fraction          O: Fractional part of Log2. (range: 0<=val<1)
+ *
+ * Function:
+ *    Computes log2
+ *
+ *    Computes log2(L_x, exp),  where   L_x is positive and
+ *    normalized, and exp is the normalisation exponent
+ *    If L_x is negative or zero, the result is 0.
+ *
+ *    The function Log2(L_x) is approximated by a table and linear
+ *    interpolation. The following steps are used to compute Log2(L_x)
+ *
+ *    exponent = 30-normExponent
+ *    i = bit25-b31 of L_x;  32<=i<=63  (because of normalization).
+ *    a = bit10-b24
+ *    i -=32
+ *    fraction = table[i]<<16 - (table[i] - table[i+1]) * a * 2
+ *
+ * Returns:
+ *    void
+ */
+static void Log2_norm( Word32 x, Word32 exp, Word32 *exponent, Word32 *
+      fraction )
+{
+   Word32 y, i, a;
+
+
+   if ( x <= 0 ) {
+      *exponent = 0;
+      *fraction = 0;
+      return;
+   }
+
+   /* Extract b25-b31 */
+   i = x >> 25;
+   i = i - 32;
+
+   /* Extract b10-b24 of fraction */
+   a = x >> 9;
+   a = a & 0xFFFE;   /* 2a */
+
+   /* fraction */
+   y = ( log2_table[i] << 16 ) - a * ( log2_table[i] - log2_table[i + 1] );
+   *fraction = y >> 16;
+   *exponent = 30 - exp;
+   return;
+}
+
+
+/*
+ * Log2
+ *
+ *
+ * Parameters:
+ *    x                 I: input value
+ *    exponent          O: Integer part of Log2. (range: 0<=val<=30)
+ *    fraction          O: Fractional part of Log2. (range: 0<=val<1)
+ *
+ * Function:
+ *    Computes log2(L_x)
+ *    If x is negative or zero, the result is 0.
+ *
+ * Returns:
+ *    void
+ */
+static void Log2( Word32 x, Word32 *exponent, Word32 *fraction )
+{
+   int tmp, exp=0;
+
+   if (x != 0){
+         tmp = x;
+         while (!((tmp & 0x80000000) ^ ((tmp & 0x40000000) << 1)))
+         {
+            exp++;
+            tmp = tmp << 1;
+         }
+      }
+   Log2_norm( x <<exp, exp, exponent, fraction );
+}
+
+
+/*
+ * Pow2
+ *
+ *
+ * Parameters:
+ *    exponent          I: Integer part. (range: 0<=val<=30)
+ *    fraction          O: Fractional part. (range: 0.0<=val<1.0)
+ *
+ * Function:
+ *    pow(2.0, exponent.fraction)
+ *
+ *    The function Pow2(L_x) is approximated by a table and linear interpolation.
+ *
+ *    i = bit10-b15 of fraction, 0 <= i <= 31
+ *    a = biT0-b9   of fraction
+ *    x = table[i]<<16 - (table[i] - table[i+1]) * a * 2
+ *    x = L_x >> (30-exponent) (with rounding)
+ *
+ * Returns:
+ *    result (range: 0<=val<=0x7fffffff)
+ */
+static Word32 Pow2( Word32 exponent, Word32 fraction )
+{
+   Word32 i, a, tmp, x, exp;
+
+
+   /* Extract b10-b16 of fraction */
+   i = fraction >> 10;
+
+   /* Extract b0-b9 of fraction */
+   a = ( fraction << 5 ) & 0x7fff;
+
+   /* table[i] << 16 */
+   x = pow2_table[i] << 16;
+
+   /* table[i] - table[i+1] */
+   tmp = pow2_table[i] - pow2_table[i + 1];
+
+   /* L_x -= tmp*a*2 */
+   x -= ( tmp * a ) << 1;
+
+   if ( exponent >= -1 ) {
+      exp = ( 30 - exponent );
+
+      /* Rounding */
+      if ( ( x & ( ( Word32 )1 << ( exp - 1 ) ) ) != 0 ) {
+         x = ( x >> exp ) + 1;
+      }
+      else
+         x = x >> exp;
+   }
+   else
+      x = 0;
+   return( x );
+}
+
+
+/*
+ * Build_CN_code
+ *
+ *
+ * Parameters:
+ *    seed              B: Old CN generator shift register state
+ *    cod               O: Generated CN fixed codebook vector
+ *
+ * Function:
+ *    Generate CN fixed codebook vector
+ *
+ * Returns:
+ *    void
+ */
+static void Build_CN_code( Word32 *seed, Word32 cod[] )
+{
+   Word32 i, j, k;
+
+
+   memset( cod, 0, L_SUBFR <<2 );
+
+   for ( k = 0; k < 10; k++ ) {
+      i = pseudonoise( seed, 2 );   /* generate pulse position */
+      i = ( i * 20 ) >> 1;
+      i = ( i + k );
+      j = pseudonoise( seed, 1 );   /* generate sign           */
+
+      if ( j > 0 ) {
+         cod[i] = 4096;
+      }
+      else {
+         cod[i] = -4096;
+      }
+   }
+   return;
+}
+
+
+/*
+ * Build_CN_param
+ *
+ *
+ * Parameters:
+ *    seed              B: Old CN generator shift register state
+ *    nParam            I: number of params
+ *    paramSizeTable    I: size of params
+ *    parm              O: CN Generated params
+ *
+ * Function:
+ *    Generate parameters for comfort noise generation
+ *
+ * Returns:
+ *    void
+ */
+static void Build_CN_param( Word16 *seed, enum Mode mode, Word16 parm[] )
+{
+   Word32 i;
+   const Word32 *p;
+
+
+   *seed = ( Word16 )( ( *seed * 31821 ) + 13849L );
+   p = &window_200_40[ * seed & 0x7F];
+
+   switch ( mode ) {
+      case MR122:
+         for ( i = 0; i < PRMNO_MR122; i++ ) {
+            parm[i] = ( Word16 )( *p++ & ~( 0xFFFF << bitno_MR122[i] ) );
+         }
+         break;
+
+      case MR102:
+         for ( i = 0; i < PRMNO_MR102; i++ ) {
+            parm[i] = ( Word16 )( *p++ & ~( 0xFFFF << bitno_MR102[i] ) );
+         }
+         break;
+
+      case MR795:
+         for ( i = 0; i < PRMNO_MR795; i++ ) {
+            parm[i] = ( Word16 )( *p++ & ~( 0xFFFF << bitno_MR795[i] ) );
+         }
+         break;
+
+      case MR74:
+         for ( i = 0; i < PRMNO_MR74; i++ ) {
+            parm[i] = ( Word16 )( *p++ & ~( 0xFFFF << bitno_MR74[i] ) );
+         }
+         break;
+
+      case MR67:
+         for ( i = 0; i < PRMNO_MR67; i++ ) {
+            parm[i] = ( Word16 )( *p++ & ~( 0xFFFF << bitno_MR67[i] ) );
+         }
+         break;
+
+      case MR59:
+         for ( i = 0; i < PRMNO_MR59; i++ ) {
+            parm[i] = ( Word16 )( *p++ & ~( 0xFFFF << bitno_MR59[i] ) );
+         }
+         break;
+
+      case MR515:
+         for ( i = 0; i < PRMNO_MR515; i++ ) {
+            parm[i] = ( Word16 )( *p++ & ~( 0xFFFF << bitno_MR515[i] ) );
+         }
+         break;
+
+      case MR475:
+         for ( i = 0; i < PRMNO_MR475; i++ ) {
+            parm[i] = ( Word16 )( *p++ & ~( 0xFFFF << bitno_MR475[i] ) );
+         }
+         break;
+   }
+}
+
+
+/*
+ * Syn_filt
+ *
+ *
+ * Parameters:
+ *    a                 I: prediction coefficients [M+1]
+ *    x                 I: input signal
+ *    y                 O: output signal
+ *    lg                I: size of filtering
+ *    mem               B: memory associated with this filtering
+ *    update            I: 0=no update, 1=update of memory.
+ *
+ * Function:
+ *    Perform synthesis filtering through 1/A(z).
+ *
+ * Returns:
+ *    void
+ */
+static Word32 Syn_filt( Word32 a[], Word32 x[], Word32 y[], Word32 lg, Word32 mem[]
+      , Word32 update )
+{
+   Word32 tmp[50];   /* malloc is slow */
+   Word32 s, a0, overflow = 0;
+   Word32 *yy, *yy_limit;
+
+
+   /* Copy mem[] to yy[] */
+   memcpy( tmp, mem, 40 );
+   yy = tmp + M;
+   yy_limit = yy + lg;
+   a0 = a[0];
+
+   /* Do the filtering. */
+   while ( yy < yy_limit ) {
+
+      s = *x++ * a0;
+      s -= yy[-1] * a[1];
+      s -= yy[-2] * a[2];
+      s -= yy[-3] * a[3];
+      s -= yy[-4] * a[4];
+      s -= yy[-5] * a[5];
+      s -= yy[-6] * a[6];
+      s -= yy[-7] * a[7];
+      s -= yy[-8] * a[8];
+      s -= yy[-9] * a[9];
+      s -= yy[-10] * a[10];
+      if ( labs( s ) < 0x7ffffff )
+         *yy = ( s + 0x800L ) >> 12;
+      else if ( s > 0 ) {
+         *yy = 32767;
+         overflow = 1;
+      }
+      else {
+         *yy = -32768;
+         overflow = 1;
+      }
+      yy++;
+   }
+   memcpy( y, &tmp[M], lg <<2 );
+
+   /* Update of memory if update==1 */
+   if ( update ) {
+      memcpy( mem, &y[lg - M], 40 );
+   }
+   return overflow;
+}
+
+/*
+ * Syn_filt_overflow
+ *
+ *
+ * Parameters:
+ *    a                 I: prediction coefficients [M+1]
+ *    x                 I: input signal
+ *    y                 O: output signal
+ *    lg                I: size of filtering
+ *    mem               B: memory associated with this filtering
+ *    update            I: 0=no update, 1=update of memory.
+ *
+ * Function:
+ *    Perform synthesis filtering through 1/A(z).
+ *    Saturate after every multiplication.
+ * Returns:
+ *    void
+ */
+static void Syn_filt_overflow( Word32 a[], Word32 x[], Word32 y[], Word32 lg, Word32 mem[]
+      , Word32 update )
+{
+   Word32 tmp[50];   /* malloc is slow */
+   Word32 i, j, s, a0;
+   Word32 *yy;
+
+
+   /* Copy mem[] to yy[] */
+   memcpy( tmp, mem, 40 );
+   yy = tmp + M;
+   a0 = a[0];
+
+   /* Do the filtering. */
+   for ( i = 0; i < lg; i++ ) {
+      s = x[i] * a0;
+
+      for ( j = 1; j <= M; j++ ) {
+         s -= a[j] * yy[ - j];
+         if (s > 1073741823){
+            s = 1073741823;
+         }
+         else if ( s < -1073741824) {
+            s = -1073741824;
+         }
+      }
+
+      if ( labs( s ) < 0x7FFE800 )
+         *yy = ( s + 0x800L ) >> 12;
+      else if ( s > 0 ) {
+         *yy = 32767;
+      }
+      else {
+         *yy = -32768;
+      }
+      yy++;
+   }
+   memcpy( y, &tmp[M], lg <<2 );
+
+   /* Update of memory if update==1 */
+   if ( update ) {
+      memcpy( mem, &y[lg - M], 40 );
+   }
+   return;
+}
+
+/*
+ * dtx_dec
+ *
+ *
+ * Parameters:
+ *    st                            B: DTX state struct
+ *    mem_syn                       I: AMR decoder state
+ *    lsfState                      B: LSF state struct
+ *    pred_state->past_qua_en       O: table of past quantized energies
+ *    pred_state->past_qua_en_MR122 O: table of past quantized energies MR122
+ *    averState->hangVar            O:
+ *    averState->hangCount          O: hangover variable
+ *    new_state                     I: new DTX state
+ *    mode                          I: AMR mode
+ *    parm                          I: vector of synthesis parameters
+ *    synth                         O: synthesised speech
+ *    A_t                           O: decoded LP filter in 4 subframes
+ *
+ * Function:
+ *    DTX
+ *
+ * Returns:
+ *    void
+ */
+static void dtx_dec( dtx_decState *st, Word32 *mem_syn, D_plsfState *lsfState,
+      gc_predState *pred_state, Cb_gain_averageState *averState, enum
+      DTXStateType new_state, enum Mode mode, Word16 parm[], Word32 synth[],
+      Word32 A_t[] )
+{
+   Word32 ex[L_SUBFR], acoeff[11], acoeff_variab[M + 1], lsp_int[M];
+   Word32 refl[M], lsf[M], lsf_int[M], lsf_int_variab[M], lsp_int_variab[M];
+   Word32 i, j, int_fac, log_en_int, pred_err, log_pg_e, log_pg_m, log_pg;
+   Word32 negative, lsf_mean, lsf_variab_index, lsf_variab_factor, ptr;
+   Word16 log_en_index, log_en_int_e, log_en_int_m, level, ma_pred_init,
+         tmp_int_length;
+
+
+   if ( ( st->dtxHangoverAdded != 0 ) & ( st->sid_frame != 0 ) ) {
+      /*
+       * sidFirst after dtx hangover period
+       * or sidUpd after dtxhangover
+       */
+      /* set log_en_adjust to correct value */
+      st->log_en_adjust = dtx_log_en_adjust[mode];
+      ptr = st->lsf_hist_ptr + M;
+
+      if ( ptr == 80 ) {
+         ptr = 0;
+      }
+      memcpy( &st->lsf_hist[ptr], &st->lsf_hist[st->lsf_hist_ptr], M <<2 );
+      ptr = st->log_en_hist_ptr + 1;
+
+      if ( ptr == DTX_HIST_SIZE ) {
+         ptr = 0;
+      }
+      st->log_en_hist[ptr] = st->log_en_hist[st->log_en_hist_ptr];   /* Q11 */
+
+      /*
+       * compute mean log energy and lsp
+       * from decoded signal (SID_FIRST)
+       */
+      st->log_en = 0;
+      memset( lsf, 0, M <<2 );
+
+      /* average energy and lsp */
+      for ( i = 0; i < DTX_HIST_SIZE; i++ ) {
+         st->log_en = st->log_en + ( st->log_en_hist[i] >> 3 );
+
+         for ( j = 0; j < M; j++ ) {
+            lsf[j] += st->lsf_hist[i * M + j];
+         }
+      }
+
+      for ( j = 0; j < M; j++ ) {
+         lsf[j] = lsf[j] >> 3;   /* divide by 8 */
+      }
+      Lsf_lsp( lsf, st->lsp );
+
+      /*
+       * make log_en speech coder mode independent
+       * added again later before synthesis
+       */
+      st->log_en = st->log_en - st->log_en_adjust;
+
+      /* compute lsf variability vector */
+      memcpy( st->lsf_hist_mean, st->lsf_hist, 80 <<2 );
+
+      for ( i = 0; i < M; i++ ) {
+         lsf_mean = 0;
+
+         /* compute mean lsf */
+         for ( j = 0; j < 8; j++ ) {
+            lsf_mean += st->lsf_hist_mean[i + j * M];
+         }
+         lsf_mean = lsf_mean >> 3;
+
+         /*
+          * subtract mean and limit to within reasonable limits
+          * moreover the upper lsf's are attenuated
+          */
+         for ( j = 0; j < 8; j++ ) {
+            /* subtract mean */
+            st->lsf_hist_mean[i + j * M] = st->lsf_hist_mean[i + j * M] -
+                  lsf_mean;
+
+            /* attenuate deviation from mean, especially for upper lsf's */
+            st->lsf_hist_mean[i + j * M] = ( st->lsf_hist_mean[i + j * M] *
+                  lsf_hist_mean_scale[i] ) >> 15;
+
+            /* limit the deviation */
+            if ( st->lsf_hist_mean[i + j * M] < 0 ) {
+               negative = 1;
+            }
+            else {
+               negative = 0;
+            }
+            st->lsf_hist_mean[i + j * M] = labs( st->lsf_hist_mean[i + j * M] );
+
+            /* apply soft limit */
+            if ( st->lsf_hist_mean[i + j * M] > 655 ) {
+               st->lsf_hist_mean[i + j * M] = 655 + ( ( st->lsf_hist_mean[i + j
+                     * M] - 655 ) >> 2 );
+            }
+
+            /* apply hard limit */
+            if ( st->lsf_hist_mean[i + j * M] > 1310 ) {
+               st->lsf_hist_mean[i + j * M] = 1310;
+            }
+
+            if ( negative != 0 ) {
+               st->lsf_hist_mean[i + j * M] = -st->lsf_hist_mean[i + j * M];
+            }
+         }
+      }
+   }
+
+   if ( st->sid_frame != 0 ) {
+      /*
+       * Set old SID parameters, always shift
+       * even if there is no new valid_data
+       */
+      memcpy( st->lsp_old, st->lsp, M <<2 );
+      st->old_log_en = st->log_en;
+
+      if ( st->valid_data != 0 ) /* new data available (no CRC) */ {
+      /* Compute interpolation factor, since the division only works
+       * for values of since_last_sid < 32 we have to limit the
+       * interpolation to 32 frames
+       */
+         tmp_int_length = st->since_last_sid;
+         st->since_last_sid = 0;
+
+         if ( tmp_int_length > 32 ) {
+            tmp_int_length = 32;
+         }
+
+         if ( tmp_int_length >= 2 ) {
+            st->true_sid_period_inv = 0x2000000 / ( tmp_int_length
+                  << 10 );
+         }
+         else {
+            st->true_sid_period_inv = 16384;   /* 0.5 it Q15 */
+         }
+         memcpy( lsfState->past_r_q, &past_rq_init[parm[0] * M], M <<2 );
+         D_plsf_3( lsfState, MRDTX, 0, &parm[1], st->lsp );
+
+         /* reset for next speech frame */
+         memset( lsfState->past_r_q, 0, M <<2 );
+         log_en_index = parm[4];
+
+         /* Q11 and divide by 4 */
+         st->log_en = ( Word16 )( log_en_index << 9 );
+
+         /* Subtract 2.5 in Q11 */
+         st->log_en = ( Word16 )( st->log_en - 5120 );
+
+         /* Index 0 is reserved for silence */
+         if ( log_en_index == 0 ) {
+            st->log_en = MIN_16;
+         }
+
+         /*
+          * no interpolation at startup after coder reset
+          * or when SID_UPD has been received right after SPEECH
+          */
+         if ( ( st->data_updated == 0 ) || ( st->dtxGlobalState == SPEECH ) ) {
+            memcpy( st->lsp_old, st->lsp, M <<2 );
+            st->old_log_en = st->log_en;
+         }
+      }   /* endif valid_data */
+
+      /* initialize gain predictor memory of other modes */
+      ma_pred_init = ( Word16 )( ( st->log_en >> 1 ) - 9000 );
+
+      if ( ma_pred_init > 0 ) {
+         ma_pred_init = 0;
+      }
+
+      if ( ma_pred_init < - 14436 ) {
+         ma_pred_init = -14436;
+      }
+      pred_state->past_qua_en[0] = ma_pred_init;
+      pred_state->past_qua_en[1] = ma_pred_init;
+      pred_state->past_qua_en[2] = ma_pred_init;
+      pred_state->past_qua_en[3] = ma_pred_init;
+
+      /* past_qua_en for other modes than MR122 */
+      ma_pred_init = ( Word16 )( ( 5443*ma_pred_init ) >> 15 );
+
+      /* scale down by factor 20*log10(2) in Q15 */
+      pred_state->past_qua_en_MR122[0] = ma_pred_init;
+      pred_state->past_qua_en_MR122[1] = ma_pred_init;
+      pred_state->past_qua_en_MR122[2] = ma_pred_init;
+      pred_state->past_qua_en_MR122[3] = ma_pred_init;
+   }   /* endif sid_frame */
+
+   /*
+    * CN generation
+    * recompute level adjustment factor Q11
+    * st->log_en_adjust = 0.9*st->log_en_adjust +
+    *                     0.1*dtx_log_en_adjust[mode]);
+    */
+   st->log_en_adjust = ( Word16 )( ( ( st->log_en_adjust * 29491 ) >> 15 ) + ( (
+         ( dtx_log_en_adjust[mode] << 5 ) * 3277 ) >> 20 ) );
+
+   /* Interpolate SID info */
+   /* Q10 */
+   if ( st->since_last_sid > 30 )
+      int_fac = 32767;
+   else
+      int_fac = ( Word16 )( (st->since_last_sid + 1) << 10 );
+
+   /* Q10 * Q15 -> Q10 */
+   int_fac = ( int_fac * st->true_sid_period_inv ) >> 15;
+
+   /* Maximize to 1.0 in Q10 */
+   if ( int_fac > 1024 ) {
+      int_fac = 1024;
+   }
+
+   /* Q10 -> Q14 */
+   int_fac = ( Word16 )( int_fac << 4 );
+
+   /* Q14 * Q11->Q26 */
+   log_en_int = ( int_fac * st->log_en ) << 1;
+
+   for ( i = 0; i < M; i++ ) {
+      /* Q14 * Q15 -> Q14 */
+      lsp_int[i] = ( int_fac * st->lsp[i] ) >> 15;
+   }
+
+   /* 1-k in Q14 */
+   int_fac = 16384 - int_fac;
+
+   /* (Q14 * Q11 -> Q26) + Q26 -> Q26 */
+   log_en_int += ( int_fac * st->old_log_en ) << 1;
+
+   for ( i = 0; i < M; i++ ) {
+      /* Q14 + (Q14 * Q15 -> Q14) -> Q14 */
+      lsp_int[i] = lsp_int[i] + ( ( int_fac * st->lsp_old[i] ) >> 15 );
+
+      /* Q14 -> Q15 */
+      lsp_int[i] = lsp_int[i] << 1;
+   }
+
+   /* compute the amount of lsf variability */
+   /* -0.6 in Q12 */
+   lsf_variab_factor = st->log_pg_mean - 2457;
+
+   /* *0.3 Q12*Q15 -> Q12 */
+   lsf_variab_factor = 4096 - ( ( lsf_variab_factor * 9830 ) >> 15 );
+
+   /* limit to values between 0..1 in Q12 */
+   if ( lsf_variab_factor >= 4096 ) {
+      lsf_variab_factor = 32767;
+   }
+   else if ( lsf_variab_factor < 0 ) {
+      lsf_variab_factor = 0;
+   }
+   else
+      lsf_variab_factor = lsf_variab_factor << 3;   /* -> Q15 */
+
+   /* get index of vector to do variability with */
+   lsf_variab_index = pseudonoise( &st->pn_seed_rx, 3 );
+
+   /* convert to lsf */
+   Lsp_lsf( lsp_int, lsf_int );
+
+   /* apply lsf variability */
+   memcpy( lsf_int_variab, lsf_int, M <<2 );
+
+   for ( i = 0; i < M; i++ ) {
+      lsf_int_variab[i] = lsf_int_variab[i] + ( ( lsf_variab_factor * st->
+            lsf_hist_mean[i + lsf_variab_index * M] ) >> 15 );
+   }
+
+   /* make sure that LSP's are ordered */
+   Reorder_lsf( lsf_int, LSF_GAP );
+   Reorder_lsf( lsf_int_variab, LSF_GAP );
+
+   /* copy lsf to speech decoders lsf state */
+   memcpy( lsfState->past_lsf_q, lsf_int, M <<2 );
+
+   /* convert to lsp */
+   Lsf_lsp( lsf_int, lsp_int );
+   Lsf_lsp( lsf_int_variab, lsp_int_variab );
+
+     /* Compute acoeffs Q12 acoeff is used for level
+      * normalization and Post_Filter, acoeff_variab is
+      * used for synthesis filter
+      * by doing this we make sure that the level
+      * in high frequenncies does not jump up and down
+      */
+   Lsp_Az( lsp_int, acoeff );
+   Lsp_Az( lsp_int_variab, acoeff_variab );
+
+   /* For use in Post_Filter */
+   memcpy( &A_t[0], acoeff, MP1 <<2 );
+   memcpy( &A_t[MP1], acoeff, MP1 <<2 );
+   memcpy( &A_t[MP1 <<1], acoeff, MP1 <<2 );
+   memcpy( &A_t[MP1 + MP1 + MP1], acoeff, MP1 <<2 );
+
+   /* Compute reflection coefficients Q15 */
+   A_Refl( &acoeff[1], refl );
+
+   /* Compute prediction error in Q15 */
+   /* 0.99997 in Q15 */
+   pred_err = MAX_16;
+
+   for ( i = 0; i < M; i++ ) {
+      pred_err = ( pred_err * ( MAX_16 - ( ( refl[i] * refl[i] ) >> 15 ) ) ) >>
+            15;
+   }
+
+   /* compute logarithm of prediction gain */
+   Log2( pred_err, &log_pg_e, &log_pg_m );
+
+   /* convert exponent and mantissa to Word16 Q12 */
+   /* Q12 */
+   log_pg = ( log_pg_e - 15 ) << 12;
+   /* saturate */
+   if (log_pg < -32768) {
+      log_pg = -32768;
+   }
+   log_pg = ( -( log_pg + ( log_pg_m >> 3 ) ) ) >> 1;
+   st->log_pg_mean = ( Word16 )( ( ( 29491*st->log_pg_mean ) >> 15 ) + ( ( 3277
+         * log_pg ) >> 15 ) );
+
+   /* Compute interpolated log energy */
+   /* Q26 -> Q16 */
+   log_en_int = log_en_int >> 10;
+
+   /* Add 4 in Q16 */
+   log_en_int += 262144L;
+
+   /* subtract prediction gain */
+   log_en_int = log_en_int - ( log_pg << 4 );
+
+   /* adjust level to speech coder mode */
+   log_en_int += st->log_en_adjust << 5;
+   log_en_int_e = ( Word16 )( log_en_int >> 16 );
+   log_en_int_m = ( Word16 )( ( log_en_int - ( log_en_int_e << 16 ) ) >> 1 );
+
+   /* Q4 */
+   level = ( Word16 )( Pow2( log_en_int_e, log_en_int_m ) );
+
+   for ( i = 0; i < 4; i++ ) {
+      /* Compute innovation vector */
+      Build_CN_code( &st->pn_seed_rx, ex );
+
+      for ( j = 0; j < L_SUBFR; j++ ) {
+         ex[j] = ( level * ex[j] ) >> 15;
+      }
+
+      /* Synthesize */
+      Syn_filt( acoeff_variab, ex, &synth[i * L_SUBFR], L_SUBFR, mem_syn, 1 );
+   }   /* next i */
+
+   /* reset codebook averaging variables */
+   averState->hangVar = 20;
+   averState->hangCount = 0;
+
+   if ( new_state == DTX_MUTE ) {
+        /*
+         * mute comfort noise as it has been quite a long time since
+         * last SID update  was performed
+         */
+      Word32 num, denom;
+
+
+      tmp_int_length = st->since_last_sid;
+
+      if ( tmp_int_length > 32 ) {
+         tmp_int_length = 32;
+      }
+
+      if ( tmp_int_length == 1 ) {
+         st->true_sid_period_inv = MAX_16;
+      }
+      else {
+         num = 1024;
+         denom = ( tmp_int_length << 10 );
+         st->true_sid_period_inv = 0;
+
+         for ( i = 0; i < 15; i++ ) {
+            st->true_sid_period_inv <<= 1;
+            num <<= 1;
+
+            if ( num >= denom ) {
+               num = num - denom;
+               st->true_sid_period_inv += 1;
+            }
+         }
+      }
+      st->since_last_sid = 0;
+      memcpy( st->lsp_old, st->lsp, M << 2 );
+      st->old_log_en = st->log_en;
+
+      /* subtract 1/8 in Q11 i.e -6/8 dB */
+      st->log_en = st->log_en - 256;
+      if (st->log_en < -32768) st->log_en = -32768;
+   }
+
+     /*
+      * reset interpolation length timer
+      * if data has been updated.
+      */
+   if ( ( st->sid_frame != 0 ) & ( ( st->valid_data != 0 ) || ( ( st->valid_data
+         == 0 ) & ( st->dtxHangoverAdded != 0 ) ) ) ) {
+      st->since_last_sid = 0;
+      st->data_updated = 1;
+   }
+   return;
+}
+
+
+/*
+ * lsp_avg
+ *
+ *
+ * Parameters:
+ *    st->lsp_meanSave  B: LSP averages
+ *    lsp               I: LSPs
+ *
+ * Function:
+ *    Calculate the LSP averages
+ *
+ * Returns:
+ *    void
+ */
+static void lsp_avg( lsp_avgState *st, Word32 *lsp )
+{
+   Word32 i, tmp;
+
+
+   for ( i = 0; i < M; i++ ) {
+      /* mean = 0.84*mean */
+      tmp = ( st->lsp_meanSave[i] << 16 );
+      tmp -= ( EXPCONST * st->lsp_meanSave[i] ) << 1;
+
+      /* Add 0.16 of newest LSPs to mean */
+      tmp += ( EXPCONST * lsp[i] ) << 1;
+
+      /* Save means */
+      tmp += 0x00008000L;
+      st->lsp_meanSave[i] = tmp >> 16;
+   }
+   return;
+}
+
+
+/*
+ * Int_lpc_1and3
+ *
+ *
+ * Parameters:
+ *    lsp_old        I: LSP vector at the 4th subfr. of past frame      [M]
+ *    lsp_mid        I: LSP vector at the 2nd subframe of present frame [M]
+ *    lsp_new        I: LSP vector at the 4th subframe of present frame [M]
+ *    Az             O: interpolated LP parameters in subframes 1 and 3
+ *                                                                   [AZ_SIZE]
+ *
+ * Function:
+ *    Interpolates the LSPs and converts to LPC parameters
+ *    to get a different LP filter in each subframe.
+ *
+ *    The 20 ms speech frame is divided into 4 subframes.
+ *    The LSPs are quantized and transmitted at the 2nd and
+ *    4th subframes (twice per frame) and interpolated at the
+ *    1st and 3rd subframe.
+ *
+ * Returns:
+ *    void
+ */
+static void Int_lpc_1and3( Word32 lsp_old[], Word32 lsp_mid[], Word32 lsp_new[],
+      Word32 Az[] )
+{
+   Word32 lsp[M];
+   Word32 i;
+
+
+   /* lsp[i] = lsp_mid[i] * 0.5 + lsp_old[i] * 0.5 */
+   for ( i = 0; i < 10; i++ ) {
+      lsp[i] = ( lsp_mid[i] >> 1 ) + ( lsp_old[i] >> 1 );
+   }
+
+   /* Subframe 1 */
+   Lsp_Az( lsp, Az );
+   Az += MP1;
+
+   /* Subframe 2 */
+   Lsp_Az( lsp_mid, Az );
+   Az += MP1;
+
+   for ( i = 0; i < 10; i++ ) {
+      lsp[i] = ( lsp_mid[i] >> 1 ) + ( lsp_new[i] >> 1 );
+   }
+
+   /* Subframe 3 */
+   Lsp_Az( lsp, Az );
+   Az += MP1;
+
+   /* Subframe 4 */
+   Lsp_Az( lsp_new, Az );
+   return;
+}
+
+
+/*
+ * Int_lpc_1to3
+ *
+ *
+ * Parameters:
+ *    lsp_old           I: LSP vector at the 4th subframe of past frame    [M]
+ *    lsp_new           I: LSP vector at the 4th subframe of present frame [M]
+ *    Az                O: interpolated LP parameters in all subframes
+ *                                                                   [AZ_SIZE]
+ *
+ * Function:
+ *    Interpolates the LSPs and converts to LPC parameters to get a different
+ *    LP filter in each subframe.
+ *
+ *    The 20 ms speech frame is divided into 4 subframes.
+ *    The LSPs are quantized and transmitted at the 4th
+ *    subframes (once per frame) and interpolated at the
+ *    1st, 2nd and 3rd subframe.
+ *
+ * Returns:
+ *    void
+ */
+static void Int_lpc_1to3( Word32 lsp_old[], Word32 lsp_new[], Word32 Az[] )
+{
+   Word32 lsp[M];
+   Word32 i;
+
+
+   for ( i = 0; i < 10; i++ ) {
+      lsp[i] = ( lsp_new[i] >> 2 ) + ( lsp_old[i] - ( lsp_old[i] >> 2 ) );
+   }
+
+   /* Subframe 1 */
+   Lsp_Az( lsp, Az );
+   Az += MP1;
+
+   for ( i = 0; i < 10; i++ ) {
+      lsp[i] = ( lsp_old[i] >> 1 ) + ( lsp_new[i] >> 1 );
+   }
+
+   /* Subframe 2 */
+   Lsp_Az( lsp, Az );
+   Az += MP1;
+
+   for ( i = 0; i < 10; i++ ) {
+      lsp[i] = ( lsp_old[i] >> 2 ) + ( lsp_new[i] - ( lsp_new[i] >> 2 ) );
+   }
+
+   /* Subframe 3 */
+   Lsp_Az( lsp, Az );
+   Az += MP1;
+
+   /* Subframe 4 */
+   Lsp_Az( lsp_new, Az );
+   return;
+}
+
+
+/*
+ * D_plsf_5
+ *
+ *
+ * Parameters:
+ *    st->past_lsf_q I: Past dequantized LFSs
+ *    st->past_r_q      B: past quantized residual
+ *    bfi               B: bad frame indicator
+ *    indice            I: quantization indices of 3 submatrices, Q0
+ *    lsp1_q            O: quantized 1st LSP vector
+ *    lsp2_q            O: quantized 2nd LSP vector
+ *
+ * Function:
+ *    Decodes the 2 sets of LSP parameters in a frame
+ *    using the received quantization indices.
+ *
+ * Returns:
+ *    void
+ */
+static void D_plsf_5( D_plsfState *st, Word16 bfi, Word16 *indice, Word32 *lsp1_q
+      , Word32 *lsp2_q )
+{
+   Word32 lsf1_r[M], lsf2_r[M], lsf1_q[M], lsf2_q[M];
+   Word32 i, temp1, temp2, sign;
+   const Word32 *p_dico;
+
+
+   /* if bad frame */
+   if ( bfi != 0 ) {
+      /* use the past LSFs slightly shifted towards their mean */
+      for ( i = 0; i < M; i += 2 ) {
+         /* lsfi_q[i] = ALPHA*st->past_lsf_q[i] + ONE_ALPHA*meanLsf[i]; */
+         lsf1_q[i] = ( ( st->past_lsf_q[i] * ALPHA_122 ) >> 15 ) + ( ( mean_lsf_5[i]
+               * ONE_ALPHA_122 ) >> 15 );
+         lsf1_q[i + 1] = ( ( st->past_lsf_q[i + 1] * ALPHA_122 ) >> 15 ) + ( (
+               mean_lsf_5[i + 1] * ONE_ALPHA_122 ) >> 15 );
+      }
+      memcpy( lsf2_q, lsf1_q, M <<2 );
+
+      /* estimate past quantized residual to be used in next frame */
+      for ( i = 0; i < M; i += 2 ) {
+         /* temp  = meanLsf[i] +  st->past_r_q[i] * LSPPpred_facMR122; */
+         temp1 = mean_lsf_5[i] + ( ( st->past_r_q[i] * LSP_PRED_FAC_MR122 ) >>
+               15 );
+         temp2 = mean_lsf_5[i + 1] +( ( st->past_r_q[i + 1] *LSP_PRED_FAC_MR122
+               ) >> 15 );
+         st->past_r_q[i] = lsf2_q[i] - temp1;
+         st->past_r_q[i + 1] = lsf2_q[i + 1] -temp2;
+      }
+   }
+
+   /* if good LSFs received */
+   else {
+      /* decode prediction residuals from 5 received indices */
+      p_dico = &dico1_lsf_5[indice[0] << 2];
+      lsf1_r[0] = *p_dico++;
+      lsf1_r[1] = *p_dico++;
+      lsf2_r[0] = *p_dico++;
+      lsf2_r[1] = *p_dico++;
+      p_dico = &dico2_lsf_5[indice[1] << 2];
+      lsf1_r[2] = *p_dico++;
+      lsf1_r[3] = *p_dico++;
+      lsf2_r[2] = *p_dico++;
+      lsf2_r[3] = *p_dico++;
+      sign = ( Word16 )( indice[2] & 1 );
+      i = indice[2] >> 1;
+      p_dico = &dico3_lsf_5[i << 2];
+
+      if ( sign == 0 ) {
+         lsf1_r[4] = *p_dico++;
+         lsf1_r[5] = *p_dico++;
+         lsf2_r[4] = *p_dico++;
+         lsf2_r[5] = *p_dico++;
+      }
+      else {
+         lsf1_r[4] = ( Word16 )( -( *p_dico++ ) );
+         lsf1_r[5] = ( Word16 )( -( *p_dico++ ) );
+         lsf2_r[4] = ( Word16 )( -( *p_dico++ ) );
+         lsf2_r[5] = ( Word16 )( -( *p_dico++ ) );
+      }
+      p_dico = &dico4_lsf_5[( indice[3]<<2 )];
+      lsf1_r[6] = *p_dico++;
+      lsf1_r[7] = *p_dico++;
+      lsf2_r[6] = *p_dico++;
+      lsf2_r[7] = *p_dico++;
+      p_dico = &dico5_lsf_5[( indice[4]<<2 )];
+      lsf1_r[8] = *p_dico++;
+      lsf1_r[9] = *p_dico++;
+      lsf2_r[8] = *p_dico++;
+      lsf2_r[9] = *p_dico++;
+
+      /* Compute quantized LSFs and update the past quantized residual */
+      for ( i = 0; i < M; i++ ) {
+         temp1 = mean_lsf_5[i] + ( ( st->past_r_q[i] * LSP_PRED_FAC_MR122 ) >>
+               15 );
+         lsf1_q[i] = lsf1_r[i] + temp1;
+         lsf2_q[i] = lsf2_r[i] + temp1;
+         st->past_r_q[i] = lsf2_r[i];
+      }
+   }
+
+   /* verification that LSFs have minimum distance of LSF_GAP Hz */
+   Reorder_lsf( lsf1_q, LSF_GAP );
+   Reorder_lsf( lsf2_q, LSF_GAP );
+   memcpy( st->past_lsf_q, lsf2_q, M <<2 );
+
+   /*  convert LSFs to the cosine domain */
+   Lsf_lsp( lsf1_q, lsp1_q );
+   Lsf_lsp( lsf2_q, lsp2_q );
+   return;
+}
+
+
+/*
+ * Dec_lag3
+ *
+ *
+ * Parameters:
+ *    index             I: received pitch index
+ *    t0_min            I: minimum of search range
+ *    t0_max            I: maximum of search range
+ *    i_subfr           I: subframe flag
+ *    T0_prev           I: integer pitch delay of last subframe used
+ *                         in 2nd and 4th subframes
+ *    T0                O: integer part of pitch lag
+ *    T0_frac           O : fractional part of pitch lag
+ *    flag4             I : flag for encoding with 4 bits
+ * Function:
+ *    Decoding of fractional pitch lag with 1/3 resolution.
+ *    Extract the integer and fraction parts of the pitch lag from
+ *    the received adaptive codebook index.
+ *
+ *    The fractional lag in 1st and 3rd subframes is encoded with 8 bits
+ *    while that in 2nd and 4th subframes is relatively encoded with 4, 5
+ *    and 6 bits depending on the mode.
+ *
+ * Returns:
+ *    void
+ */
+static void Dec_lag3( Word32 index, Word32 t0_min, Word32 t0_max, Word32 i_subfr
+      , Word32 T0_prev, Word32 *T0, Word32 *T0_frac, Word32 flag4 )
+{
+   Word32 i, tmp_lag;
+
+
+   /* if 1st or 3rd subframe */
+   if ( i_subfr == 0 ) {
+      if ( index < 197 ) {
+         *T0 = ( ( ( index + 2 ) * 10923 ) >> 15 ) + 19;
+         i = *T0 + *T0 + *T0;
+         *T0_frac = ( index - i ) + 58;
+      }
+      else {
+         *T0 = index - 112;
+         *T0_frac = 0;
+      }
+   }
+
+   /* 2nd or 4th subframe */
+   else {
+      if ( flag4 == 0 ) {
+         /* 'normal' decoding: either with 5 or 6 bit resolution */
+         i = ( ( ( index + 2 ) * 10923 ) >> 15 ) - 1;
+         *T0 = i + t0_min;
+         i = i + i + i;
+         *T0_frac = ( index - 2 ) - i;
+      }
+      else {
+         /* decoding with 4 bit resolution */
+         tmp_lag = T0_prev;
+
+         if ( ( tmp_lag - t0_min ) > 5 )
+            tmp_lag = t0_min + 5;
+
+         if ( ( t0_max - tmp_lag ) > 4 )
+            tmp_lag = t0_max - 4;
+
+         if ( index < 4 ) {
+            i = ( tmp_lag - 5 );
+            *T0 = i + index;
+            *T0_frac = 0;
+         }
+         else {
+            if ( index < 12 ) {
+               i = ( ( ( index - 5 ) * 10923 ) >> 15 ) - 1;
+               *T0 = i + tmp_lag;
+               i = i + i + i;
+               *T0_frac = ( index - 9 ) - i;
+            }
+            else {
+               i = ( index - 12 ) + tmp_lag;
+               *T0 = i + 1;
+               *T0_frac = 0;
+            }
+         }
+      }   /* end if (decoding with 4 bit resolution) */
+   }
+   return;
+}
+
+
+/*
+ * Pred_lt_3or6_40
+ *
+ *
+ * Parameters:
+ *    exc               B: excitation buffer
+ *    T0                I: integer pitch lag
+ *    frac              I: fraction of lag
+ *    flag3             I: if set, upsampling rate = 3 (6 otherwise)
+ *
+ * Function:
+ *    Compute the result of long term prediction with fractional
+ *    interpolation of resolution 1/3 or 1/6. (Interpolated past excitation).
+ *
+ *    Once the fractional pitch lag is determined,
+ *    the adaptive codebook vector v(n) is computed by interpolating
+ *    the past excitation signal u(n) at the given integer delay k
+ *    and phase (fraction)  :
+ *
+ *          9                       9
+ *    v(n) = SUM[ u(n-k-i) * b60(t+i*6) ] + SUM[ u(n-k+1+i) * b60(6-t+i*6) ],
+ *          i=0                       i=0
+ *    n = 0, ...,39, t = 0, ...,5.
+ *
+ *    The interpolation filter b60 is based on a Hamming windowed sin(x)/x
+ *    function truncated at  59 and padded with zeros at  60 (b60(60)=0)).
+ *    The filter has a cut-off frequency (-3 dB) at 3 600 Hz in
+ *    the over-sampled domain.
+ *
+ * Returns:
+ *    void
+ */
+static void Pred_lt_3or6_40( Word32 exc[], Word32 T0, Word32 frac, Word32 flag3 )
+{
+   Word32 s, i;
+   Word32 *x0, *x1, *x2;
+   const Word32 *c1, *c2;
+
+
+   x0 = &exc[ - T0];
+   frac = -frac;
+
+   if ( flag3 != 0 ) {
+      frac <<= 1;   /* inter_3l[k] = inter6[2*k] -> k' = 2*k */
+   }
+
+   if ( frac < 0 ) {
+      frac += 6;
+      x0--;
+   }
+   c1 = &inter6[frac];
+   c2 = &inter6[6 - frac];
+
+   for ( i = 0; i < 40; i++ ) {
+      x1 = x0++;
+      x2 = x0;
+      s = x1[0] * c1[0];
+      s += x1[ - 1] * c1[6];
+      s += x1[ - 2] * c1[12];
+      s += x1[ - 3] * c1[18];
+      s += x1[ - 4] * c1[24];
+      s += x1[ - 5] * c1[30];
+      s += x1[ - 6] * c1[36];
+      s += x1[ - 7] * c1[42];
+      s += x1[ - 8] * c1[48];
+      s += x1[ - 9] * c1[54];
+      s += x2[0] * c2[0];
+      s += x2[1] * c2[6];
+      s += x2[2] * c2[12];
+      s += x2[3] * c2[18];
+      s += x2[4] * c2[24];
+      s += x2[5] * c2[30];
+      s += x2[6] * c2[36];
+      s += x2[7] * c2[42];
+      s += x2[8] * c2[48];
+      s += x2[9] * c2[54];
+      exc[i] = ( s + 0x4000 ) >> 15;
+
+   }
+}
+
+
+/*
+ * Dec_lag6
+ *
+ *
+ * Parameters:
+ *    index             I: received pitch index
+ *    pit_min           I: minimum pitch lag
+ *    pit_max           I: maximum pitch lag
+ *    i_subfr           I: subframe flag
+ *    T0                B: integer part of pitch lag
+ *    T0_frac           O : fractional part of pitch lag
+ *
+ * Function:
+ *    Decoding of fractional pitch lag with 1/6 resolution.
+ *    Extract the integer and fraction parts of the pitch lag from
+ *    the received adaptive codebook index.
+ *
+ *    The fractional lag in 1st and 3rd subframes is encoded with 9 bits
+ *    while that in 2nd and 4th subframes is relatively encoded with 6 bits.
+ *    Note that in relative encoding only 61 values are used. If the
+ *    decoder receives 61, 62, or 63 as the relative pitch index, it means
+ *    that a transmission error occurred. In this case, the pitch lag from
+ *    previous subframe (actually from previous frame) is used.
+ *
+ * Returns:
+ *    void
+ */
+static void Dec_lag6( Word32 index, Word32 pit_min, Word32 pit_max, Word32
+      i_subfr, Word32 *T0, Word32 *T0_frac )
+{
+   Word32 t0_min, t0_max, i;
+
+
+   /* if 1st or 3rd subframe */
+   if ( i_subfr == 0 ) {
+      if ( index < 463 ) {
+         /* T0 = (index+5)/6 + 17 */
+         *T0 = ( index + 5 ) / 6 + 17;
+         i = *T0 + *T0 + *T0;
+
+         /* *T0_frac = index - T0*6 + 105 */
+         *T0_frac = ( index - ( i + i ) ) + 105;
+      }
+      else {
+         *T0 = index - 368;
+         *T0_frac = 0;
+      }
+   }
+
+   /* second or fourth subframe */
+   else {
+      /* find t0_min and t0_max for 2nd (or 4th) subframe */
+      t0_min = *T0 - 5;
+
+      if ( t0_min < pit_min ) {
+         t0_min = pit_min;
+      }
+      t0_max = t0_min + 9;
+
+      if ( t0_max > pit_max ) {
+         t0_max = pit_max;
+         t0_min = t0_max - 9;
+      }
+
+      /* i = (index+5)/6 - 1 */
+      i = ( index + 5 ) / 6 - 1;
+      *T0 = i + t0_min;
+      i = i + i + i;
+      *T0_frac = ( index - 3 ) - ( i + i );
+   }
+}
+
+
+/*
+ * decompress10
+ *
+ *
+ * Parameters:
+ *    MSBs              I: MSB part of the index
+ *    LSBs              I: LSB part of the index
+ *    index1            I: index for first pos in posIndex
+ *    index2            I: index for second pos in posIndex
+ *    index3            I: index for third pos in posIndex
+ *    pos_indx          O: position of 3 pulses (decompressed)
+ * Function:
+ *    Decompression of the linear codeword
+ *
+ * Returns:
+ *    void
+ */
+static void decompress10( Word32 MSBs, Word32 LSBs, Word32 index1, Word32 index2
+      , Word32 index3, Word32 pos_indx[] )
+{
+   Word32 divMSB;
+
+   if (MSBs > 124)
+   {
+      MSBs = 124;
+   }
+   /*
+    * pos_indx[index1] = ((MSBs-25*(MSBs/25))%5)*2 + (LSBs-4*(LSBs/4))%2;
+    * pos_indx[index2] = ((MSBs-25*(MSBs/25))/5)*2 + (LSBs-4*(LSBs/4))/2;
+    * pos_indx[index3] = (MSBs/25)*2 + LSBs/4;
+    */
+   divMSB = MSBs / 25;
+   pos_indx[index1] = ( ( ( MSBs - 25 * ( divMSB ) ) % 5 ) << 1 ) + ( LSBs & 0x1
+         );
+   pos_indx[index2] = ( ( ( MSBs - 25 * ( divMSB ) ) / 5 ) << 1 ) + ( ( LSBs &
+         0x2 ) >> 1 );
+   pos_indx[index3] = ( divMSB << 1 ) + ( LSBs >> 2 );
+   return;
+}
+
+
+/*
+ * decompress_codewords
+ *
+ *
+ * Parameters:
+ *    indx              I: position of 8 pulses (compressed)
+ *    pos_indx          O: position index of 8 pulses (position only)
+ *
+ * Function:
+ *    Decompression of the linear codewords to 4+three indeces
+ *    one bit from each pulse is made robust to errors by
+ *    minimizing the phase shift of a bit error.
+ *
+ *    i0,i4,i1 => one index (7+3) bits, 3   LSBs more robust
+ *    i2,i6,i5 => one index (7+3) bits, 3   LSBs more robust
+ *    i3,i7    => one index (5+2) bits, 2-3 LSbs more robust
+ *
+ * Returns:
+ *    void
+ */
+static void decompress_codewords( Word16 indx[], Word32 pos_indx[] )
+{
+   Word32 ia, ib, MSBs, LSBs, MSBs0_24, tmp;
+
+
+    /*
+     * First index: 10x10x10 -> 2x5x2x5x2x5-> 125x2x2x2 -> 7+1x3 bits
+     * MSBs = indx[NB_TRACK]/8;
+     * LSBs = indx[NB_TRACK]%8;
+     */
+   MSBs = *indx >> 3;
+   LSBs = *indx & 0x7;
+   decompress10( MSBs, LSBs, 0, 4, 1, pos_indx );
+
+    /*
+     * Second index: 10x10x10 -> 2x5x2x5x2x5-> 125x2x2x2 -> 7+1x3 bits
+     * MSBs = indx[NB_TRACK+1]/8;
+     * LSBs = indx[NB_TRACK+1]%8;
+     */
+   MSBs = indx[1] >> 3;
+   LSBs = indx[1] & 0x7;
+   decompress10( MSBs, LSBs, 2, 6, 5, pos_indx );
+
+    /*
+     * Third index: 10x10 -> 2x5x2x5-> 25x2x2 -> 5+1x2 bits
+     * MSBs = indx[NB_TRACK+2]/4;
+     * LSBs = indx[NB_TRACK+2]%4;
+     * MSBs0_24 = (MSBs*25+12)/32;
+     * if ((MSBs0_24/5)%2==1)
+     *    pos_indx[3] = (4-(MSBs0_24%5))*2 + LSBs%2;
+     * else
+     *    pos_indx[3] = (MSBs0_24%5)*2 + LSBs%2;
+     * pos_indx[7] = (MSBs0_24/5)*2 + LSBs/2;
+     */
+   MSBs = indx[2] >> 2;
+   LSBs = indx[2] & 0x3;
+   MSBs0_24 = ( ( ( MSBs * 25 ) + 12 ) >> 5 );
+   tmp = ( MSBs0_24 * 6554 ) >> 15;
+   ia = tmp & 0x1;
+   ib = ( MSBs0_24 - ( tmp * 5 ) );
+
+   if ( ia == 1 ) {
+      ib = 4 - ib;
+   }
+   pos_indx[3] = ( ib << 1 ) + ( LSBs & 0x1 );
+   pos_indx[7] = ( tmp << 1 ) + ( LSBs >> 1 );
+}
+
+
+/*
+ * decode_2i40_9bits
+ *
+ *
+ * Parameters:
+ *    subNr             I: subframe number
+ *    sign              I: signs of 2 pulses
+ *    index             I: Positions of the 2 pulses
+ *    cod               O: algebraic (fixed) codebook excitation
+ *
+ * Function:
+ *    Algebraic codebook decoder
+ *
+ * Returns:
+ *    void
+ */
+static void decode_2i40_9bits( Word32 subNr, Word32 sign, Word32 index, Word32
+      cod[] )
+{
+   Word32 pos[2];
+   Word32 i, j, k;
+
+
+   /* Decode the positions */
+   /* table bit  is the MSB */
+   j = ( index & 64 ) >> 6;
+   i = index & 7;
+
+   /* pos0 =i*5+startPos[j*8+subNr*2] */
+   i = ( i + ( i << 2 ) );
+   k = startPos[( j <<3 )+( subNr << 1 )];
+   pos[0] = i + k;
+   index = index >> 3;
+   i = index & 7;
+
+   /* pos1 =i*5+startPos[j*8+subNr*2+1] */
+   i = ( i + ( i << 2 ) );
+   k = startPos[( ( j <<3 )+ ( subNr <<1 ) ) + 1];
+   pos[1] = ( Word16 )( i + k );
+
+   /* decode the signs  and build the codeword */
+   memset( cod, 0, L_SUBFR <<2 );
+
+   for ( j = 0; j < 2; j++ ) {
+      i = sign & 1;
+      sign = sign >> 1;
+
+      if ( i != 0 ) {
+         cod[pos[j]] = 8191;   /* +1.0 */
+      }
+      else {
+         cod[pos[j]] = -8192;   /* -1.0 */
+      }
+   }
+   return;
+}
+
+
+/*
+ * decode_2i40_11bits
+ *
+ *
+ * Parameters:
+ *    sign              I: signs of 2 pulses
+ *    index             I: Positions of the 2 pulses
+ *    cod               O: algebraic (fixed) codebook excitation
+ *
+ * Function:
+ *    Algebraic codebook decoder
+ *
+ * Returns:
+ *    void
+ */
+static void decode_2i40_11bits( Word32 sign, Word32 index, Word32 cod[] )
+{
+   Word32 pos[2];
+   Word32 i, j;
+
+
+   /* Decode the positions */
+   j = index & 1;
+   index = index >> 1;
+   i = index & 7;
+
+   /* pos0 =i*5+1+j*2 */
+   i = ( i + ( i << 2 ) );
+   i = ( i + 1 );
+   j = ( j << 1 );
+   pos[0] = i + j;
+   index = index >> 3;
+   j = index & 3;
+   index = index >> 2;
+   i = index & 7;
+
+   if ( j == 3 ) {
+      /* pos1 =i*5+4 */
+      i = ( i + ( i << 2 ) );
+      pos[1] = i + 4;
+   }
+   else {
+      /* pos1 =i*5+j */
+      i = ( i + ( i << 2 ) );
+      pos[1] = i + j;
+   }
+
+   /* decode the signs  and build the codeword */
+   memset( cod, 0, L_SUBFR <<2 );
+
+   for ( j = 0; j < 2; j++ ) {
+      i = sign & 1;
+      sign = sign >> 1;
+
+      if ( i != 0 ) {
+         cod[pos[j]] = 8191;   /* +1.0 */
+      }
+      else {
+         cod[pos[j]] = -8192;   /* -1.0 */
+      }
+   }
+   return;
+}
+
+
+/*
+ * decode_3i40_14bits
+ *
+ *
+ * Parameters:
+ *    sign              I: signs of 3 pulses
+ *    index             I: Positions of the 3 pulses
+ *    cod               O: algebraic (fixed) codebook excitation
+ *
+ * Function:
+ *    Algebraic codebook decoder
+ *
+ * Returns:
+ *    void
+ */
+static void decode_3i40_14bits( Word32 sign, Word32 index, Word32 cod[] )
+{
+   Word32 pos[3];
+   Word32 i, j;
+
+
+   /* Decode the positions */
+   i = index & 7;
+
+   /* pos0 =i*5 */
+   pos[0] = i + ( i << 2 );
+   index = index >> 3;
+   j = index & 1;
+   index = index >> 1;
+   i = index & 7;
+
+   /* pos1 =i*5+1+j*2 */
+   i = ( i + ( i << 2 ) );
+   i = ( i + 1 );
+   j = ( j << 1 );
+   pos[1] = i + j;
+   index = index >> 3;
+   j = index & 1;
+   index = index >> 1;
+   i = index & 7;
+
+   /* pos2 =i*5+2+j*2 */
+   i = ( i + ( i << 2 ) );
+   i = ( i + 2 );
+   j = ( j << 1 );
+   pos[2] = i + j;
+
+   /* decode the signs  and build the codeword */
+   memset( cod, 0, L_SUBFR <<2 );
+
+   for ( j = 0; j < 3; j++ ) {
+      i = sign & 1;
+      sign = sign >> 1;
+
+      if ( i > 0 ) {
+         cod[pos[j]] = 8191;   /* +1.0 */
+      }
+      else {
+         cod[pos[j]] = -8192;   /* -1.0 */
+      }
+   }
+   return;
+}
+
+
+/*
+ * decode_3i40_14bits
+ *
+ *
+ * Parameters:
+ *    sign              I: signs of 4 pulses
+ *    index             I: Positions of the 4 pulses
+ *    cod               O: algebraic (fixed) codebook excitation
+ *
+ * Function:
+ *    Algebraic codebook decoder
+ *
+ * Returns:
+ *    void
+ */
+static void decode_4i40_17bits( Word32 sign, Word32 index, Word32 cod[] )
+{
+   Word32 pos[4];
+   Word32 i, j;
+
+
+   /* Decode the positions */
+   i = index & 7;
+   i = dgray[i];
+
+   /* pos0 =i*5 */
+   pos[0] = i + ( i << 2 );
+   index = index >> 3;
+   i = index & 7;
+   i = dgray[i];
+
+   /* pos1 =i*5+1 */
+   i = ( i + ( i << 2 ) );
+   pos[1] = i + 1;
+   index = index >> 3;
+   i = index & 7;
+   i = dgray[i];
+
+   /* pos2 =i*5+1 */
+   i = ( i + ( i << 2 ) );
+   pos[2] = i + 2;
+   index = index >> 3;
+   j = index & 1;
+   index = index >> 1;
+   i = index & 7;
+   i = dgray[i];
+
+   /* pos3 =i*5+3+j */
+   i = ( i + ( i << 2 ) );
+   i = ( i + 3 );
+   pos[3] = i + j;
+
+   /* decode the signs  and build the codeword */
+   memset( cod, 0, L_SUBFR <<2 );
+
+   for ( j = 0; j < 4; j++ ) {
+      i = sign & 1;
+      sign = sign >> 1;
+
+      if ( i != 0 ) {
+         cod[pos[j]] = 8191;
+      }
+      else {
+         cod[pos[j]] = -8192;
+      }
+   }
+   return;
+}
+
+
+/*
+ * decode_8i40_31bits
+ *
+ *
+ * Parameters:
+ *    index             I: index of 8 pulses (sign+position)
+ *    cod               O: algebraic (fixed) codebook excitation
+ *
+ * Function:
+ *    Algebraic codebook decoder
+ *
+ * Returns:
+ *    void
+ */
+static void decode_8i40_31bits( Word16 index[], Word32 cod[] )
+{
+   Word32 linear_codewords[8];
+   Word32 i, j, pos1, pos2, sign;
+
+
+   memset( cod, 0, L_CODE <<2 );
+   decompress_codewords( &index[NB_TRACK_MR102], linear_codewords );
+
+   /* decode the positions and signs of pulses and build the codeword */
+   for ( j = 0; j < NB_TRACK_MR102; j++ ) {
+      /* compute index i */
+      i = linear_codewords[j];
+      i <<= 2;
+
+      /* position of pulse "j" */
+      pos1 = i + j;
+
+      if ( index[j] == 0 ) {
+         sign = POS_CODE;   /* +1.0 */
+      }
+      else {
+         sign = -NEG_CODE;   /* -1.0 */
+      }
+
+      /* compute index i */
+      i = linear_codewords[j + 4];
+      i = i << 2;
+
+      /* position of pulse "j+4" */
+      pos2 = i + j;
+      cod[pos1] = sign;
+
+      if ( pos2 < pos1 ) {
+         sign = -( sign );
+      }
+      cod[pos2] = cod[pos2] + sign;
+   }
+   return;
+}
+
+
+/*
+ * decode_10i40_35bits
+ *
+ *
+ * Parameters:
+ *    index             I: index of 10 pulses (sign+position)
+ *    cod               O: algebraic (fixed) codebook excitation
+ *
+ * Function:
+ *    Algebraic codebook decoder
+ *
+ * Returns:
+ *    void
+ */
+static void decode_10i40_35bits( Word16 index[], Word32 cod[] )
+{
+   Word32 i, j, pos1, pos2, sign, tmp;
+
+
+   memset( cod, 0, L_CODE <<2 );
+
+   /* decode the positions and signs of pulses and build the codeword */
+   for ( j = 0; j < 5; j++ ) {
+      /* compute index i */
+      tmp = index[j];
+      i = tmp & 7;
+      i = dgray[i];
+      i = ( i * 5 );
+
+      /* position of pulse "j" */
+      pos1 = ( i + j );
+      i = ( tmp >> 3 ) & 1;
+
+      if ( i == 0 ) {
+         sign = 4096;   /* +1.0 */
+      }
+      else {
+         sign = -4096;   /* -1.0 */
+      }
+
+      /* compute index i */
+      i = index[j + 5] & 7;
+      i = dgray[i];
+      i = i * 5;
+
+      /* position of pulse "j+5" */
+      pos2 = ( i + j );
+      cod[pos1] = sign;
+
+      if ( pos2 < pos1 ) {
+         sign = -( sign );
+      }
+      cod[pos2] = cod[pos2] + sign;
+   }
+   return;
+}
+
+
+/*
+ * gmed_n
+ *
+ *
+ * Parameters:
+ *    ind               I: values
+ *    n                 I: The number of gains (odd)
+ *
+ * Function:
+ *    Calculates N-point median.
+ *
+ * Returns:
+ *    index of the median value
+ */
+static Word32 gmed_n( Word32 ind[], Word32 n )
+{
+   Word32 tmp[NMAX], tmp2[NMAX];
+   Word32 max, medianIndex, i, j, ix = 0;
+
+
+   for ( i = 0; i < n; i++ ) {
+      tmp2[i] = ind[i];
+   }
+
+   for ( i = 0; i < n; i++ ) {
+      max = -32767;
+
+      for ( j = 0; j < n; j++ ) {
+         if ( tmp2[j] >= max ) {
+            max = tmp2[j];
+            ix = j;
+         }
+      }
+      tmp2[ix] = -32768;
+      tmp[i] = ix;
+   }
+   medianIndex = tmp[( n >>1 )];
+   return( ind[medianIndex] );
+}
+
+
+/*
+ * ec_gain_pitch
+ *
+ *
+ * Parameters:
+ *    st->pbuf          I: last five gains
+ *    st->past_gain_pit I: past gain
+ *    state             I: state of the state machine
+ *    gain_pitch        O: pitch gain
+ *
+ * Function:
+ *    Calculates pitch from previous values.
+ *
+ * Returns:
+ *    void
+ */
+static void ec_gain_pitch( ec_gain_pitchState *st, Word16 state, Word32 *
+      gain_pitch )
+{
+   Word32 tmp;
+
+
+   /* calculate median of last five gains */
+   tmp = gmed_n( st->pbuf, 5 );
+
+   /* new gain = minimum(median, past_gain) * pdown[state] */
+   if ( tmp > st->past_gain_pit ) {
+      tmp = st->past_gain_pit;
+   }
+   *gain_pitch = ( tmp * pdown[state] ) >> 15;
+}
+
+
+/*
+ * d_gain_pitch
+ *
+ *
+ * Parameters:
+ *    mode              I: AMR mode
+ *    index             I: index of quantization
+ *
+ * Function:
+ *    Decodes the pitch gain using the received index
+ *
+ * Returns:
+ *    gain
+ */
+static Word32 d_gain_pitch( enum Mode mode, Word32 index )
+{
+   Word32 gain;
+
+
+   if ( mode == MR122 ) {
+      /* clear 2 LSBits */
+      gain = ( qua_gain_pitch[index] >> 2 ) << 2;
+   }
+   else {
+      gain = qua_gain_pitch[index];
+   }
+   return gain;
+}
+
+
+/*
+ * ec_gain_pitch_update
+ *
+ *
+ * Parameters:
+ *    st->prev_gp       B: previous pitch gain
+ *    st->past_gain_pit O: past gain
+ *    st->pbuf          B: past gain buffer
+ *    bfi               I: bad frame indicator
+ *    prev_bf           I: previous frame was bad
+ *    gain_pitch        B: pitch gain
+ *
+ * Function:
+ *    Update the pitch gain concealment state
+ *    Limit gain_pitch if the previous frame was bad
+ *
+ * Returns:
+ *    gain
+ */
+static void ec_gain_pitch_update( ec_gain_pitchState *st, Word32 bfi,
+      Word32 prev_bf, Word32 *gain_pitch )
+{
+   if ( bfi == 0 ) {
+      if ( prev_bf != 0 ) {
+         if ( *gain_pitch > st->prev_gp ) {
+            *gain_pitch = st->prev_gp;
+         }
+      }
+      st->prev_gp = *gain_pitch;
+   }
+   st->past_gain_pit = *gain_pitch;
+
+   /* if (st->past_gain_pit > 1.0) */
+   if ( st->past_gain_pit > 16384 ) {
+      st->past_gain_pit = 16384;
+   }
+   st->pbuf[0] = st->pbuf[1];
+   st->pbuf[1] = st->pbuf[2];
+   st->pbuf[2] = st->pbuf[3];
+   st->pbuf[3] = st->pbuf[4];
+   st->pbuf[4] = st->past_gain_pit;
+}
+
+
+/*
+ * gc_pred (366)
+ *
+ *
+ * Parameters:
+ *    st->past_qua_en         I: MA predictor
+ *    st->past_qua_en_MR122   I: MA predictor MR122
+ *    mode                    I: AMR mode
+ *    code                    I: innovative codebook vector
+ *    exp_gcode0              O: predicted gain factor (exponent)
+ *    frac_gcode0             O: predicted gain factor (fraction)
+ *    exp_en                  I: innovation energy (MR795) (exponent)
+ *    frac_en                 I: innovation energy (MR795) (fraction)
+ *
+ * Function:
+ *    MA prediction of the innovation energy
+ *
+ *    Mean removed innovation energy (dB) in subframe n
+ *                          N-1
+ *    E(n) = 10*log(gc*gc * SUM[(code(i) * code(i)]/N) - EMean
+ *                          i=0
+ *    N=40
+ *
+ *    Mean innovation energy (dB)
+ *                   N-1
+ *    Ei(n) = 10*log(SUM[(code(i) * code(i)]/N)
+ *                   i=0
+ *
+ *    Predicted energy
+ *              4
+ *    Ep(n) = SUM[b(i) * R(n-i)]
+ *            i=1
+ *    b = [0.68 0.58 0.34 0.19]
+ *    R(k) is quantified prediction error at subframe k
+ *
+ *    E_Mean = 36 dB (MR122)
+ *
+ *    Predicted gain gc is found by
+ *
+ *    gc = POW[10, 0.05 * (Ep(n) + EMean - Ei)]
+ *
+ * Returns:
+ *    void
+ */
+static void gc_pred( gc_predState *st, enum Mode mode, Word32 *code, Word32 *
+      exp_gcode0, Word32 *frac_gcode0, Word32 *exp_en, Word32 *frac_en )
+{
+   Word32 exp, frac, ener_code = 0, i = 0;
+
+
+    /* energy of code:
+     * ener_code = sum(code[i]^2)
+     */
+   while ( i < L_SUBFR ) {
+      ener_code += code[i] * code[i];
+      i++;
+   }
+
+   if ( ( 0x3fffffff <= ener_code ) | ( ener_code < 0 ) )
+      ener_code = MAX_32;
+   else
+      ener_code <<= 1;
+
+   if ( mode == MR122 ) {
+      Word32 ener;
+
+
+      /* ener_code = ener_code / lcode; lcode = 40; 1/40 = 26214 Q20       */
+      ener_code = ( ( ener_code + 0x00008000L ) >> 16 ) * 52428;
+
+      /* Q9  * Q20 -> Q30 */
+        /* energy of code:
+         * ener_code(Q17) = 10 * Log10(energy) / constant
+         *                = 1/2 * Log2(energy)
+         * constant = 20*Log10(2)
+         */
+      /* ener_code = 1/2 * Log2(ener_code); Note: Log2=log2+30 */
+      Log2( ener_code, &exp, &frac );
+      ener_code = ( ( exp - 30 ) << 16 ) + ( frac << 1 );
+
+      /* Q16 for log(), ->Q17 for 1/2 log() */
+         /*
+          * predicted energy:
+          * ener(Q24) = (Emean + sum{pred[i]*pastEn[i]})/constant
+          *           = MEAN_ENER + sum(pred[i]*past_qua_en[i])
+          * constant = 20*Log10(2)
+          */
+      ener = 0;
+      i = 0;
+
+      while ( i < 4 ) {
+         ener += st->past_qua_en_MR122[i] * pred_MR122[i];
+         i++;
+      }
+      ener <<= 1;
+      ener += MEAN_ENER_MR122;
+
+        /*
+         * predicted codebook gain
+
+         * gc0 = Pow10( (ener*constant - ener_code*constant) / 20 )
+         *     = Pow2(ener-ener_code)
+         *     = Pow2(int(d)+frac(d))
+         */
+      ener = ( ener - ener_code ) >> 1;   /* Q16 */
+      *exp_gcode0 = ener >> 16;
+      *frac_gcode0 = ( ener >> 1 ) - ( *exp_gcode0 << 15 );
+   }
+
+   /* all modes except 12.2 */
+   else {
+      Word32 tmp, gcode0;
+      int exp_code;
+
+
+        /*
+         * Compute: meansEner - 10log10(ener_code/ LSufr)
+         */
+      exp_code=0;
+      if (ener_code != 0){
+         while (!(ener_code & 0x40000000))
+         {
+            exp_code++;
+            ener_code = ener_code << 1;
+         }
+      }
+
+      /* Log2 = log2 + 27 */
+      Log2_norm( ener_code, exp_code, &exp, &frac );
+
+      /* fact = 10/log2(10) = 3.01 = 24660 Q13 */
+      /* Q0.Q15 * Q13 -> Q14 */
+      tmp = ( exp * ( -49320 ) ) + ( ( ( frac * ( -24660 ) ) >> 15 ) << 1 );
+
+      /*
+       * tmp = meansEner - 10log10(ener_code/L_SUBFR)
+       *       = meansEner - 10log10(ener_code) + 10log10(L_SUBFR)
+       *       = K - fact * Log2(ener_code)
+       *     = K - fact * log2(ener_code) - fact*27
+       *
+       *   ==> K = meansEner + fact*27 + 10log10(L_SUBFR)
+       *
+       *   meansEner =       33    =  540672    Q14  (MR475, MR515, MR59)
+       *   meansEner =       28.75 =  471040    Q14  (MR67)
+       *   meansEner =       30    =  491520    Q14  (MR74)
+       *   meansEner =       36    =  589824    Q14  (MR795)
+       *   meansEner =       33    =  540672    Q14  (MR102)
+       *   10log10(L_SUBFR) = 16.02 =  262481.51 Q14
+       *   fact * 27                = 1331640    Q14
+       *   -----------------------------------------
+       *   (MR475, MR515, MR59)   K = 2134793.51 Q14 ~= 16678 * 64 * 2
+       *   (MR67)                 K = 2065161.51 Q14 ~= 32268 * 32 * 2
+       *   (MR74)                 K = 2085641.51 Q14 ~= 32588 * 32 * 2
+       *   (MR795)                K = 2183945.51 Q14 ~= 17062 * 64 * 2
+       *   (MR102)                K = 2134793.51 Q14 ~= 16678 * 64 * 2
+       */
+      if ( mode == MR102 ) {
+         /* mean = 33 dB */
+         tmp += 2134784;   /* Q14 */
+      }
+      else if ( mode == MR795 ) {
+         /* mean = 36 dB */
+         tmp += 2183936;   /* Q14 */
+
+         /*
+          * ener_code  = <xn xn> * 2^27*2^exp_code
+          * frac_en    = ener_code / 2^16
+          *            = <xn xn> * 2^11*2^exp_code
+          * <xn xn>    = <xn xn>*2^11*2^exp * 2^exp_en
+          *           := frac_en            * 2^exp_en
+          *
+          * ==> exp_en = -11-exp_code;
+          */
+         *frac_en = ener_code >> 16;
+         *exp_en = -11 - exp_code;
+      }
+      else if ( mode == MR74 ) {
+         /* mean = 30 dB */
+         tmp += 2085632;   /* Q14 */
+      }
+      else if ( mode == MR67 ) {
+         /* mean = 28.75 dB */
+         tmp += 2065152;   /* Q14 */
+      }
+      else /* MR59, MR515, MR475 */ {
+         /* mean = 33 dB */
+         tmp += 2134784;   /* Q14 */
+      }
+
+        /*
+         * Compute gcode0
+         * = Sum(i=0,3) pred[i]*past_qua_en[i] - ener_code + meanEner
+         */
+      tmp = tmp << 9;   /* Q23 */
+
+      /* Q13 * Q10 -> Q23 */
+      i = 0;
+
+      while ( i < 4 ) {
+         tmp += pred[i] * st->past_qua_en[i];
+         i++;
+      }
+      gcode0 = tmp >> 15;   /* Q8  */
+
+        /*
+         * gcode0 = pow(10.0, gcode0/20)
+         *        = pow(2, 3.3219*gcode0/20)
+         *        = pow(2, 0.166*gcode0)
+         */
+      /* 5439 Q15 = 0.165985                                        */
+      /* (correct: 1/(20*log10(2)) 0.166096 = 5443 Q15)             */
+      /* For IS641 bitexactness */
+      if ( mode == MR74 ) {
+         /* Q8 * Q15 -> Q24 */
+         tmp = gcode0 * 10878;
+      }
+      else {
+         /* Q8 * Q15 -> Q24 */
+         tmp = gcode0 * 10886;
+      }
+      tmp = tmp >> 9;   /* -> Q15 */
+
+      /* -> Q0.Q15 */
+      *exp_gcode0 = tmp >> 15;
+      *frac_gcode0 = tmp - ( *exp_gcode0 * 32768 );
+   }
+}
+
+
+/*
+ * gc_pred_update
+ *
+ *
+ * Parameters:
+ *    st->past_qua_en         B: MA predictor
+ *    st->past_qua_en_MR122   B: MA predictor MR122
+ *    qua_ener_MR122          I: quantized energy for update (log2(quaErr))
+ *    qua_ener                I: quantized energy for update (20*log10(quaErr))
+ *
+ * Function:
+ *    Update MA predictor with last quantized energy
+ *
+ * Returns:
+ *    void
+ */
+static void gc_pred_update( gc_predState *st, Word32 qua_ener_MR122,
+      Word32 qua_ener )
+{
+   Word32 i;
+
+
+   for ( i = 3; i > 0; i-- ) {
+      st->past_qua_en[i] = st->past_qua_en[i - 1];
+      st->past_qua_en_MR122[i] = st->past_qua_en_MR122[i - 1];
+   }
+   st->past_qua_en_MR122[0] = qua_ener_MR122;   /* log2 (quaErr), Q10 */
+   st->past_qua_en[0] = qua_ener;   /* 20*log10(quaErr), Q10 */
+}
+
+
+/*
+ * Dec_gain
+ *
+ *
+ * Parameters:
+ *    pred_state->past_qua_en       B: MA predictor
+ *    pred_state->past_qua_en_MR122 B: MA predictor MR122
+ *    mode                          I: AMR mode
+ *    index                         I: index of quantization
+ *    code                          I: Innovative vector
+ *    evenSubfr                     I: Flag for even subframes
+ *    gain_pit                      O: Pitch gain
+ *    gain_cod                      O: Code gain
+ *
+ * Function:
+ *    Decode the pitch and codebook gains
+ *
+ * Returns:
+ *    void
+ */
+static void Dec_gain( gc_predState *pred_state, enum Mode mode, Word32 index,
+      Word32 code[], Word32 evenSubfr, Word32 *gain_pit, Word32 *gain_cod )
+{
+   Word32 frac, gcode0, exp, qua_ener, qua_ener_MR122, g_code, tmp;
+   const Word32 *p;
+
+
+   /* Read the quantized gains (table depends on mode) */
+   index = index << 2;
+
+   if ( ( mode == MR102 ) || ( mode == MR74 ) || ( mode == MR67 ) ) {
+      p = &table_gain_highrates[index];
+      *gain_pit = *p++;
+      g_code = *p++;
+      qua_ener_MR122 = *p++;
+      qua_ener = *p;
+   }
+   else {
+      if ( mode == MR475 ) {
+         index = index + ( ( 1 - evenSubfr ) << 1 );
+         p = &table_gain_MR475[index];
+         *gain_pit = *p++;
+         g_code = *p++;
+
+            /*
+             * calculate predictor update values (not stored in 4.75
+             * quantizer table to save space):
+             *   qua_ener       = log2(g)
+             *   qua_ener_MR122 = 20*log10(g)
+             */
+         /* Log2(x Q12) = log2(x) + 12 */
+         Log2( g_code, &exp, &frac );
+         exp = exp - 12;
+         tmp = frac >> 5;
+
+         if ( ( frac & ( ( Word16 )1 << 4 ) ) != 0 ) {
+            tmp++;
+         }
+         qua_ener_MR122 = tmp + ( exp << 10 );
+
+         /* 24660 Q12 ~= 6.0206 = 20*log10(2) */
+         tmp = exp * 49320;
+         tmp += ( ( ( frac * 24660 ) >> 15 ) << 1 );
+
+         /* Q12 * Q0 = Q13 -> Q10 */
+         qua_ener = ( ( tmp << 13 ) + 0x00008000L ) >> 16;
+      }
+      else {
+         p = &table_gain_lowrates[index];
+         *gain_pit = *p++;
+         g_code = *p++;
+         qua_ener_MR122 = *p++;
+         qua_ener = *p;
+      }
+   }
+
+    /*
+     * predict codebook gain
+     * gc0 = Pow2(int(d)+frac(d))
+     *     = 2^exp + 2^frac
+     * gcode0 (Q14) = 2^14*2^frac = gc0 * 2^(14-exp)
+     */
+   gc_pred( pred_state, mode, code, &exp, &frac, NULL, NULL );
+   gcode0 = Pow2( 14, frac );
+
+    /*
+     * read quantized gains, update table of past quantized energies
+     * st->past_qua_en(Q10) = 20 * Log10(gFac) / constant
+     *                      = Log2(gFac)
+     *                      = qua_ener
+     * constant = 20*Log10(2)
+     */
+   if ( exp < 11 ) {
+      *gain_cod = ( g_code * gcode0 ) >> ( 25 - exp );
+   }
+   else {
+      tmp = ( ( g_code * gcode0 ) << ( exp - 9 ) );
+
+      if ( ( tmp >> ( exp - 9 ) ) != ( g_code * gcode0 ) ) {
+         *gain_cod = 0x7FFF;
+      }
+      else {
+         *gain_cod = tmp >> 16;
+      }
+   }
+
+   /* update table of past quantized energies */
+   gc_pred_update( pred_state, qua_ener_MR122, qua_ener );
+   return;
+}
+
+
+/*
+ * gc_pred_average_limited
+ *
+ *
+ * Parameters:
+ *    st->past_qua_en         I: MA predictor
+ *    st->past_qua_en_MR122   I: MA predictor MR122
+ *    ener_avg_MR122          O: everaged quantized energy (log2(quaErr))
+ *    ener_avg                O: averaged quantized energy (20*log10(quaErr))
+ *
+ * Function:
+ *    Compute average limited quantized energy
+ * Returns:
+ *    void
+ */
+static void gc_pred_average_limited( gc_predState *st, Word32 *ener_avg_MR122,
+      Word32 *ener_avg )
+{
+   Word32 av_pred_en, i;
+
+
+   /* do average in MR122 mode (log2() domain) */
+   av_pred_en = 0;
+
+   for ( i = 0; i < NPRED; i++ ) {
+      av_pred_en = ( av_pred_en + st->past_qua_en_MR122[i] );
+   }
+
+   /* av_pred_en = 0.25*av_pred_en */
+   av_pred_en = ( av_pred_en * 8192 ) >> 15;
+
+   /* if (av_pred_en < -14/(20Log10(2))) av_pred_en = .. */
+   if ( av_pred_en < MIN_ENERGY_MR122 ) {
+      av_pred_en = MIN_ENERGY_MR122;
+   }
+   *ener_avg_MR122 = ( Word16 )av_pred_en;
+
+   /* do average for other modes (20*log10() domain) */
+   av_pred_en = 0;
+
+   for ( i = 0; i < NPRED; i++ ) {
+      av_pred_en = ( av_pred_en + st->past_qua_en[i] );
+      if (av_pred_en < -32768)
+         av_pred_en = -32768;
+      else if (av_pred_en > 32767)
+         av_pred_en = 32767;
+   }
+
+   /* av_pred_en = 0.25*av_pred_en */
+   av_pred_en = ( av_pred_en * 8192 ) >> 15;
+
+   *ener_avg = av_pred_en;
+}
+
+
+/*
+ * ec_gain_code
+ *
+ *
+ * Parameters:
+ *    st->gbuf             I: last five gains
+ *    st->past_gain_code   I: past gain
+ *    pred_state           B: MA predictor state
+ *    state                I: state of the state machine
+ *    gain_code            O: decoded innovation gain
+ *
+ * Function:
+ *    Conceal the codebook gain
+ *
+ * Returns:
+ *    void
+ */
+static void ec_gain_code( ec_gain_codeState *st, gc_predState *pred_state,
+      Word16 state, Word32 *gain_code )
+{
+   Word32 tmp, qua_ener_MR122, qua_ener;
+
+
+   /* calculate median of last five gain values */
+   tmp = gmed_n( st->gbuf, 5 );
+
+   /* new gain = minimum(median, past_gain) * cdown[state] */
+   if ( tmp > st->past_gain_code ) {
+      tmp = st->past_gain_code;
+   }
+   tmp = ( tmp * cdown[state] ) >> 15;
+   *gain_code = tmp;
+
+      /*
+       * update table of past quantized energies with average of
+       * current values
+       */
+   gc_pred_average_limited( pred_state, &qua_ener_MR122, &qua_ener );
+   gc_pred_update( pred_state, qua_ener_MR122, qua_ener );
+}
+
+
+/*
+ * ec_gain_code_update
+ *
+ *
+ * Parameters:
+ *    st->gbuf             B: last five gains
+ *    st->past_gain_code   O: past gain
+ *    st->prev_gc          B  previous gain
+ *    bfi                  I: bad indicator
+ *    prev_bf              I: previous frame bad indicator
+ *    gain_code            O: decoded innovation gain
+ *
+ * Function:
+ *    Update the codebook gain concealment state
+ *
+ * Returns:
+ *    void
+ */
+static void ec_gain_code_update( ec_gain_codeState *st, Word16 bfi,
+      Word16 prev_bf, Word32 *gain_code )
+{
+   /* limit gain_code by previous good gain if previous frame was bad */
+   if ( bfi == 0 ) {
+      if ( prev_bf != 0 ) {
+         if ( *gain_code > st->prev_gc ) {
+            *gain_code = st->prev_gc;
+         }
+      }
+      st->prev_gc = *gain_code;
+   }
+
+   /* update EC states: previous gain, gain buffer */
+   st->past_gain_code = *gain_code;
+   st->gbuf[0] = st->gbuf[1];
+   st->gbuf[1] = st->gbuf[2];
+   st->gbuf[2] = st->gbuf[3];
+   st->gbuf[3] = st->gbuf[4];
+   st->gbuf[4] = *gain_code;
+   return;
+}
+
+
+/*
+ * d_gain_code
+ *
+ *
+ * Parameters:
+ *    pred_state        B: MA predictor state
+ *    mode              I: AMR mode (MR795 or MR122)
+ *    index             I: received quantization index
+ *    code              I: innovation codevector
+ *    gain_code         O: decoded innovation gain
+ *
+ * Function:
+ *    Decode the fixed codebook gain using the received index
+ *
+ * Returns:
+ *    void
+ */
+static void d_gain_code( gc_predState *pred_state, enum Mode mode, Word32 index,
+                        Word32 code[], Word32 *gain_code )
+{
+   Word32 g_code0, exp, frac, qua_ener_MR122, qua_ener;
+   Word32 exp_inn_en, frac_inn_en, tmp, tmp2, i;
+   const Word32 *p;
+
+
+   /*
+    * Decode codebook gain
+    */
+   gc_pred( pred_state, mode, code, &exp, &frac, &exp_inn_en, &frac_inn_en );
+   p = &qua_gain_code[( ( index + index )+ index )];
+
+   /* Different scalings between MR122 and the other modes */
+   if ( mode == MR122 ) {
+      /* predicted gain */
+      g_code0 = Pow2( exp, frac );
+
+      if ( g_code0 <= 2047 )
+         g_code0 = g_code0 << 4;
+      else
+         g_code0 = 32767;
+      *gain_code = ( ( g_code0 * *p++ ) >> 15 ) << 1;
+      if (*gain_code & 0xFFFF8000)
+         *gain_code = 32767;
+
+   }
+   else {
+      g_code0 = Pow2( 14, frac );
+      tmp = ( *p++ * g_code0 ) << 1;
+      exp = 9 - exp;
+
+      if ( exp > 0 ) {
+         tmp = tmp >> exp;
+      }
+      else {
+         for (i = exp; i < 0; i++) {
+            tmp2 = tmp << 1;
+            if ((tmp ^ tmp2) & 0x80000000) {
+               tmp = (tmp & 0x80000000) ? 0x80000000 : 0x7FFFFFFF;
+               break;
+            }
+            else {
+               tmp = tmp2;
+            }
+         }
+      }
+      *gain_code = tmp >> 16;
+      if (*gain_code & 0xFFFF8000)
+         *gain_code = 32767;
+   }
+
+   /*
+    * update table of past quantized energies
+    */
+   qua_ener_MR122 = *p++;
+   qua_ener = *p++;
+   gc_pred_update( pred_state, qua_ener_MR122, qua_ener );
+   return;
+}
+
+
+/*
+ * Int_lsf
+ *
+ *
+ * Parameters:
+ *    lsf_old           I: LSF vector at the 4th subframe of past frame
+ *    lsf_new           I: LSF vector at the 4th subframe of present frame
+ *    i_subfr           I: current subframe
+ *    lsf_out           O: interpolated LSF parameters for current subframe
+ *
+ * Function:
+ *    Interpolates the LSFs for selected subframe
+ *
+ *    The LSFs are interpolated at the 1st, 2nd and 3rd
+ *    ubframe and only forwarded at the 4th subframe.
+ *
+ *    sf1:  3/4 F0 + 1/4 F1
+ *    sf2:  1/2 F0 + 1/2 F1
+ *    sf3:  1/4 F0 + 3/4 F1
+ *    sf4:  F1
+ *
+ * Returns:
+ *    void
+ */
+static void Int_lsf( Word32 lsf_old[], Word32 lsf_new[], int i_subfr, Word32
+      lsf_out[] )
+{
+   Word32 i;
+
+
+   switch ( i_subfr ) {
+      case 0:
+         for ( i = 0; i < 10; i++ ) {
+            lsf_out[i] = lsf_old[i] - ( lsf_old[i] >> 2 ) + ( lsf_new[i] >> 2 );
+         }
+         break;
+
+      case 40:
+         for ( i = 0; i < 10; i++ ) {
+            lsf_out[i] = ( lsf_old[i] >> 1 ) + ( lsf_new[i] >> 1 );
+         }
+         break;
+
+      case 80:
+         for ( i = 0; i < 10; i++ ) {
+            lsf_out[i] = ( lsf_old[i] >> 2 ) - ( lsf_new[i] >> 2 ) +
+                  lsf_new[i];
+         }
+         break;
+
+      case 120:
+         memcpy( lsf_out, lsf_new, M <<2 );
+         break;
+   }
+}
+
+
+/*
+ * Cb_gain_average
+ *
+ *
+ * Parameters:
+ *    st->cbGainHistory B: codebook gain history
+ *    st->hangCount     B: hangover counter
+ *    mode              I: AMR mode
+ *    gain_code         I: codebook gain
+ *    lsp               I: The LSP for the current frame
+ *    lspAver           I: The average of LSP for 8 frames
+ *    bfi               I: bad frame indication
+ *    prev_bf           I: previous bad frame indication
+ *    pdfi              I: potential degraded bad frame indication
+ *    prev_pdf          I: previous potential degraded bad frame indication
+ *    inBackgroundNoise I: background noise decision
+ *    voicedHangover    I: number of frames after last voiced frame
+ *
+ * Function:
+ *    The mixed codebook gain, used to make codebook gain more smooth in background
+ *
+ *
+ * Returns:
+ *    void
+ */
+static Word32 Cb_gain_average( Cb_gain_averageState *st, enum Mode mode, Word32
+      gain_code, Word32 lsp[], Word32 lspAver[], Word16 bfi, Word16 prev_bf,
+      Word16 pdfi, Word16 prev_pdf, Word32 inBackgroundNoise, Word32
+      voicedHangover )
+{
+   Word32 tmp[M];
+   Word32 i, cbGainMix, tmp_diff, bgMix, cbGainMean, sum, diff, tmp1, tmp2;
+   int shift1, shift2, shift;
+
+
+   /* set correct cbGainMix for MR74, MR795, MR122 */
+   cbGainMix = gain_code;
+
+   /*
+    * Store list of CB gain needed in the CB gain averaging                                           *
+    */
+   st->cbGainHistory[0] = st->cbGainHistory[1];
+   st->cbGainHistory[1] = st->cbGainHistory[2];
+   st->cbGainHistory[2] = st->cbGainHistory[3];
+   st->cbGainHistory[3] = st->cbGainHistory[4];
+   st->cbGainHistory[4] = st->cbGainHistory[5];
+   st->cbGainHistory[5] = st->cbGainHistory[6];
+   st->cbGainHistory[6] = gain_code;
+
+   /* compute lsp difference */
+   for ( i = 0; i < M; i++ ) {
+      tmp1 = labs( lspAver[i]- lsp[i] );
+      shift1 = 0;
+      if (tmp1 != 0){
+         while (!(tmp1 & 0x2000))
+         {
+            shift1++;
+            tmp1 = tmp1 << 1;
+         }
+      }
+      tmp2 = lspAver[i];
+      shift2 = 0;
+      if (tmp2 != 0){
+         while (!(tmp2 & 0x4000))
+         {
+            shift2++;
+            tmp2 = tmp2 << 1;
+         }
+      }
+      tmp[i] = ( tmp1 << 15 ) / tmp2;
+      shift = 2 + shift1 - shift2;
+
+      if ( shift >= 0 ) {
+         tmp[i] = tmp[i] >> shift;
+      }
+      else {
+         tmp[i] = tmp[i] << -( shift );
+      }
+   }
+   diff = *tmp + tmp[1] + tmp[2] + tmp[3] + tmp[4] + tmp[5] + tmp[6] + tmp[7] +
+         tmp[8] + tmp[9];
+
+   /* saturate */
+   if ( diff > 32767 ) {
+      diff = 32767;
+   }
+
+   /* Compute hangover */
+   st->hangVar += 1;
+
+   if ( diff <= 5325 ) {
+      st->hangVar = 0;
+   }
+
+   if ( st->hangVar > 10 ) {
+      /* Speech period, reset hangover variable */
+      st->hangCount = 0;
+   }
+
+   /* Compute mix constant (bgMix) */
+   bgMix = 8192;
+
+   /* MR475, MR515, MR59, MR67, MR102 */
+   if ( ( mode <= MR67 ) | ( mode == MR102 ) ) {
+      /* disable mix if too short time since */
+      if ( ( st->hangCount >= 40 ) & ( diff <= 5325 ) ) /* 0.65 in Q13 */ {
+         /* if errors and presumed noise make smoothing probability stronger */
+         if ( ( ( ( ( pdfi != 0 ) & ( prev_pdf != 0 ) ) | ( bfi != 0 ) | (
+               prev_bf != 0 ) ) & ( ( voicedHangover > 1 ) ) & (
+               inBackgroundNoise != 0 ) & ( mode < MR67 ) ) ) {
+            /* bgMix = min(0.25, max(0.0, diff-0.55)) / 0.25; */
+            tmp_diff = diff - 4506;   /* 0.55 in Q13 */
+
+            /* max(0.0, diff-0.55) */
+            tmp1 = 0;
+
+            if ( tmp_diff > 0 ) {
+               tmp1 = tmp_diff;
+            }
+
+            /* min(0.25, tmp1) */
+            if ( 2048 >= tmp1 ) {
+               bgMix = tmp1 << 2;
+            }
+         }
+         else {
+            /* bgMix = min(0.25, max(0.0, diff-0.40)) / 0.25; */
+            tmp_diff = diff - 3277;   /* 0.4 in Q13 */
+
+            /* max(0.0, diff-0.40) */
+            tmp1 = 0;
+
+            if ( tmp_diff > 0 ) {
+               tmp1 = tmp_diff;
+            }
+
+            /* min(0.25, tmp1) */
+            if ( 2048 >= tmp1 ) {
+               bgMix = tmp1 << 2;
+            }
+         }
+      }
+
+      /*
+       * Smoothen the cb gain trajectory
+       * smoothing depends on mix constant bgMix
+       */
+      sum = st->cbGainHistory[2] + st->cbGainHistory[3] + st->cbGainHistory[4] +
+            st->cbGainHistory[5] + st->cbGainHistory[6];
+
+      if ( sum > 163822 ) {
+         cbGainMean = 32767;
+      }
+      else {
+         cbGainMean = ( 3277 * sum + 0x00002000L ) >> 14;   /* Q1 */
+      }
+
+      /* more smoothing in error and bg noise (NB no DFI used  here) */
+      if ( ( ( bfi != 0 ) | ( prev_bf != 0 ) ) & ( inBackgroundNoise != 0 ) & (
+            mode < MR67 ) ) {
+         sum = 9362 * ( st->cbGainHistory[0] + st->cbGainHistory[1] + st->
+               cbGainHistory[2] + st->cbGainHistory[3] + st->cbGainHistory[4] +
+               st->cbGainHistory[5] + st->cbGainHistory[6] );
+         cbGainMean = ( sum + 0x00008000L ) >> 16;   /* Q1 */
+      }
+
+      /* cbGainMix = bgMix*cbGainMix + (1-bgMix)*cbGainMean; */
+      sum = bgMix * cbGainMix;   /* sum in Q14 */
+      sum += cbGainMean << 13;
+      sum -= bgMix * cbGainMean;
+      cbGainMix = ( sum + 0x00001000L ) >> 13;
+
+      /* Q1 */
+   }
+   st->hangCount += 1;
+   if (st->hangCount & 0x80000000)
+      st->hangCount = 40;
+   return cbGainMix;
+}
+
+
+/*
+ * ph_disp
+ *
+ *
+ * Parameters:
+ *    state->gainMem    B: LTP gain memory
+ *    state->prevCbGain B: Codebook gain memory
+ *    mode              I: AMR mode
+ *    x                 B: LTP excitation signal -> total excitation signal
+ *    cbGain            I: Codebook gain
+ *    ltpGain           I: LTP gain
+ *    inno              B: Innovation vector
+ *    pitch_fac         I: pitch factor used to scale the LTP excitation
+ *    tmp_shift         I: shift factor applied to sum of scaled LTP ex & innov.
+ *                         before rounding
+ *
+ * Function:
+ *    Adaptive phase dispersion; forming of total excitation
+ *
+ *
+ * Returns:
+ *    void
+ */
+static void ph_disp( ph_dispState *state, enum Mode mode, Word32 x[],
+                    Word32 cbGain, Word32 ltpGain, Word32 inno[],
+                    Word32 pitch_fac, Word32 tmp_shift)
+{
+   Word32 inno_sav[L_SUBFR], ps_poss[L_SUBFR];
+   Word32 i, i1, impNr, temp1, temp2, j, nze, nPulse, ppos;
+   const Word32 *ph_imp;   /* Pointer to phase dispersion filter */
+
+
+   /* Update LTP gain memory */
+   state->gainMem[4] = state->gainMem[3];
+   state->gainMem[3] = state->gainMem[2];
+   state->gainMem[2] = state->gainMem[1];
+   state->gainMem[1] = state->gainMem[0];
+   state->gainMem[0] = ltpGain;
+
+   /* basic adaption of phase dispersion */
+   /* no dispersion */
+   impNr = 2;
+
+   /* if (ltpGain < 0.9) */
+   if ( ltpGain < PHDTHR2LTP ) {
+      /* maximum dispersion */
+      impNr = 0;
+
+      /* if (ltpGain > 0.6 */
+      if ( ltpGain > PHDTHR1LTP ) {
+         /* medium dispersion */
+         impNr = 1;
+      }
+   }
+
+   /* onset indicator */
+   /* onset = (cbGain  > onFact * cbGainMem[0]) */
+   temp1 = ( ( state->prevCbGain * ONFACTPLUS1 ) + 0x1000 ) >> 13;
+
+   if ( cbGain > temp1 ) {
+      state->onset = ONLENGTH;
+   }
+   else {
+      if ( state->onset > 0 ) {
+         state->onset--;
+      }
+   }
+
+   /*
+    * if not onset, check ltpGain buffer and use max phase dispersion if
+    * half or more of the ltpGain-parameters say so
+    */
+   if ( state->onset == 0 ) {
+      /* Check LTP gain memory and set filter accordingly */
+      i1 = 0;
+
+      for ( i = 0; i < PHDGAINMEMSIZE; i++ ) {
+         if ( state->gainMem[i] < PHDTHR1LTP ) {
+            i1++;
+         }
+      }
+
+      if ( i1 > 2 ) {
+         impNr = 0;
+      }
+   }
+
+   /* Restrict decrease in phase dispersion to one step if not onset */
+   if ( ( impNr > ( state->prevState + 1 ) ) & ( state->onset == 0 ) ) {
+      impNr--;
+   }
+
+   /* if onset, use one step less phase dispersion */
+   if ( ( impNr<2 )&( state->onset>0 ) ) {
+      impNr++;
+   }
+
+   /* disable for very low levels */
+   if ( cbGain < 10 ) {
+      impNr = 2;
+   }
+
+   if ( state->lockFull == 1 ) {
+      impNr = 0;
+   }
+
+   /* update static memory */
+   state->prevState = impNr;
+   state->prevCbGain = cbGain;
+
+   /*
+    * do phase dispersion for all modes but 12.2 and 7.4;
+    * don't modify the innovation if impNr >=2 (= no phase disp)
+    */
+   if ( ( mode != MR122 ) & ( mode != MR102 ) & ( mode != MR74 ) & ( impNr < 2 )
+      ) {
+      /*
+       * track pulse positions, save innovation,
+       * and initialize new innovation
+       */
+      nze = 0;
+
+      for ( i = 0; i < L_SUBFR; i++ ) {
+         if ( inno[i] != 0 ) {
+            ps_poss[nze] = i;
+            nze++;
+         }
+      }
+      memcpy( inno_sav, inno, L_SUBFR <<2 );
+      memset( inno, 0, L_SUBFR <<2 );
+
+      /* Choose filter corresponding to codec mode and dispersion criterium */
+      ph_imp = ph_imp_mid;
+
+      if ( impNr == 0 ) {
+         ph_imp = ph_imp_low;
+      }
+
+      if ( mode == MR795 ) {
+         ph_imp = ph_imp_mid_MR795;
+
+         if ( impNr == 0 ) {
+            ph_imp = ph_imp_low_MR795;
+         }
+      }
+
+      /* Do phase dispersion of innovation */
+      for ( nPulse = 0; nPulse < nze; nPulse++ ) {
+         ppos = ps_poss[nPulse];
+
+         /* circular convolution with impulse response */
+         j = 0;
+
+         for ( i = ppos; i < L_SUBFR; i++ ) {
+            /* inno[i1] += inno_sav[ppos] * ph_imp[i1-ppos] */
+            temp1 = ( inno_sav[ppos] * ph_imp[j++] ) >> 15;
+            inno[i] = inno[i] + temp1;
+         }
+
+         for ( i = 0; i < ppos; i++ ) {
+            /* inno[i] += inno_sav[ppos] * ph_imp[L_SUBFR-ppos+i] */
+            temp1 = ( inno_sav[ppos] * ph_imp[j++] ) >> 15;
+            inno[i] = inno[i] + temp1;
+         }
+      }
+   }
+
+   /*
+    * compute total excitation for synthesis part of decoder
+    * (using modified innovation if phase dispersion is active)
+    */
+   for ( i = 0; i < L_SUBFR; i++ ) {
+      /* x[i] = gain_pit*x[i] + cbGain*code[i]; */
+      temp1 = x[i] * pitch_fac + inno[i] * cbGain;
+      temp2 = temp1 << tmp_shift;
+      x[i] = ( temp2 + 0x4000 ) >> 15;
+      if (labs(x[i]) > 32767)
+      {
+         if ((temp1 ^ temp2) & 0x80000000) {
+            x[i] = (temp1 & 0x80000000) ? -32768: 32767;
+         }
+         else {
+            x[i] = (temp2 & 0x80000000) ? -32768: 32767;
+         }
+      }
+   }
+   return;
+}
+
+
+/*
+ * sqrt_l_exp
+ *
+ *
+ * Parameters:
+ *    x                 I: input value
+ *    exp               O: right shift to be applied to result
+ *
+ * Function:
+ *    Sqrt with exponent value.
+ *
+ *    y = sqrt(x)
+ *    x = f * 2^-e,   0.5 <= f < 1   (normalization)
+ *    y = sqrt(f) * 2^(-e/2)
+ *
+ *    a) e = 2k   --> y = sqrt(f)   * 2^-k
+ *       (k = e div 2, 0.707 <= sqrt(f) < 1)
+ *    b) e = 2k+1 --> y = sqrt(f/2) * 2^-k
+ *       (k = e div 2, 0.5 <= sqrt(f/2) < 0.707)
+ *
+ *
+ * Returns:
+ *    y                 output value
+ */
+static Word32 sqrt_l_exp( Word32 x, Word32 *exp )
+{
+   Word32 y, a, i, tmp;
+   int e;
+
+
+   if ( x <= ( Word32 )0 ) {
+      *exp = 0;
+      return( Word32 )0;
+   }
+   e=0;
+   if (x != 0){
+      tmp = x;
+      while (!(tmp & 0x40000000))
+      {
+         e++;
+         tmp = tmp << 1;
+      }
+   }
+   e = e & 0xFFFE;
+   x = ( x << e );
+   *exp = ( Word16 )e;
+   x = ( x >> 9 );
+   i = ( Word16 )( x >> 16 );
+   x = ( x >> 1 );
+   a = x & ( Word16 )0x7fff;
+   i = ( i - 16 );
+   y = ( sqrt_table[i] << 16 );
+   tmp = ( sqrt_table[i] - sqrt_table[i + 1] );
+   y -= ( tmp * a ) << 1;
+   return( y );
+}
+
+
+/*
+ * Ex_ctrl
+ *
+ *
+ * Parameters:
+ *    excitation        B: Current subframe excitation
+ *    excEnergy         I: Exc. Energy, sqrt(totEx*totEx)
+ *    exEnergyHist      I: History of subframe energies
+ *    voicedHangover    I: number of frames after last voiced frame
+ *    prevBFI           I: Set i previous bad frame indicators
+ *    carefulFlag       I: Restrict dymamic in scaling
+ *
+ * Function:
+ *    Charaterice synthesis speech and detect background noise
+ *
+ * Returns:
+ *    background noise decision; 0 = no bgn, 1 = bgn
+ */
+static Word16 Ex_ctrl( Word32 excitation[], Word32 excEnergy, Word32
+      exEnergyHist[], Word32 voicedHangover, Word16 prevBFI, Word16 carefulFlag
+      )
+{
+   Word32 i, testEnergy, scaleFactor, avgEnergy, prevEnergy, T0;
+   int exp;
+
+
+   /* get target level */
+   avgEnergy = gmed_n( exEnergyHist, 9 );
+   prevEnergy = ( exEnergyHist[7] + exEnergyHist[8] ) >> 1;
+
+   if ( exEnergyHist[8] < prevEnergy ) {
+      prevEnergy = exEnergyHist[8];
+   }
+
+   /* upscaling to avoid too rapid energy rises  for some cases */
+   if ( ( excEnergy<avgEnergy )&( excEnergy>5 ) ) {
+      /* testEnergy = 4*prevEnergy; */
+      testEnergy = prevEnergy << 2;
+
+      if ( ( voicedHangover < 7 ) || prevBFI != 0 ) {
+         /* testEnergy = 3*prevEnergy */
+         testEnergy = testEnergy - prevEnergy;
+      }
+
+      if ( avgEnergy > testEnergy ) {
+         avgEnergy = testEnergy;
+      }
+
+      /* scaleFactor=avgEnergy/excEnergy in Q0 */
+      exp=0;
+      if (excEnergy != 0){
+         while (!(excEnergy & 0x4000))
+         {
+            exp++;
+            excEnergy = excEnergy << 1;
+         }
+      }
+      excEnergy = 536838144 / excEnergy;
+      T0 = ( avgEnergy * excEnergy ) << 1;
+      T0 = ( T0 >> ( 20 - exp ) );
+
+      if ( T0 > 32767 ) {
+         /* saturate  */
+         T0 = 32767;
+      }
+      scaleFactor = T0;
+
+      /* test if scaleFactor > 3.0 */
+      if ( ( carefulFlag != 0 ) & ( scaleFactor > 3072 ) ) {
+         scaleFactor = 3072;
+      }
+
+      /* scale the excitation by scaleFactor */
+      for ( i = 0; i < L_SUBFR; i++ ) {
+         T0 = ( scaleFactor * excitation[i] ) << 1;
+         T0 = ( T0 >> 11 );
+         excitation[i] = T0;
+      }
+   }
+   return 0;
+}
+
+
+/*
+ * Inv_sqrt
+ *
+ *
+ * Parameters:
+ *    x                 I: input value
+ *
+ * Function:
+ *    1/sqrt(x)
+ *
+ * Returns:
+ *    y                 1/sqrt(x)
+ */
+static Word32 Inv_sqrt( Word32 x )
+{
+   int i, a, tmp, exp;
+   Word32 y;
+
+
+   if ( x <= ( Word32 )0 )
+      return( ( Word32 )0x3fffffffL );
+   exp=0;
+   while (!(x & 0x40000000))
+   {
+      exp++;
+      x = x << 1;
+   }
+
+   /* x is normalized */
+   exp = ( 30 - exp );
+
+   /* If exponent even -> shift right */
+   if ( ( exp & 1 ) == 0 ) {
+      x = ( x >> 1 );
+   }
+   exp = ( exp >> 1 );
+   exp = ( exp + 1 );
+   x = ( x >> 9 );
+
+   /* Extract b25-b31 */
+   i = ( Word16 )( x >> 16 );
+
+   /* Extract b10-b24 */
+   x = ( x >> 1 );
+   a = x & ( Word16 )0x7fff;
+   i = ( i - 16 );
+
+   /* table[i] << 16 */
+   y = inv_sqrt_table[i] << 16;
+
+   /* table[i] - table[i+1]) */
+   tmp = ( inv_sqrt_table[i] - inv_sqrt_table[i + 1] );
+
+   /* y -= tmp*a*2 */
+   y -= ( tmp * a ) << 1;
+
+   /* denormalization */
+   y = ( y >> exp );
+   return( y );
+}
+
+
+/*
+ * energy_old
+ *
+ *
+ * Parameters:
+ *    in                I: input value
+ *
+ * Function:
+ *    Energy of signal
+ *
+ * Returns:
+ *    Energy
+ */
+static Word32 energy_old( Word32 in[] )
+{
+   Word32 temp, i, sum = 0;
+
+
+   for ( i = 0; i < L_SUBFR; i += 8 ) {
+      temp = in[i] >> 2;
+      sum += temp * temp;
+      temp = in[i + 1] >> 2;
+      sum += temp * temp;
+      temp = in[i + 2] >> 2;
+      sum += temp * temp;
+      temp = in[i + 3] >> 2;
+      sum += temp * temp;
+      temp = in[i + 4] >> 2;
+      sum += temp * temp;
+      temp = in[i + 5] >> 2;
+      sum += temp * temp;
+      temp = in[i + 6] >> 2;
+      sum += temp * temp;
+      temp = in[i + 7] >> 2;
+      sum += temp * temp;
+   }
+
+   if ( sum & 0xC0000000 ) {
+      return 0x7FFFFFFF;
+   }
+   return( sum << 1 );
+}
+
+
+/*
+ * energy_new
+ *
+ *
+ * Parameters:
+ *    in                I: input value
+ *
+ * Function:
+ *    Energy of signal
+ *
+ * Returns:
+ *    Energy
+ */
+static Word32 energy_new( Word32 in[] )
+{
+   Word32 i, s = 0, overflow = 0;
+
+   s += in[0] * in[0];
+   for ( i = 1; i < L_SUBFR; i += 3 ) {
+      s += in[i] * in[i];
+      s += in[i + 1] *in[i + 1];
+      s += in[i + 2] * in[i + 2];
+
+
+      if ( s & 0xC0000000 ) {
+         overflow = 1;
+         break;
+      }
+   }
+
+   /* check for overflow */
+   if ( overflow ) {
+      s = energy_old( in );
+   }
+   else {
+      s = ( s >> 3 );
+   }
+   return s;
+}
+
+
+/*
+ * agc2
+ *
+ *
+ * Parameters:
+ *    sig_in            I: Post_Filter input signal
+ *    sig_out           B: Post_Filter output signal
+ *
+ * Function:
+ *    Scales the excitation on a subframe basis
+ *
+ * Returns:
+ *    Energy
+ */
+static void agc2( Word32 *sig_in, Word32 *sig_out )
+{
+   Word32 s;
+   int i, exp;
+   Word16 gain_in, gain_out, g0;
+
+
+   /* calculate gain_out with exponent */
+   s = energy_new( sig_out );
+
+   if ( s == 0 ) {
+      return;
+   }
+   exp=0;
+   while (!(s & 0x20000000))
+   {
+      exp++;
+      s = s << 1;
+   }
+
+   gain_out = ( Word16 )( ( s + 0x00008000L ) >> 16 );
+
+   /* calculate gain_in with exponent */
+   s = energy_new( sig_in );
+
+   if ( s == 0 ) {
+      g0 = 0;
+   }
+   else {
+      i = 0;
+      while (!(s & 0x40000000))
+      {
+         i++;
+         s = s << 1;
+      }
+
+      if ( s < 0x7fff7fff )
+         gain_in = ( Word16 )( ( s + 0x00008000L ) >> 16 );
+      else
+         gain_in = 32767;
+      exp = ( exp - i );
+
+        /*
+         * g0 = sqrt(gain_in/gain_out);
+         */
+      /* s = gain_out / gain_in */
+      s = ( gain_out << 15 ) / gain_in;
+      s = ( s << 7 );
+
+      if ( exp > 0 )
+         s = ( s >> exp );
+      else
+         s = ( s << ( -exp ) );
+      s = Inv_sqrt( s );
+      g0 = ( Word16 )( ( ( s << 9 ) + 0x00008000L ) >> 16 );
+   }
+
+   /* sig_out(n) = gain(n) * sig_out(n) */
+   for ( i = 0; i < L_SUBFR; i++ ) {
+      sig_out[i] = ( sig_out[i] * g0 ) >> 12;
+   }
+   return;
+}
+
+
+/*
+ * Bgn_scd
+ *
+ *
+ * Parameters:
+ *    st->frameEnergyHist  B: Frame Energy memory
+ *    st->bgHangover       B: Background hangover counter
+ *    ltpGainHist          I: LTP gain history
+ *    speech               I: synthesis speech frame
+ *    voicedHangover       O: number of frames after last voiced frame
+ *
+ * Function:
+ *    Charaterice synthesis speech and detect background noise
+ *
+ * Returns:
+ *    inbgNoise         background noise decision; 0 = no bgn, 1 = bgn
+ */
+static Word16 Bgn_scd( Bgn_scdState *st, Word32 ltpGainHist[], Word32 speech[],
+      Word32 *voicedHangover )
+{
+   Word32 temp, ltpLimit, frame_energyMin, currEnergy, noiseFloor, maxEnergy,
+         maxEnergyLastPart, s, i;
+   Word16 prevVoiced, inbgNoise;
+
+
+   /*
+    * Update the inBackgroundNoise flag (valid for use in next frame if BFI)
+    * it now works as a energy detector floating on top
+    * not as good as a VAD.
+    */
+   s = 0;
+
+   for ( i = 0; i < L_FRAME; i++ ) {
+      s += speech[i] * speech[i];
+   }
+
+   if ( (s < 0xFFFFFFF) & (s >= 0) )
+      currEnergy = s >> 13;
+   else
+      currEnergy = 32767;
+   frame_energyMin = 32767;
+
+   for ( i = 0; i < L_ENERGYHIST; i++ ) {
+      if ( st->frameEnergyHist[i] < frame_energyMin )
+         frame_energyMin = st->frameEnergyHist[i];
+   }
+
+   /* Frame Energy Margin of 16 */
+   noiseFloor = frame_energyMin << 4;
+   maxEnergy = st->frameEnergyHist[0];
+
+   for ( i = 1; i < L_ENERGYHIST - 4; i++ ) {
+      if ( maxEnergy < st->frameEnergyHist[i] ) {
+         maxEnergy = st->frameEnergyHist[i];
+      }
+   }
+   maxEnergyLastPart = st->frameEnergyHist[2 * L_ENERGYHIST / 3];
+
+   for ( i = 2 * L_ENERGYHIST / 3 + 1; i < L_ENERGYHIST; i++ ) {
+      if ( maxEnergyLastPart < st->frameEnergyHist[i] ) {
+         maxEnergyLastPart = st->frameEnergyHist[i];
+      }
+   }
+
+   /* false */
+   inbgNoise = 0;
+
+   /*
+    * Do not consider silence as noise
+    * Do not consider continuous high volume as noise
+    * Or if the current noise level is very low
+    * Mark as noise if under current noise limit
+    * OR if the maximum energy is below the upper limit
+    */
+   if ( ( maxEnergy> LOWERNOISELIMIT )&( currEnergy<FRAMEENERGYLIMIT )&(
+         currEnergy>LOWERNOISELIMIT ) & ( ( currEnergy < noiseFloor ) || (
+         maxEnergyLastPart < UPPERNOISELIMIT ) ) ) {
+      if ( ( st->bgHangover + 1 ) > 30 ) {
+         st->bgHangover = 30;
+      }
+      else {
+         st->bgHangover += 1;
+      }
+   }
+   else {
+      st->bgHangover = 0;
+   }
+
+   /* make final decision about frame state, act somewhat cautiosly */
+   if ( st->bgHangover > 1 )
+      inbgNoise = 1;   /* true  */
+
+   for ( i = 0; i < L_ENERGYHIST - 1; i++ ) {
+      st->frameEnergyHist[i] = st->frameEnergyHist[i + 1];
+   }
+   st->frameEnergyHist[L_ENERGYHIST - 1] = currEnergy;
+
+   /*
+    * prepare for voicing decision;
+    * tighten the threshold after some time in noise
+    */
+   ltpLimit = 13926;   /* 0.85  Q14 */
+
+   if ( st->bgHangover > 8 ) {
+      ltpLimit = 15565;   /* 0.95  Q14 */
+   }
+
+   if ( st->bgHangover > 15 ) {
+      ltpLimit = 16383;   /* 1.00  Q14 */
+   }
+
+   /* weak sort of voicing indication. */
+   prevVoiced = 0;   /* false */
+
+   if ( gmed_n( &ltpGainHist[4], 5 ) > ltpLimit ) {
+      prevVoiced = 1;   /* true  */
+   }
+
+   if ( st->bgHangover > 20 ) {
+      if ( gmed_n( ltpGainHist, 9 ) > ltpLimit ) {
+         prevVoiced = 1;   /* true  */
+      }
+      else {
+         prevVoiced = 0;   /* false  */
+      }
+   }
+
+   if ( prevVoiced ) {
+      *voicedHangover = 0;
+   }
+   else {
+      temp = *voicedHangover + 1;
+
+      if ( temp > 10 ) {
+         *voicedHangover = 10;
+      }
+      else {
+         *voicedHangover = temp;
+      }
+   }
+   return inbgNoise;
+}
+
+
+/*
+ * dtx_dec_activity_update
+ *
+ *
+ * Parameters:
+ *    st->lsf_hist_ptr  B: LSF history pointer
+ *    st->lsf_hist      B: LSF history
+ *    lsf               I: lsf
+ *    frame             I: noise frame
+ *
+ * Function:
+ *    Update lsp history and compute log energy.
+ *
+ * Returns:
+ *    void
+ */
+static void dtx_dec_activity_update( dtx_decState *st, Word32 lsf[], Word32
+      frame[] )
+{
+   Word32 frame_en;
+   Word32 log_en_e, log_en_m, log_en, i;
+
+
+   /* update lsp history */
+   st->lsf_hist_ptr += M;
+
+   if ( st->lsf_hist_ptr == 80 ) {
+      st->lsf_hist_ptr = 0;
+   }
+   memcpy( &st->lsf_hist[st->lsf_hist_ptr], lsf, M <<2 );
+
+   /* compute log energy based on frame energy */
+   frame_en = 0;   /* Q0 */
+
+   for ( i = 0; (i < L_FRAME); i ++ ) {
+      frame_en += frame[i] * frame[i];
+      if (frame_en & 0x80000000)
+         break;
+   }
+
+   log_en = (frame_en & 0xC0000000) ? 0x7FFFFFFE: (Word32)frame_en << 1;
+
+   Log2( log_en , &log_en_e, &log_en_m );
+
+   /* convert exponent and mantissa to Word16 Q10 */
+   log_en = log_en_e << 10;   /* Q10 */
+   log_en = log_en + ( log_en_m >> 5 );
+
+   /* divide with L_FRAME i.e subtract with log2(L_FRAME) = 7.32193 */
+   log_en = log_en - 8521;
+
+   /*
+    * insert into log energy buffer, no division by two as
+    * log_en in decoder is Q11
+    */
+   st->log_en_hist_ptr += 1;
+
+   if ( st->log_en_hist_ptr == DTX_HIST_SIZE ) {
+      st->log_en_hist_ptr = 0;
+   }
+   st->log_en_hist[st->log_en_hist_ptr] = log_en;   /* Q11 */
+}
+
+
+/*
+ * Decoder_amr
+ *
+ *
+ * Parameters:
+ *    st                B: State variables
+ *    mode              I: AMR mode
+ *    parm              I: vector of synthesis parameters
+ *    frame_type        I: received frame type
+ *    synth             O: synthesis speech
+ *    A_t               O: decoded LP filter in 4 subframes
+ *
+ * Function:
+ *    Speech decoder routine
+ *
+ * Returns:
+ *    void
+ */
+static void Decoder_amr( Decoder_amrState *st, enum Mode mode, Word16 parm[],
+      enum RXFrameType frame_type, Word32 synth[], Word32 A_t[] )
+{
+   /* LSPs */
+   Word32 lsp_new[M];
+   Word32 lsp_mid[M];
+
+
+   /* LSFs */
+   Word32 prev_lsf[M];
+   Word32 lsf_i[M];
+
+
+   /* Algebraic codevector */
+   Word32 code[L_SUBFR];
+
+
+   /* excitation */
+   Word32 excp[L_SUBFR];
+   Word32 exc_enhanced[L_SUBFR];
+
+
+   /* Scalars */
+   Word32 i, i_subfr, overflow, T0_frac, index, temp, temp2, subfrNr, excEnergy;
+   Word32 gain_code, gain_code_mix, pit_sharp, pit_flag, pitch_fac, t0_min, t0_max;
+   Word32 gain_pit = 0, evenSubfr = 0, T0 = 0, index_mr475 = 0;
+   Word32 *Az;   /* Pointer on A_t */
+   Word16 flag4, carefulFlag;
+   Word16 delta_frc_low, delta_frc_range, tmp_shift;
+   Word16 bfi = 0, pdfi = 0;
+   /* bad frame indication flag, potential degraded bad frame flag */
+
+
+   enum DTXStateType newDTXState;   /* SPEECH , DTX, DTX_MUTE */
+
+   /* find the new  DTX state  SPEECH OR DTX */
+   newDTXState = rx_dtx_handler( st->dtxDecoderState, frame_type );
+
+   /* DTX actions */
+   if ( newDTXState != SPEECH ) {
+      Decoder_amr_reset( st, MRDTX );
+      dtx_dec( st->dtxDecoderState, st->mem_syn, st->lsfState, st->pred_state,
+            st->Cb_gain_averState, newDTXState, mode, parm, synth, A_t );
+
+      /* update average lsp */
+      Lsf_lsp( st->lsfState->past_lsf_q, st->lsp_old );
+      lsp_avg( st->lsp_avg_st, st->lsfState->past_lsf_q );
+      goto theEnd;
+   }
+
+   /* SPEECH action state machine  */
+   if ( table_speech_bad[frame_type] ) {
+      bfi = 1;
+
+      if ( frame_type != RX_SPEECH_BAD ) {
+         Build_CN_param( &st->nodataSeed, mode, parm );
+      }
+   }
+   else if ( frame_type == RX_SPEECH_DEGRADED ) {
+      pdfi = 1;
+   }
+
+   if ( bfi != 0 ) {
+      st->state += 1;
+   }
+   else if ( st->state == 6 ) {
+      st->state = 5;
+   }
+   else {
+      st->state = 0;
+   }
+
+   if ( st->state > 6 ) {
+      st->state = 6;
+   }
+
+    /*
+     * If this frame is the first speech frame after CNI period,
+     * set the BFH state machine to an appropriate state depending
+     * on whether there was DTX muting before start of speech or not
+     * If there was DTX muting, the first speech frame is muted.
+     * If there was no DTX muting, the first speech frame is not
+     * muted. The BFH state machine starts from state 5, however, to
+     * keep the audible noise resulting from a SID frame which is
+     * erroneously interpreted as a good speech frame as small as
+     * possible (the decoder output in this case is quickly muted)
+     */
+   if ( st->dtxDecoderState->dtxGlobalState == DTX ) {
+      st->state = 5;
+      st->prev_bf = 0;
+   }
+   else if ( st->dtxDecoderState->dtxGlobalState == DTX_MUTE ) {
+      st->state = 5;
+      st->prev_bf = 1;
+   }
+
+   /* save old LSFs for CB gain smoothing */
+   memcpy( prev_lsf, st->lsfState->past_lsf_q, M <<2 );
+
+    /*
+     * decode LSF parameters and generate interpolated lpc coefficients
+     * for the 4 subframes
+     */
+   if ( mode != MR122 ) {
+      D_plsf_3( st->lsfState, mode, bfi, parm, lsp_new );
+
+      /* Advance synthesis parameters pointer */
+      parm += 3;
+      Int_lpc_1to3( st->lsp_old, lsp_new, A_t );
+   }
+   else {
+      D_plsf_5( st->lsfState, bfi, parm, lsp_mid, lsp_new );
+
+      /* Advance synthesis parameters pointer */
+      parm += 5;
+      Int_lpc_1and3( st->lsp_old, lsp_mid, lsp_new, A_t );
+   }
+
+   /* update the LSPs for the next frame */
+   memcpy( st->lsp_old, lsp_new, M <<2 );
+
+   /*
+    * Loop for every subframe in the analysis frame
+    *
+    * The subframe size is L_SUBFR and the loop is repeated
+    * L_FRAME/L_SUBFR times                                                                 *
+    *  - decode the pitch delay
+    *  - decode algebraic code
+    *  - decode pitch and codebook gains
+    *  - find the excitation and compute synthesis speech
+    */
+   /* pointer to interpolated LPC parameters */
+   Az = A_t;
+   evenSubfr = 0;
+   subfrNr = -1;
+
+   for ( i_subfr = 0; i_subfr < L_FRAME; i_subfr += L_SUBFR ) {
+      subfrNr += 1;
+      evenSubfr = 1 - evenSubfr;
+
+      /* flag for first and 3th subframe */
+      pit_flag = i_subfr;
+
+      if ( i_subfr == L_FRAME_BY2 ) {
+         if ( ( mode != MR475 ) & ( mode != MR515 ) ) {
+            pit_flag = 0;
+         }
+      }
+
+      /* pitch index */
+      index = *parm++;
+
+       /*
+        * decode pitch lag and find adaptive codebook vector.
+        */
+      if ( mode != MR122 ) {
+          /*
+           * flag4 indicates encoding with 4 bit resolution;
+           * this is needed for mode MR475, MR515, MR59 and MR67
+           */
+         flag4 = 0;
+
+         if ( ( mode == MR475 ) || ( mode == MR515 ) || ( mode == MR59 ) || (
+               mode == MR67 ) ) {
+            flag4 = 1;
+         }
+
+          /*
+           * get ranges for the t0_min and t0_max
+           * only needed in delta decoding
+           */
+         delta_frc_low = 5;
+         delta_frc_range = 9;
+
+         if ( mode == MR795 ) {
+            delta_frc_low = 10;
+            delta_frc_range = 19;
+         }
+         t0_min = st->old_T0 - delta_frc_low;
+
+         if ( t0_min < PIT_MIN ) {
+            t0_min = PIT_MIN;
+         }
+         t0_max = t0_min + delta_frc_range;
+
+         if ( t0_max > PIT_MAX ) {
+            t0_max = PIT_MAX;
+            t0_min = t0_max - delta_frc_range;
+         }
+         Dec_lag3( index, t0_min, t0_max, pit_flag, st->old_T0, &T0, &T0_frac,
+               flag4 );
+         st->T0_lagBuff = T0;
+
+         if ( bfi != 0 ) {
+            if ( st->old_T0 < PIT_MAX ) {
+               /* Graceful pitch degradation */
+               st->old_T0 += 1;
+            }
+            T0 = st->old_T0;
+            T0_frac = 0;
+
+            if ( ( st->inBackgroundNoise != 0 ) & ( st->voicedHangover > 4 ) & (
+                  ( mode == MR475 ) || ( mode == MR515 ) || ( mode == MR59 ) ) )
+            {
+               T0 = st->T0_lagBuff;
+            }
+         }
+         Pred_lt_3or6_40( st->exc, T0, T0_frac, 1 );
+      }
+      else {
+         Dec_lag6( index, PIT_MIN_MR122, PIT_MAX, pit_flag, &T0, &T0_frac );
+
+         if ( ( bfi != 0 ) || ( ( pit_flag != 0 ) & ( index > 60 ) ) ) {
+            st->T0_lagBuff = T0;
+            T0 = st->old_T0;
+            T0_frac = 0;
+         }
+         Pred_lt_3or6_40( st->exc, T0, T0_frac, 0 );
+      }
+
+       /*
+        * (MR122 only: Decode pitch gain.)
+        * Decode innovative codebook.
+        * set pitch sharpening factor
+        */
+      /* MR475, MR515 */
+      if ( ( mode == MR475 ) || ( mode == MR515 ) ) {
+         /* index of position */
+         index = *parm++;
+
+         /* signs */
+         i = *parm++;
+         decode_2i40_9bits( subfrNr, i, index, code );
+         pit_sharp = st->sharp << 1;
+      }
+
+      /* MR59 */
+      else if ( mode == MR59 ) {
+         /* index of position */
+         index = *parm++;
+
+         /* signs */
+         i = *parm++;
+         decode_2i40_11bits( i, index, code );
+         pit_sharp = st->sharp << 1;
+      }
+
+      /* MR67 */
+      else if ( mode == MR67 ) {
+         /* index of position */
+         index = *parm++;
+
+         /* signs */
+         i = *parm++;
+         decode_3i40_14bits( i, index, code );
+         pit_sharp = st->sharp << 1;
+      }
+
+      /* MR74, MR795 */
+      else if ( mode <= MR795 ) {
+         /* index of position */
+         index = *parm++;
+
+         /* signs */
+         i = *parm++;
+         decode_4i40_17bits( i, index, code );
+         pit_sharp = st->sharp << 1;
+      }
+
+      /* MR102 */
+      else if ( mode == MR102 ) {
+         decode_8i40_31bits( parm, code );
+         parm += 7;
+         pit_sharp = st->sharp << 1;
+      }
+
+      /* MR122 */
+      else {
+         index = *parm++;
+
+         if ( bfi != 0 ) {
+            ec_gain_pitch( st->ec_gain_p_st, st->state, &gain_pit );
+         }
+         else {
+            gain_pit = d_gain_pitch( mode, index );
+         }
+         ec_gain_pitch_update( st->ec_gain_p_st, bfi, st->prev_bf, &gain_pit );
+         decode_10i40_35bits( parm, code );
+         parm += 10;
+
+           /*
+            * pit_sharp = gain_pit;
+            * if (pit_sharp > 1.0) pit_sharp = 1.0;
+            */
+         pit_sharp = gain_pit;
+
+         if ( pit_sharp > 16383 )
+            pit_sharp = 32767;
+         else
+            pit_sharp *= 2;
+      }
+
+        /*
+         * Add the pitch contribution to code[].
+         */
+      for ( i = T0; i < L_SUBFR; i++ ) {
+         temp = ( code[i - T0] * pit_sharp ) >> 15;
+         code[i] = code[i] + temp;
+      }
+
+        /*
+         * Decode codebook gain (MR122) or both pitch
+         * gain and codebook gain (all others)
+         * Update pitch sharpening "sharp" with quantized gain_pit
+         */
+      if ( mode == MR475 ) {
+         /* read and decode pitch and code gain */
+         if ( evenSubfr != 0 ) {
+            /* index of gain(s) */
+            index_mr475 = *parm++;
+         }
+
+         if ( bfi == 0 ) {
+            Dec_gain( st->pred_state, mode, index_mr475, code, evenSubfr, &
+                  gain_pit, &gain_code );
+         }
+         else {
+            ec_gain_pitch( st->ec_gain_p_st, st->state, &gain_pit );
+            ec_gain_code( st->ec_gain_c_st, st->pred_state, st->state, &
+                  gain_code );
+         }
+         ec_gain_pitch_update( st->ec_gain_p_st, bfi, st->prev_bf, &gain_pit );
+         ec_gain_code_update( st->ec_gain_c_st, bfi, st->prev_bf, &gain_code );
+         pit_sharp = gain_pit;
+
+         if ( pit_sharp > SHARPMAX ) {
+            pit_sharp = SHARPMAX;
+         }
+      }
+      else if ( ( mode <= MR74 ) || ( mode == MR102 ) ) {
+         /* read and decode pitch and code gain */
+         /* index of gain(s) */
+         index = *parm++;
+
+         if ( bfi == 0 ) {
+            Dec_gain( st->pred_state, mode, index, code, evenSubfr, &gain_pit, &
+                  gain_code );
+         }
+         else {
+            ec_gain_pitch( st->ec_gain_p_st, st->state, &gain_pit );
+            ec_gain_code( st->ec_gain_c_st, st->pred_state, st->state, &
+                  gain_code );
+         }
+         ec_gain_pitch_update( st->ec_gain_p_st, bfi, st->prev_bf, &gain_pit );
+         ec_gain_code_update( st->ec_gain_c_st, bfi, st->prev_bf, &gain_code );
+         pit_sharp = gain_pit;
+
+         if ( pit_sharp > SHARPMAX ) {
+            pit_sharp = SHARPMAX;
+         }
+
+         if ( mode == MR102 ) {
+            if ( st->old_T0 > ( L_SUBFR + 5 ) ) {
+               pit_sharp = pit_sharp >> 2;
+            }
+         }
+      }
+      else {
+         /* read and decode pitch gain */
+         /* index of gain(s) */
+         index = *parm++;
+
+         if ( mode == MR795 ) {
+            /* decode pitch gain */
+            if ( bfi != 0 ) {
+               ec_gain_pitch( st->ec_gain_p_st, st->state, &gain_pit );
+            }
+            else {
+               gain_pit = d_gain_pitch( mode, index );
+            }
+            ec_gain_pitch_update( st->ec_gain_p_st, bfi, st->prev_bf, &gain_pit
+                  );
+
+            /* read and decode code gain */
+            index = *parm++;
+
+            if ( bfi == 0 ) {
+               d_gain_code( st->pred_state, mode, index, code, &gain_code );
+            }
+            else {
+               ec_gain_code( st->ec_gain_c_st, st->pred_state, st->state, &
+                     gain_code );
+            }
+            ec_gain_code_update( st->ec_gain_c_st, bfi, st->prev_bf, &gain_code
+                  );
+            pit_sharp = gain_pit;
+
+            if ( pit_sharp > SHARPMAX ) {
+               pit_sharp = SHARPMAX;
+            }
+         }
+         else {   /* MR122 */
+
+            if ( bfi == 0 ) {
+               d_gain_code( st->pred_state, mode, index, code, &gain_code );
+            }
+            else {
+               ec_gain_code( st->ec_gain_c_st, st->pred_state, st->state, &
+                     gain_code );
+            }
+            ec_gain_code_update( st->ec_gain_c_st, bfi, st->prev_bf, &gain_code
+                  );
+            pit_sharp = gain_pit;
+         }
+      }
+
+        /*
+         * store pitch sharpening for next subframe
+         * (for modes which use the previous pitch gain for
+         *  pitch sharpening in the search phase)
+         * do not update sharpening in even subframes for MR475
+         */
+      if ( ( mode != MR475 ) || evenSubfr == 0 ) {
+         st->sharp = gain_pit;
+
+         if ( st->sharp > SHARPMAX ) {
+            st->sharp = SHARPMAX;
+         }
+      }
+
+      if ( pit_sharp > 16383 )
+         pit_sharp = 32767;
+      else
+         pit_sharp *= 2;
+
+      if ( pit_sharp > 16384 ) {
+         for ( i = 0; i < L_SUBFR; i++ ) {
+            temp = ( st->exc[i] * pit_sharp ) >> 15;
+            temp2 = ( temp * gain_pit ) << 1;
+
+            if ( mode == MR122 ) {
+               temp2 = ( temp2 >> 1 );
+            }
+            excp[i] = ( temp2 + 0x00008000L ) >> 16;
+         }
+      }
+
+        /*
+         * Store list of LTP gains needed in the source
+         * characteristic detector (SCD)
+         */
+      if ( bfi == 0 ) {
+         for (i = 0; i < 8; i++){
+            st->ltpGainHistory[i] = st->ltpGainHistory[i+1];
+         }
+         st->ltpGainHistory[8] = gain_pit;
+      }
+
+
+        /*
+         * Limit gain_pit if in background noise and BFI
+         * for MR475, MR515, MR59
+         */
+      if ( ( st->prev_bf != 0 || bfi != 0 ) & ( st->inBackgroundNoise != 0 ) & (
+            ( mode == MR475 ) || ( mode == MR515 ) || ( mode == MR59 ) ) ) {
+         /* if (gain_pit > 0.75) in Q14*/
+         if ( gain_pit > 12288 )
+            /* gain_pit = (gain_pit-0.75)/2.0 + 0.75; */
+            gain_pit = ( ( gain_pit - 12288 ) >> 1 ) + 12288;
+
+         /* if (gain_pit > 0.90) in Q14*/
+         if ( gain_pit > 14745 ) {
+            gain_pit = 14745;
+         }
+      }
+
+        /*
+         * Calculate CB mixed gain
+         */
+      Int_lsf( prev_lsf, st->lsfState->past_lsf_q, i_subfr, lsf_i );
+      gain_code_mix = Cb_gain_average( st->Cb_gain_averState, mode, gain_code,
+            lsf_i, st->lsp_avg_st->lsp_meanSave, bfi, st->prev_bf, pdfi, st->
+            prev_pdf, st->inBackgroundNoise, st->voicedHangover );
+
+      /* make sure that MR74, MR795, MR122 have original codeGain*/
+      /* MR74, MR795, MR122 */
+      if ( ( mode > MR67 ) & ( mode != MR102 ) ) {
+         gain_code_mix = gain_code;
+      }
+
+        /*
+         * Find the total excitation.
+         * Find synthesis speech corresponding to st->exc[].
+         */
+      /* MR475, MR515, MR59, MR67, MR74, MR795, MR102*/
+      if ( mode <= MR102 ) {
+         pitch_fac = gain_pit;
+         tmp_shift = 1;
+      }
+
+      /* MR122 */
+      else {
+         pitch_fac = gain_pit >> 1;
+         tmp_shift = 2;
+      }
+
+        /*
+         * copy unscaled LTP excitation to exc_enhanced (used in phase
+         * dispersion below) and compute total excitation for LTP feedback
+         */
+      memcpy( exc_enhanced, st->exc, L_SUBFR <<2 );
+
+      for ( i = 0; i < L_SUBFR; i++ ) {
+         /* st->exc[i] = gain_pit*st->exc[i] + gain_code*code[i]; */
+         temp = ( st->exc[i] * pitch_fac ) + ( code[i] * gain_code );
+         temp2 = ( temp << tmp_shift );
+         if (((temp2 >> 1) ^ temp2) & 0x40000000) {
+            if ((temp ^ temp2) & 0x80000000) {
+               temp2 = (temp & 0x80000000) ? (-1073741824L) : 1073725439;
+            }
+            else {
+               temp2 = (temp2 & 0x80000000) ? (-1073741824L) : 1073725439;
+            }
+         }
+         st->exc[i] = ( temp2 + 0x00004000L ) >> 15;
+      }
+      /*
+       * Adaptive phase dispersion
+       */
+
+      /* free phase dispersion adaption */
+      st->ph_disp_st->lockFull = 0;
+
+      if ( ( ( mode == MR475 ) || ( mode == MR515 ) || ( mode == MR59 ) ) & ( st
+            ->voicedHangover > 3 ) & ( st->inBackgroundNoise != 0 ) & ( bfi != 0
+            ) ) {
+           /*
+            * Always Use full Phase Disp.
+            * if error in bg noise
+            */
+         st->ph_disp_st->lockFull = 1;
+      }
+
+        /*
+         * apply phase dispersion to innovation (if enabled) and
+         * compute total excitation for synthesis part
+         */
+      ph_disp( st->ph_disp_st, mode, exc_enhanced, gain_code_mix, gain_pit, code
+            , pitch_fac, tmp_shift );
+
+        /*
+         * The Excitation control module are active during BFI.
+         * Conceal drops in signal energy if in bg noise.
+         */
+      temp2 = 0;
+
+      for ( i = 0; i < L_SUBFR; i++ ) {
+         temp2 += ( exc_enhanced[i] * exc_enhanced[i] );
+      }
+
+      if ( temp2 > 0x3FFFFFFF ) {
+         excEnergy = 11584;
+      }
+      else {
+         temp2 = sqrt_l_exp( temp2, &temp );
+         temp2 = ( temp2 >> ( ( temp >> 1 ) + 15 ) );
+         excEnergy = temp2 >> 2;
+      }
+
+      if ( ( ( mode == MR475 ) || ( mode == MR515 ) || ( mode == MR59 ) ) & ( st
+            ->voicedHangover > 5 ) & ( st->inBackgroundNoise != 0 ) & ( st->
+            state < 4 ) & ( ( ( pdfi != 0 ) & ( st->prev_pdf != 0 ) ) || bfi !=
+            0 || st->prev_bf != 0 ) ) {
+         carefulFlag = 0;
+
+         if ( ( pdfi != 0 ) & ( bfi == 0 ) ) {
+            carefulFlag = 1;
+         }
+         Ex_ctrl( exc_enhanced, excEnergy, st->excEnergyHist, st->voicedHangover
+               , st->prev_bf, carefulFlag );
+      }
+
+      if ( ( st->inBackgroundNoise != 0 ) & ( bfi != 0 || st->prev_bf != 0 ) & (
+            st->state < 4 ) ) {;   /* do nothing! */
+      }
+      else {
+         /* Update energy history for all modes */
+         for (i = 0; i < 8; i++){
+            st->excEnergyHist[i] = st->excEnergyHist[i+1];
+         }
+         st->excEnergyHist[8] = excEnergy;
+      }
+
+        /*
+         * Excitation control module end.
+         */
+      if ( pit_sharp > 16384 ) {
+         for ( i = 0; i < L_SUBFR; i++ ) {
+            excp[i] = excp[i] + exc_enhanced[i];
+            if (labs(excp[i]) > 32767)
+               excp[i] = (excp[i] & 0x80000000) ? -32768 : 32767;
+         }
+         agc2( exc_enhanced, excp );
+         overflow = Syn_filt( Az, excp, &synth[i_subfr], L_SUBFR, st->mem_syn, 0
+            );
+      }
+      else {
+         overflow = Syn_filt( Az, exc_enhanced, &synth[i_subfr], L_SUBFR, st->
+            mem_syn, 0 );
+      }
+
+      if ( overflow ) {
+         for ( i = 0; i < PIT_MAX + L_INTERPOL + L_SUBFR; i++ ) {
+            st->old_exc[i] = st->old_exc[i] >> 2;
+         }
+
+         for ( i = 0; i < L_SUBFR; i++ ) {
+            exc_enhanced[i] = exc_enhanced[i] >> 2;
+         }
+         Syn_filt_overflow( Az, exc_enhanced, &synth[i_subfr], L_SUBFR, st->mem_syn, 1 );
+      }
+      else {
+         memcpy( st->mem_syn, &synth[i_subfr + 30], 40 );
+      }
+
+        /*
+         * Update signal for next frame.
+         * -> shift to the left by L_SUBFR  st->exc[]
+         */
+      memcpy( &st->old_exc[0], &st->old_exc[L_SUBFR], ( PIT_MAX + L_INTERPOL )<<
+            2 );
+
+      /* interpolated LPC parameters for next subframe */
+      Az += MP1;
+
+      /* store T0 for next subframe */
+      st->old_T0 = T0;
+   }
+
+    /*
+     * Call the Source Characteristic Detector which updates
+     * st->inBackgroundNoise and st->voicedHangover.
+     */
+   st->inBackgroundNoise = Bgn_scd( st->background_state, &( st->ltpGainHistory[
+         0] ), &( synth[0] ), &( st->voicedHangover ) );
+   dtx_dec_activity_update( st->dtxDecoderState, st->lsfState->past_lsf_q, synth
+         );
+
+   /* store bfi for next subframe */
+   st->prev_bf = bfi;
+   st->prev_pdf = pdfi;
+
+    /*
+     * Calculate the LSF averages on the eight
+     * previous frames
+     */
+   lsp_avg( st->lsp_avg_st, st->lsfState->past_lsf_q );
+theEnd:
+   st->dtxDecoderState->dtxGlobalState = newDTXState;
+   return;
+}
+
+
+/*
+ * Residu40
+ *
+ *
+ * Parameters:
+ *    a                 I: prediction coefficients
+ *    x                 I: speech signal
+ *    y                 O: residual signal
+ *
+ * Function:
+ *    The LP residual is computed by filtering the input
+ *    speech through the LP inverse filter a(z)
+ *
+ * Returns:
+ *    void
+ */
+static void Residu40( Word32 a[], Word32 x[], Word32 y[] )
+{
+   Word32 s, i, j;
+
+
+   for ( i = 0; i < 40; i++ ) {
+      s = a[0] * x[i] + a[1] * x[i - 1] + a[2] * x[i - 2] + a[3] * x[i - 3];
+      s += a[4] * x[i - 4] + a[5] * x[i - 5] + a[6] * x[i - 6] + a[7] * x[i - 7]
+         ;
+      s += a[8] * x[i - 8] + a[9] * x[i - 9] + a[10] * x[i - 10];
+      y[i] = ( s + 0x800 ) >> 12;
+      if (abs(y[i]) > 32767){
+         /* go to safe mode */
+         for (i = 0; i < 40; i++) {
+            s = a[0] * x[i];
+            for (j = 1; j <= 10; j++) {
+               s += a[j] * x[i - j];
+               if (s > 1073741823){
+                  s = 1073741823;
+               }
+               else if ( s < -1073741824) {
+                  s = -1073741824;
+               }
+            }
+            y[i] = ( s + 0x800 ) >> 12;
+            if (abs(y[i]) > 32767)
+               y[i] = (y[i] & 0x80000000) ? -32768 : 32767;
+         }
+         return;
+      }
+
+   }
+   return;
+}
+
+
+/*
+ * agc
+ *
+ *
+ * Parameters:
+ *    st->past_gain     B: gain memory
+ *    sig_in            I: Post_Filter input signal
+ *    sig_out           B: Post_Filter output signal
+ *    agc_fac           I: AGC factor
+ *
+ * Function:
+ *    Scales the Post_Filter output on a subframe basis
+ *
+ * Returns:
+ *    void
+ */
+static void agc( agcState *st, Word32 *sig_in, Word32 *sig_out, Word16 agc_fac )
+{
+   Word32 s, gain_in, gain_out, g0, gain;
+   int exp, i;
+
+
+   /* calculate gain_out with exponent */
+   s = energy_new( sig_out );
+
+   if ( s == 0 ) {
+      st->past_gain = 0;
+      return;
+   }
+   exp=0;
+   i = s;
+   while (!(i & 0x40000000))
+   {
+      exp++;
+      i = i << 1;
+   }
+   exp -=1;
+   if (exp & 0x80000000) {
+      s >>= 1;
+   }
+   else {
+      s <<= exp;
+   }
+   gain_out = ( s + 0x00008000L ) >> 16;
+
+   /* calculate gain_in with exponent */
+   s = energy_new( sig_in );
+
+   if ( s == 0 ) {
+      g0 = 0;
+   }
+   else {
+      i=0;
+   while (!(s & 0x40000000))
+   {
+      i++;
+      s = s << 1;
+   }
+      s = s + 0x00008000L;
+
+      if ( s >= 0 )
+         gain_in = s >> 16;
+      else
+         gain_in = 32767;
+      exp = ( exp - i );
+
+      /*
+       * g0 = (1-agc_fac) * sqrt(gain_in/gain_out);
+       */
+      /* s = gain_out / gain_in */
+      s = ( gain_out << 15 ) / gain_in;
+      exp = 7 - exp;
+
+      if ( exp > 0 ){
+         if (exp > 31)
+         {
+            if(s){
+               s = 2147483647;
+            }
+         }
+         else {
+            s = s << exp ;
+         }
+      }
+      else
+         s = ( s >> ( -exp ) );
+      if (s < 0)
+         s = 2147483647;
+      s = Inv_sqrt( s );
+      i = ( ( s << 9 ) + 0x00008000L ) >> 16;
+      if (i & 0xFFFF8000)
+         i = 32767;
+
+      /* g0 = i * (1-agc_fac) */
+      g0 = ( i * ( 32767 - agc_fac ) ) >> 15;
+   }
+
+   /*
+    * compute gain[n] = agc_fac * gain[n-1] + (1-agc_fac) * sqrt(gain_in/gain_out)
+    * sig_out[n] = gain[n] * sig_out[n]
+    */
+   gain = st->past_gain;
+
+   for ( i = 0; i < L_SUBFR; i++ ) {
+      gain = ( gain * agc_fac ) >> 15;
+      gain = gain + g0;
+      sig_out[i] = ( sig_out[i] * gain ) >> 12;
+      if (labs(sig_out[i]) > 32767)
+         sig_out[i] = (sig_out[i] & 0x8000000) ? -32768 : 32767;
+   }
+   st->past_gain = gain;
+   return;
+}
+
+
+/*
+ * Post_Filter
+ *
+ *
+ * Parameters:
+ *    st                B: post filter states
+ *    mode              I: AMR mode
+ *    syn               B: synthesis speech
+ *    Az_4              I: interpolated LPC parameters in all subfr.
+ *
+ * Function:
+ *    Post_Filtering of synthesis speech.
+ *
+ *    inverse filtering of syn[] through A(z/0.7) to get res2[]
+ *    tilt compensation filtering; 1 - MU*k*z^-1
+ *    synthesis filtering through 1/A(z/0.75)
+ *    adaptive gain control
+ *
+ * Returns:
+ *    void
+ */
+static void Post_Filter( Post_FilterState *st, enum Mode mode, Word32 *syn,
+      Word32 *Az_4 )
+{
+   Word32 h[22], Ap3[MP1], Ap4[MP1];   /* bandwidth expanded LP parameters */
+   Word32 tmp, i_subfr, i, temp1, temp2, overflow = 0;
+   Word32 *Az, *p1, *p2, *syn_work = &st->synth_buf[M];
+   const Word32 *pgamma3 = &gamma3[0];
+   const Word32 *pgamma4 = &gamma4_gamma3_MR122[0];
+
+
+   /*
+    * Post filtering
+    */
+   memcpy( syn_work, syn, L_FRAME <<2 );
+   Az = Az_4;
+
+   if ( ( mode == MR122 ) || ( mode == MR102 ) ) {
+      pgamma3 = &gamma4_gamma3_MR122[0];
+      pgamma4 = &gamma4_MR122[0];
+   }
+
+   for ( i_subfr = 0; i_subfr < L_FRAME; i_subfr += L_SUBFR ) {
+      /* Find weighted filter coefficients Ap3[] and Ap[4] */
+      Ap3[0] = Az[0];
+      Ap4[0] = Az[0];
+
+      for ( i = 1; i <= 10; i++ ) {
+         Ap3[i] = ( Az[i] * pgamma3[i - 1] +0x4000 ) >> 15;
+         Ap4[i] = ( Az[i] * pgamma4[i - 1] +0x4000 ) >> 15;
+      }
+
+      /* filtering of synthesis speech by A(z/0.7) to find res2[] */
+      Residu40( Ap3, &syn_work[i_subfr], st->res2 );
+
+      /* tilt compensation filter */
+      /* impulse response of A(z/0.7)/A(z/0.75) */
+      memcpy( h, Ap3, MP1 <<2 );
+      memset( &h[M +1], 0, ( 22 - M - 1 )<<2 );
+      Syn_filt( Ap4, h, h, 22, &h[M +1], 0 );
+
+      /* 1st correlation of h[] */
+      tmp = 16777216 + h[1] * h[1];
+
+      for ( i = 2; i < 22; i++ ) {
+         tmp += h[i] * h[i];
+         if (tmp > 0x3FFF8000)
+            break;
+      }
+      temp1 = tmp >> 15;
+      if (temp1 & 0xFFFF8000)
+         temp1 = 32767;
+
+      tmp = h[0] * h[1];
+
+      for ( i = 1; i < 21; i++ ) {
+         tmp += h[i] * h[i + 1];
+         if (abs(tmp) > 1073741823)
+            tmp = 1073741823;
+      }
+      temp2 = tmp >> 15;
+
+      if ( temp2 <= 0 ) {
+         temp2 = 0;
+      }
+      else {
+         tmp = temp2 * 26214;
+         temp2 = ( tmp & 0xffff8000 ) / temp1;
+      }
+
+      /* preemphasis */
+      p1 = st->res2 + 39;
+      p2 = p1 - 1;
+      tmp = *p1;
+
+      do {
+         *p1 = *p1 - ( ( temp2 * *p2-- ) >> 15 );
+         if (abs(*p1) > 32767) {
+            *p1 = (*p1 & 0x80000000) ? -32768 : 32767;
+         }
+         p1--;
+         *p1 = *p1 - ( ( temp2 * *p2-- ) >> 15 );
+         if (abs(*p1) > 32767) {
+            *p1 = (*p1 & 0x80000000) ? -32768 : 32767;
+         }
+         p1--;
+         *p1 = *p1 - ( ( temp2 * *p2-- ) >> 15 );
+         if (abs(*p1) > 32767) {
+            *p1 = (*p1 & 0x80000000) ? -32768 : 32767;
+         }
+         p1--;
+      } while( p1 > st->res2 );
+      *p1 = *p1 - ( ( temp2 * st->preemph_state_mem_pre ) >> 15 );
+      if (abs(*p1) > 32767) {
+         *p1 = (*p1 & 0x80000000) ? -32768 : 32767;
+      }
+      st->preemph_state_mem_pre = tmp;
+
+      /* filtering through  1/A(z/0.75) */
+      overflow = Syn_filt( Ap4, st->res2, &syn[i_subfr], L_SUBFR, st->mem_syn_pst, 0 );
+      if (overflow){
+         Syn_filt_overflow( Ap4, st->res2, &syn[i_subfr], L_SUBFR, st->mem_syn_pst, 1 );
+         overflow = 0;
+      }
+      else {
+         memcpy(st->mem_syn_pst, &syn[i_subfr + 30], 40);
+      }
+
+      /* scale output to input */
+      agc( st->agc_state, &syn_work[i_subfr], &syn[i_subfr], AGC_FAC );
+      Az += MP1;
+   }
+
+   /* update syn_work[] buffer */
+   memcpy( &syn_work[- M], &syn_work[L_FRAME - M], M <<2 );
+   return;
+}
+
+
+/*
+ * Post_Process
+ *
+ *
+ * Parameters:
+ *    st                B: post filter states
+ *    signal            B: signal
+ *
+ * Function:
+ *    Postprocessing of input speech.
+ *
+ *    2nd order high pass filtering with cut off frequency at 60 Hz.
+ *    Multiplication of output by two.
+ *
+ *
+ * Returns:
+ *    void
+ */
+ static void Post_Process( Post_ProcessState *st, Word32 signal[] )
+ {
+    Word32 x2, tmp, i = 0;
+    Word32 mask = 0x40000000;
+
+    do {
+       x2 = st->x1;
+       st->x1 = st->x0;
+       st->x0 = signal[i];
+
+       /*
+       * y[i] = b[0]*x[i]*2 + b[1]*x[i-1]*2 + b140[2]*x[i-2]/2
+       *                    + a[1]*y[i-1] + a[2] * y[i-2];
+       */
+       tmp = ( st->y1_hi * 15836) + ( ( ( st->y1_lo * 15836 ) & ( Word32 )0xffff8000 ) >> 15);
+       tmp += (st->y2_hi * -7667) + ( ( ( st->y2_lo * ( -7667 ) ) & ( Word32 )0xffff8000 ) >> 15);
+       tmp += st->x0 * 7699;
+       tmp += st->x1 * -15398;
+       if ( ( (tmp >> 1) ^ tmp ) & mask)
+          tmp = (tmp & 0x80000000) ? -1073741824 : 1073741823;
+
+       tmp += x2 * 7699;
+       if ( ( (tmp >> 1) ^ tmp ) & mask)
+          tmp = (tmp & 0x80000000) ? -1073741824 : 1073741823;
+
+       tmp = tmp << 1;
+       if ( ( (tmp >> 1) ^ tmp ) & mask)
+          tmp = (tmp & 0x80000000) ? -1073741824 : 1073741823;
+
+       tmp = tmp << 1;
+       if ( ( (tmp >> 1) ^ tmp ) & mask)
+          tmp = (tmp & 0x80000000) ? -1073741824 : 1073741823;
+
+       if ( labs( tmp ) < 536862720 ) {
+          signal[i++] = ( tmp + 0x00002000L ) >> 14;
+       }
+       else if ( tmp > 0 ) {
+          signal[i++] = 32767;
+       }
+       else {
+          signal[i++] = -32768;
+       }
+       st->y2_hi = st->y1_hi;
+       st->y2_lo = st->y1_lo;
+       st->y1_hi = tmp >> 15;
+       st->y1_lo = ( ( tmp << 1 ) - ( st->y1_hi << 16 ) ) >> 1;
+    } while( i < 160 );
+    return;
+}
+
+
+/*
+ * Speech_Decode_Frame
+ *
+ *
+ * Parameters:
+ *    st                B: decoder memory
+ *    mode              I: AMR mode
+ *    parm              I: speech parameters
+ *    frame_type        I: Frame type
+ *    synth             O: synthesis speech
+
+ * Function:
+ *    Decode one frame
+ *
+ * Returns:
+ *    void
+ */
+void Speech_Decode_Frame( void *st, enum Mode mode, Word16 *parm, enum
+      RXFrameType frame_type, Word16 *synth )
+{
+   Word32 Az_dec[AZ_SIZE];   /* Decoded Az for post-filter in 4 subframes*/
+   Word32 synth_speech[L_FRAME];
+   Word32 i;
+
+   /* Synthesis */
+   Decoder_amr( ( ( Speech_Decode_FrameState * ) st )->decoder_amrState, mode,
+         parm, frame_type, synth_speech, Az_dec );
+   Post_Filter( ( ( Speech_Decode_FrameState * ) st )->post_state, mode,
+         synth_speech, Az_dec );
+
+   /* post HP filter, and 15->16 bits */
+   Post_Process( ( ( Speech_Decode_FrameState * ) st )->postHP_state,
+         synth_speech );
+
+for ( i = 0; i < L_FRAME; i++ ) {
+#ifndef NO13BIT
+      /* Truncate to 13 bits */
+      synth[i] = ( Word16 )( synth_speech[i] & 0xfff8 );
+#else
+      synth[i] = ( Word16 )( synth_speech[i]);
+#endif
+   }
+
+
+   return;
+}
+
+
+/*
+ * Decoder_amr_exit
+ *
+ *
+ * Parameters:
+ *    state                I: state structure
+ *
+ * Function:
+ *    The memory used for state memory is freed
+ *
+ * Returns:
+ *    Void
+ */
+static void Decoder_amr_exit( Decoder_amrState **state )
+{
+   if ( state == NULL || *state == NULL )
+      return;
+   free( ( *state )->lsfState );
+   free( ( *state )->ec_gain_p_st );
+   free( ( *state )->ec_gain_c_st );
+   free( ( *state )->pred_state );
+   free( ( *state )->background_state );
+   free( ( *state )->ph_disp_st );
+   free( ( *state )->Cb_gain_averState );
+   free( ( *state )->lsp_avg_st );
+   free( ( *state )->dtxDecoderState );
+
+   /* deallocate memory */
+   free( *state );
+   *state = NULL;
+   return;
+}
+
+
+/*
+ * Post_Filter_exit
+ *
+ *
+ * Parameters:
+ *    state                I: state structure
+ *
+ * Function:
+ *    The memory used for state memory is freed
+ *
+ * Returns:
+ *    Void
+ */
+static void Post_Filter_exit( Post_FilterState **state )
+{
+   if ( state == NULL || *state == NULL )
+      return;
+   free( ( *state )->agc_state );
+
+   /* deallocate memory */
+   free( *state );
+   *state = NULL;
+   return;
+}
+
+
+/*
+ * Post_Process_reset
+ *
+ *
+ * Parameters:
+ *    state             B: state structure
+ *
+ * Function:
+ *    Resets state memory
+ *
+ * Returns:
+ *    -1 failure
+ */
+static int Post_Process_reset( Post_ProcessState *state )
+{
+   if ( ( Post_ProcessState * )state == NULL ) {
+      fprintf( stderr, "Post_Process_reset: invalid parameter\n" );
+      return-1;
+   }
+   state->y2_hi = 0;
+   state->y2_lo = 0;
+   state->y1_hi = 0;
+   state->y1_lo = 0;
+   state->x0 = 0;
+   state->x1 = 0;
+   return 0;
+}
+
+
+/*
+ * Post_Process_exit
+ *
+ *
+ * Parameters:
+ *    state                I: state structure
+ *
+ * Function:
+ *    The memory used for state memory is freed
+ *
+ * Returns:
+ *    Void
+ */
+static void Post_Process_exit( Post_ProcessState **state )
+{
+   if ( state == NULL || *state == NULL )
+      return;
+
+   /* deallocate memory */
+   free( *state );
+   *state = NULL;
+   return;
+}
+
+
+/*
+ * Decoder_amr_init
+ *
+ *
+ * Parameters:
+ *    state             O: state structure
+ *
+ * Function:
+ *    Allocates state memory and initializes state memory
+ *
+ * Returns:
+ *    success = 0
+ */
+static int Decoder_amr_init( Decoder_amrState **state )
+{
+   Decoder_amrState * s;
+
+   if ( ( Decoder_amrState * )state == NULL ) {
+      fprintf( stderr, "Decoder_amr_init: invalid parameter\n" );
+      return-1;
+   }
+   *state = NULL;
+
+   /* allocate memory */
+   if ( ( s = ( Decoder_amrState * ) malloc( sizeof( Decoder_amrState ) ) ) ==
+         NULL ) {
+      fprintf( stderr, "Decoder_amr_init: can not malloc state structure\n" );
+      return-1;
+   }
+
+   /* DPlsf_init */
+   /* allocate memory */
+   if ( ( s->lsfState = ( D_plsfState * ) malloc( sizeof( D_plsfState ) ) ) ==
+         NULL ) {
+      fprintf( stderr, "DPlsf_init: can not malloc state structure\n" );
+      return-1;
+   }
+
+   /* ecGainPitchInit */
+   /* allocate memory */
+   if ( ( s->ec_gain_p_st = ( ec_gain_pitchState * ) malloc( sizeof(
+         ec_gain_pitchState ) ) ) == NULL ) {
+      fprintf( stderr, "ecGainPitchInit: can not malloc state structure\n" );
+      return-1;
+   }
+
+   /* ecGainCodeInit */
+   /* allocate memory */
+   if ( ( s->ec_gain_c_st = ( ec_gain_codeState * ) malloc( sizeof(
+         ec_gain_codeState ) ) ) == NULL ) {
+      fprintf( stderr, "ecGainCodeInit: can not malloc state structure\n" );
+      return-1;
+   }
+
+   /* gcPredInit */
+   /* allocate memory */
+   if ( ( s->pred_state = ( gc_predState * ) malloc( sizeof( gc_predState ) ) )
+         == NULL ) {
+      fprintf( stderr, "gcPredInit: can not malloc state structure\n" );
+      return-1;
+   }
+
+   /* Cb_gain_averageInit */
+   /* allocate memory */
+   if ( ( s->Cb_gain_averState = ( Cb_gain_averageState * ) malloc( sizeof(
+         Cb_gain_averageState ) ) ) == NULL ) {
+      fprintf( stderr, "Cb_gain_averageInit: can not malloc state structure\n" )
+      ;
+      return-1;
+   }
+   memset( s->Cb_gain_averState->cbGainHistory, 0, L_CBGAINHIST <<2 );
+
+   /* Initialize hangover handling */
+   s->Cb_gain_averState->hangVar = 0;
+   s->Cb_gain_averState->hangCount = 0;
+
+   /* lsp_avgInit */
+   /* allocate memory */
+   if ( ( s->lsp_avg_st = ( lsp_avgState * ) malloc( sizeof( lsp_avgState ) ) )
+         == NULL ) {
+      fprintf( stderr, "lsp_avgInit: can not malloc state structure\n" );
+      return-1;
+   }
+
+   /* Bgn_scdInit */
+   /* allocate memory */
+   if ( ( s->background_state = ( Bgn_scdState * ) malloc( sizeof( Bgn_scdState
+         ) ) ) == NULL ) {
+      fprintf( stderr, "Bgn_scdInit: can not malloc state structure\n" );
+      return-1;
+   }
+
+   /* phDispInit */
+   /* allocate memory */
+   if ( ( s->ph_disp_st = ( ph_dispState * ) malloc( sizeof( ph_dispState ) ) )
+         == NULL ) {
+      fprintf( stderr, "phDispInit: can not malloc state structure\n" );
+      return-1;
+   }
+
+   /* dtxDecInit */
+   /* allocate memory */
+   if ( ( s->dtxDecoderState = ( dtx_decState * ) malloc( sizeof( dtx_decState )
+         ) ) == NULL ) {
+      fprintf( stderr, "dtxDecInit: can not malloc state structure\n" );
+      return-1;
+   }
+   Decoder_amr_reset( s, 0 );
+   *state = s;
+   return 0;
+}
+
+
+/*
+ * Post_Filter_reset
+ *
+ *
+ * Parameters:
+ *    state             B: state structure
+ *
+ * Function:
+ *    Resets state memory
+ *
+ * Returns:
+ *    -1 failure
+ */
+static int Post_Filter_reset( Post_FilterState *state )
+{
+   if ( ( Post_FilterState * )state == NULL ) {
+      fprintf( stderr, "Post_Filter_reset: invalid parameter\n" );
+      return-1;
+   }
+   state->preemph_state_mem_pre = 0;
+   state->agc_state->past_gain = 4096;
+   memset( state->mem_syn_pst, 0, M <<2 );
+   memset( state->res2, 0, L_SUBFR <<2 );
+   memset( state->synth_buf, 0, ( L_FRAME + M )<<2 );
+   return 0;
+}
+
+
+/*
+ * Post_Filter_init
+ *
+ *
+ * Parameters:
+ *    state             O: state structure
+ *
+ * Function:
+ *    Allocates state memory and initializes state memory
+ *
+ * Returns:
+ *    success = 0
+ */
+static int Post_Filter_init( Post_FilterState **state )
+{
+   Post_FilterState * s;
+
+   if ( ( Post_FilterState * )state == NULL ) {
+      fprintf( stderr, "F057:invalid parameter\n" );
+      return-1;
+   }
+   *state = NULL;
+
+   /* allocate memory */
+   if ( ( s = ( Post_FilterState * ) malloc( sizeof( Post_FilterState ) ) ) ==
+         NULL ) {
+      fprintf( stderr, "F057:can not malloc filter structure\n" );
+      return-1;
+   }
+   s->agc_state = NULL;
+
+   /* allocate memory */
+   if ( ( s->agc_state = ( agcState * ) malloc( sizeof( agcState ) ) ) == NULL )
+   {
+      fprintf( stderr, "agcInit: can not malloc state structure\n" );
+      return-1;
+   }
+   Post_Filter_reset( s );
+   *state = s;
+   return 0;
+}
+
+
+/*
+ * Post_Process_init
+ *
+ *
+ * Parameters:
+ *    state             O: state structure
+ *
+ * Function:
+ *    Allocates state memory and initializes state memory
+ *
+ * Returns:
+ *    success = 0
+ */
+static int Post_Process_init( Post_ProcessState **state )
+{
+   Post_ProcessState * s;
+
+   if ( ( Post_ProcessState * )state == NULL ) {
+      fprintf( stderr, "Post_Process_init: invalid parameter\n" );
+      return-1;
+   }
+   *state = NULL;
+
+   /* allocate memory */
+   if ( ( s = ( Post_ProcessState * ) malloc( sizeof( Post_ProcessState ) ) ) ==
+         NULL ) {
+      fprintf( stderr, "Post_Process_init: can not malloc state structure\n" );
+      return-1;
+   }
+   Post_Process_reset( s );
+   *state = s;
+   return 0;
+}
+
+
+/*
+ * Speech_Decode_Frame_exit
+ *
+ *
+ * Parameters:
+ *    state                I: state structure
+ *
+ * Function:
+ *    The memory used for state memory is freed
+ *
+ * Returns:
+ *    Void
+ */
+void Speech_Decode_Frame_exit( void **st )
+{
+   if ( (( Speech_Decode_FrameState * )( st )) == NULL )
+      return;
+   Decoder_amr_exit( &( ( ( Speech_Decode_FrameState * ) st )->decoder_amrState
+         ) );
+   Post_Filter_exit( &( ( ( Speech_Decode_FrameState * ) st )->post_state ) );
+   Post_Process_exit( &( ( ( Speech_Decode_FrameState * ) st )->postHP_state ) )
+   ;
+
+   /* deallocate memory */
+   free( (( Speech_Decode_FrameState * )st) );
+   return;
+}
+
+
+/*
+ * Speech_Decode_Frame_reset
+ *
+ *
+ * Parameters:
+ *    state             B: state structure
+ *
+ * Function:
+ *    Resets state memory
+ *
+ * Returns:
+ *    -1 = failure
+ */
+int Speech_Decode_Frame_reset( void **st )
+{
+   Speech_Decode_FrameState * state;
+
+   if ( st == NULL || *st == NULL )
+      return (-1);
+   state = ( Speech_Decode_FrameState * )st;
+   Decoder_amr_reset( state->decoder_amrState, ( enum Mode ) 0 );
+   Post_Filter_reset( state->post_state );
+   Post_Process_reset( state->postHP_state );
+   return 0;
+}
+
+
+/*
+ * Speech_Decode_Frame_init
+ *
+ *
+ * Parameters:
+ *    state             O: state structure
+ *
+ * Function:
+ *    Allocates state memory and initializes state memory
+ *
+ * Returns:
+ *    success = 0
+ */
+void * Speech_Decode_Frame_init( )
+{
+   Speech_Decode_FrameState * s;
+
+   /* allocate memory */
+   if ( ( s = ( Speech_Decode_FrameState * ) malloc( sizeof(
+         Speech_Decode_FrameState ) ) ) == NULL ) {
+      fprintf( stderr, "Speech_Decode_Frame_init: can not malloc state "
+            "structure\n" );
+      return NULL;
+   }
+   s->decoder_amrState = NULL;
+   s->post_state = NULL;
+   s->postHP_state = NULL;
+
+   if ( Decoder_amr_init( &s->decoder_amrState ) || Post_Filter_init( &s->
+         post_state ) || Post_Process_init( &s->postHP_state ) ) {
+      Speech_Decode_Frame_exit( ( void ** )( &s ) );
+      return NULL;
+   }
+   return s;
+}
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/amr/sp_dec.h asterisk-1.8.3.2_com_amr/codecs/amr/sp_dec.h
--- asterisk-1.8.3.2_com_rtsp/codecs/amr/sp_dec.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/amr/sp_dec.h	2012-03-26 16:29:06.000000000 +0100
@@ -0,0 +1,81 @@
+/*
+ * ===================================================================
+ *  TS 26.104
+ *  REL-5 V5.4.0 2004-03
+ *  REL-6 V6.1.0 2004-03
+ *  3GPP AMR Floating-point Speech Codec
+ * ===================================================================
+ *
+ */
+
+/*
+ * sp_enc.h
+ *
+ *
+ * Project:
+ *    AMR Floating-Point Codec
+ *
+ * Contains:
+ *    Defines interface to AMR encoder
+ *
+ */
+#ifndef _SP_DEC_H_
+#define _SP_DEC_H_
+/*
+ * definition of enumerated types
+ */
+
+/*
+ * definition of modes for decoder
+ */
+enum Mode { MR475 = 0,
+            MR515,
+            MR59,
+            MR67,
+            MR74,
+            MR795,
+            MR102,
+            MR122,
+            MRDTX,
+            N_MODES     /* number of (SPC) modes */
+};
+
+/* Declaration recieved frame types */
+enum RXFrameType { RX_SPEECH_GOOD = 0,
+                   RX_SPEECH_DEGRADED,
+                   RX_ONSET,
+                   RX_SPEECH_BAD,
+                   RX_SID_FIRST,
+                   RX_SID_UPDATE,
+                   RX_SID_BAD,
+                   RX_NO_DATA,
+                   RX_N_FRAMETYPES     /* number of frame types */
+};
+
+/*
+ * Function prototypes
+ */
+
+/*
+ * initialize one instance of the speech decoder
+ */
+void* Speech_Decode_Frame_init ();
+
+/*
+ * free status struct
+ */
+void Speech_Decode_Frame_exit (void **st);
+
+/*
+ * Decodes one frame from encoded parameters
+ */
+void Speech_Decode_Frame (void *st, enum Mode mode, short *serial,
+                   enum RXFrameType frame_type, short *synth);
+
+/*
+ * reset speech decoder
+ */
+int Speech_Decode_Frame_reset (void **st);
+
+#endif
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/amr/.sp_dec.o.d asterisk-1.8.3.2_com_amr/codecs/amr/.sp_dec.o.d
--- asterisk-1.8.3.2_com_rtsp/codecs/amr/.sp_dec.o.d	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/amr/.sp_dec.o.d	2012-03-28 11:20:25.000000000 +0100
@@ -0,0 +1,106 @@
+sp_dec.o sp_dec.o: sp_dec.c /usr/include/stdio.h /usr/include/features.h \
+  /usr/include/sys/cdefs.h /usr/include/bits/wordsize.h \
+  /usr/include/gnu/stubs.h /usr/include/gnu/stubs-32.h \
+  /usr/lib/gcc/i386-redhat-linux/4.1.2/include/stddef.h \
+  /usr/include/bits/types.h /usr/include/bits/typesizes.h \
+  /usr/include/libio.h /usr/include/_G_config.h /usr/include/wchar.h \
+  /usr/include/bits/wchar.h /usr/include/gconv.h \
+  /usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h \
+  /usr/include/bits/stdio_lim.h /usr/include/bits/sys_errlist.h \
+  /usr/include/bits/stdio.h /usr/include/stdlib.h \
+  /usr/include/sys/types.h /usr/include/time.h /usr/include/endian.h \
+  /usr/include/bits/endian.h /usr/include/sys/select.h \
+  /usr/include/bits/select.h /usr/include/bits/sigset.h \
+  /usr/include/bits/time.h /usr/include/sys/sysmacros.h \
+  /usr/include/bits/pthreadtypes.h /usr/include/alloca.h \
+  /usr/include/memory.h /usr/include/string.h /usr/include/bits/string.h \
+  /usr/include/bits/string2.h /usr/include/math.h \
+  /usr/include/bits/huge_val.h /usr/include/bits/mathdef.h \
+  /usr/include/bits/mathcalls.h /usr/include/bits/mathinline.h sp_dec.h \
+  rom_dec.h typedef.h interf_rom.h
+
+/usr/include/stdio.h:
+
+/usr/include/features.h:
+
+/usr/include/sys/cdefs.h:
+
+/usr/include/bits/wordsize.h:
+
+/usr/include/gnu/stubs.h:
+
+/usr/include/gnu/stubs-32.h:
+
+/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stddef.h:
+
+/usr/include/bits/types.h:
+
+/usr/include/bits/typesizes.h:
+
+/usr/include/libio.h:
+
+/usr/include/_G_config.h:
+
+/usr/include/wchar.h:
+
+/usr/include/bits/wchar.h:
+
+/usr/include/gconv.h:
+
+/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h:
+
+/usr/include/bits/stdio_lim.h:
+
+/usr/include/bits/sys_errlist.h:
+
+/usr/include/bits/stdio.h:
+
+/usr/include/stdlib.h:
+
+/usr/include/sys/types.h:
+
+/usr/include/time.h:
+
+/usr/include/endian.h:
+
+/usr/include/bits/endian.h:
+
+/usr/include/sys/select.h:
+
+/usr/include/bits/select.h:
+
+/usr/include/bits/sigset.h:
+
+/usr/include/bits/time.h:
+
+/usr/include/sys/sysmacros.h:
+
+/usr/include/bits/pthreadtypes.h:
+
+/usr/include/alloca.h:
+
+/usr/include/memory.h:
+
+/usr/include/string.h:
+
+/usr/include/bits/string.h:
+
+/usr/include/bits/string2.h:
+
+/usr/include/math.h:
+
+/usr/include/bits/huge_val.h:
+
+/usr/include/bits/mathdef.h:
+
+/usr/include/bits/mathcalls.h:
+
+/usr/include/bits/mathinline.h:
+
+sp_dec.h:
+
+rom_dec.h:
+
+typedef.h:
+
+interf_rom.h:
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/amr/sp_enc.c asterisk-1.8.3.2_com_amr/codecs/amr/sp_enc.c
--- asterisk-1.8.3.2_com_rtsp/codecs/amr/sp_enc.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/amr/sp_enc.c	2012-03-26 16:29:06.000000000 +0100
@@ -0,0 +1,11374 @@
+/*
+ * ===================================================================
+ *  TS 26.104
+ *  REL-5 V5.4.0 2004-03
+ *  REL-6 V6.1.0 2004-03
+ *  3GPP AMR Floating-point Speech Codec
+ * ===================================================================
+ *
+ */
+
+/*
+ * sp_enc.c
+ *
+ *
+ * Project:
+ *    AMR Floating-Point Codec
+ *
+ * Contains:
+ *    This module contains all the functions needed encoding 160
+ *    16-bit speech samples to AMR encoder parameters.
+ *
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <memory.h>
+#include <math.h>
+#include <float.h>
+#include "sp_enc.h"
+#include "rom_enc.h"
+
+/*
+ * Definition of structures used in encoding process
+ */
+typedef struct
+{
+   Float32 y2;
+   Float32 y1;
+   Float32 x0;
+   Float32 x1;
+
+}Pre_ProcessState;
+
+#ifdef VAD2
+
+/* Defines for VAD2 */
+#define	FRM_LEN1		80
+#define	DELAY0			24
+#define	FFT_LEN1		128
+
+#define	UPDATE_CNT_THLD1	50
+
+#define	INIT_FRAMES		4
+
+#define	CNE_SM_FAC1		0.1
+#define	CEE_SM_FAC1		0.55
+
+#define	HYSTER_CNT_THLD1	6	/* forced update constants... */
+#define	HIGH_ALPHA1		0.9
+#define	LOW_ALPHA1		0.7
+#define	ALPHA_RANGE1		(HIGH_ALPHA1-LOW_ALPHA1)
+
+#define NORM_ENRG		(4.0)	/* account for div by 2 by the HPF */
+#define	MIN_CHAN_ENRG		(0.0625 / NORM_ENRG)
+#define	INE			(16.0 / NORM_ENRG)
+#define	NOISE_FLOOR		(1.0 / NORM_ENRG)
+
+#define	PRE_EMP_FAC1		(-0.8)
+
+#define	NUM_CHAN		16
+#define	LO_CHAN			0
+#define	HI_CHAN			15
+#define	UPDATE_THLD		35
+
+#define	SINE_START_CHAN		2
+#define	P2A_THRESH		10.0
+#define	DEV_THLD1		28.0
+
+/* Defines for the FFT function */
+#define	SIZE			128
+#define	SIZE_BY_TWO		64
+#define	NUM_STAGE		6
+
+#define	PI			3.141592653589793
+
+#define	TRUE			1
+#define	FALSE			0
+
+/* Macros */
+#define	min(a,b)		((a)<(b)?(a):(b))
+#define	max(a,b)		((a)>(b)?(a):(b))
+#define	square(a)		((a)*(a))
+
+/* structures */
+typedef struct
+{
+  Float32 pre_emp_mem;
+  Word16  update_cnt;
+  Word16  hyster_cnt;
+  Word16  last_update_cnt;
+  Float32 ch_enrg_long_db[NUM_CHAN];
+  Word32  Lframe_cnt;
+  Float32 ch_enrg[NUM_CHAN];
+  Float32 ch_noise[NUM_CHAN];
+  Float32 tsnr;
+  Word16  hangover;
+  Word16  burstcount;
+  Word16  fupdate_flag;
+  Float32 negSNRvar;
+  Float32 negSNRbias;
+  Float32 R0;
+  Float32 Rmax;
+  Word16  LTP_flag;
+}vadState;
+#else
+typedef struct
+{
+   Float32 bckr_est[COMPLEN];   /* background noise estimate */
+   Float32 ave_level[COMPLEN];
+
+
+   /* averaged input components for stationary estimation */
+   Float32 old_level[COMPLEN];   /* input levels of the previous frame */
+   Float32 sub_level[COMPLEN];
+
+
+   /* input levels calculated at the end of a frame (lookahead) */
+   Float32 a_data5[3][2];   /* memory for the filter bank */
+   Float32 a_data3[5];   /* memory for the filter bank */
+   Float32 best_corr_hp;   /* FIP filtered value */
+
+
+   /* counts length of a speech burst incl HO addition */
+   Float32 corr_hp_fast;   /* filtered value */
+   Word32 vadreg;   /* flags for intermediate VAD decisions */
+   Word32 pitch;   /* flags for pitch detection */
+   Word32 oldlag_count, oldlag;   /* variables for pitch detection */
+   Word32 complex_high;   /* flags for complex detection */
+   Word32 complex_low;   /* flags for complex detection */
+   Word32 complex_warning;   /* complex background warning */
+   Word32 tone;   /* flags for tone detection */
+   Word16 burst_count;   /* counts length of a speech burst */
+   Word16 hang_count;   /* hangover counter */
+   Word16 stat_count;   /* stationary counter */
+   Word16 complex_hang_count;   /* complex hangover counter, used by VAD */
+   Word16 complex_hang_timer;   /* hangover initiator, used by CAD */
+   Word16 speech_vad_decision;   /* final decision */
+   Word16 sp_burst_count;
+
+
+}vadState;
+#endif
+#define DTX_HIST_SIZE 8
+#define DTX_ELAPSED_FRAMES_THRESH (24 + 7 -1)
+#define DTX_HANG_CONST 7   /* yields eight frames of SP HANGOVER */
+typedef struct
+{
+   Float32 lsp_hist[M * DTX_HIST_SIZE];
+   Float32 log_en_hist[DTX_HIST_SIZE];
+   Word32 init_lsf_vq_index;
+   Word16 hist_ptr;
+   Word16 log_en_index;
+   Word16 lsp_index[3];
+
+
+   /* DTX handler stuff */
+   Word16 dtxHangoverCount;
+   Word16 decAnaElapsedCount;
+
+
+}dtx_encState;
+typedef struct
+{
+   /* gain history */
+   Float32 gp[N_FRAME];
+
+
+   /* counters */
+   Word16 count;
+
+
+}tonStabState;
+typedef struct
+{
+   Word32 past_qua_en[4];
+
+
+   /* normal MA predictor memory, (contains 20*log10(qua_err)) */
+}gc_predState;
+
+typedef struct
+{
+   Float32 prev_alpha;   /* previous adaptor output, */
+   Float32 prev_gc;   /* previous code gain, */
+   Float32 ltpg_mem[LTPG_MEM_SIZE];   /* LTP coding gain history, */
+   Word16 onset;   /* onset state, */
+
+
+   /* (ltpg_mem[0] not used for history) */
+}gain_adaptState;
+typedef struct
+{
+
+   Float32 sf0_target_en;
+   Float32 sf0_coeff[5];
+   Word32 sf0_gcode0_exp;
+   Word32 sf0_gcode0_fra;
+   Word16 *gain_idx_ptr;
+
+
+   gc_predState * gc_predSt;
+   gc_predState * gc_predUncSt;
+   gain_adaptState * adaptSt;
+}gainQuantState;
+typedef struct
+{
+   Word32 T0_prev_subframe;   /* integer pitch lag of previous sub-frame */
+
+
+}Pitch_frState;
+typedef struct
+{
+   Pitch_frState * pitchSt;
+}clLtpState;
+typedef struct
+{
+   Float32 ada_w;
+   Word32 old_T0_med;
+   Word16 wght_flg;
+
+
+}pitchOLWghtState;
+typedef struct
+{
+   Float32 past_rq[M];   /* Past quantized prediction error */
+
+
+}Q_plsfState;
+typedef struct
+{
+   /* Past LSPs */
+   Float32 lsp_old[M];
+   Float32 lsp_old_q[M];
+
+
+   /* Quantization state */
+   Q_plsfState * qSt;
+}lspState;
+typedef struct
+{
+   Float32 old_A[M + 1];   /* Last A(z) for case of unstable filter */
+
+
+}LevinsonState;
+typedef struct
+{
+   LevinsonState * LevinsonSt;
+}lpcState;
+typedef struct
+{
+   /* Speech vector */
+   Float32 old_speech[L_TOTAL];
+   Float32 *speech, *p_window, *p_window_12k2;
+   Float32 *new_speech;   /* Global variable */
+
+
+   /* Weight speech vector */
+   Float32 old_wsp[L_FRAME + PIT_MAX];
+   Float32 *wsp;
+
+
+   /* OL LTP states */
+   Word32 old_lags[5];
+   Float32 ol_gain_flg[2];
+
+
+   /* Excitation vector */
+   Float32 old_exc[L_FRAME + PIT_MAX + L_INTERPOL];
+   Float32 *exc;
+
+
+   /* Zero vector */
+   Float32 ai_zero[L_SUBFR + MP1];
+   Float32 *zero;
+
+
+   /* Impulse response vector */
+   Float32 *h1;
+   Float32 hvec[L_SUBFR * 2];
+
+
+   /* Substates */
+   lpcState * lpcSt;
+   lspState * lspSt;
+   clLtpState * clLtpSt;
+   gainQuantState * gainQuantSt;
+   pitchOLWghtState * pitchOLWghtSt;
+   tonStabState * tonStabSt;
+   vadState * vadSt;
+
+   Word32 dtx;
+
+
+   dtx_encState * dtxEncSt;
+
+   /* Filter's memory */
+   Float32 mem_syn[M], mem_w0[M], mem_w[M];
+   Float32 mem_err[M + L_SUBFR], *error;
+   Float32 sharp;
+
+
+}cod_amrState;
+typedef struct
+{
+   cod_amrState * cod_amr_state;
+   Pre_ProcessState * pre_state;
+
+   Word32 dtx;
+
+
+}Speech_Encode_FrameState;
+
+
+/*
+ * Dotproduct40
+ *
+ *
+ * Parameters:
+ *    x                 I: First input
+ *    y                 I: Second input
+ * Function:
+ *    Computes dot product size 40
+ *
+ * Returns:
+ *    acc                dot product
+ */
+static Float64 Dotproduct40( Float32 *x, Float32 *y )
+{
+   Float64 acc;
+
+
+   acc = x[0] * y[0] + x[1] * y[1] + x[2] * y[2] + x[3] * y[3];
+   acc += x[4] * y[4] + x[5] * y[5] + x[6] * y[6] + x[7] * y[7];
+   acc += x[8] * y[8] + x[9] * y[9] + x[10] * y[10] + x[11] * y[11];
+   acc += x[12] * y[12] + x[13] * y[13] + x[14] * y[14] + x[15] * y[15];
+   acc += x[16] * y[16] + x[17] * y[17] + x[18] * y[18] + x[19] * y[19];
+   acc += x[20] * y[20] + x[21] * y[21] + x[22] * y[22] + x[23] * y[23];
+   acc += x[24] * y[24] + x[25] * y[25] + x[26] * y[26] + x[27] * y[27];
+   acc += x[28] * y[28] + x[29] * y[29] + x[30] * y[30] + x[31] * y[31];
+   acc += x[32] * y[32] + x[33] * y[33] + x[34] * y[34] + x[35] * y[35];
+   acc += x[36] * y[36] + x[37] * y[37] + x[38] * y[38] + x[39] * y[39];
+   return( acc );
+}
+
+
+/*
+ * Autocorr
+ *
+ *
+ * Parameters:
+ *    x                 I: Input signal
+ *    r                 O: Autocorrelations
+ *    wind              I: Window for LPC analysis
+ * Function:
+ *    Calculate autocorrelation with window, LPC order = M
+ *
+ * Returns:
+ *    void
+ */
+static void Autocorr( Float32 x[], Float32 r[], const Float32 wind[] )
+{
+   Word32 i, j;   /* Counters */
+   Float32 y[L_WINDOW + M + 1];   /* Windowed signal */
+   Float64 sum;   /* temp */
+
+
+   /*
+    * Windowing of signal
+    */
+   for ( i = 0; i < L_WINDOW; i++ ) {
+      y[i] = x[i] * wind[i];
+   }
+
+   /*
+    * Zero remaining memory
+    */
+   memset( &y[L_WINDOW], 0, 44 );
+
+   /*
+    * Autocorrelation
+    */
+   for ( i = 0; i <= M; i++ ) {
+      sum = 0;
+
+      for ( j = 0; j < L_WINDOW; j += 40 ) {
+         sum += Dotproduct40( &y[j], &y[j + i] );
+      }
+      r[i] = (Float32)sum;
+   }
+}
+
+
+/*
+ * Levinson
+ *
+ *
+ * Parameters:
+ *    old_A             I: Vector of old LP coefficients [M+1]
+ *    r                 I: Vector of autocorrelations    [M+1]
+ *    a                 O: LP coefficients               [M+1]
+ *    rc                O: Reflection coefficients       [4]
+ * Function:
+ *    Levinson-Durbin algorithm
+ *
+ * Returns:
+ *    void
+ *
+ */
+static void Levinson( Float32 *old_A, Float32 *r, Float32 *A, Float32 *rc )
+{
+   Float32 sum, at, err;
+   Word32 l, j, i;
+   Float32 rct[M];   /* temporary reflection coefficients  0,...,m-1 */
+
+
+   rct[0] = ( -r[1] ) / r[0];
+   A[0] = 1.0F;
+   A[1] = rct[0];
+   err = r[0] + r[1] * rct[0];
+
+   if ( err <= 0.0 )
+      err = 0.01F;
+
+   for ( i = 2; i <= M; i++ ) {
+      sum = 0.0F;
+
+      for ( j = 0; j < i; j++ )
+         sum += r[i - j] * A[j];
+      rct[i - 1] = ( -sum ) / ( err );
+
+      for ( j = 1; j <= ( i / 2 ); j++ ) {
+         l = i - j;
+         at = A[j] + rct[i - 1] *A[l];
+         A[l] += rct[i - 1] *A[j];
+         A[j] = at;
+      }
+      A[i] = rct[i - 1];
+      err += rct[i - 1] *sum;
+
+      if ( err <= 0.0 )
+         err = 0.01F;
+   }
+   memcpy( rc, rct, 4 * sizeof( Float32 ) );
+   memcpy( old_A, A, MP1 * sizeof( Float32 ) );
+}
+
+
+/*
+ * lpc
+ *
+ *
+ * Parameters:
+ *    old_A             O: Vector of old LP coefficients [M+1]
+ *    x                 I: Input signal
+ *    x_12k2            I: Input signal 12.2k
+ *    a                 O: predictor coefficients
+ *    mode              I: AMR mode
+ * Function:
+ *    LP analysis
+ *
+ *    In 12.2 kbit/s mode linear prediction (LP) analysis is performed
+ *    twice per speech frame using the auto-correlation approach with
+ *    30 ms asymmetric windows. No lookahead is used in
+ *    the auto-correlation computation.
+ *
+ *    In other modes analysis is performed once per speech frame
+ *    using the auto-correlation approach with 30 ms asymmetric windows.
+ *    A lookahead of 40 samples (5 ms) is used in the auto-correlation computation.
+ *
+ *    The auto-correlations of windowed speech are converted to the LP
+ *    coefficients using the Levinson-Durbin algorithm.
+ *    Then the LP coefficients are transformed to the Line Spectral Pair
+ *    (LSP) domain  for quantization and interpolation purposes.
+ *    The interpolated quantified and unquantized filter coefficients
+ *    are converted back to the LP filter coefficients
+ *    (to construct the synthesis and weighting filters at each subframe).
+ *
+ * Returns:
+ *    void
+ *
+ */
+static void lpc( Float32 *old_A, Float32 x[], Float32 x_12k2[], Float32 a[], enum Mode
+      mode )
+{
+   Word32 i;
+   Float32 r[MP1];
+   Float32 rc[4];
+
+
+   if ( mode == MR122 ) {
+      Autocorr( x_12k2, r, window_160_80 );
+
+      /*
+       * Lag windowing
+       */
+      for ( i = 1; i <= M; i++ ) {
+         r[i] = r[i] * lag_wind[i - 1];
+      }
+      r[0] *= 1.0001F;
+
+      if ( r[0] < 1.0F )
+         r[0] = 1.0F;
+
+      /*
+       * Levinson Durbin
+       */
+      Levinson( old_A, r, &a[MP1], rc );
+
+      /*
+       * Autocorrelations
+       */
+      Autocorr( x_12k2, r, window_232_8 );
+
+      /*
+       * Lag windowing
+       */
+      for ( i = 1; i <= M; i++ ) {
+         r[i] = r[i] * lag_wind[i - 1];
+      }
+      r[0] *= 1.0001F;
+
+      if ( r[0] < 1.0F )
+         r[0] = 1.0F;
+
+      /*
+       * Levinson Durbin
+       */
+      Levinson( old_A, r, &a[MP1 * 3], rc );
+   }
+   else {
+      /*
+       * Autocorrelations
+       */
+      Autocorr( x, r, window_200_40 );
+
+      /*
+       * a 60 Hz bandwidth expansion is used by lag windowing
+       * the auto-correlations. Further, auto-correlation[0] is
+       * multiplied by the white noise correction factor 1.0001
+       * which is equivalent to adding a noise floor at -40 dB.
+       */
+      for ( i = 1; i <= M; i++ ) {
+         r[i] = r[i] * lag_wind[i - 1];
+      }
+      r[0] *= 1.0001F;
+
+      if ( r[0] < 1.0F )
+         r[0] = 1.0F;
+
+      /*
+       * Levinson Durbin
+       */
+      Levinson( old_A, r, &a[MP1 * 3], rc );
+   }
+}
+
+
+/*
+ * Chebps
+ *
+ *
+ * Parameters:
+ *    x                 I: Cosine value for the freqency given
+ *    f                 I: angular freqency
+ * Function:
+ *    Evaluates the Chebyshev polynomial series
+ *
+ * Returns:
+ *    result of polynomial evaluation
+ */
+static Float32 Chebps( Float32 x, Float32 f[] )
+{
+   Float32 b0, b1, b2, x2;
+   Word32 i;
+
+
+   x2 = 2.0F * x;
+   b2 = 1.0F;
+   b1 = x2 + f[1];
+
+   for ( i = 2; i < 5; i++ ) {
+      b0 = x2 * b1 - b2 + f[i];
+      b2 = b1;
+      b1 = b0;
+   }
+   return( x * b1 - b2 + f[i] );
+}
+
+
+/*
+ * Az_lsp
+ *
+ *
+ * Parameters:
+ *    a                 I: Predictor coefficients              [MP1]
+ *    lsp               O: Line spectral pairs                 [M]
+ *    old_lsp           I: Old lsp, in case not found 10 roots [M]
+ *
+ * Function:
+ *    LP to LSP conversion
+ *
+ *    The LP filter coefficients A[], are converted to the line spectral pair
+ *    (LSP) representation for quantization and interpolation purposes.
+ *
+ * Returns:
+ *    void
+ */
+static void Az_lsp( Float32 a[], Float32 lsp[], Float32 old_lsp[] )
+{
+   Word32 i, j, nf, ip;
+   Float32 xlow, ylow, xhigh, yhigh, xmid, ymid, xint;
+   Float32 y;
+   Float32 *coef;
+   Float32 f1[6], f2[6];
+
+
+   /*
+    *  find the sum and diff. pol. F1(z) and F2(z)
+    */
+   f1[0] = 1.0F;
+   f2[0] = 1.0F;
+
+   for ( i = 0; i < ( NC ); i++ ) {
+      f1[i + 1] = a[i + 1] +a[M - i] - f1[i];
+      f2[i + 1] = a[i + 1] -a[M - i] + f2[i];
+   }
+   f1[NC] *= 0.5F;
+   f2[NC] *= 0.5F;
+
+   /*
+    * find the LSPs using the Chebychev pol. evaluation
+    */
+   nf = 0;   /* number of found frequencies */
+   ip = 0;   /* indicator for f1 or f2 */
+   coef = f1;
+   xlow = grid[0];
+   ylow = Chebps( xlow, coef );
+   j = 0;
+
+   while ( ( nf < M ) && ( j < 60 ) ) {
+      j++;
+      xhigh = xlow;
+      yhigh = ylow;
+      xlow = grid[j];
+      ylow = Chebps( xlow, coef );
+
+      if ( ylow * yhigh <= 0 ) {
+         /* divide 4 times the interval */
+         for ( i = 0; i < 4; i++ ) {
+            xmid = ( xlow + xhigh ) * 0.5F;
+            ymid = Chebps( xmid, coef );
+
+            if ( ylow * ymid <= 0.0F ) {
+               yhigh = ymid;
+               xhigh = xmid;
+            }
+            else {
+               ylow = ymid;
+               xlow = xmid;
+            }
+         }
+
+         /*
+          * Linear interpolation
+          * xint = xlow - ylow*(xhigh-xlow)/(yhigh-ylow)
+          */
+         y = yhigh - ylow;
+
+         if ( y == 0 ) {
+            xint = xlow;
+         }
+         else {
+            y = ( xhigh - xlow ) / ( yhigh - ylow );
+            xint = xlow - ylow * y;
+         }
+         lsp[nf] = xint;
+         xlow = xint;
+         nf++;
+
+         if ( ip == 0 ) {
+            ip = 1;
+            coef = f2;
+         }
+         else {
+            ip = 0;
+            coef = f1;
+         }
+         ylow = Chebps( xlow, coef );
+      }
+   }
+
+   /* Check if M roots found */
+   if ( nf < M ) {
+      memcpy( lsp, old_lsp, M <<2 );
+   }
+   return;
+}
+
+
+/*
+ * Get_lsp_pol
+ *
+ *
+ * Parameters:
+ *    lsp                 I: line spectral frequencies
+ *    f                   O: polynomial F1(z) or F2(z)
+ *
+ * Function:
+ *    Find the polynomial F1(z) or F2(z) from the LSPs.
+ *
+ *    F1(z) = product ( 1 - 2 lsp[i] z^-1 + z^-2 )
+ *             i=0,2,4,6,8
+ *    F2(z) = product   ( 1 - 2 lsp[i] z^-1 + z^-2 )
+ *             i=1,3,5,7,9
+ *
+ *    where lsp[] is the LSP vector in the cosine domain.
+ *
+ *    The expansion is performed using the following recursion:
+ *
+ *    f[0] = 1
+ *    b = -2.0 * lsp[0]
+ *    f[1] = b
+ *    for i=2 to 5 do
+ *       b = -2.0 * lsp[2*i-2];
+ *       f[i] = b*f[i-1] + 2.0*f[i-2];
+ *       for j=i-1 down to 2 do
+ *          f[j] = f[j] + b*f[j-1] + f[j-2];
+ *       f[1] = f[1] + b;
+ *
+ * Returns:
+ *    void
+ */
+static void Get_lsp_pol( Float32 *lsp, Float32 *f )
+{
+   Word32 i, j;
+   Float32 T0;
+
+
+   f[0] = 1.0F;
+   f[1] = -2.0F * lsp[0];
+
+   for ( i = 2; i <= 5; i++ ) {
+      T0 = -2.0F * lsp[2 * i - 2];
+      f[i] = ( Float32 )( T0 * f[i - 1] +2.0F * f[i - 2] );
+
+      for ( j = i - 1; j >= 2; j-- ) {
+         f[j] = f[j] + T0 * f[j - 1] +f[j - 2];
+      }
+      f[1] = f[1] + T0;
+   }
+   return;
+}
+
+
+/*
+ * Lsp_Az
+ *
+ *
+ * Parameters:
+ *    lsp                 I: Line spectral frequencies
+ *    a                   O: Predictor coefficients
+ *
+ * Function:
+ *    Converts from the line spectral pairs (LSP) to LP coefficients,
+ *    for a 10th order filter.
+ *
+ * Returns:
+ *    void
+ */
+static void Lsp_Az( Float32 lsp[], Float32 a[] )
+{
+   Float32 f1[6], f2[6];
+   Word32 i, j;
+
+
+   Get_lsp_pol( &lsp[0], f1 );
+   Get_lsp_pol( &lsp[1], f2 );
+
+   for ( i = 5; i > 0; i-- ) {
+      f1[i] += f1[i - 1];
+      f2[i] -= f2[i - 1];
+   }
+   a[0] = 1;
+
+   for ( i = 1, j = 10; i <= 5; i++, j-- ) {
+      a[i] = ( Float32 )( ( f1[i] + f2[i] ) * 0.5F );
+      a[j] = ( Float32 )( ( f1[i] - f2[i] ) * 0.5F );
+   }
+   return;
+}
+
+
+/*
+ * Int_lpc_1and3_2
+ *
+ *
+ * Parameters:
+ *    lsp_old        I: LSP vector at the 4th subfr. of past frame      [M]
+ *    lsp_mid        I: LSP vector at the 2nd subframe of present frame [M]
+ *    lsp_new        I: LSP vector at the 4th subframe of present frame [M]
+ *    az             O: interpolated LP parameters in subframes 1 and 3
+ *                                                                [AZ_SIZE]
+ *
+ * Function:
+ *    Interpolation of the LPC parameters. Same as the Int_lpc
+ *    function but we do not recompute Az() for subframe 2 and
+ *	   4 because it is already available.
+ *
+ * Returns:
+ *    void
+ */
+static void Int_lpc_1and3_2( Float32 lsp_old[], Float32 lsp_mid[], Float32
+      lsp_new[], Float32 az[] )
+{
+   Float32 lsp[M];
+   Word32 i;
+
+
+   for ( i = 0; i < M; i += 2 ) {
+      lsp[i] = ( lsp_mid[i] + lsp_old[i] ) * 0.5F;
+      lsp[i + 1] = ( lsp_mid[i + 1] +lsp_old[i+1] )*0.5F;
+   }
+
+   /* Subframe 1 */
+   Lsp_Az( lsp, az );
+   az += MP1 * 2;
+
+   for ( i = 0; i < M; i += 2 ) {
+      lsp[i] = ( lsp_mid[i] + lsp_new[i] ) * 0.5F;
+      lsp[i + 1] = ( lsp_mid[i + 1] +lsp_new[i+1] )*0.5F;
+   }
+
+   /* Subframe 3 */
+   Lsp_Az( lsp, az );
+   return;
+}
+
+
+/*
+ * Lsp_lsf
+ *
+ *
+ * Parameters:
+ *    lsp               I: LSP vector
+ *    lsf               O: LSF vector
+ *
+ * Function:
+ *    Transformation lsp to lsf, LPC order M
+ *
+ * Returns:
+ *    void
+ */
+static void Lsp_lsf( Float32 lsp[], Float32 lsf[] )
+{
+   Word32 i;
+
+
+   for ( i = 0; i < M; i++ ) {
+      lsf[i] = ( Float32 )( acos( lsp[i] )*SCALE_LSP_FREQ );
+   }
+   return;
+}
+
+
+/*
+ * Lsf_wt
+ *
+ *
+ * Parameters:
+ *    lsf               I: LSF vector
+ *    wf                O: square of weighting factors
+ *
+ * Function:
+ *    Compute LSF weighting factors
+ *
+ * Returns:
+ *    void
+ */
+static void Lsf_wt( Float32 *lsf, Float32 *wf )
+{
+   Float32 temp;
+   Word32 i;
+
+
+   wf[0] = lsf[1];
+
+   for ( i = 1; i < 9; i++ ) {
+      wf[i] = lsf[i + 1] -lsf[i - 1];
+   }
+   wf[9] = 4000.0F - lsf[8];
+
+   for ( i = 0; i < 10; i++ ) {
+      if ( wf[i] < 450.0F ) {
+         temp = 3.347F - SLOPE1_WGHT_LSF * wf[i];
+      }
+      else {
+         temp = 1.8F - SLOPE2_WGHT_LSF * ( wf[i] - 450.0F );
+      }
+      wf[i] = temp * temp;
+   }
+   return;
+}
+
+
+/*
+ * Vq_subvec
+ *
+ *
+ * Parameters:
+ *    lsf_r1            I: 1st LSF residual vector
+ *    lsf_r2            I: 2nd LSF residual vector
+ *    dico              I: quantization codebook
+ *    wf1               I: 1st LSF weighting factors
+ *    wf2               I: 2nd LSF weighting factors
+ *    dico_size         I: size of quantization codebook
+ * Function:
+ *    Quantization of a 4 dimensional subvector
+ *
+ * Returns:
+ *    index             quantization index
+ */
+static Word16 Vq_subvec( Float32 *lsf_r1, Float32 *lsf_r2, const Float32 *dico,
+      Float32 *wf1, Float32 *wf2, Word16 dico_size )
+{
+   Float64 temp, dist, dist_min;
+   const Float32 *p_dico;
+   Word32 i, index = 0;
+
+
+   dist_min = DBL_MAX;
+   p_dico = dico;
+
+   for ( i = 0; i < dico_size; i++ ) {
+      temp = lsf_r1[0] - *p_dico++;
+      dist = temp * temp * wf1[0];
+      temp = lsf_r1[1] - *p_dico++;
+      dist += temp * temp * wf1[1];
+      temp = lsf_r2[0] - *p_dico++;
+      dist += temp * temp * wf2[0];
+      temp = lsf_r2[1] - *p_dico++;
+      dist += temp * temp * wf2[1];
+
+      if ( dist < dist_min ) {
+         dist_min = dist;
+         index = i;
+      }
+   }
+
+   /* Reading the selected vector */
+   p_dico = &dico[index << 2];
+   lsf_r1[0] = *p_dico++;
+   lsf_r1[1] = *p_dico++;
+   lsf_r2[0] = *p_dico++;
+   lsf_r2[1] = *p_dico++;
+   return( Word16 )index;
+}
+
+
+/*
+ * Vq_subvec_s
+ *
+ *
+ * Parameters:
+ *    lsf_r1            I: 1st LSF residual vector
+ *    lsf_r2            I: 2nd LSF residual vector
+ *    dico              I: quantization codebook
+ *    wf1               I: 1st LSF weighting factors
+ *    wf2               I: 2nd LSF weighting factors
+ *    dico_size         I: size of quantization codebook
+ * Function:
+ *    Quantization of a 4 dimensional subvector with a signed codebook
+ *
+ * Returns:
+ *    index             quantization index
+ */
+static Word16 Vq_subvec_s( Float32 *lsf_r1, Float32 *lsf_r2, const Float32 *dico
+      , Float32 *wf1, Float32 *wf2, Word16 dico_size )
+{
+   Float64 dist_min, dist1, dist2, temp1, temp2;
+   const Float32 *p_dico;
+   Word32 i, index = 0;
+   Word16 sign = 0;
+
+
+   dist_min = DBL_MAX;
+   p_dico = dico;
+
+   for ( i = 0; i < dico_size; i++ ) {
+      temp1 = lsf_r1[0] - *p_dico;
+      temp2 = lsf_r1[0] + *p_dico++;
+      dist1 = temp1 * temp1 * wf1[0];
+      dist2 = temp2 * temp2 * wf1[0];
+      temp1 = lsf_r1[1] - *p_dico;
+      temp2 = lsf_r1[1] + *p_dico++;
+      dist1 += temp1 * temp1 * wf1[1];
+      dist2 += temp2 * temp2 * wf1[1];
+      temp1 = lsf_r2[0] - *p_dico;
+      temp2 = lsf_r2[0] + *p_dico++;
+      dist1 += temp1 * temp1 * wf2[0];
+      dist2 += temp2 * temp2 * wf2[0];
+      temp1 = lsf_r2[1] - *p_dico;
+      temp2 = lsf_r2[1] + *p_dico++;
+      dist1 += temp1 * temp1 * wf2[1];
+      dist2 += temp2 * temp2 * wf2[1];
+
+      if ( dist1 < dist_min ) {
+         dist_min = dist1;
+         index = i;
+         sign = 0;
+      }
+
+      if ( dist2 < dist_min ) {
+         dist_min = dist2;
+         index = i;
+         sign = 1;
+      }
+   }
+
+   /* Reading the selected vector */
+   p_dico = &dico[index << 2];
+
+   if ( sign == 0 ) {
+      lsf_r1[0] = *p_dico++;
+      lsf_r1[1] = *p_dico++;
+      lsf_r2[0] = *p_dico++;
+      lsf_r2[1] = *p_dico++;
+   }
+   else {
+      lsf_r1[0] = -( *p_dico++ );
+      lsf_r1[1] = -( *p_dico++ );
+      lsf_r2[0] = -( *p_dico++ );
+      lsf_r2[1] = -( *p_dico++ );
+   }
+   index = index << 1;
+   index = index + sign;
+   return( Word16 )index;
+}
+
+
+/*
+ * Reorder_lsf
+ *
+ *
+ * Parameters:
+ *    lsf               B: vector of LSFs
+ *    min_dist          I: minimum required distance
+ *
+ * Function:
+ *    Make sure that the LSFs are properly ordered and to keep a certain minimum
+ *    distance between adjacent LSFs. LPC order = M.
+ *
+ * Returns:
+ *    void
+ */
+static void Reorder_lsf( Float32 *lsf, Float32 min_dist )
+{
+   Float32 lsf_min;
+   Word32 i;
+
+
+   lsf_min = min_dist;
+
+   for ( i = 0; i < M; i++ ) {
+      if ( lsf[i] < lsf_min ) {
+         lsf[i] = lsf_min;
+      }
+      lsf_min = lsf[i] + min_dist;
+   }
+}
+
+
+/*
+ * Lsf_lsp
+ *
+ *
+ * Parameters:
+ *    lsf               I: vector of LSFs
+ *    lsp	            O: vector of LSPs
+ *
+ * Function:
+ *    Transformation lsf to lsp, order M
+ *
+ * Returns:
+ *    void
+ */
+static void Lsf_lsp( Float32 lsf[], Float32 lsp[] )
+{
+   Word32 i;
+
+
+   for ( i = 0; i < M; i++ ) {
+      lsp[i] = ( Float32 )cos( SCALE_FREQ_LSP * lsf[i] );
+   }
+   return;
+}
+
+
+/*
+ * Vq_subvec3
+ *
+ *
+ * Parameters:
+ *    lsf_r1            I: 1st LSF residual vector
+ *    dico              I: quantization codebook
+ *    wf1               I: 1st LSF weighting factors
+ *    dico_size         I: size of quantization codebook
+ *    use_half          I: use every second entry in codebook
+ *
+ * Function:
+ *    Quantization of a 3 dimensional subvector
+ *
+ * Returns:
+ *    index             quantization index
+ */
+static Word16 Vq_subvec3( Float32 *lsf_r1, const Float32 *dico, Float32 *wf1,
+      Word16 dico_size, Word32 use_half )
+{
+   Float64 dist, dist_min;
+   Float32 temp;
+   const Float32 *p_dico;
+   Word32 i, index = 0;
+
+
+   dist_min = FLT_MAX;
+   p_dico = dico;
+
+   if ( use_half == 0 ) {
+      for ( i = 0; i < dico_size; i++ ) {
+         temp = lsf_r1[0] - *p_dico++;
+         temp *= wf1[0];
+         dist = temp * temp;
+         temp = lsf_r1[1] - *p_dico++;
+         temp *= wf1[1];
+         dist += temp * temp;
+         temp = lsf_r1[2] - *p_dico++;
+         temp *= wf1[2];
+         dist += temp * temp;
+
+         if ( dist < dist_min ) {
+            dist_min = dist;
+            index = i;
+         }
+      }
+      p_dico = &dico[( 3 * index )];
+   }
+   else {
+      for ( i = 0; i < dico_size; i++ ) {
+         temp = lsf_r1[0] - *p_dico++;
+         temp *= wf1[0];
+         dist = temp * temp;
+         temp = lsf_r1[1] - *p_dico++;
+         temp *= wf1[1];
+         dist += temp * temp;
+         temp = lsf_r1[2] - *p_dico++;
+         temp *= wf1[2];
+         dist += temp * temp;
+
+         if ( dist < dist_min ) {
+            dist_min = dist;
+            index = i;
+         }
+         p_dico = p_dico + 3;
+      }
+      p_dico = &dico[6 * index];
+   }
+
+   /* Reading the selected vector */
+   lsf_r1[0] = *p_dico++;
+   lsf_r1[1] = *p_dico++;
+   lsf_r1[2] = *p_dico++;
+   return( Word16 )index;
+}
+
+
+/*
+ * Vq_subvec4
+ *
+ *
+ * Parameters:
+ *    lsf_r1            I: 1st LSF residual vector
+ *    dico              I: quantization codebook
+ *    wf1               I: 1st LSF weighting factors
+ *    dico_size         I: size of quantization codebook
+ *
+ * Function:
+ *    Quantization of a 4 dimensional subvector
+ *
+ * Returns:
+ *    index             quantization index
+ */
+static Word16 Vq_subvec4( Float32 *lsf_r1, const Float32 *dico, Float32 *wf1,
+      Word16 dico_size )
+{
+   Float64 dist, dist_min;
+   Float32 temp;
+   const Float32 *p_dico;
+   Word32 i, index = 0;
+
+
+   dist_min = FLT_MAX;
+   p_dico = dico;
+
+   for ( i = 0; i < dico_size; i++ ) {
+      temp = lsf_r1[0] - *p_dico++;
+      temp *= wf1[0];
+      dist = temp * temp;
+      temp = lsf_r1[1] - *p_dico++;
+      temp *= wf1[1];
+      dist += temp * temp;
+      temp = lsf_r1[2] - *p_dico++;
+      temp *= wf1[2];
+      dist += temp * temp;
+      temp = lsf_r1[3] - *p_dico++;
+      temp *= wf1[3];
+      dist += temp * temp;
+
+      if ( dist < dist_min ) {
+         dist_min = dist;
+         index = i;
+      }
+   }
+
+   /* Reading the selected vector */
+   p_dico = &dico[index << 2];
+   lsf_r1[0] = *p_dico++;
+   lsf_r1[1] = *p_dico++;
+   lsf_r1[2] = *p_dico++;
+   lsf_r1[3] = *p_dico++;
+   return( Word16 )index;
+}
+
+
+/*
+ * Q_plsf_3
+ *
+ *
+ * Parameters:
+ *    mode              I: AMR mode
+ *    past_rq           B: past quantized residual
+ *    lsp1              I: 1st LSP vector
+ *    lsp1_q            O: quantized 1st LSP vector
+ *    indice            I: quantization indices of 5 matrices and
+ *                         one sign for 3rd
+ *    pred_init_i       O: init index for MA prediction in DTX mode
+ *
+ * Function:
+ *    Quantization of LSF parameters with 1st order MA prediction and
+ *    split by 3 vector quantization (split-VQ)
+ *
+ * Returns:
+ *    void
+ */
+static void Q_plsf_3( enum Mode mode, Float32 *past_rq, Float32 *lsp1, Float32 *
+      lsp1_q, Word16 *indice, Word32 *pred_init_i )
+{
+   Float32 lsf1[M], wf1[M], lsf_p[M], lsf_r1[M];
+   Float32 lsf1_q[M];
+   Float32 pred_init_err;
+   Float32 min_pred_init_err;
+   Float32 temp_r1[M];
+   Float32 temp_p[M];
+   Word32 j, i;
+
+
+   /* convert LSFs to normalize frequency domain */
+   Lsp_lsf( lsp1, lsf1 );
+
+   /* compute LSF weighting factors */
+   Lsf_wt( lsf1, wf1 );
+
+   /* Compute predicted LSF and prediction error */
+   if ( mode != MRDTX ) {
+      for ( i = 0; i < M; i++ ) {
+         lsf_p[i] = mean_lsf_3[i] + past_rq[i] * pred_fac[i];
+         lsf_r1[i] = lsf1[i] - lsf_p[i];
+      }
+   }
+   else {
+      /*
+       * DTX mode, search the init vector that yields
+       * lowest prediction resuidual energy
+       */
+      *pred_init_i = 0;
+      min_pred_init_err = FLT_MAX;
+
+      for ( j = 0; j < PAST_RQ_INIT_SIZE; j++ ) {
+         pred_init_err = 0;
+
+         for ( i = 0; i < M; i++ ) {
+            temp_p[i] = mean_lsf_3[i] + past_rq_init[j * M + i];
+            temp_r1[i] = lsf1[i] - temp_p[i];
+            pred_init_err += temp_r1[i] * temp_r1[i];
+         }   /* next i */
+
+         if ( pred_init_err < min_pred_init_err ) {
+            min_pred_init_err = pred_init_err;
+            memcpy( lsf_r1, temp_r1, M <<2 );
+            memcpy( lsf_p, temp_p, M <<2 );
+            memcpy( past_rq, &past_rq_init[j * M], M <<2 );
+            *pred_init_i = j;
+         }
+      }
+   }
+
+   /* Split-VQ of prediction error */
+   /* MR475, MR515 */
+   if ( ( mode == MR475 ) || ( mode == MR515 ) ) {
+      indice[0] = Vq_subvec3( &lsf_r1[0], dico1_lsf_3, &wf1[0], DICO1_SIZE_3, 0
+            );
+      indice[1] = Vq_subvec3( &lsf_r1[3], dico2_lsf_3, &wf1[3], DICO2_SIZE_3 /2,
+            1 );
+      indice[2] = Vq_subvec4( &lsf_r1[6], mr515_3_lsf, &wf1[6], MR515_3_SIZE );
+   }
+
+   /* MR795 */
+   else if ( mode == MR795 ) {
+      indice[0] = Vq_subvec3( &lsf_r1[0], mr795_1_lsf, &wf1[0], MR795_1_SIZE, 0
+            );
+      indice[1] = Vq_subvec3( &lsf_r1[3], dico2_lsf_3, &wf1[3], DICO2_SIZE_3, 0
+            );
+      indice[2] = Vq_subvec4( &lsf_r1[6], dico3_lsf_3, &wf1[6], DICO3_SIZE_3 );
+   }
+
+   /* MR59, MR67, MR74, MR102 , MRDTX */
+   else {
+      indice[0] = Vq_subvec3( &lsf_r1[0], dico1_lsf_3, &wf1[0], DICO1_SIZE_3, 0
+            );
+      indice[1] = Vq_subvec3( &lsf_r1[3], dico2_lsf_3, &wf1[3], DICO2_SIZE_3, 0
+            );
+      indice[2] = Vq_subvec4( &lsf_r1[6], dico3_lsf_3, &wf1[6], DICO3_SIZE_3 );
+   }
+
+   /* Compute quantized LSFs and update the past quantized residual */
+   for ( i = 0; i < M; i++ ) {
+      lsf1_q[i] = lsf_r1[i] + lsf_p[i];
+      past_rq[i] = lsf_r1[i];
+   }
+
+   /* verification that LSFs has mimimum distance of LSF_GAP 50 Hz */
+   Reorder_lsf( lsf1_q, 50.0F );
+
+   /*  convert LSFs to the cosine domain */
+   Lsf_lsp( lsf1_q, lsp1_q );
+}
+
+
+/*
+ * Q_plsf_5
+ *
+ *
+ * Parameters:
+ *    past_rq           B: past quantized residual
+ *    lsp1              I: 1st LSP vector
+ *    lsp2              I: 2nd LSP vector
+ *    lsp1_q            O: quantized 1st LSP vector
+ *    lsp2_q            O: quantized 2nd LSP vector
+ *    indice	         I: quantization indices of 5 matrices and
+ *                         one sign for 3rd
+ *
+ * Function:
+ *    Quantization of 2 sets of LSF parameters using 1st order MA
+ *    prediction and split by 5 matrix quantization (split-MQ).
+ *
+ * Returns:
+ *    void
+ */
+static void Q_plsf_5( Float32 *past_rq, Float32 *lsp1, Float32 *lsp2, Float32 *
+      lsp1_q, Float32 *lsp2_q, Word16 *indice )
+{
+   Float32 lsf1[M], lsf2[M], wf1[M], wf2[M], lsf_p[M], lsf_r1[M], lsf_r2[M];
+   Float32 lsf1_q[M], lsf2_q[M];
+   Word32 i;
+
+
+   /* convert LSFs to normalize frequency domain */
+   Lsp_lsf( lsp1, lsf1 );
+   Lsp_lsf( lsp2, lsf2 );
+
+   /* Compute LSF weighting factors */
+   Lsf_wt( lsf1, wf1 );
+   Lsf_wt( lsf2, wf2 );
+
+   /* Compute predicted LSF and prediction error */
+   for ( i = 0; i < M; i++ ) {
+      /* MR122 LSP prediction factor = 0.65 */
+      lsf_p[i] = mean_lsf_5[i] + past_rq[i] * 0.65F;
+      lsf_r1[i] = lsf1[i] - lsf_p[i];
+      lsf_r2[i] = lsf2[i] - lsf_p[i];
+   }
+
+   /* Split-MQ of prediction error */
+   indice[0] = Vq_subvec( &lsf_r1[0], &lsf_r2[0], dico1_lsf_5, &wf1[0], &wf2[0],
+         DICO1_SIZE_5 );
+   indice[1] = Vq_subvec( &lsf_r1[2], &lsf_r2[2], dico2_lsf_5, &wf1[2], &wf2[2],
+         DICO2_SIZE_5 );
+   indice[2] = Vq_subvec_s( &lsf_r1[4], &lsf_r2[4], dico3_lsf_5, &wf1[4], &wf2[4
+         ], DICO3_SIZE_5 );
+   indice[3] = Vq_subvec( &lsf_r1[6], &lsf_r2[6], dico4_lsf_5, &wf1[6], &wf2[6],
+         DICO4_SIZE_5 );
+   indice[4] = Vq_subvec( &lsf_r1[8], &lsf_r2[8], dico5_lsf_5, &wf1[8], &wf2[8],
+         DICO5_SIZE_5 );
+
+   /* Compute quantized LSFs and update the past quantized residual */
+   for ( i = 0; i < M; i++ ) {
+      lsf1_q[i] = lsf_r1[i] + lsf_p[i];
+      lsf2_q[i] = lsf_r2[i] + lsf_p[i];
+      past_rq[i] = lsf_r2[i];
+   }
+
+   /* verification that LSFs has minimum distance of LSF_GAP 50hz */
+   Reorder_lsf( lsf1_q, 50.0F );
+   Reorder_lsf( lsf2_q, 50.0F );
+
+   /*  convert LSFs to the cosine domain */
+   Lsf_lsp( lsf1_q, lsp1_q );
+   Lsf_lsp( lsf2_q, lsp2_q );
+}
+
+
+/*
+ * Int_lpc_1and3
+ *
+ *
+ * Parameters:
+ *    lsp_old        I: LSP vector at the 4th subfr. of past frame      [M]
+ *    lsp_mid        I: LSP vector at the 2nd subframe of present frame [M]
+ *    lsp_new        I: LSP vector at the 4th subframe of present frame [M]
+ *    az             O: interpolated LP parameters in subframes 1 and 3
+ *                                                                [AZ_SIZE]
+ *
+ * Function:
+ *    Interpolates the LSPs and converts to LPC parameters
+ *    to get a different LP filter in each subframe.
+ *
+ *    The 20 ms speech frame is divided into 4 subframes.
+ *    The LSPs are quantized and transmitted at the 2nd and
+ *    4th subframes (twice per frame) and interpolated at the
+ *    1st and 3rd subframe.
+ *
+ * Returns:
+ *    void
+ */
+static void Int_lpc_1and3( Float32 lsp_old[], Float32 lsp_mid[], Float32 lsp_new
+      [], Float32 az[] )
+{
+   Word32 i;
+   Float32 lsp[M];
+
+
+   for ( i = 0; i < M; i++ ) {
+      lsp[i] = ( lsp_mid[i] + lsp_old[i] ) * 0.5F;
+   }
+
+   /* Subframe 1 */
+   Lsp_Az( lsp, az );
+   az += MP1;
+
+   /* Subframe 2 */
+   Lsp_Az( lsp_mid, az );
+   az += MP1;
+
+   for ( i = 0; i < M; i++ ) {
+      lsp[i] = ( lsp_mid[i] + lsp_new[i] ) * 0.5F;
+   }
+
+   /* Subframe 3 */
+   Lsp_Az( lsp, az );
+   az += MP1;
+
+   /* Subframe 4 */
+   Lsp_Az( lsp_new, az );
+   return;
+}
+
+
+/*
+ * Int_lpc_1to3_2
+ *
+ *
+ * Parameters:
+ *    lsp_old           I: LSP vector at the 4th subfr. of past frame      [M]
+ *    lsp_new           I: LSP vector at the 4th subframe of present frame [M]
+ *    az                O: interpolated LP parameters in subframes 1, 2 and 3
+ *                                                                   [AZ_SIZE]
+ *
+ * Function:
+ *    Interpolation of the LPC parameters.
+ *
+ * Returns:
+ *    void
+ */
+static void Int_lpc_1to3_2( Float32 lsp_old[], Float32 lsp_new[], Float32 az[] )
+{
+   Float32 lsp[M];
+   Word32 i;
+
+
+   for ( i = 0; i < M; i += 2 ) {
+      lsp[i] = lsp_new[i] * 0.25F + lsp_old[i] * 0.75F;
+      lsp[i + 1] = lsp_new[i + 1] *0.25F + lsp_old[i + 1] *0.75F;
+   }
+
+   /* Subframe 1 */
+   Lsp_Az( lsp, az );
+   az += MP1;
+
+   for ( i = 0; i < M; i += 2 ) {
+      lsp[i] = ( lsp_old[i] + lsp_new[i] ) * 0.5F;
+      lsp[i + 1] = ( lsp_old[i + 1] +lsp_new[i+1] )*0.5F;
+   }
+
+   /* Subframe 2 */
+   Lsp_Az( lsp, az );
+   az += MP1;
+
+   for ( i = 0; i < M; i += 2 ) {
+      lsp[i] = lsp_old[i] * 0.25F + lsp_new[i] * 0.75F;
+      lsp[i + 1] = lsp_old[i + 1] *0.25F + lsp_new[i + 1] *0.75F;
+   }
+
+   /* Subframe 3 */
+   Lsp_Az( lsp, az );
+   return;
+}
+
+
+/*
+ * Int_lpc_1to3
+ *
+ *
+ * Parameters:
+ *    lsp_old           I: LSP vector at the 4th subfr. of past frame      [M]
+ *    lsp_new           I: LSP vector at the 4th subframe of present frame [M]
+ *    az                O: interpolated LP parameters in all subframes
+ *                                                                   [AZ_SIZE]
+ *
+ * Function:
+ *    Interpolates the LSPs and converts to LPC parameters to get a different
+ *    LP filter in each subframe.
+ *
+ *    The 20 ms speech frame is divided into 4 subframes.
+ *    The LSPs are quantized and transmitted at the 4th
+ *    subframes (once per frame) and interpolated at the
+ *    1st, 2nd and 3rd subframe.
+ *
+ * Returns:
+ *    void
+ */
+static void Int_lpc_1to3( Float32 lsp_old[], Float32 lsp_new[], Float32 az[] )
+{
+   Float32 lsp[M];
+   Word32 i;
+
+
+   for ( i = 0; i < M; i++ ) {
+      lsp[i] = lsp_new[i] * 0.25F + lsp_old[i] * 0.75F;
+   }
+
+   /* Subframe 1 */
+   Lsp_Az( lsp, az );
+   az += MP1;
+
+   for ( i = 0; i < M; i++ ) {
+      lsp[i] = ( lsp_old[i] + lsp_new[i] ) * 0.5F;
+   }
+
+   /* Subframe 2 */
+   Lsp_Az( lsp, az );
+   az += MP1;
+
+   for ( i = 0; i < M; i++ ) {
+      lsp[i] = lsp_old[i] * 0.25F + lsp_new[i] * 0.75F;
+   }
+
+   /* Subframe 3 */
+   Lsp_Az( lsp, az );
+   az += MP1;
+
+   /* Subframe 4 */
+   Lsp_Az( lsp_new, az );
+   return;
+}
+
+
+/*
+ * lsp
+ *
+ *
+ * Parameters:
+ *    req_mode          I: requested mode
+ *    used_mode         I: used mode
+ *    lsp_old           B: old LSP vector
+ *    lsp_old_q         B: old quantized LSP vector
+ *    past_rq           B: past quantized residual
+ *    az                B: interpolated LP parameters
+ *    azQ               O: quantization interpol. LP parameters
+ *    lsp_new           O: new lsp vector
+ *    anap              O: analysis parameters
+ *
+ * Function:
+ *    From A(z) to lsp. LSP quantization and interpolation
+ *
+ * Returns:
+ *    void
+ */
+static void lsp( enum Mode req_mode, enum Mode used_mode, Float32 *lsp_old,
+      Float32 *lsp_old_q, Float32 *past_rq, Float32 az[], Float32 azQ[], Float32
+      lsp_new[], Word16 **anap )
+{
+   Float32 lsp_new_q[M];   /* LSPs at 4th subframe */
+   Float32 lsp_mid[M], lsp_mid_q[M];   /* LSPs at 2nd subframe */
+   Word32 pred_init_i;   /* init index for MA prediction in DTX mode */
+
+
+   if ( req_mode == MR122 ) {
+      Az_lsp( &az[MP1], lsp_mid, lsp_old );
+      Az_lsp( &az[MP1 * 3], lsp_new, lsp_mid );
+
+      /*
+       * Find interpolated LPC parameters in all subframes
+       * (both quantized and unquantized).
+       * The interpolated parameters are in array A_t[] of size (M+1)*4
+       * and the quantized interpolated parameters are in array Aq_t[]
+       */
+      Int_lpc_1and3_2( lsp_old, lsp_mid, lsp_new, az );
+
+      if ( used_mode != MRDTX ) {
+         /* LSP quantization (lsp_mid[] and lsp_new[] jointly quantized) */
+         Q_plsf_5( past_rq, lsp_mid, lsp_new, lsp_mid_q, lsp_new_q, *anap );
+         Int_lpc_1and3( lsp_old_q, lsp_mid_q, lsp_new_q, azQ );
+
+         /* Advance analysis parameters pointer */
+         ( *anap ) += 5;
+      }
+   }
+   else {
+      /* From A(z) to lsp */
+      Az_lsp( &az[MP1 * 3], lsp_new, lsp_old );
+
+      /*
+       * Find interpolated LPC parameters in all subframes
+       * (both quantized and unquantized).
+       * The interpolated parameters are in array A_t[] of size (M+1)*4
+       * and the quantized interpolated parameters are in array Aq_t[]
+       */
+      Int_lpc_1to3_2( lsp_old, lsp_new, az );
+
+      /* LSP quantization */
+      if ( used_mode != MRDTX ) {
+         Q_plsf_3( req_mode, past_rq, lsp_new, lsp_new_q, *anap, &pred_init_i );
+         Int_lpc_1to3( lsp_old_q, lsp_new_q, azQ );
+
+         /* Advance analysis parameters pointer */
+         ( *anap ) += 3;
+      }
+   }
+
+   /* update the LSPs for the next frame */
+   memcpy( lsp_old, lsp_new, M <<2 );
+   memcpy( lsp_old_q, lsp_new_q, M <<2 );
+}
+
+
+/*
+ * check_lsp
+ *
+ *
+ * Parameters:
+ *    count          B: counter for resonance
+ *    lsp            B: LSP vector
+ *
+ * Function:
+ *    Check the LSP's to detect resonances
+ *
+ *    Resonances in the LPC filter are monitored to detect possible problem
+ *    areas where divergence between the adaptive codebook memories in
+ *    the encoder and the decoder could cause unstable filters in areas
+ *    with highly correlated continuos signals. Typically, this divergence
+ *    is due to channel errors.
+ *    The monitoring of resonance signals is performed using unquantized LSPs
+ *    q(i), i = 1,...,10. The algorithm utilises the fact that LSPs are
+ *    closely located at a peak in the spectrum. First, two distances,
+ *    dist 1 and dist 2 ,are calculated in two different regions,
+ *    defined as
+ *
+ *    dist1 = min[q(i) - q(i + 1)],  i = 4,...,8
+ *    dist2 = min[q(i) - q(i + 1)],  i = 2,3
+ *
+ *    Either of these two minimum distance conditions must be fulfilled
+ *    to classify the frame as a resonance frame and increase the resonance
+ *    counter.
+ *
+ *    if(dist1 < TH1) || if (dist2 < TH2)
+ *       counter++
+ *    else
+ *       counter = 0
+ *
+ *    TH1 = 0.046
+ *    TH2 = 0.018, q(2) > 0.98
+ *    TH2 = 0.024, 0.93 < q(2) <= 0.98
+ *    TH2 = 0.018, otherwise
+ *
+ *    12 consecutive resonance frames are needed to indicate possible
+ *    problem conditions, otherwise the LSP_flag is cleared.
+ *
+ * Returns:
+ *    resonance flag
+ */
+static Word16 check_lsp( Word16 *count, Float32 *lsp )
+{
+   Float32 dist, dist_min1, dist_min2, dist_th;
+   Word32 i;
+
+
+   /*
+    * Check for a resonance:
+    * Find minimum distance between lsp[i] and lsp[i+1]
+    */
+   dist_min1 = FLT_MAX;
+
+   for ( i = 3; i < 8; i++ ) {
+      dist = lsp[i] - lsp[i + 1];
+
+      if ( dist < dist_min1 ) {
+         dist_min1 = dist;
+      }
+   }
+   dist_min2 = FLT_MAX;
+
+   for ( i = 1; i < 3; i++ ) {
+      dist = lsp[i] - lsp[i + 1];
+
+      if ( dist < dist_min2 ) {
+         dist_min2 = dist;
+      }
+   }
+
+   if ( lsp[1] > 0.98F ) {
+      dist_th = 0.018F;
+   }
+   else if ( lsp[1] > 0.93F ) {
+      dist_th = 0.024F;
+   }
+   else {
+      dist_th = 0.034F;
+   }
+
+   if ( ( dist_min1 < 0.046F ) || ( dist_min2 < dist_th ) ) {
+      *count += 1;
+   }
+   else {
+      *count = 0;
+   }
+
+   /* Need 12 consecutive frames to set the flag */
+   if ( *count >= 12 ) {
+      *count = 12;
+      return 1;
+   }
+   else {
+      return 0;
+   }
+}
+
+
+/*
+ * Weight_Ai
+ *
+ *
+ * Parameters:
+ *    a                 I: LPC coefficients                    [M+1]
+ *    fac               I: Spectral expansion factors.         [M+1]
+ *    a_exp             O: Spectral expanded LPC coefficients  [M+1]
+ *
+ * Function:
+ *    Spectral expansion of LP coefficients
+ *
+ * Returns:
+ *    void
+ */
+static void Weight_Ai( Float32 a[], const Float32 fac[], Float32 a_exp[] )
+{
+   Word32 i;
+
+
+   a_exp[0] = a[0];
+
+   for ( i = 1; i <= M; i++ ) {
+      a_exp[i] = a[i] * fac[i - 1];
+   }
+   return;
+}
+
+
+/*
+ * Residu
+ *
+ *
+ * Parameters:
+ *    a                 I: prediction coefficients
+ *    x                 I: speech signal
+ *    y                 O: residual signal
+ *
+ * Function:
+ *    Computes the LTP residual signal.
+ *
+ * Returns:
+ *    void
+ */
+static void Residu( Float32 a[], Float32 x[], Float32 y[] )
+{
+   Float32 s;
+   Word32 i;
+
+
+   for ( i = 0; i < L_SUBFR; i += 4 ) {
+      s = x[i] * a[0];
+      s += x[i - 1] *a[1];
+      s += x[i - 2] * a[2];
+      s += x[i - 3] * a[3];
+      s += x[i - 4] * a[4];
+      s += x[i - 5] * a[5];
+      s += x[i - 6] * a[6];
+      s += x[i - 7] * a[7];
+      s += x[i - 8] * a[8];
+      s += x[i - 9] * a[9];
+      s += x[i - 10] * a[10];
+      y[i] = s;
+      s = x[i + 1] *a[0];
+      s += x[i] * a[1];
+      s += x[i - 1] *a[2];
+      s += x[i - 2] * a[3];
+      s += x[i - 3] * a[4];
+      s += x[i - 4] * a[5];
+      s += x[i - 5] * a[6];
+      s += x[i - 6] * a[7];
+      s += x[i - 7] * a[8];
+      s += x[i - 8] * a[9];
+      s += x[i - 9] * a[10];
+      y[i + 1] = s;
+      s = x[i + 2] * a[0];
+      s += x[i + 1] *a[1];
+      s += x[i] * a[2];
+      s += x[i - 1] *a[3];
+      s += x[i - 2] * a[4];
+      s += x[i - 3] * a[5];
+      s += x[i - 4] * a[6];
+      s += x[i - 5] * a[7];
+      s += x[i - 6] * a[8];
+      s += x[i - 7] * a[9];
+      s += x[i - 8] * a[10];
+      y[i + 2] = s;
+      s = x[i + 3] * a[0];
+      s += x[i + 2] * a[1];
+      s += x[i + 1] *a[2];
+      s += x[i] * a[3];
+      s += x[i - 1] *a[4];
+      s += x[i - 2] * a[5];
+      s += x[i - 3] * a[6];
+      s += x[i - 4] * a[7];
+      s += x[i - 5] * a[8];
+      s += x[i - 6] * a[9];
+      s += x[i - 7] * a[10];
+      y[i + 3] = s;
+   }
+   return;
+}
+
+
+/*
+ * Syn_filt
+ *
+ *
+ * Parameters:
+ *    a                 I: prediction coefficients [M+1]
+ *    x                 I: input signal
+ *    y                 O: output signal
+ *    mem               B: memory associated with this filtering
+ *    update            I: 0=no update, 1=update of memory.
+ *
+ * Function:
+ *    Perform synthesis filtering through 1/A(z).
+ *
+ * Returns:
+ *    void
+ */
+static void Syn_filt( Float32 a[], Float32 x[], Float32 y[], Float32 mem[],
+      Word16 update )
+{
+   Float64 tmp[50];
+   Float64 sum;
+   Float64 *yy;
+   Word32 i;
+
+
+   /* Copy mem[] to yy[] */
+   yy = tmp;
+
+   for ( i = 0; i < M; i++ ) {
+      *yy++ = mem[i];
+   }
+
+   /* Do the filtering. */
+   for ( i = 0; i < L_SUBFR; i = i + 4 ) {
+      sum = x[i] * a[0];
+      sum -= a[1] * yy[ - 1];
+      sum -= a[2] * yy[ - 2];
+      sum -= a[3] * yy[ - 3];
+      sum -= a[4] * yy[ - 4];
+      sum -= a[5] * yy[ - 5];
+      sum -= a[6] * yy[ - 6];
+      sum -= a[7] * yy[ - 7];
+      sum -= a[8] * yy[ - 8];
+      sum -= a[9] * yy[ - 9];
+      sum -= a[10] * yy[ - 10];
+      *yy++ = sum;
+      y[i] = ( Float32 )yy[ - 1];
+      sum = x[i + 1] *a[0];
+      sum -= a[1] * yy[ - 1];
+      sum -= a[2] * yy[ - 2];
+      sum -= a[3] * yy[ - 3];
+      sum -= a[4] * yy[ - 4];
+      sum -= a[5] * yy[ - 5];
+      sum -= a[6] * yy[ - 6];
+      sum -= a[7] * yy[ - 7];
+      sum -= a[8] * yy[ - 8];
+      sum -= a[9] * yy[ - 9];
+      sum -= a[10] * yy[ - 10];
+      *yy++ = sum;
+      y[i + 1] = ( Float32 )yy[ - 1];
+      sum = x[i + 2] * a[0];
+      sum -= a[1] * yy[ - 1];
+      sum -= a[2] * yy[ - 2];
+      sum -= a[3] * yy[ - 3];
+      sum -= a[4] * yy[ - 4];
+      sum -= a[5] * yy[ - 5];
+      sum -= a[6] * yy[ - 6];
+      sum -= a[7] * yy[ - 7];
+      sum -= a[8] * yy[ - 8];
+      sum -= a[9] * yy[ - 9];
+      sum -= a[10] * yy[ - 10];
+      *yy++ = sum;
+      y[i + 2] = ( Float32 )yy[ - 1];
+      sum = x[i + 3] * a[0];
+      sum -= a[1] * yy[ - 1];
+      sum -= a[2] * yy[ - 2];
+      sum -= a[3] * yy[ - 3];
+      sum -= a[4] * yy[ - 4];
+      sum -= a[5] * yy[ - 5];
+      sum -= a[6] * yy[ - 6];
+      sum -= a[7] * yy[ - 7];
+      sum -= a[8] * yy[ - 8];
+      sum -= a[9] * yy[ - 9];
+      sum -= a[10] * yy[ - 10];
+      *yy++ = sum;
+      y[i + 3] = ( Float32 )yy[ - 1];
+   }
+
+   /* Update of memory if update==1 */
+   if ( update != 0 ) {
+      for ( i = 0; i < M; i++ ) {
+         mem[i] = y[30 + i];
+      }
+   }
+   return;
+}
+
+
+/*
+ * pre_big
+ *
+ *
+ * Parameters:
+ *    mode              I: AMR mode
+ *    gamma1            I: spectral exp. factor 1
+ *    gamma1_12k2       I: spectral exp. factor 1 for modes above MR795
+ *    gamma2            I: spectral exp. factor 2
+ *    A_t               I: A(z) unquantized, for 4 subframes
+ *    frame_offset      I: frameoffset, 1st or second big_sbf
+ *    speech            I: speech
+ *    mem_w             B: synthesis filter memory state
+ *    wsp               O: weighted speech
+ *
+ * Function:
+ *    Big subframe (2 subframes) preprocessing
+ *
+ *    Open-loop pitch analysis is performed in order to simplify the pitch
+ *    analysis and confine the closed-loop pitch search to a small number of
+ *    lags around the open-loop estimated lags.
+ *    Open-loop pitch estimation is based on the weighted speech signal Sw(n)
+ *    which is obtained by filtering the input speech signal through
+ *    the weighting filter
+ *
+ *    W(z) = A(z/g1) / A(z/g2)
+ *
+ *    That is, in a subframe of size L, the weighted speech is given by:
+ *
+ *                    10                           10
+ *    Sw(n) = S(n) + SUM[a(i) * g1(i) * S(n-i)] - SUM[a(i) * g2(i) * Sw(n-i)],
+ *                   i=1                          i=1
+ *    n = 0, ..., L-1
+ *
+ * Returns:
+ *    void
+ */
+static Word32 pre_big( enum Mode mode, const Float32 gamma1[], const Float32
+      gamma1_12k2[], const Float32 gamma2[], Float32 A_t[], Word16 frame_offset,
+      Float32 speech[], Float32 mem_w[], Float32 wsp[] )
+{
+   Float32 Ap1[MP1], Ap2[MP1];
+   Word32 offset, i;
+
+
+   /* A(z) with spectral expansion */
+   const Float32 *g1;
+
+
+   g1 = gamma1_12k2;
+
+   if ( mode <= MR795 ) {
+      g1 = gamma1;
+   }
+   offset = 0;
+
+   if ( frame_offset > 0 ) {
+      offset = MP1 << 1;
+   }
+
+   /* process two subframes (which form the "big" subframe) */
+   for ( i = 0; i < 2; i++ ) {
+      /* a(i) * g1(i) */
+      Weight_Ai( &A_t[offset], g1, Ap1 );
+
+      /* a(i) * g2(i) */
+      Weight_Ai( &A_t[offset], gamma2, Ap2 );
+
+      /*
+       *       10
+       *  S(n) + SUM[a(i) * g1(i) * S(n-i)]
+       *       i=1
+       */
+      Residu( Ap1, &speech[frame_offset], &wsp[frame_offset] );
+
+      /*
+       *          10                            10
+       *  S(n) + SUM[a(i) * g1(i) * S(n-i)]    SUM[a(i) * g2(i) * Sn(n-i)]
+       *         i=1                           i=1
+       */
+      Syn_filt( Ap2, &wsp[frame_offset], &wsp[frame_offset], mem_w, 1 );
+      offset += MP1;
+      frame_offset += L_SUBFR;
+   }
+   return 0;
+}
+
+
+/*
+ * comp_corr
+ *
+ *
+ * Parameters:
+ *    sig               I: signal
+ *    L_frame           I: length of frame to compute pitch
+ *    lag_max           I: maximum lag
+ *    lag_min           I: minimum lag
+ *    corr              O: correlation of selected lag
+ *
+ * Function:
+ *    Calculate all correlations in a given delay range.
+ *
+ * Returns:
+ *    void
+ */
+static void comp_corr( Float32 sig[], Word32 L_frame, Word32 lag_max, Word32
+      lag_min, Float32 corr[] )
+{
+   Word32 i, j;
+   Float32 *p, *p1;
+   Float32 T0;
+
+
+   for ( i = lag_max; i >= lag_min; i-- ) {
+      p = sig;
+      p1 = &sig[ - i];
+      T0 = 0.0F;
+
+      for ( j = 0; j < L_frame; j = j + 40, p += 40, p1 += 40 ) {
+         T0 += p[0] * p1[0] + p[1] * p1[1] + p[2] * p1[2] + p[3] * p1[3];
+         T0 += p[4] * p1[4] + p[5] * p1[5] + p[6] * p1[6] + p[7] * p1[7];
+         T0 += p[8] * p1[8] + p[9] * p1[9] + p[10] * p1[10] + p[11] * p1[11];
+         T0 += p[12] * p1[12] + p[13] * p1[13] + p[14] * p1[14] + p[15] * p1[15]
+         ;
+         T0 += p[16] * p1[16] + p[17] * p1[17] + p[18] * p1[18] + p[19] * p1[19]
+         ;
+         T0 += p[20] * p1[20] + p[21] * p1[21] + p[22] * p1[22] + p[23] * p1[23]
+         ;
+         T0 += p[24] * p1[24] + p[25] * p1[25] + p[26] * p1[26] + p[27] * p1[27]
+         ;
+         T0 += p[28] * p1[28] + p[29] * p1[29] + p[30] * p1[30] + p[31] * p1[31]
+         ;
+         T0 += p[32] * p1[32] + p[33] * p1[33] + p[34] * p1[34] + p[35] * p1[35]
+         ;
+         T0 += p[36] * p1[36] + p[37] * p1[37] + p[38] * p1[38] + p[39] * p1[39]
+         ;
+      }
+      corr[ - i] = T0;
+   }
+   return;
+}
+
+
+/*
+ * vad_tone_detection
+ *
+ *
+ * Parameters:
+ *    st->tone          B: flags indicating presence of a tone
+ *    T0                I: autocorrelation maxima
+ *    t1                I: energy
+ *
+ * Function:
+ *    Set tone flag if pitch gain is high.
+ *    This is used to detect signaling tones and other signals
+ *    with high pitch gain.
+ *
+ * Returns:
+ *    void
+ */
+#ifndef VAD2
+static void vad_tone_detection( vadState *st, Float32 T0, Float32 t1 )
+{
+   if ( ( t1 > 0 ) && ( T0 > t1 * TONE_THR ) ) {
+      st->tone = st->tone | 0x00004000;
+   }
+}
+#endif
+
+/*
+ * Lag_max
+ *
+ *
+ * Parameters:
+ *    vadSt          B: vad structure
+ *    corr           I: correlation vector
+ *    sig            I: signal
+ *    L_frame        I: length of frame to compute pitch
+ *    lag_max        I: maximum lag
+ *    lag_min        I: minimum lag
+ *    cor_max        O: maximum correlation
+ *    dtx            I: dtx on/off
+ *
+ * Function:
+ *    Compute the open loop pitch lag.
+ *
+ * Returns:
+ *    p_max             lag found
+ */
+#ifdef VAD2
+static Word16 Lag_max( Float32 corr[], Float32 sig[], Word16 L_frame,
+		       Word32 lag_max, Word32 lag_min, Float32 *cor_max,
+		       Word32 dtx, Float32 *rmax, Float32 *r0 )
+#else
+static Word16 Lag_max( vadState *vadSt, Float32 corr[], Float32 sig[], Word16
+      L_frame, Word32 lag_max, Word32 lag_min, Float32 *cor_max, Word32 dtx )
+#endif
+{
+   Float32 max, T0;
+   Float32 *p;
+   Word32 i, j, p_max;
+
+
+   max = -FLT_MAX;
+   p_max = lag_max;
+
+   for ( i = lag_max, j = ( PIT_MAX - lag_max - 1 ); i >= lag_min; i--, j-- ) {
+      if ( corr[ - i] >= max ) {
+         max = corr[ - i];
+         p_max = i;
+      }
+   }
+
+   /* compute energy for normalization */
+   T0 = 0.0F;
+   p = &sig[ - p_max];
+
+   for ( i = 0; i < L_frame; i++, p++ ) {
+      T0 += *p * *p;
+   }
+
+   if ( dtx ) {
+#ifdef VAD2
+     *rmax = max;
+     *r0 = T0;
+#else
+     /* check tone */
+     vad_tone_detection( vadSt, max, T0 );
+#endif
+   }
+
+   if ( T0 > 0.0F )
+      T0 = 1.0F / ( Float32 )sqrt( T0 );
+   else
+      T0 = 0.0F;
+
+   /* max = max/sqrt(energy) */
+   max *= T0;
+   *cor_max = max;
+   return( ( Word16 )p_max );
+}
+
+
+/*
+ * hp_max
+ *
+ *
+ * Parameters:
+ *    corr           I: correlation vector
+ *    sig            I: signal
+ *    L_frame        I: length of frame to compute pitch
+ *    lag_max        I: maximum lag
+ *    lag_min        I: minimum lag
+ *    cor_hp_max     O: max high-pass filtered correlation
+ *
+ * Function:
+ *    Find the maximum correlation of scal_sig[] in a given delay range.
+ *
+ *    The correlation is given by
+ *       cor[t] = <scal_sig[n],scal_sig[n-t]>,  t=lag_min,...,lag_max
+ *    The functions outputs the maximum correlation after normalization
+ *    and the corresponding lag.
+ *
+ * Returns:
+ *    void
+ */
+#ifndef VAD2
+static void hp_max( Float32 corr[], Float32 sig[], Word32 L_frame, Word32
+      lag_max, Word32 lag_min, Float32 *cor_hp_max )
+{
+   Float32 T0, t1, max;
+   Float32 *p, *p1;
+   Word32 i;
+
+
+   max = -FLT_MAX;
+   T0 = 0;
+
+   for ( i = lag_max - 1; i > lag_min; i-- ) {
+      /* high-pass filtering */
+      T0 = ( ( corr[ - i] * 2 ) - corr[ - i-1] )-corr[ - i + 1];
+      T0 = ( Float32 )fabs( T0 );
+
+      if ( T0 >= max ) {
+         max = T0;
+      }
+   }
+
+   /* compute energy */
+   p = sig;
+   p1 = &sig[0];
+   T0 = 0;
+
+   for ( i = 0; i < L_frame; i++, p++, p1++ ) {
+      T0 += *p * *p1;
+   }
+   p = sig;
+   p1 = &sig[ - 1];
+   t1 = 0;
+
+   for ( i = 0; i < L_frame; i++, p++, p1++ ) {
+      t1 += *p * *p1;
+   }
+
+   /* high-pass filtering */
+   T0 = T0 - t1;
+   T0 = ( Float32 )fabs( T0 );
+
+   /* max/T0 */
+   if ( T0 != 0 ) {
+      *cor_hp_max = max / T0;
+   }
+   else {
+      *cor_hp_max = 0;
+   }
+}
+#endif
+
+/*
+ * vad_tone_detection_update
+ *
+ *
+ * Parameters:
+ *    st->tone          B: flags indicating presence of a tone
+ *    one_lag_per_frame I: 1 open-loop lag is calculated per each frame
+ *
+ * Function:
+ *    Update the tone flag register.
+ *
+ * Returns:
+ *    void
+ */
+#ifndef VAD2
+static void vad_tone_detection_update( vadState *st, Word16 one_lag_per_frame )
+{
+   /* Shift tone flags right by one bit */
+   st->tone = st->tone >> 1;
+
+   /*
+    * If open-loop lag is calculated only once in each frame,
+    * do extra update and assume that the other tone flag
+    * of the frame is one.
+    */
+   if ( one_lag_per_frame != 0 ) {
+      st->tone = st->tone >> 1;
+      st->tone = st->tone | 0x00002000;
+   }
+}
+#endif
+
+/*
+ * Pitch_ol
+ *
+ *
+ * Parameters:
+ *    mode           I: AMR mode
+ *    vadSt          B: VAD state struct
+ *    signal         I: signal used to compute the open loop pitch
+ *                                                 [[-pit_max]:[-1]]
+ *    pit_min        I: minimum pitch lag
+ *    pit_max        I: maximum pitch lag
+ *    L_frame        I: length of frame to compute pitch
+ *    dtx            I: DTX flag
+ *    idx            I: frame index
+ *
+ * Function:
+ *    Compute the open loop pitch lag.
+ *
+ *    Open-loop pitch analysis is performed twice per frame (each 10 ms)
+ *    to find two estimates of the pitch lag in each frame.
+ *    Open-loop pitch analysis is performed as follows.
+ *    In the first step, 3 maxima of the correlation:
+ *
+ *          79
+ *    O(k) = SUM Sw(n)*Sw(n-k)
+ *          n=0
+ *
+ *    are found in the three ranges:
+ *       pit_min     ...      2*pit_min-1
+ *       2*pit_min   ...      4*pit_min-1
+ *       4*pit_min   ...      pit_max
+ *
+ *    The retained maxima O(t(i)), i = 1, 2, 3, are normalized by dividing by
+ *
+ *    SQRT[SUM[POW(Sw(n-t(i)), 2]], i = 1, 2, 3,
+ *         n
+ *
+ *    respectively.
+ *    The normalized maxima and corresponding delays are denoted by
+ *    (M(i), t(i)), i = 1, 2, 3. The winner, Top, among the three normalized
+ *    correlations is selected by favouring the delays with the values
+ *    in the lower range. This is performed by weighting the normalized
+ *    correlations corresponding to the longer delays. The best
+ *    open-loop delay Top is determined as follows:
+ *
+ *    Top = t(1)
+ *    M(Top) = M(1)
+ *    if M(2) > 0.85 * M(Top)
+ *       M(Top) = M(2)
+ *       Top = t(2)
+ *    end
+ *    if M(3) > 0.85 * M(Top)
+ *       M(Top) = M(3)
+ *       Top = t(3)
+ *    end
+ *
+ * Returns:
+ *    void
+ */
+static Word32 Pitch_ol( enum Mode mode, vadState *vadSt, Float32 signal[],
+      Word32 pit_min, Word32 pit_max, Word16 L_frame, Word32 dtx, Word16 idx )
+{
+   Float32 corr[PIT_MAX + 1];
+   Float32 max1, max2, max3, p_max1, p_max2, p_max3;
+   Float32 *corr_ptr;
+   Word32 i, j;
+#ifdef VAD2
+   Float32 r01, r02, r03;
+   Float32 rmax1, rmax2, rmax3;
+#else
+   Float32 corr_hp_max;
+#endif
+
+
+#ifndef VAD2
+   if ( dtx ) {
+      /* update tone detection */
+      if ( ( mode == MR475 ) || ( mode == MR515 ) ) {
+         vad_tone_detection_update( vadSt, 1 );
+      }
+      else {
+         vad_tone_detection_update( vadSt, 0 );
+      }
+   }
+#endif
+
+   corr_ptr = &corr[pit_max];
+
+   /*        79             */
+   /* O(k) = SUM Sw(n)*Sw(n-k)   */
+   /*        n=0               */
+   comp_corr( signal, L_frame, pit_max, pit_min, corr_ptr );
+
+#ifdef VAD2
+   /* Find a maximum for each section.	*/
+   /* Maxima 1	*/
+   j = pit_min << 2;
+   p_max1 =
+     Lag_max( corr_ptr, signal, L_frame, pit_max, j, &max1, dtx, &rmax1, &r01 );
+
+   /* Maxima 2	*/
+   i = j - 1;
+   j = pit_min << 1;
+   p_max2 = Lag_max( corr_ptr, signal, L_frame, i, j, &max2, dtx, &rmax2, &r02 );
+
+   /* Maxima 3	*/
+   i = j - 1;
+   p_max3 =
+     Lag_max( corr_ptr, signal, L_frame, i, pit_min, &max3, dtx, &rmax3, &r03 );
+#else
+   /* Find a maximum for each section.	*/
+   /* Maxima 1	*/
+   j = pit_min << 2;
+   p_max1 = Lag_max( vadSt, corr_ptr, signal, L_frame, pit_max, j, &max1, dtx );
+
+   /* Maxima 2 */
+   i = j - 1;
+   j = pit_min << 1;
+   p_max2 = Lag_max( vadSt, corr_ptr, signal, L_frame, i, j, &max2, dtx );
+
+   /* Maxima 3 */
+   i = j - 1;
+   p_max3 = Lag_max( vadSt, corr_ptr, signal, L_frame, i, pit_min, &max3, dtx );
+
+   if ( dtx ) {
+      if ( idx == 1 ) {
+         /* calculate max high-passed filtered correlation of all lags */
+         hp_max( corr_ptr, signal, L_frame, pit_max, pit_min, &corr_hp_max );
+
+         /* update complex background detector */
+         vadSt->best_corr_hp = corr_hp_max * 0.5F;
+      }
+   }
+#endif
+
+   /* The best open-loop delay */
+   if ( ( max1 * 0.85F ) < max2 ) {
+      max1 = max2;
+      p_max1 = p_max2;
+#ifdef VAD2
+      if (dtx) {
+	rmax1 = rmax2;
+	r01 = r02;
+      }
+#endif
+   }
+
+   if ( ( max1 * 0.85F ) < max3 ) {
+      p_max1 = p_max3;
+#ifdef VAD2
+      if (dtx) {
+	rmax1 = rmax3;
+	r01 = r03;
+      }
+#endif
+   }
+#ifdef VAD2
+   if (dtx) {
+     vadSt->Rmax += rmax1;   /* Save max correlation */
+     vadSt->R0   += r01;     /* Save max energy */
+   }
+#endif
+   return( Word32 )p_max1;
+}
+
+
+/*
+ * Lag_max_wght
+ *
+ *
+ * Parameters:
+ *    vadSt          B: vad structure
+ *    corr           I: correlation vector
+ *    signal         I: signal
+ *    L_frame        I: length of frame to compute pitch
+ *    old_lag        I: old open-loop lag
+ *    cor_max        O: maximum correlation
+ *    wght_flg       I: weighting function flag
+ *    gain_flg       O: open-loop flag
+ *    dtx            I: dtx on/off
+ *
+ * Function:
+ *    Find the lag that has maximum correlation of signal in a given delay range.
+ *    maximum lag = 143
+ *    minimum lag = 20
+ *
+ * Returns:
+ *    p_max             lag found
+ */
+static Word32 Lag_max_wght( vadState *vadSt, Float32 corr[], Float32 signal[],
+      Word32 old_lag, Word32 *cor_max, Word32 wght_flg, Float32 *gain_flg,
+      Word32 dtx )
+{
+   Float32 t0, t1, max;
+   Float32 *psignal, *p1signal;
+   const Float32 *ww, *we;
+   Word32 i, j, p_max;
+
+
+   ww = &corrweight[250];
+   we = &corrweight[266 - old_lag];
+   max = -FLT_MAX;
+   p_max = PIT_MAX;
+
+   /* see if the neigbouring emphasis is used */
+   if ( wght_flg > 0 ) {
+      /* find maximum correlation with weighting */
+      for ( i = PIT_MAX; i >= PIT_MIN; i-- ) {
+         /* Weighting of the correlation function. */
+         t0 = corr[ - i] * *ww--;
+          /* Weight the neighbourhood of the old lag. */
+         t0 *= *we--;
+
+         if ( t0 >= max ) {
+            max = t0;
+            p_max = i;
+         }
+      }
+
+   }
+   else {
+      /* find maximum correlation with weighting */
+      for ( i = PIT_MAX; i >= PIT_MIN; i-- ) {
+         /* Weighting of the correlation function. */
+         t0 = corr[ - i] * *ww--;
+
+         if ( t0 >= max ) {
+            max = t0;
+            p_max = i;
+         }
+      }
+
+   }
+   psignal = &signal[0];
+   p1signal = &signal[ - p_max];
+   t0 = 0;
+   t1 = 0;
+
+   /* Compute energy */
+   for ( j = 0; j < L_FRAME_BY2; j++, psignal++, p1signal++ ) {
+      t0 += *psignal * *p1signal;
+      t1 += *p1signal * *p1signal;
+   }
+
+   if ( dtx ) {
+#ifdef VAD2
+       vadSt->Rmax += t0;   /* Save max correlation */
+       vadSt->R0   += t1;   /* Save max energy */
+#else
+      /* update and detect tone */
+      vad_tone_detection_update( vadSt, 0 );
+      vad_tone_detection( vadSt, t0, t1 );
+#endif
+   }
+
+   /*
+    * gain flag is set according to the open_loop gain
+    * is t2/t1 > 0.4 ?
+    */
+   *gain_flg = t0 - ( t1 * 0.4F );
+   *cor_max = 0;
+   return( p_max );
+}
+
+
+/*
+ * gmed_n
+ *
+ *
+ * Parameters:
+ *    ind               I: values
+ *    n                 I: The number of gains
+ *
+ * Function:
+ *    Calculates N-point median.
+ *
+ * Returns:
+ *    index of the median value
+ */
+static Word32 gmed_n( Word32 ind[], Word32 n )
+{
+   Word32 i, j, ix = 0;
+   Word32 max;
+   Word32 medianIndex;
+   Word32 tmp[9];
+   Word32 tmp2[9];
+
+
+   for ( i = 0; i < n; i++ ) {
+      tmp2[i] = ind[i];
+   }
+
+   for ( i = 0; i < n; i++ ) {
+      max = -32767;
+
+      for ( j = 0; j < n; j++ ) {
+         if ( tmp2[j] >= max ) {
+            max = tmp2[j];
+            ix = j;
+         }
+      }
+      tmp2[ix] = -32768;
+      tmp[i] = ix;
+   }
+   medianIndex = tmp[( n >>1 )];
+   return( ind[medianIndex] );
+}
+
+
+/*
+ * Pitch_ol_wgh
+ *
+ *
+ * Parameters:
+ *    old_T0_med     O: old Cl lags median
+ *    wght_flg       I: weighting function flag
+ *    ada_w          B:
+ *    vadSt          B: VAD state struct
+ *    signal         I: signal used to compute the open loop pitch
+ *                                                  [[-pit_max]:[-1]]
+ *    old_lags       I: history with old stored Cl lags
+ *    ol_gain_flg    I: OL gain flag
+ *    idx            I: frame index
+ *    dtx            I: DTX flag
+ *
+ * Function:
+ *    Open-loop pitch search with weight
+ *
+ *    Open-loop pitch analysis is performed twice per frame (every 10 ms)
+ *    for the 10.2 kbit/s mode to find two estimates of the pitch lag
+ *    in each frame. The open-loop pitch analysis is done in order to simplify
+ *    the pitch analysis and confine the closed loop pitch search to
+ *    a small number of lags around the open-loop estimated lags.
+ *    Open-loop pitch estimation is based on the weighted speech signal
+ *    which is obtained by filtering the input speech signal through
+ *    the weighting filter.
+ *    The correlation of weighted speech is determined.
+ *    The estimated pitch-lag is the delay that maximises
+ *    the weighted autocorrelation function. To enhance  pitch-lag analysis
+ *    the autocorrelation function estimate is modified by a weighting window.
+ *    The weighting emphasises relevant pitch-lags, thus increasing
+ *    the likelihood of selecting the correct delay.
+ *    minimum pitch lag = 20
+ *    maximum pitch lag = 143
+ *
+ * Returns:
+ *    p_max1            open loop pitch lag
+ */
+static Word32 Pitch_ol_wgh( Word32 *old_T0_med, Word16 *wght_flg, Float32 *ada_w,
+      vadState *vadSt, Float32 signal[], Word32 old_lags[], Float32 ol_gain_flg[],
+      Word16 idx, Word32 dtx )
+{
+   Float32 corr[PIT_MAX + 1];
+#ifndef VAD2
+   Float32 corr_hp_max;
+#endif
+   Float32 *corrPtr;
+   Word32 i, max1, p_max1;
+
+
+   /* calculate all coreelations of signal, from pit_min to pit_max */
+   corrPtr = &corr[PIT_MAX];
+   comp_corr( signal, L_FRAME_BY2, PIT_MAX, PIT_MIN, corrPtr );
+   p_max1 = Lag_max_wght( vadSt, corrPtr, signal, *old_T0_med,
+         &max1, *wght_flg, &ol_gain_flg[idx], dtx );
+
+   if ( ol_gain_flg[idx] > 0 ) {
+      /* Calculate 5-point median of previous lags */
+      /* Shift buffer */
+      for ( i = 4; i > 0; i-- ) {
+         old_lags[i] = old_lags[i - 1];
+      }
+      old_lags[0] = p_max1;
+      *old_T0_med = gmed_n( old_lags, 5 );
+      *ada_w = 1;
+   }
+   else {
+      *old_T0_med = p_max1;
+      *ada_w = *ada_w * 0.9F;
+   }
+
+   if ( *ada_w < 0.3 ) {
+      *wght_flg = 0;
+   }
+   else {
+      *wght_flg = 1;
+   }
+
+#ifndef VAD2
+   if ( dtx ) {
+      if ( idx == 1 ) {
+         /* calculate max high-passed filtered correlation of all lags */
+         hp_max( corrPtr, signal, L_FRAME_BY2, PIT_MAX, PIT_MIN, &corr_hp_max );
+
+         /* update complex background detector */
+         vadSt->best_corr_hp = corr_hp_max * 0.5F;
+      }
+   }
+#endif
+   return( p_max1 );
+}
+
+
+/*
+ * ol_ltp
+ *
+ *
+ * Parameters:
+ *    mode              I: AMR mode
+ *    vadSt             B: VAD state struct
+ *    wsp               I: signal used to compute the OL pitch
+ *    T_op              O: open loop pitch lag
+ *    ol_gain_flg       I: OL gain flag
+ *    old_T0_med        O: old Cl lags median
+ *    wght_flg          I: weighting function flag
+ *    ada_w             B:
+ *    old_lags          I: history with old stored Cl lags
+ *    ol_gain_flg       I: OL gain flag
+ *    dtx               I: DTX flag
+ *    idx               I: frame index
+ *
+ * Function:
+ *    Compute the open loop pitch lag.
+ *
+ *    Open-loop pitch analysis is performed in order to simplify
+ *    the pitch analysis and confine the closed-loop pitch search to
+ *    a small number of lags around the open-loop estimated lags.
+ *    Open-loop pitch estimation is based on the weighted speech signal Sw(n)
+ *    which is obtained by filtering the input speech signal through
+ *    the weighting filter W(z) = A(z/g1) / A(z/g2). That is,
+ *    in a subframe of size L, the weighted speech is given by:
+ *
+ *                10
+ *    Sw(n) = S(n) + SUM[ a(i) * g1(i) * S(n-i) ]
+ *                i=1
+ *                   10
+ *                - SUM[ a(i) * g2(i) * Sw(n-i) ], n = 0, ..., L-1
+ *                  i=1
+ *
+ * Returns:
+ *    void
+ */
+static void ol_ltp( enum Mode mode, vadState *vadSt, Float32 wsp[], Word32 *T_op
+      , Float32 ol_gain_flg[], Word32 *old_T0_med, Word16 *wght_flg, Float32 *ada_w
+      , Word32 *old_lags, Word32 dtx, Word16 idx )
+{
+   if ( mode != MR102 ) {
+      ol_gain_flg[0] = 0;
+      ol_gain_flg[1] = 0;
+   }
+
+   if ( ( mode == MR475 ) || ( mode == MR515 ) ) {
+      *T_op = Pitch_ol( mode, vadSt, wsp, PIT_MIN, PIT_MAX, L_FRAME, dtx, idx );
+   }
+   else {
+      if ( mode <= MR795 ) {
+         *T_op = Pitch_ol( mode, vadSt, wsp, PIT_MIN, PIT_MAX, L_FRAME_BY2, dtx,
+               idx );
+      }
+      else if ( mode == MR102 ) {
+         *T_op = Pitch_ol_wgh( old_T0_med, wght_flg, ada_w, vadSt, wsp, old_lags,
+            ol_gain_flg, idx, dtx );
+      }
+      else {
+         *T_op = Pitch_ol( mode, vadSt, wsp, PIT_MIN_MR122, PIT_MAX, L_FRAME_BY2
+               , dtx, idx );
+      }
+   }
+}
+
+
+/*
+ * subframePreProc
+ *
+ *
+ * Parameters:
+ *    mode           I: AMR mode
+ *    gamma1         I: spectral exp. factor 1
+ *    gamma1_12k2    I: spectral exp. factor 1 for EFR
+ *    gamma2         I: spectral exp. factor 2
+ *    A              I: A(z) unquantized for the 4 subframes
+ *    Aq             I: A(z)   quantized for the 4 subframes
+ *    speech         I: speech segment
+ *    mem_err        I: pointer to error signal
+ *    mem_w0         I: memory of weighting filter
+ *    zero           I: pointer to zero vector
+ *    ai_zero        O: history of weighted synth. filter
+ *    exc            O: long term prediction residual
+ *    h1             O: impulse response
+ *    xn             O: target vector for pitch search
+ *    res2           O: long term prediction residual
+ *    error          O: error of LPC synthesis filter
+ *
+ * Function:
+ *    Subframe preprocessing
+ *
+ *    Impulse response computation:
+ *       The impulse response, h(n), of the weighted synthesis filter
+ *
+ *       H(z) * W(z) = A(z/g1) / ( A'(z) * A(z/g2) )
+ *
+ *       is computed each subframe. This impulse response is needed for
+ *       the search of adaptive and fixed codebooks. The impulse response h(n)
+ *       is computed by filtering the vector of coefficients of
+ *       the filter A(z/g1) extended by zeros through the two filters
+ *       1/A'(z) and 1/A(z/g2).
+ *
+ *    Target signal computation:
+ *       The target signal for adaptive codebook search is usually computed
+ *       by subtracting the zero input response of
+ *       the weighted synthesis filter H(z) * W(z) from the weighted
+ *       speech signal Sw(n). This is performed on a subframe basis.
+ *       An equivalent procedure for computing the target signal is
+ *       the filtering of the LP residual signal res(n) through
+ *       the combination of synthesis filter 1/A'(z) and
+ *       the weighting filter A(z/g1)/A(z/g2). After determining
+ *       the excitation for the subframe, the initial states of
+ *       these filters are updated by filtering the difference between
+ *       the LP residual and excitation.
+ *
+ *       The residual signal res(n) which is needed for finding
+ *       the target vector is also used in the adaptive codebook search
+ *       to extend the past excitation buffer. This simplifies
+ *       the adaptive codebook search procedure for delays less than
+ *       the subframe size of 40. The LP residual is given by:
+ *
+ *                        10
+ *       res(n) = S(n) + SUM[A'(i)* S(n-i)
+ *                       i=1
+ *
+ * Returns:
+ *    void
+ */
+static void subframePreProc( enum Mode mode, const Float32 gamma1[], const
+      Float32 gamma1_12k2[], const Float32 gamma2[], Float32 *A, Float32 *Aq,
+      Float32 *speech, Float32 *mem_err, Float32 *mem_w0, Float32 *zero, Float32
+      ai_zero[], Float32 *exc, Float32 h1[], Float32 xn[], Float32 res2[],
+      Float32 error[] )
+{
+   Float32 Ap1[MP1];   /* weighted LPC coefficients */
+   Float32 Ap2[MP1];   /* weighted LPC coefficients */
+   const Float32 *g1;
+
+
+   /* mode specific pointer to gamma1 values */
+   g1 = gamma1;
+
+   if ( ( mode == MR122 ) || ( mode == MR102 ) ) {
+      g1 = gamma1_12k2;
+   }
+
+   /* Find the weighted LPC coefficients for the weighting filter. */
+   Weight_Ai( A, g1, Ap1 );
+   Weight_Ai( A, gamma2, Ap2 );
+
+   /*
+    * Compute impulse response, h1[],
+    * of weighted synthesis filter A(z/g1)/A(z/g2)
+    */
+   memcpy( ai_zero, Ap1, MP1 <<2 );
+   Syn_filt( Aq, ai_zero, h1, zero, 0 );
+   Syn_filt( Ap2, h1, h1, zero, 0 );
+
+   /*
+    * Find the target vector for pitch search:
+    */
+   /* LP residual */
+   Residu( Aq, speech, res2 );
+   memcpy( exc, res2, L_SUBFR <<2 );
+
+   /* Synthesis filter */
+   Syn_filt( Aq, exc, error, mem_err, 0 );
+   Residu( Ap1, error, xn );
+
+   /* target signal xn[] */
+   Syn_filt( Ap2, xn, xn, mem_w0, 0 );
+}
+
+
+/*
+ * getRange
+ *
+ *
+ * Parameters:
+ *    T0                I: integer pitch
+ *    delta_low         I: search start offset
+ *    delta_range       I: search range
+ *    pitmin            I: minimum pitch
+ *    pitmax            I: maximum pitch
+ *    T0_min            I: search range minimum
+ *    T0_max            I: search range maximum
+ *
+ * Function:
+ *    Sets range around open-loop pitch or integer pitch of last subframe
+ *
+ *    Takes integer pitch T0 and calculates a range around it with
+ *    T0_min = T0-delta_low and T0_max = (T0-delta_low) + delta_range
+ *    T0_min and T0_max are bounded by pitmin and pitmax
+ *
+ * Returns:
+ *    void
+ */
+static void getRange( Word32 T0, Word16 delta_low, Word16 delta_range,
+      Word16 pitmin, Word16 pitmax, Word32 *T0_min, Word32 *T0_max )
+{
+   *T0_min = T0 - delta_low;
+
+   if ( *T0_min < pitmin ) {
+      *T0_min = pitmin;
+   }
+   *T0_max = *T0_min + delta_range;
+
+   if ( *T0_max > pitmax ) {
+      *T0_max = pitmax;
+      *T0_min = *T0_max - delta_range;
+   }
+}
+
+
+/*
+ * Norm_Corr
+ *
+ *
+ * Parameters:
+ *    exc         I: excitation buffer                      [L_SUBFR]
+ *    xn          I: target vector                          [L_SUBFR]
+ *    h           I: impulse response of synthesis and weighting filters
+ *                                                          [L_SUBFR]
+ *    t_min       I: interval to compute normalized correlation
+ *    t_max       I: interval to compute normalized correlation
+ *    corr_norm   O: Normalized correlation                 [wT_min-wT_max]
+ *
+ * Function:
+ *    Normalized correlation
+ *
+ *    The closed-loop pitch search is performed by minimizing
+ *    the mean-square weighted error between the original and
+ *    synthesized speech. This is achieved by maximizing the term:
+ *
+ *            39                           39
+ *    R(k) = SUM[ X(n) * Yk(n)) ] / SQRT[ SUM[ Yk(n) * Yk(n)] ]
+ *           n=0                          n=0
+ *
+ *    where X(n) is the target signal and Yk(n) is the past filtered
+ *    excitation at delay k (past excitation convolved with h(n) ).
+ *    The search range is limited around the open-loop pitch.
+ *
+ *    The convolution Yk(n) is computed for the first delay t_min in
+ *    the searched range, and for the other delays in the search range
+ *    k = t_min + 1, ..., t_max, it is updated using the recursive relation:
+ *
+ *    Yk(n) = Yk-1(n-1) + u(-k) * h(n),
+ *
+ *    where u(n), n = -( 143 + 11 ), ..., 39, is the excitation buffer.
+ *    Note that in search stage, the samples u(n), n = 0, ..., 39,
+ *    are not known, and they are needed for pitch delays less than 40.
+ *    To simplify the search, the LP residual is copied to u(n) in order
+ *    to make the relation in above equation valid for all delays.
+ *
+ * Returns:
+ *    void
+ */
+static void Norm_Corr( Float32 exc[], Float32 xn[], Float32 h[], Word32 t_min,
+      Word32 t_max, Float32 corr_norm[] )
+{
+   Float32 exc_temp[L_SUBFR];
+   Float32 *p_exc;
+   Float32 corr, norm;
+   Float32 sum;
+   Word32 i, j, k;
+
+
+   k = -t_min;
+   p_exc = &exc[ - t_min];
+
+   /* compute the filtered excitation for the first delay t_min */
+   /* convolution Yk(n) */
+   for ( j = 0; j < L_SUBFR; j++ ) {
+      sum = 0;
+
+      for ( i = 0; i <= j; i++ ) {
+         sum += p_exc[i] * h[j - i];
+      }
+      exc_temp[j] = sum;
+   }
+
+   /* loop for every possible period */
+   for ( i = t_min; i <= t_max; i++ ) {
+      /*        39                     */
+      /* SQRT[ SUM[ Yk(n) * Yk(n)] ]   */
+      /*       n=0                     */
+      norm = (Float32)Dotproduct40( exc_temp, exc_temp );
+
+      if ( norm == 0 )
+         norm = 1.0;
+      else
+         norm = ( Float32 )( 1.0 / ( sqrt( norm ) ) );
+
+      /*        39                  */
+      /* SQRT[ SUM[ X(n) * Yk(n)] ] */
+      /*       n=0                  */
+      corr = (Float32)Dotproduct40( xn, exc_temp );
+
+      /* R(k) */
+      corr_norm[i] = corr * norm;
+
+      /* modify the filtered excitation exc_tmp[] for the next iteration */
+      if ( i != t_max ) {
+         k--;
+
+         for ( j = L_SUBFR - 1; j > 0; j-- ) {
+            /* Yk(n) = Yk-1(n-1) + u(-k) * h(n) */
+            exc_temp[j] = exc_temp[j - 1] + exc[k] * h[j];
+         }
+         exc_temp[0] = exc[k];
+      }
+   }
+}
+
+
+/*
+ * Interpol_3or6
+ *
+ *
+ * Parameters:
+ *    x                 I: input vector
+ *    frac              I: fraction  (-2..2 for 3*, -3..3 for 6*)
+ *    flag3             I: if set, upsampling rate = 3 (6 otherwise)
+ *
+ * Function:
+ *    Interpolating the normalized correlation with 1/3 or 1/6 resolution.
+ *
+ *    The interpolation is performed using an FIR filter b24
+ *    based on a Hamming windowed sin(x)/x function truncated at 23
+ *    and padded with zeros at 24 (b24(24) = 0). The filter has its
+ *    cut-off frequency (-3 dB) at 3 600 Hz in the over-sampled domain.
+ *    The interpolated values of R(k) for the fractions -3/6 to 3/6
+ *    are obtained using the interpolation formula:
+ *
+ *              3                            3
+ *    R(k)t = SUM[ R(k-i) * b24(t+i*6) ] + SUM [ R(k+1+i) * b24(6-t+i*6) ],
+ *            i=0                          i=0
+ *    t = 0, ..., 5,
+ *
+ *    where t = 0, ..., 5, corresponds to the fractions
+ *    0, 1/6, 2/6, 3/6, -2/6, and -1/6, respectively. Note that it is
+ *    necessary to compute the correlation terms using a range t_min - 4,
+ *    t_max + 4, to allow for the proper interpolation.
+ *
+ * Returns:
+ *    s                 interpolated value
+ */
+static Float32 Interpol_3or6( Float32 *x, Word32 frac, Word16 flag3 )
+{
+   Float32 s;
+   Float32 *x1, *x2;
+   const Float32 *c1, *c2;
+   Word32 i, k;
+
+
+   if ( flag3 != 0 ) {
+      /* inter_3[k] = b60[2*k] -> k' = 2*k */
+      frac <<= 1;
+   }
+
+   if ( frac < 0 ) {
+      frac += UP_SAMP_MAX;
+      x--;
+   }
+   x1 = &x[0];
+   x2 = &x[1];
+   c1 = &b24[frac];
+   c2 = &b24[UP_SAMP_MAX - frac];
+   s = 0;
+
+   for ( i = 0, k = 0; i < L_INTER_SRCH; i++, k += UP_SAMP_MAX ) {
+      /* R(k-i) * b24(t+i*6) */
+      s += x1[ - i] * c1[k];
+
+      /* R(k+1+i) * b24(6-t+i*6) */
+      s += x2[i] * c2[k];
+   }
+   return s;
+}
+
+
+/*
+ * searchFrac
+ *
+ *
+ * Parameters:
+ *    lag               B: integer pitch
+ *    frac              B: start point of search - fractional pitch
+ *    last_frac         I: endpoint of search
+ *    corr              I: normalized correlation
+ *    flag3             I: if set, upsampling rate = 3 (6 otherwise)
+ *
+ * Function:
+ *    Find fractional pitch
+ *
+ *    The function interpolates the normalized correlation at the
+ *    fractional positions around lag T0. The position at which the
+ *    interpolation function reaches its maximum is the fractional pitch.
+ *    Starting point of the search is frac, end point is last_frac.
+ *    frac is overwritten with the fractional pitch.
+ *
+ * Returns:
+ *    void
+ */
+static void searchFrac( Word32 *lag, Word32 *frac, Word16 last_frac, Float32
+      corr[], Word16 flag3 )
+{
+   Float32 max, corr_int;
+   Word32 i;
+
+
+   /*
+    * Test the fractions around T0 and choose the one which maximizes
+    * the interpolated normalized correlation.
+    */
+   max = Interpol_3or6( &corr[ * lag], *frac, flag3 );
+
+   for ( i = *frac + 1; i <= last_frac; i++ ) {
+      corr_int = Interpol_3or6( &corr[ * lag], i, flag3 );
+
+      if ( corr_int > max ) {
+         max = corr_int;
+         *frac = i;
+      }
+   }
+
+   if ( flag3 == 0 ) {
+      /* Limit the fraction value in the interval [-2,-1,0,1,2,3] */
+      if ( *frac == -3 ) {
+         *frac = 3;
+         *lag -= 1;
+      }
+   }
+   else {
+      /* limit the fraction value between -1 and 1 */
+      if ( *frac == -2 ) {
+         *frac = 1;
+         *lag -= 1;
+      }
+
+      if ( *frac == 2 ) {
+         *frac = -1;
+         *lag += 1;
+      }
+   }
+}
+
+
+/*
+ * Enc_lag3
+ *
+ *
+ * Parameters:
+ *    T0             I: Pitch delay
+ *    T0_frac        I: Fractional pitch delay
+ *    T0_prev        I: Integer pitch delay of last subframe
+ *    T0_min         I: minimum of search range
+ *    T0_max         I: maximum of search range
+ *    delta_flag     I: Flag for 1st (or 3rd) subframe
+ *    flag4          I: Flag for encoding with 4 bits
+ *
+ * Function:
+ *    Encoding of fractional pitch lag with 1/3 resolution.
+ *
+ * Returns:
+ *    index             index of encoding
+ */
+static Word32 Enc_lag3( Word32 T0, Word32 T0_frac, Word32 T0_prev, Word32 T0_min
+      , Word32 T0_max, Word16 delta_flag, Word16 flag4 )
+{
+   Word32 index, i, tmp_ind, uplag, tmp_lag;
+
+
+   /* if 1st or 3rd subframe */
+   if ( delta_flag == 0 ) {
+      /* encode pitch delay (with fraction) */
+      if ( T0 <= 85 ) {
+         index = T0 * 3 - 58 + T0_frac;
+      }
+      else {
+         index = T0 + 112;
+      }
+   }
+
+   /* if second or fourth subframe */
+   else {
+      if ( flag4 == 0 ) {
+         /* 'normal' encoding: either with 5 or 6 bit resolution */
+         index = 3 * ( T0 - T0_min ) + 2 + T0_frac;
+      }
+      else {
+         /* encoding with 4 bit resolution */
+         tmp_lag = T0_prev;
+
+         if ( ( tmp_lag - T0_min ) > 5 )
+            tmp_lag = T0_min + 5;
+
+         if ( ( T0_max - tmp_lag ) > 4 )
+            tmp_lag = T0_max - 4;
+         uplag = T0 + T0 + T0 + T0_frac;
+         i = tmp_lag - 2;
+         tmp_ind = i + i + i;
+
+         if ( tmp_ind >= uplag ) {
+            index = ( T0 - tmp_lag ) + 5;
+         }
+         else {
+            i = tmp_lag + 1;
+            i = i + i + i;
+
+            if ( i > uplag ) {
+               index = ( uplag - tmp_ind ) + 3;
+            }
+            else {
+               index = ( T0 - tmp_lag ) + 11;
+            }
+         }
+      }   /* end if (encoding with 4 bit resolution) */
+   }   /* end if (second of fourth subframe) */
+   return index;
+}
+
+
+/*
+ * Enc_lag6
+ *
+ *
+ * Parameters:
+ *    T0             I: Pitch delay
+ *    T0_frac        I: Fractional pitch delay
+ *    T0_min         I: minimum of search range
+ *    delta_flag     I: Flag for 1st (or 3rd) subframe
+ *
+ * Function:
+ *    Encoding of fractional pitch lag with 1/6 resolution.
+ *
+ *    First and third subframes:
+ *       The pitch range is divided as follows:
+ *          17 3/6  to   94 3/6   resolution 1/6
+ *          95      to   143      resolution 1
+ *       The period is encoded with 9 bits.
+ *       For the range with fractions:
+ *          index = (T-17)*6 + frac - 3;
+ *          where T=[17..94] and frac=[-2,-1,0,1,2,3]
+ *       and for the integer only range
+ *          index = (T - 95) + 463;
+ *          where T=[95..143]
+ *    Second and fourth subframes:
+ *       For the 2nd and 4th subframes a resolution of 1/6 is always used,
+ *       and the search range is relative to the lag in previous subframe.
+ *       If T0 is the lag in the previous subframe then
+ *       t_min=T0-5   and  t_max=T0+4   and  the range is given by
+ *       (t_min-1) 3/6   to  (t_max) 3/6
+ *       The period in the 2nd (and 4th) subframe is encoded with 6 bits:
+ *          index = (T-(t_min-1))*6 + frac - 3;
+ *          where T=[t_min-1..t_max] and frac=[-2,-1,0,1,2,3]
+ *    Note that only 61 values are used. If the decoder receives 61, 62,
+ *    or 63 as the relative pitch index, it means that a transmission
+ *    error occurred and the pitch from previous subframe should be used.
+ *
+ * Returns:
+ *    index             index of encoding
+ */
+static Word32 Enc_lag6( Word32 T0, Word32 T0_frac, Word32 T0_min, Word16
+      delta_flag )
+{
+   Word32 index;
+
+
+   /* if 1st or 3rd subframe */
+   if ( delta_flag == 0 ) {
+      /* encode pitch delay (with fraction) */
+      if ( T0 <= 94 ) {
+         /* index = (t-17)*6 + frac - 3 */
+         index = T0 * 6 - 105 + T0_frac;
+      }
+      else {
+         /* index = (t - 95) + 463 */
+         index = T0 + 368;
+      }
+   }
+
+   /* if second or fourth subframe */
+   else {
+      /* index = (t-(t_min-1))*6 + frac - 3 */
+      index = 6 * ( T0 - T0_min ) + 3 + T0_frac;
+   }
+   return index;
+}
+
+
+/*
+ * Pitch_fr
+ *
+ *
+ * Parameters:
+ *    T0_prev_subframe  B: integer pitch lag of previous sub-frame
+ *    mode              I: codec mode
+ *    T_op              I: open-loop pitch estimations for
+ *                         the 2 big subframes [2]
+ *    exc               I: excitation buffer
+ *    xn                I: target vector
+ *    h                 I: impulse response of synthesis
+ *                         and weighting filters
+ *    i_subfr           I: subframe number
+ *    pit_frac          O: pitch period (fractional)
+ *    resu3             O: subsample resolution 1/3 (=1) or 1/6 (=0)
+ *    ana_index         O: index of encoding
+ *
+ * Function:
+ *    Closed-loop pitch search
+ *
+ *    In the first and third subframes, a fractional pitch delay is used
+ *    with resolutions: 1/6 in the range [17 3/6, 94 3/6] and integers only
+ *    in the range [95, 143]. For the second and fourth subframes,
+ *    a pitch resolution of 1/6 is always used in
+ *    the range [T1 - 5 3/6, T1 + 4 /3/6], where T1 is nearest integer to
+ *    the fractional pitch lag of the previous (1st or 3rd) subframe,
+ *    bounded by 18...143.
+ *
+ *    Closed-loop pitch analysis is performed around
+ *    the open-loop pitch estimates on a subframe basis.
+ *    In the first (and third) subframe the range Top3,
+ *    bounded by 18...143, is searched. For the other subframes,
+ *    closed-loop pitch analysis is performed around the integer pitch
+ *    selected in the previous subframe, as described above.
+ *    The pitch delay is encoded with 9 bits in the first and
+ *    third subframes and the relative delay of the other subframes
+ *    is encoded with 6 bits.
+ *
+ *    The closed-loop pitch search is performed by minimizing
+ *    the mean-square weighted error between the original and
+ *    synthesized speech. This is achieved by maximizing the term:
+ *
+ *            39                           39
+ *    R(k) = SUM[ X(n) * Yk(n)) ] / SQRT[ SUM[ Yk(n) * Yk(n)] ]
+ *           n=0                          n=0
+ *
+ *    where X(n) is the target signal and Yk(n) is the past filtered
+ *    excitation at delay k (past excitation convolved with h(n) ).
+ *
+ *    Once the optimum integer pitch delay is determined, the fractions
+ *    from -3/6 to 3/6 with a step of 1/6 around that integer are tested.
+ *    The fractional pitch search is performed by interpolating
+ *    the normalized correlation R(k) and searching for its maximum.
+ *    The interpolation is performed using an FIR filter b24
+ *    based on a Hamming windowed sin(x)/x function truncated at 23
+ *    and padded with zeros at 24 (b24(24) = 0). The filter has its
+ *    cut-off frequency (-3 dB) at 3 600 Hz in the over-sampled domain.
+ *    The interpolated values of R(k) for the fractions -3/6 to 3/6
+ *    are obtained using the interpolation formula:
+ *
+ *              3                            3
+ *    R(k)t = SUM[ R(k-i) * b24(t+i*6) ] + SUM [ R(k+1+i) * b24(6-t+i*6) ],
+ *            i=0                          i=0
+ *    t = 0, ..., 5,
+ *
+ *    where t = 0, ..., 5, corresponds to the fractions
+ *    0, 1/6, 2/6, 3/6, -2/6, and -1/6, respectively. Note that it is
+ *    necessary to compute the correlation terms using a range t_min -4,
+ *    t_max + 4, to allow for the proper interpolation.
+ *
+ * Returns:
+ *    lag             closed-loop pitch lag
+ */
+static Word32 Pitch_fr( Word32 *T0_prev_subframe, enum Mode mode, Word32 T_op[],
+      Float32 exc[], Float32 xn[], Float32 h[], Word16 i_subfr, Word32 *pit_frac
+      , Word16 *resu3, Word32 *ana_index )
+{
+   Float32 corr_v[40];
+   Float32 max;
+   Float32 *corr;
+   Word32 i, t_min, t_max, T0_min, T0_max;
+   Word32 lag, frac, tmp_lag;
+   Word16 max_frac_lag, flag3, flag4, last_frac;
+   Word16 delta_int_low, delta_int_range, delta_frc_low, delta_frc_range;
+   Word16 pit_min;
+   Word16 frame_offset;
+   Word16 delta_search;
+
+
+   /* set mode specific variables */
+   max_frac_lag = mode_dep_parm[mode].max_frac_lag;
+   flag3 = mode_dep_parm[mode].flag3;
+   frac = mode_dep_parm[mode].first_frac;
+   last_frac = mode_dep_parm[mode].last_frac;
+   delta_int_low = mode_dep_parm[mode].delta_int_low;
+   delta_int_range = mode_dep_parm[mode].delta_int_range;
+   delta_frc_low = mode_dep_parm[mode].delta_frc_low;
+   delta_frc_range = mode_dep_parm[mode].delta_frc_range;
+   pit_min = mode_dep_parm[mode].pit_min;
+
+   /* decide upon full or differential search */
+   delta_search = 1;
+
+   if ( ( i_subfr == 0 ) || ( i_subfr == L_FRAME_BY2 ) ) {
+      /* Subframe 1 and 3 */
+      if ( ( ( mode != MR475 ) && ( mode != MR515 ) ) || ( i_subfr !=
+            L_FRAME_BY2 ) ) {
+         /*
+          * set T0_min, T0_max for full search
+          * this is *not* done for mode MR475, MR515 in subframe 3
+          */
+         delta_search = 0;   /* no differential search */
+
+         /*
+          * calculate index into T_op which contains the open-loop
+          * pitch estimations for the 2 big subframes
+          */
+         frame_offset = 1;
+
+         if ( i_subfr == 0 )
+            frame_offset = 0;
+
+         /*
+          * get T_op from the corresponding half frame and
+          * set T0_min, T0_max
+          */
+         getRange( T_op[frame_offset], delta_int_low, delta_int_range, pit_min,
+               PIT_MAX, &T0_min, &T0_max );
+      }
+      else {
+         /* mode MR475, MR515 and 3. Subframe: delta search as well */
+         getRange( *T0_prev_subframe, delta_frc_low, delta_frc_range, pit_min,
+               PIT_MAX, &T0_min, &T0_max );
+      }
+   }
+   else {
+      /*
+       * for Subframe 2 and 4
+       * get range around T0 of previous subframe for delta search
+       */
+      getRange( *T0_prev_subframe, delta_frc_low, delta_frc_range, pit_min,
+            PIT_MAX, &T0_min, &T0_max );
+   }
+
+   /* Find interval to compute normalized correlation */
+   t_min = T0_min - L_INTER_SRCH;
+   t_max = T0_max + L_INTER_SRCH;
+   corr = &corr_v[ - t_min];
+
+   /* Compute normalized correlation between target and filtered excitation */
+   Norm_Corr( exc, xn, h, t_min, t_max, corr );
+
+   /* Find integer pitch */
+   max = corr[T0_min];
+   lag = T0_min;
+
+   for ( i = T0_min + 1; i <= T0_max; i++ ) {
+      if ( corr[i] >= max ) {
+         max = corr[i];
+         lag = i;
+      }
+   }
+
+   /* Find fractional pitch   */
+   if ( ( delta_search == 0 ) && ( lag > max_frac_lag ) ) {
+      /*
+       * full search and integer pitch greater than max_frac_lag
+       * fractional search is not needed, set fractional to zero
+       */
+      frac = 0;
+   }
+   else {
+      /*
+       * if differential search AND mode MR475 OR MR515 OR MR59 OR MR67
+       * then search fractional with 4 bits resolution
+       */
+      if ( ( delta_search != 0 ) && ( ( mode == MR475 ) || ( mode == MR515 ) ||
+            ( mode == MR59 ) || ( mode == MR67 ) ) ) {
+         /*
+          * modify frac or last_frac according to position of last
+          * integer pitch: either search around integer pitch,
+          * or only on left or right side
+          */
+         tmp_lag = *T0_prev_subframe;
+
+         if ( ( tmp_lag - T0_min ) > 5 )
+            tmp_lag = T0_min + 5;
+
+         if ( ( T0_max - tmp_lag ) > 4 )
+            tmp_lag = T0_max - 4;
+
+         if ( ( lag == tmp_lag ) || ( lag == ( tmp_lag - 1 ) ) ) {
+            /* normal search in fractions around T0 */
+            searchFrac( &lag, &frac, last_frac, corr, flag3 );
+         }
+         else if ( lag == ( tmp_lag - 2 ) ) {
+            /* limit search around T0 to the right side */
+            frac = 0;
+            searchFrac( &lag, &frac, last_frac, corr, flag3 );
+         }
+         else if ( lag == ( tmp_lag + 1 ) ) {
+            /* limit search around T0 to the left side */
+            last_frac = 0;
+            searchFrac( &lag, &frac, last_frac, corr, flag3 );
+         }
+         else {
+            /* no fractional search */
+            frac = 0;
+         }
+      }
+      else
+
+         /* test the fractions around T0 */
+         searchFrac( &lag, &frac, last_frac, corr, flag3 );
+   }
+
+   /*
+    *  encode pitch
+    */
+   if ( flag3 != 0 ) {
+      /*
+       * flag4 indicates encoding with 4 bit resolution;
+       * this is needed for mode MR475, MR515 and MR59
+       */
+      flag4 = 0;
+
+      if ( ( mode == MR475 ) || ( mode == MR515 ) || ( mode == MR59 ) || ( mode
+            == MR67 ) ) {
+         flag4 = 1;
+      }
+
+      /* encode with 1/3 subsample resolution */
+      *ana_index = Enc_lag3( lag, frac, *T0_prev_subframe, T0_min, T0_max,
+            delta_search, flag4 );
+   }
+   else {
+      /* encode with 1/6 subsample resolution */
+      *ana_index = Enc_lag6( lag, frac, T0_min, delta_search );
+   }
+
+   /*
+    *  update state variables
+    */
+   *T0_prev_subframe = lag;
+
+   /*
+    * update output variables
+    */
+   *resu3 = flag3;
+   *pit_frac = frac;
+   return( lag );
+}
+
+
+/*
+ * Pred_lt_3or6
+ *
+ *
+ * Parameters:
+ *    exc      B: excitation buffer
+ *    T0       I: integer pitch lag
+ *    frac     I: fraction of lag
+ *    flag3    I: if set, upsampling rate = 3 (6 otherwise)
+ *
+ * Function:
+ *    Compute the result of long term prediction with fractional
+ *    interpolation of resolution 1/3 or 1/6. (Interpolated past excitation).
+ *
+ *    Once the fractional pitch lag is determined,
+ *    the adaptive codebook vector v(n) is computed by interpolating
+ *    the past excitation signal u(n) at the given integer delay k
+ *    and phase (fraction)  :
+ *
+ *            9                              9
+ *    v(n) = SUM[ u(n-k-i) * b60(t+i*6) ] + SUM[ u(n-k+1+i) * b60(6-t+i*6) ],
+ *           i=0                            i=0
+ *    n = 0, ...,39, t = 0, ...,5.
+ *
+ *    The interpolation filter b60 is based on a Hamming windowed sin(x)/x
+ *    function truncated at  59 and padded with zeros at  60 (b60(60)=0)).
+ *    The filter has a cut-off frequency (-3 dB) at 3 600 Hz in
+ *    the over-sampled domain.
+ *
+ * Returns:
+ *    void
+ */
+static void Pred_lt_3or6( Float32 exc[], Word32 T0, Word32 frac, Word16 flag3 )
+{
+   Float32 s;
+   Float32 *x0, *x1, *x2;
+   const Float32 *c1, *c2;
+   Word32 j;
+
+
+   x0 = &exc[ - T0];
+   frac = -frac;
+
+   if ( flag3 != 0 ) {
+      /* inter_3l[k] = b60[2*k] -> k' = 2*k */
+      frac <<= 1;
+   }
+
+   if ( frac < 0 ) {
+      frac += UP_SAMP_MAX;
+      x0--;
+   }
+   c1 = &b60[frac];
+   c2 = &b60[UP_SAMP_MAX - frac];
+
+   for ( j = 0; j < L_SUBFR; j += 4 ) {
+      x1 = x0++;
+      x2 = x0;
+      s = x1[0] * c1[0] + x2[0] * c2[0];
+      s += x1[ - 1] *c1[6] + x2[1] * c2[6];
+      s += x1[ - 2] * c1[12] + x2[2] * c2[12];
+      s += x1[ - 3] * c1[18] + x2[3] * c2[18];
+      s += x1[ - 4] * c1[24] + x2[4] * c2[24];
+      s += x1[ - 5] * c1[30] + x2[5] * c2[30];
+      s += x1[ - 6] * c1[36] + x2[6] * c2[36];
+      s += x1[ - 7] * c1[42] + x2[7] * c2[42];
+      s += x1[ - 8] * c1[48] + x2[8] * c2[48];
+      s += x1[ - 9] * c1[54] + x2[9] * c2[54];
+      exc[j] = ( Float32 )floor(s + 0.5F);
+      x1 = x0++;
+      x2 = x0;
+      s = x1[0] * c1[0] + x2[0] * c2[0];
+      s += x1[ - 1] *c1[6] + x2[1] * c2[6];
+      s += x1[ - 2] * c1[12] + x2[2] * c2[12];
+      s += x1[ - 3] * c1[18] + x2[3] * c2[18];
+      s += x1[ - 4] * c1[24] + x2[4] * c2[24];
+      s += x1[ - 5] * c1[30] + x2[5] * c2[30];
+      s += x1[ - 6] * c1[36] + x2[6] * c2[36];
+      s += x1[ - 7] * c1[42] + x2[7] * c2[42];
+      s += x1[ - 8] * c1[48] + x2[8] * c2[48];
+      s += x1[ - 9] * c1[54] + x2[9] * c2[54];
+      exc[j + 1] = ( Float32 )floor(s + 0.5F);
+      x1 = x0++;
+      x2 = x0;
+      s = x1[0] * c1[0] + x2[0] * c2[0];
+      s += x1[ - 1] *c1[6] + x2[1] * c2[6];
+      s += x1[ - 2] * c1[12] + x2[2] * c2[12];
+      s += x1[ - 3] * c1[18] + x2[3] * c2[18];
+      s += x1[ - 4] * c1[24] + x2[4] * c2[24];
+      s += x1[ - 5] * c1[30] + x2[5] * c2[30];
+      s += x1[ - 6] * c1[36] + x2[6] * c2[36];
+      s += x1[ - 7] * c1[42] + x2[7] * c2[42];
+      s += x1[ - 8] * c1[48] + x2[8] * c2[48];
+      s += x1[ - 9] * c1[54] + x2[9] * c2[54];
+      exc[j + 2] = ( Float32 )floor(s + 0.5F);
+      x1 = x0++;
+      x2 = x0;
+      s = x1[0] * c1[0] + x2[0] * c2[0];
+      s += x1[ - 1] *c1[6] + x2[1] * c2[6];
+      s += x1[ - 2] * c1[12] + x2[2] * c2[12];
+      s += x1[ - 3] * c1[18] + x2[3] * c2[18];
+      s += x1[ - 4] * c1[24] + x2[4] * c2[24];
+      s += x1[ - 5] * c1[30] + x2[5] * c2[30];
+      s += x1[ - 6] * c1[36] + x2[6] * c2[36];
+      s += x1[ - 7] * c1[42] + x2[7] * c2[42];
+      s += x1[ - 8] * c1[48] + x2[8] * c2[48];
+      s += x1[ - 9] * c1[54] + x2[9] * c2[54];
+      exc[j + 3] = ( Float32 )floor(s + 0.5F);
+   }
+   return;
+}
+
+static void Pred_lt_3or6_fixed( Word32 exc[], Word32 T0, Word32 frac, Word32 flag3 )
+{
+   Word32 s, i;
+   Word32 *x0, *x1, *x2;
+   const Word32 *c1, *c2;
+
+   x0 = &exc[ - T0];
+   frac = -frac;
+
+   if ( flag3 != 0 ) {
+      frac <<= 1;   /* inter_3l[k] = inter6[2*k] -> k' = 2*k */
+   }
+
+   if ( frac < 0 ) {
+      frac += 6;
+      x0--;
+   }
+   c1 = &inter6[frac];
+   c2 = &inter6[6 - frac];
+
+   for ( i = 0; i < 40; i++ ) {
+      x1 = x0++;
+      x2 = x0;
+      s = x1[0] * c1[0];
+      s += x1[ - 1] * c1[6];
+      s += x1[ - 2] * c1[12];
+      s += x1[ - 3] * c1[18];
+      s += x1[ - 4] * c1[24];
+      s += x1[ - 5] * c1[30];
+      s += x1[ - 6] * c1[36];
+      s += x1[ - 7] * c1[42];
+      s += x1[ - 8] * c1[48];
+      s += x1[ - 9] * c1[54];
+      s += x2[0] * c2[0];
+      s += x2[1] * c2[6];
+      s += x2[2] * c2[12];
+      s += x2[3] * c2[18];
+      s += x2[4] * c2[24];
+      s += x2[5] * c2[30];
+      s += x2[6] * c2[36];
+      s += x2[7] * c2[42];
+      s += x2[8] * c2[48];
+      s += x2[9] * c2[54];
+      exc[i] = ( s + 0x4000 ) >> 15;
+
+   }
+}
+
+
+/*
+ * G_pitch
+ *
+ *
+ * Parameters:
+ *    xn       I: Pitch target
+ *    y1       I: Filtered adaptive codebook
+ *    gCoeff   O: Correlations need for gain quantization
+ *
+ * Function:
+ *    Compute the pitch (adaptive codebook) gain.
+ *
+ *    The adaptive codebook gain is given by
+ *
+ *       g = <x[], y[]> / <y[], y[]>
+ *
+ *    where x[] is the target vector, y[] is the filtered adaptive
+ *    codevector, and <> denotes dot product.
+ *
+ * Returns:
+ *    gain              gain saturated to 1.2
+ */
+static Float32 G_pitch( Float32 xn[], Float32 y1[], Float32 gCoeff[] )
+{
+   Float32 gain, sum;
+
+
+   /* Compute scalar product <y1[],y1[]> */
+   sum = (Float32)Dotproduct40( y1, y1 );
+
+   /* Avoid case of all zeros */
+   sum += 0.01F;
+   gCoeff[0] = sum;
+
+   /* Compute scalar product <xn[],y1[]> */
+   sum = (Float32)Dotproduct40( xn, y1 );
+   gCoeff[1] = sum;
+
+   /* compute gain = xy/yy */
+   gain = ( Float32 )( gCoeff[1] / gCoeff[0] );
+
+   /* if(gain >1.2) gain = 1.2 */
+   if ( gain < 0.0 )
+      gain = 0.0F;
+
+   if ( gain > 1.2 )
+      gain = 1.2F;
+   return( gain );
+}
+
+
+/*
+ * check_gp_clipping
+ *
+ *
+ * Parameters:
+ *    gp          I: old pitch gains
+ *    g_pitch     I: pitch gain
+ *
+ * Function:
+ *    Verify that the sum of the last (N_FRAME+1) pitch gains is under
+ *    a certain threshold.
+ *
+ * Returns:
+ *    True or false
+ */
+static Word16 check_gp_clipping( Float32 *gp, Float32 g_pitch )
+{
+   Float32 sum;
+   Word32 i;
+
+
+   sum = g_pitch;
+
+   for ( i = 0; i < N_FRAME; i++ ) {
+      sum += gp[i];
+   }
+
+   if ( sum > 7.6F /*FGP_CLIP*/ ) {
+      return 1;
+   }
+   else {
+      return 0;
+   }
+}
+
+
+/*
+ * q_gain_pitch
+ *
+ *
+ * Parameters:
+ *    mode              I: codec mode
+ *    gp_limit          I: pitch gain limit
+ *    gain              B: Pitch gain (unquant/quant)
+ *    gain_cand         O: pitch gain candidates (3),   MR795 only
+ *    gain_cind         O: pitch gain cand. indices (3),MR795 only
+ *
+ * Function:
+ *    Closed-loop pitch search
+ *
+ * Returns:
+ *    index             index of quantization
+ */
+static Word16 q_gain_pitch( enum Mode mode, Float32 gp_limit, Float32 *gain,
+      Float32 gain_cand[], Word32 gain_cind[] )
+{
+   Float32 err_min, err;
+   Word32 i, index;
+
+
+   err_min = ( Float32 )fabs( *gain - qua_gain_pitch[0] );
+   index = 0;
+
+   for ( i = 1; i < NB_QUA_PITCH; i++ ) {
+      if ( qua_gain_pitch[i] <= gp_limit ) {
+         err = ( Float32 )fabs( *gain - qua_gain_pitch[i] );
+
+         if ( err < err_min ) {
+            err_min = err;
+            index = i;
+         }
+      }
+   }
+
+   if ( mode == MR795 ) {
+   /*
+    * in MR795 mode, compute three gain_pit candidates around the index
+    * found in the quantization loop: the index found and the two direct
+    * neighbours, except for the extreme cases (i=0 or i=NB_QUA_PITCH-1),
+    * where the direct neighbour and the neighbour to that is used.
+    */
+      Word32 ii;
+
+
+      if ( index == 0 ) {
+         ii = index;
+      }
+      else {
+         ii = index - 1;
+
+         if ( index == ( NB_QUA_PITCH - 1 ) || ( qua_gain_pitch[index + 1] >
+               gp_limit ) ) {
+            ii = index - 2;
+         }
+      }
+
+      /* store candidate indices and values */
+      for ( i = 0; i < 3; i++ ) {
+         gain_cind[i] = ii;
+         gain_cand[i] = qua_gain_pitch[ii];
+         ii++;
+      }
+      *gain = qua_gain_pitch[index];
+   }
+   else {
+      /* return the index and gain pitch found */
+      *gain = qua_gain_pitch_MR122[index];
+   }
+   return( Word16 )index;
+}
+
+
+/*
+ * cl_ltp
+ *
+ *
+ * Parameters:
+ *    T0_prev_subframe  B: Integer pitch lag of previous sub-frame
+ *    gp                I: Gain history
+ *    mode              I: Coder mode
+ *    frame_offset      I: Offset to subframe
+ *    T_op              I: Open loop pitch lags
+ *    h1                I: Impulse response vector
+ *    exc               B: Excitation vector
+ *    res2              B: Long term prediction residual
+ *    xn                I: Target vector for pitch search
+ *    lsp_flag          I: LSP resonance flag
+ *    xn2               O: Target vector for codebook search
+ *    y1                O: Filtered adaptive excitation
+ *    T0                O: Pitch delay (integer part)
+ *    T0_frac           O: Pitch delay (fractional part)
+ *    gain_pit          O: Pitch gain
+ *    gCoeff[]          O: Correlations between xn, y1, & y2
+ *    anap              O: Analysis parameters
+ *    gp_limit          O: pitch gain limit
+ *
+ * Function:
+ *    Closed-loop ltp search
+ *
+ *    Adaptive codebook search is performed on a subframe basis.
+ *    It consists of performing closed-loop pitch search, and then computing
+ *    the adaptive codevector by interpolating the past excitation at
+ *    the selected fractional pitch lag.
+ *    The adaptive codebook parameters (or pitch parameters) are
+ *    the delay and gain of the pitch filter. In the adaptive codebook approach
+ *    for implementing the pitch filter, the excitation is repeated for delays
+ *    less than the subframe length. In the search stage, the excitation is
+ *    extended by the LP residual to simplify the closed-loop search.
+ *
+ * Returns:
+ *    void
+ */
+static void cl_ltp( Word32 *T0_prev_subframe, Float32 *gp, enum Mode mode,
+      Word16 frame_offset, Word32 T_op[], Float32 *h1, Float32 *exc, Float32
+      res2[], Float32 xn[], Word16 lsp_flag, Float32 xn2[], Float32 y1[], Word32
+      *T0, Word32 *T0_frac, Float32 *gain_pit, Float32 gCoeff[], Word16 **anap,
+      Float32 *gp_limit )
+{
+   Float32 s;
+   Word32 i, n;
+   Word16 gpc_flag, resu3;   /* flag for upsample resolution */
+
+   Word32 exc_tmp[314];
+   Word32 *exc_tmp_p;
+
+   exc_tmp_p = exc_tmp + PIT_MAX + L_INTERPOL;
+
+
+   /* Closed-loop fractional pitch search */
+   *T0 = Pitch_fr( T0_prev_subframe, mode, T_op, exc, xn, h1, frame_offset,
+         T0_frac, &resu3, &i );
+   *( *anap )++ = ( Word16 )i;
+
+   /*
+    * Compute the adaptive codebook vector
+    * using fixed point. This is required
+    * to maintain encoder/decoder excitation
+    * syncronisation
+    */
+   for (i = -(PIT_MAX + L_INTERPOL); i < 40; i++)
+      exc_tmp_p[i] = (Word32)exc[i];
+
+   Pred_lt_3or6_fixed( exc_tmp_p, *T0, *T0_frac, resu3 );
+
+   for (i = -(PIT_MAX + L_INTERPOL); i < 40; i++)
+      exc[i] = (Float32)exc_tmp_p[i];
+
+   /*
+    *   Convolve to get filtered adaptive codebook vector
+    *  y[n] = sum_{i=0}^{n} x[i] h[n-i], n=0,...,L-1
+    */
+   for ( n = 0; n < L_SUBFR; n++ ) {
+      s = 0;
+
+      for ( i = 0; i <= n; i++ ) {
+         s += exc[i] * h1[n - i];
+      }
+      y1[n] = s;
+   }
+
+   /* The adaptive codebook gain */
+   *gain_pit = G_pitch( xn, y1, gCoeff );
+
+   /* check if the pitch gain should be limit due to resonance in LPC filter */
+   gpc_flag = 0;
+   *gp_limit = 2.0F;
+
+   if ( ( lsp_flag != 0 ) && ( *gain_pit > 0.95F ) ) {
+      gpc_flag = check_gp_clipping( gp, *gain_pit );
+   }
+
+   /*
+    * special for the MR475, MR515 mode; limit the gain to 0.85 to
+    * cope with bit errors in the decoder in a better way.
+    */
+   if ( ( mode == MR475 ) || ( mode == MR515 ) ) {
+      if ( *gain_pit > 0.85 ) {
+         *gain_pit = 0.85F;
+      }
+
+      if ( gpc_flag != 0 )
+         *gp_limit = GP_CLIP;
+   }
+   else {
+      if ( gpc_flag != 0 ) {
+         *gp_limit = GP_CLIP;
+         *gain_pit = GP_CLIP;
+      }
+
+      /*
+       * 12k2 gain_pit is quantized here and not in gainQuant.
+       */
+      if ( mode == MR122 ) {
+
+         *( *anap )++ = q_gain_pitch( MR122, *gp_limit, gain_pit, NULL, NULL );
+      }
+   }
+
+   /*
+    * Update target vector for codebook search
+    * Find LTP residual
+    */
+   for ( i = 0; i < L_SUBFR; i++ ) {
+      xn2[i] = xn[i] - y1[i] * *gain_pit;
+      res2[i] = res2[i] - exc[i] * *gain_pit;
+   }
+}
+
+
+/*
+ * DotProduct
+ *
+ *
+ * Parameters:
+ *    x                 I: first input
+ *    y                 I: second input
+ *    len               I: length of product
+ *
+ * Function:
+ *    Computes dot product
+ *
+ * Returns:
+ *    acc               dot product
+ */
+static Float32 DotProduct( Float32 *x, Float32 *y, Word32 len )
+{
+   Word32 i;
+   Float32 acc;
+
+
+   acc = 0.0F;
+
+   for ( i = 0; i < len; i++ )
+      acc += x[i] * y[i];
+   return( acc );
+}
+
+
+/*
+ * cor_h_x
+ *
+ *
+ * Parameters:
+ *    h                 I: impulse response of weighted synthesis filter
+ *    x                 I: target
+ *    dn                O: correlation between target and impulse response
+ *
+ * Function:
+ *    Computes correlation between target signal and impulse response.
+ *
+ * Returns:
+ *    void
+ */
+static void cor_h_x( Float32 h[], Float32 x[], Float32 dn[] )
+{
+   Word32 i;
+
+
+   dn[0] = (Float32)Dotproduct40( h, x );
+
+   for ( i = 1; i < L_CODE; i++ )
+      dn[i] = (Float32)DotProduct( h, &x[i], L_CODE - i );
+}
+
+
+/*
+ * set_sign
+ *
+ *
+ * Parameters:
+ *    dn                B: correlation between target and h[]
+ *    sign              O: sign of dn[]
+ *    dn2               O: maximum of correlation in each track
+ *    n                 I: # of maximum correlations in dn2[]
+ *
+ * Function:
+ *    Builds sign[] vector.
+ *
+ * Returns:
+ *    void
+ */
+static void set_sign( Float32 dn[], Float32 sign[], Float32 dn2[], Word16 n )
+{
+   Float32 val, min;
+   Word32 i, j, k, pos = 0;
+
+
+   /* set sign according to dn[] */
+   for ( i = 0; i < L_CODE; i++ ) {
+      val = dn[i];
+
+      if ( val >= 0 ) {
+         sign[i] = 1.0F;
+      }
+      else {
+         sign[i] = -1.0F;
+         val = -val;
+      }
+
+      /* modify dn[] according to the fixed sign */
+      dn[i] = val;
+      dn2[i] = val;
+   }
+
+   /* keep 8-n maximum positions/8 of each track and store it in dn2[] */
+   for ( i = 0; i < NB_TRACK; i++ ) {
+      for ( k = 0; k < ( 8 - n ); k++ ) {
+         min = FLT_MAX;
+
+         for ( j = i; j < L_CODE; j += STEP ) {
+            if ( dn2[j] >= 0 ) {
+               val = dn2[j] - min;
+
+               if ( val < 0 ) {
+                  min = dn2[j];
+                  pos = j;
+               }
+            }
+         }
+         dn2[pos] = -1.0F;
+      }
+   }
+   return;
+}
+
+
+/*
+ * cor_h
+ *
+ *
+ * Parameters:
+ *    h                I: h[]
+ *    sign             I: sign information
+ *    rr               O: correlations
+ *
+ * Function:
+ *    Computes correlations of h[] needed for the codebook search,
+ *    and includes the sign information into the correlations.
+ *
+ * Returns:
+ *    void
+ */
+static void cor_h( Float32 h[], Float32 sign[], Float32 rr[][L_CODE] )
+{
+   Float32 sum;
+   Float32 *prr, *ph, *ph_max;
+   Float32 *rrj, *rri, *signi, *signj;
+   Word32 ii, total_loops, four_loops;
+
+
+   sum = 0.0F;
+
+   /* Compute diagonal matrix of autocorrelation of h */
+   rr[0][0] = (Float32)Dotproduct40( h, h );
+   prr = &rr[39][39];
+   ph = &h[0];
+   ph_max = ph + 39;
+
+   /*
+    * speed optimization of code:
+    * for (k=0; k<m; k++)
+    * {
+    * sum += h[k]*h[k];
+    * rr[i][i] = sum;
+    * i--;
+    * }
+    */
+   do {
+      sum += *ph * *ph;
+      ph++;
+      *prr = sum;
+      prr -= 41;
+      sum += *ph * *ph;
+      ph++;
+      *prr = sum;
+      prr -= 41;
+      sum += *ph * *ph;
+      ph++;
+      *prr = sum;
+      prr -= 41;
+      sum += *ph * *ph;
+      ph++;
+      *prr = sum;
+      prr -= 41;
+      sum += *ph * *ph;
+      ph++;
+      *prr = sum;
+      prr -= 41;
+      sum += *ph * *ph;
+      ph++;
+      *prr = sum;
+      prr -= 41;
+      sum += *ph * *ph;
+      ph++;
+      *prr = sum;
+      prr -= 41;
+      sum += *ph * *ph;
+      ph++;
+      *prr = sum;
+      prr -= 41;
+      sum += *ph * *ph;
+      ph++;
+      *prr = sum;
+      prr -= 41;
+      sum += *ph * *ph;
+      ph++;
+      *prr = sum;
+      prr -= 41;
+      sum += *ph * *ph;
+      ph++;
+      *prr = sum;
+      prr -= 41;
+      sum += *ph * *ph;
+      ph++;
+      *prr = sum;
+      prr -= 41;
+      sum += *ph * *ph;
+      ph++;
+      *prr = sum;
+      prr -= 41;
+   } while ( ph < ph_max );
+
+   /*
+    * Compute upper & bottom symmetric matrix of autocorrelation of h.
+    */
+   /* speed optimization of code:
+    * for (ii=1; ii<L_CODE; ii++)
+    * {
+    * j = m;
+    * i = j - ii;
+    * sum = (Float32)0.0;
+    * for ( k = 0; k < (L_CODE-ii); k++ )
+    * {
+    * sum += h[k]*h[k+ii];
+    * rr[i][j] = rr[j][i] = (sum*sign[i]*sign[j]);
+    * i--; j--;
+    * }
+    * }
+    */
+   ii = 1;
+
+   for ( total_loops = 9; total_loops >= 0; total_loops-- ) {
+      rrj = rri = &rr[39][39];
+      rrj -= ii;
+      rri = ( rri - 40 * ii );
+      signi = signj = &sign[39];
+      signi -= ii;
+      sum = 0.0F;
+      ph = &h[0];
+
+      for ( four_loops = 0; four_loops < total_loops; four_loops++ ) {
+         sum += *ph * *( ph + ii );
+         ph++;
+         *rri = *rrj = sum * *signi * *signj;
+         rri -= 41;
+         rrj -= 41;
+         signi--;
+         signj--;
+         sum += *ph * *( ph + ii );
+         ph++;
+         *rri = *rrj = sum * *signi * *signj;
+         rri -= 41;
+         rrj -= 41;
+         signi--;
+         signj--;
+         sum += *ph * *( ph + ii );
+         ph++;
+         *rri = *rrj = sum * *signi * *signj;
+         rri -= 41;
+         rrj -= 41;
+         signi--;
+         signj--;
+         sum += *ph * *( ph + ii );
+         ph++;
+         *rri = *rrj = sum * *signi * *signj;
+         rri -= 41;
+         rrj -= 41;
+         signi--;
+         signj--;
+      }
+      sum += *ph * *( ph + ii );
+      ph++;
+      *rri = *rrj = sum * *signi * *signj;
+      rri -= 41;
+      rrj -= 41;
+      signi--;
+      signj--;
+      sum += *ph * *( ph + ii );
+      ph++;
+      *rri = *rrj = sum * *signi * *signj;
+      rri -= 41;
+      rrj -= 41;
+      signi--;
+      signj--;
+      sum += *ph * *( ph + ii );
+      *rri = *rrj = sum * *signi * *signj;
+      ii++;
+      rrj = rri = &rr[39][39];
+      rrj -= ii;
+      rri = ( rri - 40 * ii );
+      signi = signj = &sign[39];
+      signi -= ii;
+      sum = 0.0F;
+      ph = &h[0];
+
+      for ( four_loops = 0; four_loops < total_loops; four_loops++ ) {
+         sum += *ph * *( ph + ii );
+         ph++;
+         *rri = *rrj = sum * *signi * *signj;
+         rri -= 41;
+         rrj -= 41;
+         signi--;
+         signj--;
+         sum += *ph * *( ph + ii );
+         ph++;
+         *rri = *rrj = sum * *signi * *signj;
+         rri -= 41;
+         rrj -= 41;
+         signi--;
+         signj--;
+         sum += *ph * *( ph + ii );
+         ph++;
+         *rri = *rrj = sum * *signi * *signj;
+         rri -= 41;
+         rrj -= 41;
+         signi--;
+         signj--;
+         sum += *ph * *( ph + ii );
+         ph++;
+         *rri = *rrj = sum * *signi * *signj;
+         rri -= 41;
+         rrj -= 41;
+         signi--;
+         signj--;
+      }
+      sum += *ph * *( ph + ii );
+      ph++;
+      *rri = *rrj = sum * *signi * *signj;
+      rri -= 41;
+      rrj -= 41;
+      signi--;
+      signj--;
+      sum += *ph * *( ph + ii );
+      *rri = *rrj = sum * *signi * *signj;
+      ii++;
+      rrj = rri = &rr[39][39];
+      rrj -= ii;
+      rri = ( rri - 40 * ii );
+      signi = signj = &sign[39];
+      signi -= ii;
+      sum = 0.0F;
+      ph = &h[0];
+
+      for ( four_loops = 0; four_loops < total_loops; four_loops++ ) {
+         sum += *ph * *( ph + ii );
+         ph++;
+         *rri = *rrj = sum * *signi * *signj;
+         rri -= 41;
+         rrj -= 41;
+         signi--;
+         signj--;
+         sum += *ph * *( ph + ii );
+         ph++;
+         *rri = *rrj = sum * *signi * *signj;
+         rri -= 41;
+         rrj -= 41;
+         signi--;
+         signj--;
+         sum += *ph * *( ph + ii );
+         ph++;
+         *rri = *rrj = sum * *signi * *signj;
+         rri -= 41;
+         rrj -= 41;
+         signi--;
+         signj--;
+         sum += *ph * *( ph + ii );
+         ph++;
+         *rri = *rrj = sum * *signi * *signj;
+         rri -= 41;
+         rrj -= 41;
+         signi--;
+         signj--;
+      }
+      sum += *ph * *( ph + ii );
+      *rri = *rrj = sum * *signi * *signj;
+      ii++;
+      rrj = rri = &rr[39][39];
+      rrj -= ii;
+      rri = ( rri - 40 * ii );
+      signi = signj = &sign[39];
+      signi -= ii;
+      sum = 0.0F;
+      ph = &h[0];
+
+      for ( four_loops = 0; four_loops < total_loops; four_loops++ ) {
+         sum += *ph * *( ph + ii );
+         ph++;
+         *rri = *rrj = sum * ( *signi ) * ( *signj );
+         rri -= 41;
+         rrj -= 41;
+         signi--;
+         signj--;
+         sum += *ph * *( ph + ii );
+         ph++;
+         *rri = *rrj = sum * *signi * *signj;
+         rri -= 41;
+         rrj -= 41;
+         signi--;
+         signj--;
+         sum += *ph * *( ph + ii );
+         ph++;
+         *rri = *rrj = sum * *signi * *signj;
+         rri -= 41;
+         rrj -= 41;
+         signi--;
+         signj--;
+         sum += *ph * *( ph + ii );
+         ph++;
+         *rri = *rrj = sum * *signi * *signj;
+         rri -= 41;
+         rrj -= 41;
+         signi--;
+         signj--;
+      }
+      ii++;
+   }
+   return;
+}
+
+
+/*
+ * search_2i40_9bits
+ *
+ *
+ * Parameters:
+ *    subNr             I: subframe number
+ *    dn                I: correlation between target and h[]
+ *    rr                I: matrix of autocorrelation
+ *    codvec            O: algebraic codebook vector
+ *
+ * Function:
+ *    Search the best codevector; determine positions of the 2 pulses
+ *    in the 40-sample frame.
+ *
+ *    First subframe:
+ *    first    i0 :  0, 5, 10, 15, 20, 25, 30, 35.
+ *             i1 :  2, 7, 12, 17, 22, 27, 32, 37.
+ *    second   i0 :  1, 6, 11, 16, 21, 26, 31, 36.
+ *             i1 :  3, 8, 13, 18, 23, 28, 33, 38.
+ *
+ *    Second subframe:
+ *    first    i0 :  0, 5, 10, 15, 20, 25, 30, 35.
+ *             i1 :  3, 8, 13, 18, 23, 28, 33, 38.
+ *    second   i0 :  2, 7, 12, 17, 22, 27, 32, 37.
+ *             i1 :  4, 9, 14, 19, 24, 29, 34, 39.
+ *
+ *    Third subframe:
+ *    first    i0 :  0, 5, 10, 15, 20, 25, 30, 35.
+ *             i1 :  2, 7, 12, 17, 22, 27, 32, 37.
+ *    second   i0 :  1, 6, 11, 16, 21, 26, 31, 36.
+ *             i1 :  4, 9, 14, 19, 24, 29, 34, 39.
+ *
+ *    Fourth subframe:
+ *    first    i0 :  0, 5, 10, 15, 20, 25, 30, 35.
+ *             i1 :  3, 8, 13, 18, 23, 28, 33, 38.
+ *    second   i0 :  1, 6, 11, 16, 21, 26, 31, 36.
+ *             i1 :  4, 9, 14, 19, 24, 29, 34, 39.
+ *
+ * Returns:
+ *    void
+ */
+static void search_2i40_9bits( Word16 subNr, Float32 dn[], Float32 rr[][L_CODE],
+      Word32 codvec[] )
+{
+   Float32 ps0, ps1, psk, alp, alp0, alp1, alpk, sq, sq1;
+   Word32 i0, i1, ix, i;
+   Word16 ipos[2];
+   Word16 track1;
+
+
+   psk = -1;
+   alpk = 1;
+
+   for ( i = 0; i < 2; i++ ) {
+      codvec[i] = i;
+   }
+
+   /* main loop: try 2x4  tracks	*/
+   for ( track1 = 0; track1 < 2; track1++ ) {
+      ipos[0] = startPos[( subNr << 1 ) + ( track1 << 3 )];
+      ipos[1] = startPos[( subNr << 1 ) + 1 + ( track1 << 3 )];
+
+      /* i0 loop: try 8 positions	*/
+      for ( i0 = ipos[0]; i0 < L_CODE; i0 += STEP ) {
+         ps0 = dn[i0];
+         alp0 = rr[i0][i0];
+
+         /* i1 loop: 8 positions */
+         sq = -1;
+         alp = 1;
+         ix = ipos[1];
+
+         for ( i1 = ipos[1]; i1 < L_CODE; i1 += STEP ) {
+            ps1 = ps0 + dn[i1];
+            alp1 = alp0 + rr[i1][i1] + 2.0F * rr[i0][i1];
+            sq1 = ps1 * ps1;
+
+            if ( ( alp * sq1 ) > ( sq * alp1 ) ) {
+               sq = sq1;
+               alp = alp1;
+               ix = i1;
+            }
+         }
+
+         /* memorise codevector if this one is better than the last one	*/
+         if ( ( alpk * sq ) > ( psk * alp ) ) {
+            psk = sq;
+            alpk = alp;
+            codvec[0] = i0;
+            codvec[1] = ix;
+         }
+      }
+   }
+   return;
+}
+
+
+/*
+ * build_code_2i40_9bits
+ *
+ *
+ * Parameters:
+ *    subNr             I: subframe number
+ *    codvec            I: position of pulses
+ *    dn_sign           I: sign of pulses
+ *    cod               O: algebraic codebook vector
+ *    h                 I: impulse response of weighted synthesis filter
+ *    y                 I: filtered innovative code
+ *    anap              O: analysis parameters
+ *
+ * Function:
+ *    Builds the codeword, the filtered codeword and index of the
+ *    codevector, based on the signs and positions of 2 pulses.
+ *
+ * Returns:
+ *    void
+ */
+static void build_code_2i40_9bits( Word16 subNr, Word32 codvec[], Float32
+      dn_sign[], Float32 cod[], Float32 h[], Float32 y[], Word16 *anap )
+{
+   Float32 s;
+   Float32 *p0, *p1;
+   Word32 _sign[2];
+   Word32 i, j, k, track, index, indx = 0, rsign = 0;
+   Word8 first, *pt;
+
+
+   pt = &trackTable[subNr + ( subNr << 2 )];
+   memset( cod, 0, 160 );
+
+   for ( k = 0; k < 2; k++ ) {
+      /* read pulse position */
+      i = codvec[k];
+
+      /* read sign */
+      j = ( Word32 )dn_sign[i];
+
+      /* index = pos/5 */
+      index = i / 5;
+
+      /* track = pos%5 */
+      track = i % 5;
+      first = pt[track];
+
+      if ( first == 0 ) {
+         if ( k == 0 ) {
+            /*	position of 1st pulse	*/
+            track = 0;
+         }
+         else {
+            track = 1;
+
+            /*	position of 2nd pulse	*/
+            index <<= 3;
+         }
+      }
+      else {
+         if ( k == 0 ) {
+            track = 0;
+
+            /*	position of 1st pulse, subset 2	*/
+            index += 64;
+         }
+         else {
+            track = 1;
+            index <<= 3;
+         }
+      }
+
+      if ( j > 0 ) {
+         cod[i] = 0.9998779296875F;
+         _sign[k] = 1;
+
+         /*	sign information */
+         rsign = rsign + ( 1 << track );
+      }
+      else {
+         cod[i] = -1;
+         _sign[k] = -1;
+      }
+      indx = indx + index;
+   }
+   p0 = h - codvec[0];
+   p1 = h - codvec[1];
+
+   for ( i = 0; i < L_CODE; i++ ) {
+      s = *p0++ * _sign[0];
+      s += *p1++ * _sign[1];
+      y[i] = s;
+   }
+   anap[0] = ( Word16 )indx;
+   anap[1] = ( Word16 )rsign;
+}
+
+
+/*
+ * code_2i40_9bits
+ *
+ *
+ * Parameters:
+ *    subNr             I: subframe number
+ *    x                 I: target vector
+ *    h                 I: impulse response of weighted synthesis filter
+ *    T0                I: Pitch lag
+ *    pitch_sharp       I: Last quantized pitch gain
+ *    code              O: innovative codebook
+ *    y                 O: filtered fixed codebook excitation
+ *    anap              O: analysis parameters
+ *
+ * Function:
+ *    Searches a 9 bit algebraic codebook containing 2 pulses
+ *    in a frame of 40 samples.
+ *
+ *    The code length is 40, containing 2 nonzero pulses: i0...i1.
+ *    All pulses can have two possible amplitudes: +1 or -1.
+ *    Pulse i0 can have 8 possible positions, pulse i1 can have
+ *    8 positions. Also coded is which track pair should be used,
+ *    i.e. first or second pair. Where each pair contains 2 tracks.
+ *
+ * Returns:
+ *    void
+ */
+static void code_2i40_9bits( Word16 subNr, Float32 x[], Float32 h[], Word32 T0,
+      Float32 pitch_sharp, Float32 code[], Float32 y[], Word16 *anap )
+{
+   Float32 rr[L_CODE][L_CODE];
+   Float32 dn[L_CODE], dn_sign[L_CODE], dn2[L_CODE];
+   Word32 codvec[2];
+   Word32 i;
+
+
+   if ( ( T0 < L_CODE ) && ( pitch_sharp != 0.0F ) )
+      for ( i = T0; i < L_CODE; i++ ) {
+         h[i] += h[i - T0] * pitch_sharp;
+      }
+   cor_h_x( h, x, dn );
+   set_sign( dn, dn_sign, dn2, 8 );
+   cor_h( h, dn_sign, rr );
+   search_2i40_9bits( subNr, dn, rr, codvec );
+   build_code_2i40_9bits( subNr, codvec, dn_sign, code, h, y, anap );
+
+      /*
+       * Compute innovation vector gain.
+       * Include fixed-gain pitch contribution into code[].
+       */
+   if ( ( T0 < L_CODE ) && ( pitch_sharp != 0.0F ) )
+      for ( i = T0; i < L_CODE; i++ ) {
+         code[i] += code[i - T0] * pitch_sharp;
+      }
+}
+
+
+/*
+ * search_2i40_11bits
+ *
+ *
+ * Parameters:
+ *    dn                I: correlation between target and h[]
+ *    rr                I: matrix of autocorrelation
+ *    codvec            O: algebraic codebook vector
+ *
+ * Function:
+ *    Search the best codevector; determine positions of the 2 pulses
+ *    in the 40-sample frame.
+ *
+ * Returns:
+ *    void
+ */
+static void search_2i40_11bits( Float32 dn[], Float32 rr[][L_CODE], Word32
+      codvec[] )
+{
+   Float64 alpk, alp, alp0, alp1;
+   Float32 psk, ps0, ps1, sq, sq1;
+   Word32 i, i0, i1, ix = 0;
+   Word16 ipos[2];
+   Word16 track1, track2;
+
+
+   psk = -1;
+   alpk = 1;
+
+   for ( i = 0; i < 2; i++ ) {
+      codvec[i] = i;
+   }
+
+   /*
+    * main loop: try 2x4  tracks.
+    */
+   for ( track1 = 0; track1 < 2; track1++ ) {
+      for ( track2 = 0; track2 < 4; track2++ ) {
+         /* fix starting position */
+         ipos[0] = startPos1[track1];
+         ipos[1] = startPos2[track2];
+
+         /*
+          * i0 loop: try 8 positions.
+          */
+         for ( i0 = ipos[0]; i0 < L_CODE; i0 += STEP ) {
+            ps0 = dn[i0];
+            alp0 = rr[i0][i0] * 0.25F;
+
+            /*
+             * i1 loop: 8 positions.
+             */
+            sq = -1;
+            alp = 1;
+            ix = ipos[1];
+
+            for ( i1 = ipos[1]; i1 < L_CODE; i1 += STEP ) {
+               ps1 = ps0 + dn[i1];
+
+               /* alp1 = alp0 + rr[i0][i1] + 1/2*rr[i1][i1]; */
+               alp1 = alp0 + rr[i1][i1] * 0.25F;
+               alp1 += rr[i0][i1] * 0.5F;
+               sq1 = ps1 * ps1;
+
+               if ( ( alp * sq1 ) > ( sq * alp1 ) ) {
+                  sq = sq1;
+                  alp = alp1;
+                  ix = i1;
+               }
+            }
+
+            /*
+             * memorise codevector if this one is better than the last one.
+             */
+            if ( ( alpk * sq ) > ( psk * alp ) ) {
+               psk = sq;
+               alpk = alp;
+               codvec[0] = i0;
+               codvec[1] = ix;
+            }
+         }
+      }
+   }
+   return;
+}
+
+
+/*
+ * build_code_2i40_11bits
+ *
+ *
+ * Parameters:
+ *    codvec            I: position of pulses
+ *    dn_sign           I: sign of pulses
+ *    cod               O: algebraic codebook vector
+ *    h                 I: impulse response of weighted synthesis filter
+ *    y                 O: filtered innovative code
+ *    anap              O: analysis parameters
+ *
+ * Function:
+ *    Builds the codeword, the filtered codeword and index of the
+ *    codevector, based on the signs and positions of 2 pulses.
+ *
+ * Returns:
+ *    void
+ */
+static void build_code_2i40_11bits( Word32 codvec[], Float32 dn_sign[], Float32
+      cod[], Float32 h[], Float32 y[], Word16 *anap )
+{
+   Float64 s;
+   Float32 *p0, *p1;
+   Word32 _sign[2];
+   Word32 i, j, k, track, index, indx = 0, rsign = 0;
+
+
+   memset( cod, 0, 160 );
+
+   for ( k = 0; k < 2; k++ ) {
+      i = codvec[k];   /* read pulse position */
+      j = ( Word16 )dn_sign[i];   /* read sign */
+      index = i / 5;   /* index = pos/5 */
+
+      /* track = pos%5 */
+      track = i % 5;
+
+      if ( track == 0 ) {
+         track = 1;
+         index = index << 6;
+      }
+      else if ( track == 1 ) {
+         if ( k == 0 ) {
+            track = 0;
+            index = index << 1;
+         }
+         else {
+            track = 1;
+            index = ( index << 6 ) + 16;
+         }
+      }
+      else if ( track == 2 ) {
+         track = 1;
+         index = ( index << 6 ) + 32;
+      }
+      else if ( track == 3 ) {
+         track = 0;
+         index = ( index << 1 ) + 1;
+      }
+      else if ( track == 4 ) {
+         track = 1;
+         index = ( index << 6 ) + 48;
+      }
+
+      if ( j > 0 ) {
+         cod[i] = 0.9998779296875F;
+         _sign[k] = 1;
+         rsign = rsign + ( 1 << track );
+      }
+      else {
+         cod[i] = -1;
+         _sign[k] = -1;
+      }
+      indx = indx + index;
+   }
+   p0 = h - codvec[0];
+   p1 = h - codvec[1];
+
+   for ( i = 0; i < L_CODE; i++ ) {
+      s = *p0++ * _sign[0];
+      s += *p1++ * _sign[1];
+      y[i] = ( Float32 )s;
+   }
+   anap[0] = ( Word16 )indx;
+   anap[1] = ( Word16 )rsign;
+}
+
+
+/*
+ * code_2i40_11bits
+ *
+ *
+ * Parameters:
+ *    x                 I: target vector
+ *    h                 I: impulse response of weighted synthesis filter
+ *    T0                I: Pitch lag
+ *    pitch_sharp       I: Last quantized pitch gain
+ *    code              O: innovative codebook
+ *    y                 O: filtered fixed codebook excitation
+ *    anap              O: analysis parameters
+ *
+ * Function:
+ *    Searches a 11 bit algebraic codebook containing 2 pulses
+ *    in a frame of 40 samples.
+ *
+ *    The code length is 40, containing 2 nonzero pulses: i0...i1.
+ *    All pulses can have two possible amplitudes: +1 or -1.
+ *    Pulse i0 can have 2x8=16 possible positions, pulse i1 can have
+ *    4x8=32 positions.
+ *
+ *    i0 :  1, 6, 11, 16, 21, 26, 31, 36.
+ *          3, 8, 13, 18, 23, 28, 33, 38.
+ *    i1 :  0, 5, 10, 15, 20, 25, 30, 35.
+ *          1, 6, 11, 16, 21, 26, 31, 36.
+ *          2, 7, 12, 17, 22, 27, 32, 37.
+ *          4, 9, 14, 19, 24, 29, 34, 39.
+ *
+ * Returns:
+ *    void
+ */
+static void code_2i40_11bits( Float32 x[], Float32 h[], Word32 T0, Float32
+      pitch_sharp, Float32 code[], Float32 y[], Word16 *anap )
+{
+   Float32 rr[L_CODE][L_CODE];
+   Float32 dn[L_CODE], dn2[L_CODE], dn_sign[L_CODE];
+   Word32 codvec[2];
+   Word32 i;
+
+
+   if ( ( T0 < L_CODE ) && ( pitch_sharp != 0.0F ) ) {
+      for ( i = T0; i < L_CODE; i++ ) {
+         h[i] = h[i] + ( h[i - T0] * pitch_sharp );
+      }
+   }
+   cor_h_x( h, x, dn );
+   set_sign( dn, dn_sign, dn2, 8 );
+   cor_h( h, dn_sign, rr );
+   search_2i40_11bits( dn, rr, codvec );
+   build_code_2i40_11bits( codvec, dn_sign, code, h, y, anap );
+
+   /*
+    * Compute innovation vector gain.
+    * Include fixed-gain pitch contribution into code[].
+    */
+   if ( ( T0 < L_CODE ) && ( pitch_sharp != 0.0F ) ) {
+      for ( i = T0; i < L_CODE; i++ ) {
+         code[i] = code[i] + code[i - T0] * pitch_sharp;
+      }
+   }
+}
+
+
+/*
+ * search_3i40
+ *
+ *
+ * Parameters:
+ *    dn                I: correlation between target and h[]
+ *    dn2               I: maximum of corr. in each track
+ *    rr                I: matrix of autocorrelation
+ *    codvec            O: algebraic codebook vector
+ *
+ * Function:
+ *    Searches a 14 bit algebraic codebook containing 3 pulses in
+ *    a frame of 40 samples.
+ *
+ * Returns:
+ *    void
+ */
+static void search_3i40( Float32 dn[], Float32 dn2[], Float32 rr[][L_CODE],
+      Word32 codvec[] )
+{
+   Float32 psk, ps0, ps1, sq, sq1, alpk, alp, alp0, alp1, ps = 0.0F;
+   Float32 *rr2, *rr1, *rr0, *pdn, *pdn_max;
+   Word32 ipos[3];
+   Word32 i0, i1, i2, ix, i, pos, track1, track2;
+
+
+   psk = -1.0F;
+   alpk = 1.0F;
+
+   for ( track1 = 1; track1 < 4; track1 += 2 ) {
+      for ( track2 = 2; track2 < 5; track2 += 2 ) {
+         /* fix starting position */
+         ipos[0] = 0;
+         ipos[1] = track1;
+         ipos[2] = track2;
+
+         /* main loop: try 3 tracks */
+         for ( i = 0; i < 3; i++ ) {
+            /* i0 loop: try 8 positions */
+            for ( i0 = ipos[0]; i0 < L_CODE; i0 += STEP ) {
+               if ( dn2[i0] >= 0 ) {
+                  ps0 = dn[i0];
+                  alp0 = rr[i0][i0];
+
+                  /* i1 loop: 8 positions */
+                  sq = -1.0F;
+                  alp = 1.0F;
+                  ps = 0.0F;
+                  ix = ipos[1];
+                  i1 = ipos[1];
+                  rr1 = &rr[i1][i1];
+                  rr0 = &rr[i0][i1];
+                  pdn = &dn[i1];
+                  pdn_max = &dn[L_CODE];
+
+                  do {
+                     ps1 = ps0 + *pdn;
+                     alp1 = alp0 + *rr1 + 2.0F * *rr0;
+                     sq1 = ps1 * ps1;
+
+                     if ( ( alp * sq1 ) > ( sq * alp1 ) ) {
+                        sq = sq1;
+                        ps = ps1;
+                        alp = alp1;
+                        ix = ( Word16 )( pdn - dn );
+                     }
+                     pdn += STEP;
+                     rr1 += ( 40 * STEP + STEP );
+                     rr0 += STEP;
+                  } while ( pdn < pdn_max );
+                  i1 = ix;
+
+                  /* i2 loop: 8 positions */
+                  ps0 = ps;
+                  alp0 = alp;
+                  sq = -1.0F;
+                  alp = 1.0F;
+                  ps = 0.0F;
+                  ix = ipos[2];
+                  i2 = ipos[2];
+                  rr2 = &rr[i2][i2];
+                  rr1 = &rr[i1][i2];
+                  rr0 = &rr[i0][i2];
+                  pdn = &dn[i2];
+
+                  do {
+                     ps1 = ps0 + *pdn;
+                     alp1 = alp0 + *rr2 + 2.0F * ( *rr1 + *rr0 );
+                     sq1 = ps1 * ps1;
+
+                     if ( ( alp * sq1 ) > ( sq * alp1 ) ) {
+                        sq = sq1;
+                        ps = ps1;
+                        alp = alp1;
+                        ix = ( Word16 )( pdn - dn );
+                     }
+                     pdn += STEP;
+                     rr2 += ( 40 * STEP + STEP );
+                     rr1 += STEP;
+                     rr0 += STEP;
+                  } while ( pdn < pdn_max );
+                  i2 = ix;
+
+                  /* memorise codevector if this one is better than the last one */
+                  if ( ( alpk * sq ) > ( psk * alp ) ) {
+                     psk = sq;
+                     alpk = alp;
+                     codvec[0] = i0;
+                     codvec[1] = i1;
+                     codvec[2] = i2;
+                  }
+               }
+            }
+
+            /* Cyclic permutation of i0, i1 and i2 */
+            pos = ipos[2];
+            ipos[2] = ipos[1];
+            ipos[1] = ipos[0];
+            ipos[0] = pos;
+         }
+      }
+   }
+   return;
+}
+
+
+/*
+ * build_code_3i40_14bits
+ *
+ *
+ * Parameters:
+ *    codvec            I: position of pulses
+ *    dn_sign           I: sign of pulses
+ *    cod               O: algebraic codebook vector
+ *    h                 I: impulse response of weighted synthesis filter
+ *    y                 I: filtered innovative code
+ *    anap              O: analysis parameters
+ *
+ * Function:
+ *    Builds the codeword, the filtered codeword and index of the
+ *    codevector, based on the signs and positions of 3 pulses.
+ *
+ * Returns:
+ *    void
+ */
+static void build_code_3i40_14bits( Word32 codvec[], Float32 dn_sign[], Float32
+      cod[], Float32 h[], Float32 y[], Word16 *anap )
+{
+   Float64 s;
+   Float32 _sign[3];
+   Float32 *p0, *p1, *p2;
+   Word32 i, j, k, track, index, indx, rsign;
+
+
+   memset( cod, 0, 160 );
+   indx = 0;
+   rsign = 0;
+
+   for ( k = 0; k < 3; k++ ) {
+      /* read pulse position */
+      i = codvec[k];
+
+      /* read sign */
+      j = ( Word16 )dn_sign[i];
+
+      /* index = pos/5 */
+      index = i / 5;
+
+      /* track = pos%5 */
+      track = i % 5;
+
+      if ( track == 1 )
+         index = index << 4;
+      else if ( track == 2 ) {
+         track = 2;
+         index = index << 8;
+      }
+      else if ( track == 3 ) {
+         track = 1;
+         index = ( index << 4 ) + 8;
+      }
+      else if ( track == 4 ) {
+         track = 2;
+         index = ( index << 8 ) + 128;
+      }
+
+      if ( j > 0 ) {
+         cod[i] = 0.9998779296875F;
+         _sign[k] = 1.0F;
+         rsign = rsign + ( 1 << track );
+      }
+      else {
+         cod[i] = -1.0F;
+         _sign[k] = -1.0F;
+      }
+      indx = indx + index;
+   }
+   p0 = h - codvec[0];
+   p1 = h - codvec[1];
+   p2 = h - codvec[2];
+
+   for ( i = 0; i < L_CODE; i++ ) {
+      s = *p0++ * _sign[0];
+      s += *p1++ * _sign[1];
+      s += *p2++ * _sign[2];
+      y[i] = ( Float32 )s;
+   }
+   anap[0] = ( Word16 )indx;
+   anap[1] = ( Word16 )rsign;
+}
+
+
+/*
+ * code_3i40_14bits
+ *
+ *
+ * Parameters:
+ *    x                 I: target vector
+ *    h                 I: impulse response of weighted synthesis filter
+ *    T0                I: Pitch lag
+ *    pitch_sharp       I: Last quantized pitch gain
+ *    code              O: innovative codebook
+ *    y                 O: filtered fixed codebook excitation
+ *    anap              O: analysis parameters
+ *
+ * Function:
+ *    Searches a 14 bit algebraic codebook containing 3 pulses
+ *    in a frame of 40 samples.
+ *
+ *    The code length is 40, containing 3 nonzero pulses: i0...i2.
+ *    All pulses can have two possible amplitudes: +1 or -1.
+ *    Pulse i0 can have 8 possible positions, pulses i1 and i2 can have
+ *    2x8=16 positions.
+ *
+ *       i0 :  0, 5, 10, 15, 20, 25, 30, 35.
+ *       i1 :  1, 6, 11, 16, 21, 26, 31, 36.
+ *             3, 8, 13, 18, 23, 28, 33, 38.
+ *       i2 :  2, 7, 12, 17, 22, 27, 32, 37.
+ *             4, 9, 14, 19, 24, 29, 34, 39.
+ *
+ * Returns:
+ *    void
+ */
+static void code_3i40_14bits( Float32 x[], Float32 h[], Word32 T0, Float32
+      pitch_sharp, Float32 code[], Float32 y[], Word16 *anap )
+{
+   Float32 rr[L_CODE][L_CODE];
+   Float32 dn[L_CODE], dn2[L_CODE], dn_sign[L_CODE];
+   Word32 codvec[3];
+   Word32 i;
+
+
+   if ( ( T0 < L_CODE ) && ( pitch_sharp != 0 ) ) {
+      for ( i = T0; i < L_CODE; i++ ) {
+         h[i] = h[i] + ( h[i - T0] * pitch_sharp );
+      }
+   }
+   cor_h_x( h, x, dn );
+   set_sign( dn, dn_sign, dn2, 6 );
+   cor_h( h, dn_sign, rr );
+   search_3i40( dn, dn2, rr, codvec );
+
+   /* function result */
+   build_code_3i40_14bits( codvec, dn_sign, code, h, y, anap );
+
+   /*
+    * Compute innovation vector gain.
+    * Include fixed-gain pitch contribution into code[].
+    */
+   if ( ( T0 < L_CODE ) && ( pitch_sharp != 0 ) ) {
+      for ( i = T0; i < L_CODE; i++ ) {
+         code[i] = code[i] + ( code[i - T0] * pitch_sharp );
+      }
+   }
+}
+
+
+/*
+ * search_4i40
+ *
+ *
+ * Parameters:
+ *    dn                I: correlation between target and h[]
+ *    dn2               I: maximum of corr. in each track.
+ *    rr                I: matrix of autocorrelation
+ *    codvec            O: algebraic codebook vector
+ *
+ * Function:
+ *    Search the best codevector; determine positions of the 4 pulses
+ *    in the 40-sample frame.
+ *
+ * Returns:
+ *    void
+ */
+static void search_4i40( Float32 dn[], Float32 dn2[], Float32 rr[][L_CODE],
+      Word32 codvec[] )
+{
+   Float64 alpk, alp, alp0, alp1;
+   Float32 ps, psk, ps0, ps1, sq, sq1;
+   Word32 ipos[4];
+   Word32 i0, i1, i2, i3, ix, i, pos, track;
+
+
+   /* Default value */
+   psk = -1;
+   alpk = 1;
+
+   for ( i = 0; i < 4; i++ ) {
+      codvec[i] = i;
+   }
+
+   for ( track = 3; track < 5; track++ ) {
+      /* fix starting position */
+      ipos[0] = 0;
+      ipos[1] = 1;
+      ipos[2] = 2;
+      ipos[3] = track;
+
+      /*
+       * main loop: try 4 tracks.
+       */
+      for ( i = 0; i < 4; i++ ) {
+      /*
+       * i0 loop: try 4 positions (use position with max of corr.).
+       */
+         for ( i0 = ipos[0]; i0 < L_CODE; i0 += STEP ) {
+            if ( dn2[i0] >= 0 ) {
+               ps0 = dn[i0];
+               alp0 = rr[i0][i0] * 0.25F;
+
+               /*
+                * i1 loop: 8 positions.
+                */
+               sq = -1;
+               alp = 1;
+               ps = 0;
+               ix = ipos[1];
+
+               for ( i1 = ipos[1]; i1 < L_CODE; i1 += STEP ) {
+                  ps1 = ps0 + dn[i1];
+
+                  /* alp1 = alp0 + rr[i0][i1] + 1/2*rr[i1][i1]; */
+                  alp1 = alp0 + rr[i1][i1] * 0.25F;
+                  alp1 = alp1 + rr[i0][i1] * 0.5F;
+                  sq1 = ps1 * ps1;
+
+                  if ( ( alp * sq1 ) > ( sq * alp1 ) ) {
+                     sq = sq1;
+                     ps = ps1;
+                     alp = alp1;
+                     ix = i1;
+                  }
+               }
+               i1 = ix;
+
+               /*
+                * i2 loop: 8 positions.
+                */
+               ps0 = ps;
+               alp0 = alp * 0.25F;
+               sq = -1;
+               alp = 1;
+               ps = 0;
+               ix = ipos[2];
+
+               for ( i2 = ipos[2]; i2 < L_CODE; i2 += STEP ) {
+                  ps1 = ps0 + dn[i2];
+
+                  /* alp1 = alp0 + rr[i0][i2] + rr[i1][i2] + 1/2*rr[i2][i2]; */
+                  alp1 = alp0 + rr[i2][i2] * 0.0625F;
+                  alp1 += rr[i1][i2] * 0.125F;
+                  alp1 += rr[i0][i2] * 0.125F;
+                  sq1 = ps1 * ps1;
+
+                  if ( ( alp * sq1 ) > ( sq * alp1 ) ) {
+                     sq = sq1;
+                     ps = ps1;
+                     alp = alp1;
+                     ix = i2;
+                  }
+               }
+               i2 = ix;
+
+               /*
+                * i3 loop: 8 positions
+                */
+               ps0 = ps;
+               alp0 = alp;
+               sq = -1;
+               alp = 1;
+               ps = 0;
+               ix = ipos[3];
+
+               for ( i3 = ipos[3]; i3 < L_CODE; i3 += STEP ) {
+                  ps1 = ps0 + dn[i3];
+
+                  /* alp1 = alp0 + rr[i0][i3] + rr[i1][i3] + rr[i2][i3] + 1/2*rr[i3][i3]; */
+                  alp1 = alp0 + rr[i3][i3] * 0.0625F;
+                  alp1 += rr[i2][i3] * 0.125F;
+                  alp1 += rr[i1][i3] * 0.125F;
+                  alp1 += rr[i0][i3] * 0.125F;
+                  sq1 = ps1 * ps1;
+
+                  if ( ( alp * sq1 ) > ( sq * alp1 ) ) {
+                     sq = sq1;
+                     ps = ps1;
+                     alp = alp1;
+                     ix = i3;
+                  }
+               }
+
+               /*
+                * memorise codevector if this one is better than the last one.
+                */
+               if ( ( alpk * sq ) > ( psk * alp ) ) {
+                  psk = sq;
+                  alpk = alp;
+                  codvec[0] = i0;
+                  codvec[1] = i1;
+                  codvec[2] = i2;
+                  codvec[3] = ix;
+               }
+            }
+         }
+
+          /*
+           * Cyclic permutation of i0,i1,i2 and i3.
+           */
+         pos = ipos[3];
+         ipos[3] = ipos[2];
+         ipos[2] = ipos[1];
+         ipos[1] = ipos[0];
+         ipos[0] = pos;
+      }
+   }
+   return;
+}
+
+
+/*
+ * build_code_4i40
+ *
+ *
+ * Parameters:
+ *    codvec            I: position of pulses
+ *    dn_sign           I: sign of pulses
+ *    cod               O: algebraic codebook vector
+ *    h                 I: impulse response of weighted synthesis filter
+ *    y                 O: filtered innovative code
+ *    anap              O: analysis parameters
+ *
+ * Function:
+ *    Builds the codeword, the filtered codeword and index of the
+ *    codevector, based on the signs and positions of 4 pulses.
+ *
+ * Returns:
+ *    void
+ */
+static void build_code_4i40( Word32 codvec[], Float32 dn_sign[], Float32 cod[],
+      Float32 h[], Float32 y[], Word16 *anap )
+{
+   Float64 s;
+   Float32 *p0, *p1, *p2, *p3;
+   Word32 _sign[4];
+   Word32 i, j, k, track, index, indx = 0, rsign = 0;
+
+
+   memset( cod, 0, 160 );
+
+   for ( k = 0; k < 4; k++ ) {
+      /* read pulse position */
+      i = codvec[k];
+
+      /* read sign */
+      j = ( Word16 )dn_sign[i];
+      index = i / 5;
+      track = i % 5;
+      index = gray[index];
+
+      if ( track == 1 )
+         index = index << 3;
+      else if ( track == 2 ) {
+         index = index << 6;
+      }
+      else if ( track == 3 ) {
+         index = index << 10;
+      }
+      else if ( track == 4 ) {
+         track = 3;
+         index = ( index << 10 ) + 512;
+      }
+
+      if ( j > 0 ) {
+         cod[i] = 0.9998779296875F;
+         _sign[k] = 1;
+         rsign = rsign + ( 1 << track );
+      }
+      else {
+         cod[i] = -1;
+         _sign[k] = -1;
+      }
+      indx = indx + index;
+   }
+   p0 = h - codvec[0];
+   p1 = h - codvec[1];
+   p2 = h - codvec[2];
+   p3 = h - codvec[3];
+
+   for ( i = 0; i < L_CODE; i++ ) {
+      s = *p0++ * _sign[0];
+      s += *p1++ * _sign[1];
+      s += *p2++ * _sign[2];
+      s += *p3++ * _sign[3];
+      y[i] = ( Float32 )( s );
+   }
+   anap[0] = ( Word16 )indx;
+   anap[1] = ( Word16 )rsign;
+}
+
+
+/*
+ * code_4i40_17bits
+ *
+ *
+ * Parameters:
+ *    x                 I: target vector
+ *    h                 I: impulse response of weighted synthesis filter
+ *    T0                I: Pitch lag
+ *    pitch_sharp       I: Last quantized pitch gain
+ *    code              O: innovative codebook
+ *    y                 O: filtered fixed codebook excitation
+ *    anap              O: analysis parameters
+ *
+ * Function:
+ *    Searches a 17 bit algebraic codebook containing 4 pulses
+ *    in a frame of 40 samples.
+ *
+ *    The code length is 40, containing 4 nonzero pulses: i0...i3.
+ *    All pulses can have two possible amplitudes: +1 or -1.
+ *    Pulse i0 to i2 can have 8 possible positions, pulse i3 can have
+ *    2x8=16 positions.
+ *
+ *       i0 :  0, 5, 10, 15, 20, 25, 30, 35.
+ *       i1 :  1, 6, 11, 16, 21, 26, 31, 36.
+ *       i2 :  2, 7, 12, 17, 22, 27, 32, 37.
+ *       i3 :  3, 8, 13, 18, 23, 28, 33, 38.
+ *             4, 9, 14, 19, 24, 29, 34, 39.
+ *
+ * Returns:
+ *    void
+ */
+static void code_4i40_17bits( Float32 x[], Float32 h[], Word32 T0, Float32
+      pitch_sharp, Float32 code[], Float32 y[], Word16 *anap )
+{
+   Float32 rr[L_CODE][L_CODE];
+   Float32 dn[L_CODE], dn2[L_CODE], dn_sign[L_CODE];
+   Word32 codvec[4];
+   Word32 i;
+
+
+   if ( ( T0 < L_CODE ) && ( pitch_sharp != 0 ) ) {
+      for ( i = T0; i < L_CODE; i++ ) {
+         h[i] = h[i] + h[i - T0] * pitch_sharp;
+      }
+   }
+   cor_h_x( h, x, dn );
+   set_sign( dn, dn_sign, dn2, 4 );
+   cor_h( h, dn_sign, rr );
+   search_4i40( dn, dn2, rr, codvec );
+   build_code_4i40( codvec, dn_sign, code, h, y, anap );
+
+   /*
+    * Compute innovation vector gain.
+    * Include fixed-gain pitch contribution into code[].
+    */
+   if ( ( T0 < L_CODE ) && ( pitch_sharp != 0 ) ) {
+      for ( i = T0; i < L_CODE; i++ ) {
+         code[i] = code[i] + ( code[i - T0] * pitch_sharp );
+      }
+   }
+}
+
+
+/*
+ * set_sign12k2
+ *
+ *
+ * Parameters:
+ *    dn                B: correlation between target and h[]
+ *    cn                I: residual after long term prediction
+ *    sign              O: sign of dn[]
+ *    pos_max           O: position of maximum correlation
+ *    nb_track          I: number of tracks
+ *    ipos              O: starting position for each pulse
+ *    step              I: the step size in the tracks
+ *
+ * Function:
+ *    Builds sign[] vector according to "dn[]" and "cn[]", and modifies
+ *    dn[] to include the sign information (dn[i]=sign[i]*dn[i]).
+ *    Also finds the position of maximum of correlation in each track
+ *    and the starting position for each pulse.
+ *
+ *
+ *                  cn[n]                     dn[n]
+ *    b(n) = ----------------------- + -----------------------  ;n = 0,..,39
+ *                   39                        39
+ *            sqrt( SUM cn[i]*cn[i] )   sqrt( SUM dn[i]*dn[i] )
+ *                  i=0                       i=0
+ *
+ *    sign[n] = sign(b[n])
+ *
+ *    d'[n] = sign[n] * d[n]
+ *
+ * Returns:
+ *    void
+ */
+static void set_sign12k2( Float32 dn[], Float32 cn[], Float32 sign[], Word32
+      pos_max[], Word16 nb_track, Word32 ipos[], Word16 step )
+{
+   Float32 b[L_CODE];
+   Float32 val, cor, k_cn, k_dn, max, max_of_all, sum;
+   Word32 i, j, pos = 0;
+
+
+   /* calculate energy for normalization of cn[] and dn[] */
+   sum = 0.01F;
+   sum += (Float32)Dotproduct40( cn, cn );
+   k_cn = ( Float32 )( 1 / sqrt( sum ) );
+   sum = 0.01F;
+   sum += (Float32)Dotproduct40( dn, dn );
+   k_dn = ( Float32 )( 1 / sqrt( sum ) );
+
+   for ( i = 0; i < L_CODE; i++ ) {
+      val = dn[i];
+      cor = ( k_cn * cn[i] ) + ( k_dn * val );
+
+      /* sign = +1 */
+      sign[i] = 1;
+
+      if ( cor < 0 ) {
+         /* sign = -1 */
+         sign[i] = -1;
+         cor = -cor;
+         val = -val;
+      }
+
+      /* modify dn[] according to the fixed sign */
+      dn[i] = val;
+      b[i] = cor;
+   }
+   max_of_all = -1;
+
+   for ( i = 0; i < nb_track; i++ ) {
+      max = -1;
+
+      for ( j = i; j < L_CODE; j += step ) {
+         cor = b[j];
+         val = cor - max;
+
+         if ( val > 0 ) {
+            max = cor;
+            pos = j;
+         }
+      }
+
+      /* store maximum correlation position in track */
+      pos_max[i] = pos;
+      val = max - max_of_all;
+
+      if ( val > 0 ) {
+         /* store maximum correlation of all tracks */
+         max_of_all = max;
+
+         /* starting position for i0 */
+         ipos[0] = i;
+      }
+   }
+
+   /* Set starting position of each pulse	*/
+   pos = ipos[0];
+   ipos[nb_track] = pos;
+
+   for ( i = 1; i < nb_track; i++ ) {
+      pos++;
+
+      if ( pos >= nb_track ) {
+         pos = 0;
+      }
+      ipos[i] = pos;
+      ipos[i + nb_track] = pos;
+   }
+}
+
+
+/*
+ * search_4i40
+ *
+ *
+ * Parameters:
+ *    dn                I: correlation between target and h[]
+ *    rr                I: matrix of autocorrelation
+ *    ipos              I: starting position for each pulse
+ *    pos_max           I: maximum of correlation position
+ *    codvec            O: algebraic codebook vector
+ *
+ * Function:
+ *    Search the best codevector; determine positions of the 8 pulses
+ *    in the 40-sample frame.
+ *
+ * Returns:
+ *    void
+ */
+static void search_8i40( Float32 dn[], Float32 rr[][L_CODE], Word32 ipos[],
+      Word32 pos_max[], Word32 codvec[] )
+{
+   Float32 rrv[L_CODE];
+   Float32 psk, ps, ps0, ps1, ps2, sq, sq2, alpk, alp, alp0, alp1, alp2;
+   Float32 *p_r, *p_r0, *p_r1, *p_r2, *p_r3, *p_r4, *p_r5, *p_r6, *p_r7, *p_r8;
+   Float32 *p_rrv, *p_rrv0, *p_dn, *p_dn0, *p_dn1, *p_dn_max;
+   Word32 i0, i1, i2, i3, i4, i5, i6, i7, j, k, ia, ib, i, pos;
+
+   p_dn_max = &dn[39];
+
+   /* fix i0 on maximum of correlation position */
+   i0 = pos_max[ipos[0]];
+   ia = ib = 0;
+   ps = 0;
+
+   /* i1 loop */
+   /* Default value */
+   psk = -1;
+   alpk = 1;
+
+   for ( i = 0; i < 8; i++ ) {
+      codvec[i] = i;
+   }
+   p_r = &rr[i0][i0];
+
+   for ( i = 1; i < 5; i++ ) {
+      i1 = pos_max[ipos[1]];
+      i2 = ipos[2];
+      i3 = ipos[3];
+      i4 = ipos[4];
+      i5 = ipos[5];
+      i6 = ipos[6];
+      i7 = ipos[7];
+      ps0 = dn[i0] + dn[i1];
+      alp0 = *p_r + rr[i1][i1] + 2.0F * rr[i0][i1];
+
+      /* i2 and i3 loop	*/
+      p_rrv = &rrv[i3];
+      p_r0 = &rr[i0][i3];
+      p_r1 = &rr[i1][i3];
+      p_r3 = &rr[i3][i3];
+      *p_rrv = *p_r3 + 2.0F * ( *p_r0 + *p_r1 );
+      *( p_rrv + 4 ) = *( p_r3 + 164 ) + 2.0F * ( *( p_r0 + 4 ) + *( p_r1 + 4 )
+            );
+      *( p_rrv + 8 ) = *( p_r3 + 328 ) + 2.0F * ( *( p_r0 + 8 ) + *( p_r1 + 8 )
+            );
+      *( p_rrv + 12 ) = *( p_r3 + 492 ) + 2.0F * ( *( p_r0 + 12 ) + *( p_r1 + 12
+            ) );
+      *( p_rrv + 16 ) = *( p_r3 + 656 ) + 2.0F * ( *( p_r0 + 16 ) + *( p_r1 + 16
+            ) );
+      *( p_rrv + 20 ) = *( p_r3 + 820 ) + 2.0F * ( *( p_r0 + 20 ) + *( p_r1 + 20
+            ) );
+      *( p_rrv + 24 ) = *( p_r3 + 984 ) + 2.0F * ( *( p_r0 + 24 ) + *( p_r1 + 24
+            ) );
+      *( p_rrv + 28 ) = *( p_r3 + 1148 ) + 2.0F * ( *( p_r0 + 28 ) + *( p_r1 +
+            28 ) );
+      *( p_rrv + 32 ) = *( p_r3 + 1312 ) + 2.0F * ( *( p_r0 + 32 ) + *( p_r1 +
+            32 ) );
+      *( p_rrv + 36 ) = *( p_r3 + 1476 ) + 2.0F * ( *( p_r0 + 36 ) + *( p_r1 +
+            36 ) );
+      sq = -1;
+      alp = 1;
+      ps = 0;
+      ia = i2;
+      ib = i3;
+      p_rrv = rrv + i3;
+      p_r0 = &rr[i0][i2];
+      p_r1 = &rr[i1][i2];
+      p_r2 = &rr[i2][i2];
+      p_r3 = &rr[i2][i3];
+      p_dn0 = dn + i2;
+      p_dn1 = dn + i3;
+      p_rrv0 = rrv + i3;
+
+      do {
+         ps1 = ps0 + *p_dn0;
+         alp1 = alp0 + *p_r2 + 2.0F * ( *p_r0 + *p_r1 );
+         p_rrv = p_rrv0;
+         p_dn = p_dn1;
+         p_r4 = p_r3;
+
+         do {
+            ps2 = ps1 + *p_dn;
+            sq2 = ps2 * ps2;
+            alp2 = alp1 + *p_rrv + 2.0F * *p_r4;
+
+            if ( ( alp * sq2 ) > ( sq * alp2 ) ) {
+               sq = sq2;
+               ps = ps2;
+               alp = alp2;
+               ia = p_dn0 - dn;
+               ib = p_dn - dn;
+            }
+            p_rrv += 4;
+            p_dn += 4;
+            p_r4 += 4;
+         } while ( p_dn < p_dn_max );
+         p_dn0 += 4;
+         p_r0 += 4;
+         p_r1 += 4;
+         p_r2 += 164;
+         p_r3 += 160;
+      } while ( p_dn0 <= p_dn_max );
+      i2 = ia;
+      i3 = ib;
+
+      /* i4 and i5 loop	*/
+      p_rrv = rrv + i5;
+      p_r0 = &rr[i0][i5];
+      p_r1 = &rr[i1][i5];
+      p_r2 = &rr[i2][i5];
+      p_r3 = &rr[i3][i5];
+      p_r5 = &rr[i5][i5];
+      *p_rrv = *p_r5 + 2.0F * ( *p_r0 + *p_r1 + *p_r2 + *p_r3 );
+      *( p_rrv + 4 ) = *( p_r5 + 164 ) + 2.0F * ( *( p_r0 + 4 ) + *( p_r1 + 4 )
+            + *( p_r2 + 4 ) + *( p_r3 + 4 ) );
+      *( p_rrv + 8 ) = *( p_r5 + 328 ) + 2.0F * ( *( p_r0 + 8 ) + *( p_r1 + 8 )
+            + *( p_r2 + 8 ) + *( p_r3 + 8 ) );
+      *( p_rrv + 12 ) = *( p_r5 + 492 ) + 2.0F * ( *( p_r0 + 12 ) + *( p_r1 + 12
+            ) + *( p_r2 + 12 ) + *( p_r3 + 12 ) );
+      *( p_rrv + 16 ) = *( p_r5 + 656 ) + 2.0F * ( *( p_r0 + 16 ) + *( p_r1 + 16
+            ) + *( p_r2 + 16 ) + *( p_r3 + 16 ) );
+      *( p_rrv + 20 ) = *( p_r5 + 820 ) + 2.0F * ( *( p_r0 + 20 ) + *( p_r1 + 20
+            ) + *( p_r2 + 20 ) + *( p_r3 + 20 ) );
+      *( p_rrv + 24 ) = *( p_r5 + 984 ) + 2.0F * ( *( p_r0 + 24 ) + *( p_r1 + 24
+            ) + *( p_r2 + 24 ) + *( p_r3 + 24 ) );
+      *( p_rrv + 28 ) = *( p_r5 + 1148 ) + 2.0F * ( *( p_r0 + 28 ) + *( p_r1 +
+            28 ) + *( p_r2 + 28 ) + *( p_r3 + 28 ) );
+      *( p_rrv + 32 ) = *( p_r5 + 1312 ) + 2.0F * ( *( p_r0 + 32 ) + *( p_r1 +
+            32 ) + *( p_r2 + 32 ) + *( p_r3 + 32 ) );
+      *( p_rrv + 36 ) = *( p_r5 + 1476 ) + 2.0F * ( *( p_r0 + 36 ) + *( p_r1 +
+            36 ) + *( p_r2 + 36 ) + *( p_r3 + 36 ) );
+
+      /* Default value */
+      ps0 = ps;
+      alp0 = alp;
+      sq = -1;
+      alp = 1;
+      ps = 0;
+      ia = i4;
+      ib = i5;
+      p_dn0 = dn + i4;
+      p_dn1 = dn + i5;
+      p_r0 = &rr[i0][i4];
+      p_r1 = &rr[i1][i4];
+      p_r2 = &rr[i2][i4];
+      p_r3 = &rr[i3][i4];
+      p_r4 = &rr[i4][i4];
+      p_r5 = &rr[i4][i5];
+      p_rrv0 = rrv + i5;
+
+      do {
+         ps1 = ps0 + *p_dn0;
+         alp1 = alp0 + *p_r4 + 2.0F * ( *p_r0 + *p_r1 + *p_r2 + *p_r3 );
+         p_dn = p_dn1;
+         p_r6 = p_r5;
+         p_rrv = p_rrv0;
+
+         do {
+            ps2 = ps1 + *p_dn;
+            sq2 = ps2 * ps2;
+            alp2 = alp1 + *p_rrv + 2.0F * *p_r6;
+
+            if ( ( alp * sq2 ) > ( sq * alp2 ) ) {
+               sq = sq2;
+               ps = ps2;
+               alp = alp2;
+               ia = p_dn0 - dn;
+               ib = p_dn - dn;
+            }
+            p_dn += 4;
+            p_rrv += 4;
+            p_r6 += 4;
+         } while ( p_dn <= p_dn_max );
+         p_r0 += 4;
+         p_r1 += 4;
+         p_r2 += 4;
+         p_r3 += 4;
+         p_r4 += 164;
+         p_r5 += 160;
+         p_dn0 += 4;
+      } while ( p_dn0 < p_dn_max );
+      i4 = ia;
+      i5 = ib;
+
+      /* i6 and i7 loop	*/
+      p_rrv = rrv + i7;
+      p_r0 = &rr[i0][i7];
+      p_r1 = &rr[i1][i7];
+      p_r2 = &rr[i2][i7];
+      p_r3 = &rr[i3][i7];
+      p_r4 = &rr[i4][i7];
+      p_r5 = &rr[i5][i7];
+      p_r7 = &rr[i7][i7];
+      *p_rrv = *p_r7 + 2.0F * ( *p_r0 + *p_r1 + *p_r2 + *p_r3 + *p_r4 + *p_r5 );
+      *( p_rrv + 4 ) = *( p_r7 + 164 ) + 2.0F * ( *( p_r0 + 4 ) + *( p_r1 + 4 )
+            + *( p_r2 + 4 ) + *( p_r3 + 4 ) + *( p_r4 + 4 ) + *( p_r5 + 4 ) );
+      *( p_rrv + 8 ) = *( p_r7 + 328 ) + 2.0F * ( *( p_r0 + 8 ) + *( p_r1 + 8 )
+            + *( p_r2 + 8 ) + *( p_r3 + 8 ) + *( p_r4 + 8 ) + *( p_r5 + 8 ) );
+      *( p_rrv + 12 ) = *( p_r7 + 492 ) + 2.0F * ( *( p_r0 + 12 ) + *( p_r1 + 12
+            ) + *( p_r2 + 12 ) + *( p_r3 + 12 ) + *( p_r4 + 12 ) + *( p_r5 + 12
+            ) );
+      *( p_rrv + 16 ) = *( p_r7 + 656 ) + 2.0F * ( *( p_r0 + 16 ) + *( p_r1 + 16
+            ) + *( p_r2 + 16 ) + *( p_r3 + 16 ) + *( p_r4 + 16 ) + *( p_r5 + 16
+            ) );
+      *( p_rrv + 20 ) = *( p_r7 + 820 ) + 2.0F * ( *( p_r0 + 20 ) + *( p_r1 + 20
+            ) + *( p_r2 + 20 ) + *( p_r3 + 20 ) + *( p_r4 + 20 ) + *( p_r5 + 20
+            ) );
+      *( p_rrv + 24 ) = *( p_r7 + 984 ) + 2.0F * ( *( p_r0 + 24 ) + *( p_r1 + 24
+            ) + *( p_r2 + 24 ) + *( p_r3 + 24 ) + *( p_r4 + 24 ) + *( p_r5 + 24
+            ) );
+      *( p_rrv + 28 ) = *( p_r7 + 1148 ) + 2.0F * ( *( p_r0 + 28 ) + *( p_r1 +
+            28 ) + *( p_r2 + 28 ) + *( p_r3 + 28 ) + *( p_r4 + 28 ) + *( p_r5 +
+            28 ) );
+      *( p_rrv + 32 ) = *( p_r7 + 1312 ) + 2.0F * ( *( p_r0 + 32 ) + *( p_r1 +
+            32 ) + *( p_r2 + 32 ) + *( p_r3 + 32 ) + *( p_r4 + 32 ) + *( p_r5 +
+            32 ) );
+      *( p_rrv + 36 ) = *( p_r7 + 1476 ) + 2.0F * ( *( p_r0 + 36 ) + *( p_r1 +
+            36 ) + *( p_r2 + 36 ) + *( p_r3 + 36 ) + *( p_r4 + 36 ) + *( p_r5 +
+            36 ) );
+
+      /* Default value */
+      ps0 = ps;
+      alp0 = alp;
+      sq = -1;
+      alp = 1;
+      ps = 0;
+      ia = i6;
+      ib = i7;
+      p_dn0 = dn + i6;
+      p_dn1 = dn + i7;
+      p_r0 = &rr[i0][i6];
+      p_r1 = &rr[i1][i6];
+      p_r2 = &rr[i2][i6];
+      p_r3 = &rr[i3][i6];
+      p_r4 = &rr[i4][i6];
+      p_r5 = &rr[i5][i6];
+      p_r6 = &rr[i6][i6];
+      p_r7 = &rr[i6][i7];
+      p_rrv0 = rrv + i7;
+
+      do {
+         ps1 = ps0 + *p_dn0;
+         alp1 = alp0 + *p_r6 + 2.0F * ( *p_r0 + *p_r1 + *p_r2 + *p_r3 + *p_r4 +
+               *p_r5 );
+         p_dn = p_dn1;
+         p_r8 = p_r7;
+         p_rrv = p_rrv0;
+
+         do {
+            ps2 = ps1 + *p_dn;
+            sq2 = ps2 * ps2;
+            alp2 = alp1 + *p_rrv + 2.0F * *p_r8;
+
+            if ( ( alp * sq2 ) > ( sq * alp2 ) ) {
+               sq = sq2;
+               ps = ps2;
+               alp = alp2;
+               ia = p_dn0 - dn;
+               ib = p_dn - dn;
+            }
+            p_dn += 4;
+            p_rrv += 4;
+            p_r8 += 4;
+         } while ( p_dn <= p_dn_max );
+         p_r0 += 4;
+         p_r1 += 4;
+         p_r2 += 4;
+         p_r3 += 4;
+         p_r4 += 4;
+         p_r5 += 4;
+         p_r6 += 164;
+         p_r7 += 160;
+         p_dn0 += 4;
+      } while ( p_dn0 < p_dn_max );
+
+      /*
+       * now finished searching a set of 8 pulses
+       * test and memorise if this combination is better than the last one.
+       */
+      if ( ( alpk * sq ) > ( psk * alp ) ) {
+         psk = sq;
+         alpk = alp;
+         codvec[0] = ( Word16 )i0;
+         codvec[1] = ( Word16 )i1;
+         codvec[2] = ( Word16 )i2;
+         codvec[3] = ( Word16 )i3;
+         codvec[4] = ( Word16 )i4;
+         codvec[5] = ( Word16 )i5;
+         codvec[6] = ( Word16 )ia;
+         codvec[7] = ( Word16 )ib;
+      }
+
+      /*
+       * Cyclic permutation of i1,i2,i3,i4,i5,i6,i7,(i8 and i9).
+       */
+      pos = ipos[1];
+
+      for ( j = 1, k = 2; k < 8; j++, k++ ) {
+         ipos[j] = ipos[k];
+      }
+      ipos[7] = pos;
+   }   /* end 1..nb_tracks  loop*/
+}
+
+
+/*
+ * build_code_8i40_31bits
+ *
+ *
+ * Parameters:
+ *    codvec            I: position of pulses
+ *    dn_sign           I: sign of pulses
+ *    cod               O: algebraic codebook vector
+ *    h                 I: impulse response of weighted synthesis filter
+ *    y                 O: filtered innovative code
+ *    sign_indx         O: signs of 4  pulses (signs only)
+ *    pos_indx          O: position index of 8 pulses (position only)
+ *
+ * Function:
+ *    Builds the codeword, the filtered codeword and a
+ *    linear uncombined version of  the index of the
+ *    codevector, based on the signs and positions of 8  pulses.
+ *
+ * Returns:
+ *    void
+ */
+static void build_code_8i40_31bits( Word32 codvec[], Float32 dn_sign[], Float32
+      cod[], Float32 h[], Float32 y[], Word32 sign_indx[], Word32 pos_indx[] )
+{
+   Float64 s;
+   Float32 *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7;
+   Word32 sign[8];
+   Word32 i, j, k, track, sign_index, pos_index;
+
+
+   memset( cod, 0, L_CODE <<2 );
+
+   for ( i = 0; i < NB_TRACK_MR102; i++ ) {
+      pos_indx[i] = -1;
+      sign_indx[i] = -1;
+   }
+
+   for ( k = 0; k < 8; k++ ) {
+      /* read pulse position */
+      i = codvec[k];
+
+      /* read sign */
+      j = ( Word32 )dn_sign[i];
+
+      /* index = pos/4 */
+      pos_index = i >> 2;
+
+      /* track = pos%4 */
+      track = i & 3;
+
+      if ( j > 0 ) {
+         cod[i] = cod[i] + 0.99987792968750F;
+         sign[k] = 1;
+
+         /* bit=0 -> positive pulse */
+         sign_index = 0;
+      }
+      else {
+         cod[i] = cod[i] - 0.99987792968750F;
+         sign[k] = -1;
+
+         /* bit=1 => negative pulse */
+         sign_index = 1;
+      }
+
+      /* first set first NB_TRACK pulses */
+      if ( pos_indx[track] < 0 ) {
+         pos_indx[track] = pos_index;
+         sign_indx[track] = sign_index;
+      }
+
+      /* 2nd row of pulses , test if positions needs to be switched */
+      else {
+         if ( ( ( sign_index ^ sign_indx[track] ) & 1 ) == 0 ) {
+            /* sign of 1st pulse == sign of 2nd pulse */
+            if ( pos_indx[track] <= pos_index ) {
+               /* no swap */
+               pos_indx[track + NB_TRACK_MR102] = pos_index;
+            }
+            else {
+               /* swap*/
+               pos_indx[track + NB_TRACK_MR102] = pos_indx[track];
+               pos_indx[track] = pos_index;
+               sign_indx[track] = sign_index;
+            }
+         }
+         else {
+            /* sign of 1st pulse != sign of 2nd pulse */
+            if ( pos_indx[track] <= pos_index ) {   /*swap*/
+               pos_indx[track + NB_TRACK_MR102] = pos_indx[track];
+               pos_indx[track] = pos_index;
+               sign_indx[track] = sign_index;
+            }
+            else {
+               /*no swap */
+               pos_indx[track + NB_TRACK_MR102] = pos_index;
+            }
+         }
+      }
+   }
+   p0 = h - codvec[0];
+   p1 = h - codvec[1];
+   p2 = h - codvec[2];
+   p3 = h - codvec[3];
+   p4 = h - codvec[4];
+   p5 = h - codvec[5];
+   p6 = h - codvec[6];
+   p7 = h - codvec[7];
+
+   for ( i = 0; i < L_CODE; i++ ) {
+      s = *p0++ * sign[0];
+      s += *p1++ * sign[1];
+      s += *p2++ * sign[2];
+      s += *p3++ * sign[3];
+      s += *p4++ * sign[4];
+      s += *p5++ * sign[5];
+      s += *p6++ * sign[6];
+      s += *p7++ * sign[7];
+      y[i] = ( Float32 )( s );
+   }
+}
+
+
+/*
+ * compress10
+ *
+ *
+ * Parameters:
+ *    pos_indxA         I: signs of 4 pulses (signs only)
+ *    pos_indxB         I: position index of 8 pulses (pos only)
+ *    pos_indxC         I: position and sign of 8 pulses (compressed)
+ * Function:
+ *    Compression of three indeces [0..9] to one 10 bit index
+ *    minimizing the phase shift of a bit error.
+ *
+ * Returns:
+ *    indx
+ */
+static Word16 compress10( Word32 pos_indxA, Word32 pos_indxB, Word32
+      pos_indxC )
+{
+   Word32 indx, ia, ib, ic;
+
+
+   ia = pos_indxA >> 1;
+   ib = ( ( pos_indxB >> 1 ) * 5 );
+   ic = ( ( pos_indxC >> 1 ) * 25 );
+   indx = ( ia + ( ib + ic ) ) << 3;
+   ia = pos_indxA & 1;
+   ib = ( pos_indxB & 1 ) << 1;
+   ic = ( pos_indxC & 1 ) << 2;
+   indx = indx + ( ia + ( ib + ic ) );
+   return( Word16 )indx;
+}
+
+
+/*
+ * compress_code
+ *
+ *
+ * Parameters:
+ *    sign_indx         I: signs of 4 pulses (signs only)
+ *    pos_indx          I: position index of 8 pulses (pos only)
+ *    indx              O: position and sign of 8 pulses (compressed)
+ * Function:
+ *    Compression of the linear codewords to 4+three indeces one bit from each
+ *    pulse is made robust to errors by minimizing the phase shift of a bit error.
+ *       4 signs (one for each track)
+ *       i0,i4,i1 => one index (7+3) bits, 3   LSBs more robust
+ *       i2,i6,i5 => one index (7+3) bits, 3   LSBs more robust
+ *       i3,i7    => one index (5+2) bits, 2-3 LSBs more robust
+ *
+ * Returns:
+ *    void
+ */
+static void compress_code( Word32 sign_indx[], Word32 pos_indx[], Word16 indx[]
+      )
+{
+   Word32 i, ia, ib, ic;
+
+
+   for ( i = 0; i < NB_TRACK_MR102; i++ ) {
+      indx[i] = ( Word16 )sign_indx[i];
+   }
+
+   /*
+    * First index
+    * indx[NB_TRACK] = (ia/2+(ib/2)*5 +(ic/2)*25)*8 + ia%2 + (ib%2)*2 + (ic%2)*4;
+    */
+   indx[NB_TRACK_MR102] = compress10( pos_indx[0], pos_indx[4], pos_indx[1] );
+
+   /*
+    * Second index
+    * indx[NB_TRACK+1] = (ia/2+(ib/2)*5 +(ic/2)*25)*8 + ia%2 + (ib%2)*2 + (ic%2)*4;
+    */
+   indx[NB_TRACK_MR102 + 1] = compress10( pos_indx[2], pos_indx[6], pos_indx[5]
+         );
+
+   /*
+    * Third index
+    * if ((ib/2)%2 == 1)
+    * indx[NB_TRACK+2] = ((((4-ia/2) + (ib/2)*5)*32+12)/25)*4 + ia%2 + (ib%2)*2;
+    * else
+    * indx[NB_TRACK+2] = ((((ia/2) +   (ib/2)*5)*32+12)/25)*4 + ia%2 + (ib%2)*2;
+    */
+   ib = ( pos_indx[7] >> 1 ) & 1;
+
+   if ( ib == 1 )
+      ia = 4 - ( pos_indx[3] >> 1 );
+   else
+      ia = pos_indx[3] >> 1;
+   ib = ( ( pos_indx[7] >> 1 ) * 5 );
+   ib = ( ( ia + ib ) << 5 ) + 12;
+   ic = ( ( ib * 1311 ) >> 15 ) << 2;
+   ia = pos_indx[3] & 1;
+   ib = ( pos_indx[7] & 1 ) << 1;
+   indx[NB_TRACK_MR102 + 2] = ( Word16 )( ia + ( ib + ic ) );
+}
+
+
+/*
+ * code_8i40_31bits
+ *
+ *
+ * Parameters:
+ *    x                 I: target vector
+ *    cn                I: residual after long term prediction
+ *    h                 I: impulse response of weighted synthesis filter
+ *    T0                I: Pitch lag
+ *    pitch_sharp       I: Last quantized pitch gain
+ *    code              O: algebraic (fixed) codebook excitation
+ *    y                 O: filtered fixed codebook excitation
+ *    anap              O: 7 Word16, index of 8 pulses (signs+positions)
+ *
+ * Function:
+ *    Searches a 31 bit algebraic codebook containing 8 pulses
+ *    in a frame of 40 samples.
+ *
+ *    The code contains 8 nonzero pulses: i0...i7.
+ *    All pulses can have two possible amplitudes: +1 or -1.
+ *    The 40 positions in a subframe are divided into 4 tracks of
+ *    interleaved positions. Each track contains two pulses.
+ *    The pulses can have the following possible positions:
+ *
+ *       i0, i4 :  0, 4, 8,  12, 16, 20, 24, 28, 32, 36
+ *       i1, i5 :  1, 5, 9,  13, 17, 21, 25, 29, 33, 37
+ *       i2, i6 :  2, 6, 10, 14, 18, 22, 26, 30, 34, 38
+ *       i3, i7 :  3, 7, 11, 15, 19, 23, 27, 31, 35, 39
+ *
+ *    Each pair of pulses require 1 bit for their signs. The positions
+ *    are encoded together 3,3 and 2 resulting in
+ *    (7+3) + (7+3) + (5+2) bits for their
+ *    positions. This results in a 31 (4 sign and 27 pos) bit codebook.
+ *    The function determines the optimal pulse signs and positions, builds
+ *    the codevector, and computes the filtered codevector.
+ *
+ * Returns:
+ *    void
+ */
+static void code_8i40_31bits( Float32 x[], Float32 cn[], Float32 h[],
+                             Word32 T0, Float32 pitch_sharp, Float32 code[],
+                             Float32 y[], Word16 anap[] )
+{
+   Float32 rr[L_CODE][L_CODE];
+   Float32 dn[L_CODE], sign[L_CODE];
+   Word32 ipos[8], pos_max[NB_TRACK_MR102], codvec[8], linear_signs[
+      NB_TRACK_MR102], linear_codewords[8];
+   Word32 i;
+
+   if ( pitch_sharp > 1.0F )
+      pitch_sharp = 1.0F;
+
+   /* include pitch contribution into impulse resp. */
+   if ( pitch_sharp != 0 ) {
+      for ( i = T0; i < L_SUBFR; i++ ) {
+         h[i] += h[i - T0] * pitch_sharp;
+      }
+   }
+
+   cor_h_x( h, x, dn );
+   set_sign12k2( dn, cn, sign, pos_max, NB_TRACK_MR102, ipos, STEP_MR102 );
+   cor_h( h, sign, rr );
+   search_8i40( dn, rr, ipos, pos_max, codvec );
+   build_code_8i40_31bits( codvec, sign, code, h, y, linear_signs,
+      linear_codewords );
+   compress_code( linear_signs, linear_codewords, anap );
+
+   /* Add the pitch contribution to code[]. */
+   if ( pitch_sharp != 0 ) {
+      for ( i = T0; i < L_SUBFR; i++ ) {
+         code[i] += code[i - T0] * pitch_sharp;
+      }
+   }
+   return;
+}
+
+
+/*
+ * search_10i40
+ *
+ *
+ * Parameters:
+ *    dn                I: correlation between target and h[]
+ *    rr                I: matrix of autocorrelation
+ *    ipos              I: starting position for each pulse
+ *    pos_max           I: maximum of correlation position
+ *    codvec            O: algebraic codebook vector
+ *
+ * Function:
+ *    Search the best codevector; determine positions of the 10
+ *    pulses in the 40-sample frame.
+ *
+ *    First, for each of the five tracks the pulse positions with maximum
+ *    absolute values of b(n) are searched. From these the global maximum value
+ *    for all the pulse positions is selected. The first pulse i0 is always set
+ *    into the position corresponding to the global maximum value.
+ *    Next, four iterations are carried out. During each iteration the position
+ *    of pulse i1 is set to the local maximum of one track.
+ *    The rest of the pulses are searched in pairs by sequentially searching
+ *    each of the pulse pairs {i2,i3}, {i4,i5}, {i6,i7} and {i8,i9}
+ *    in nested loops. Every pulse has 8 possible positions, i.e., there are
+ *    four 8x8-loops, resulting in 256 different combinations of
+ *    pulse positions for each iteration. In each iteration all the 9 pulse
+ *    starting positions are cyclically shifted, so that the pulse pairs are
+ *    changed and the pulse i1 is placed in a local maximum of
+ *    a different track. The rest of the pulses are searched also for
+ *    the other positions in the tracks. At least one pulse is located in
+ *    a position corresponding to the global maximum and one pulse is
+ *    located in a position corresponding to one of the 4 local maxima.
+ *
+ * Returns:
+ *    void
+ */
+static void search_10i40( Float32 dn[], Float32 rr[][L_CODE], Word32 ipos[],
+      Word32 pos_max[], Word32 codvec[] )
+{
+   Float32 rrv[L_CODE];
+   Float32 psk, ps, ps0, ps1, ps2, sq, sq2, alpk, alp, alp0, alp1, alp2;
+   Float32 *p_r, *p_r0, *p_r1, *p_r2, *p_r3, *p_r4, *p_r5, *p_r6, *p_r7, *p_r8,
+         *p_r9, *p_r10;
+   Float32 *p_rrv, *p_rrv0, *p_dn, *p_dn0, *p_dn1, *p_dn_max;
+   Word32 i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, j, k, ia, ib, i, pos;
+
+   p_dn_max = &dn[39];
+
+   /* fix i0 on maximum of correlation position */
+   i0 = pos_max[ipos[0]];
+   ia = ib = 0;
+   ps = 0;
+
+   /* i1 loop */
+   psk = -1;
+   alpk = 1;
+
+   for ( i = 0; i < 10; i++ ) {
+      codvec[i] = i;
+   }
+   p_r = &rr[i0][i0];
+
+   for ( i = 1; i < 5; i++ ) {
+      i1 = pos_max[ipos[1]];
+      i2 = ipos[2];
+      i3 = ipos[3];
+      i4 = ipos[4];
+      i5 = ipos[5];
+      i6 = ipos[6];
+      i7 = ipos[7];
+      i8 = ipos[8];
+      i9 = ipos[9];
+      ps0 = dn[i0] + dn[i1];
+      alp0 = *p_r + rr[i1][i1] + 2.0F * rr[i0][i1];
+
+      /* i2 and i3 loop	*/
+      p_rrv = &rrv[i3];
+      p_r0 = &rr[i0][i3];
+      p_r1 = &rr[i1][i3];
+      p_r3 = &rr[i3][i3];
+      *p_rrv = *p_r3 + 2.0F * ( *p_r0 + *p_r1 );
+      *( p_rrv + 5 ) = *( p_r3 + 205 ) + 2.0F * ( *( p_r0 + 5 ) + *( p_r1 + 5 )
+            );
+      *( p_rrv + 10 ) = *( p_r3 + 410 ) + 2.0F * ( *( p_r0 + 10 ) + *( p_r1 + 10
+            ) );
+      *( p_rrv + 15 ) = *( p_r3 + 615 ) + 2.0F * ( *( p_r0 + 15 ) + *( p_r1 + 15
+            ) );
+      *( p_rrv + 20 ) = *( p_r3 + 820 ) + 2.0F * ( *( p_r0 + 20 ) + *( p_r1 + 20
+            ) );
+      *( p_rrv + 25 ) = *( p_r3 + 1025 ) + 2.0F * ( *( p_r0 + 25 ) + *( p_r1 +
+            25 ) );
+      *( p_rrv + 30 ) = *( p_r3 + 1230 ) + 2.0F * ( *( p_r0 + 30 ) + *( p_r1 +
+            30 ) );
+      *( p_rrv + 35 ) = *( p_r3 + 1435 ) + 2.0F * ( *( p_r0 + 35 ) + *( p_r1 +
+            35 ) );
+      sq = -1;
+      alp = 1;
+      ps = 0;
+      ia = i2;
+      ib = i3;
+      p_rrv = rrv + i3;
+      p_r0 = &rr[i0][i2];
+      p_r1 = &rr[i1][i2];
+      p_r2 = &rr[i2][i2];
+      p_r3 = &rr[i2][i3];
+      p_dn0 = dn + i2;
+      p_dn1 = dn + i3;
+      p_rrv0 = rrv + i3;
+
+      do {
+         ps1 = ps0 + *p_dn0;
+         alp1 = alp0 + *p_r2 + 2.0F * ( *p_r0 + *p_r1 );
+         p_rrv = p_rrv0;
+         p_dn = p_dn1;
+         p_r4 = p_r3;
+
+         do {
+            ps2 = ps1 + *p_dn;
+            sq2 = ps2 * ps2;
+            alp2 = alp1 + *p_rrv + 2.0F * *p_r4;
+
+            if ( ( alp * sq2 ) > ( sq * alp2 ) ) {
+               sq = sq2;
+               ps = ps2;
+               alp = alp2;
+               ia = ( Word16 )( p_dn0 - dn );
+               ib = ( Word16 )( p_dn - dn );
+            }
+            p_rrv += 5;
+            p_dn += 5;
+            p_r4 += 5;
+         } while ( p_dn < p_dn_max );
+         p_dn0 += 5;
+         p_r0 += 5;
+         p_r1 += 5;
+         p_r2 += 205;
+         p_r3 += 200;
+      } while ( p_dn0 <= p_dn_max );
+      i2 = ia;
+      i3 = ib;
+
+      /* i4 and i5 loop	*/
+      p_rrv = rrv + i5;
+      p_r0 = &rr[i0][i5];
+      p_r1 = &rr[i1][i5];
+      p_r2 = &rr[i2][i5];
+      p_r3 = &rr[i3][i5];
+      p_r5 = &rr[i5][i5];
+      *p_rrv = *p_r5 + 2.0F * ( *p_r0 + *p_r1 + *p_r2 + *p_r3 );
+      *( p_rrv + 5 ) = *( p_r5 + 205 ) + 2.0F * ( *( p_r0 + 5 ) + *( p_r1 + 5 )
+            + *( p_r2 + 5 ) + *( p_r3 + 5 ) );
+      *( p_rrv + 10 ) = *( p_r5 + 410 ) + 2.0F * ( *( p_r0 + 10 ) + *( p_r1 + 10
+            ) + *( p_r2 + 10 ) + *( p_r3 + 10 ) );
+      *( p_rrv + 15 ) = *( p_r5 + 615 ) + 2.0F * ( *( p_r0 + 15 ) + *( p_r1 + 15
+            ) + *( p_r2 + 15 ) + *( p_r3 + 15 ) );
+      *( p_rrv + 20 ) = *( p_r5 + 820 ) + 2.0F * ( *( p_r0 + 20 ) + *( p_r1 + 20
+            ) + *( p_r2 + 20 ) + *( p_r3 + 20 ) );
+      *( p_rrv + 25 ) = *( p_r5 + 1025 ) + 2.0F * ( *( p_r0 + 25 ) + *( p_r1 +
+            25 ) + *( p_r2 + 25 ) + *( p_r3 + 25 ) );
+      *( p_rrv + 30 ) = *( p_r5 + 1230 ) + 2.0F * ( *( p_r0 + 30 ) + *( p_r1 +
+            30 ) + *( p_r2 + 30 ) + *( p_r3 + 30 ) );
+      *( p_rrv + 35 ) = *( p_r5 + 1435 ) + 2.0F * ( *( p_r0 + 35 ) + *( p_r1 +
+            35 ) + *( p_r2 + 35 ) + *( p_r3 + 35 ) );
+
+      /* Default value */
+      ps0 = ps;
+      alp0 = alp;
+      sq = -1;
+      alp = 1;
+      ps = 0;
+      ia = i4;
+      ib = i5;
+      p_dn0 = dn + i4;
+      p_dn1 = dn + i5;
+      p_r0 = &rr[i0][i4];
+      p_r1 = &rr[i1][i4];
+      p_r2 = &rr[i2][i4];
+      p_r3 = &rr[i3][i4];
+      p_r4 = &rr[i4][i4];
+      p_r5 = &rr[i4][i5];
+      p_rrv0 = rrv + i5;
+
+      do {
+         ps1 = ps0 + *p_dn0;
+         alp1 = alp0 + *p_r4 + 2.0F * ( *p_r0 + *p_r1 + *p_r2 + *p_r3 );
+         p_dn = p_dn1;
+         p_r6 = p_r5;
+         p_rrv = p_rrv0;
+
+         do {
+            ps2 = ps1 + *p_dn;
+            sq2 = ps2 * ps2;
+            alp2 = alp1 + *p_rrv + 2.0F * *p_r6;
+
+            if ( ( alp * sq2 ) > ( sq * alp2 ) ) {
+               sq = sq2;
+               ps = ps2;
+               alp = alp2;
+               ia = ( Word16 )( p_dn0 - dn );
+               ib = ( Word16 )( p_dn - dn );
+            }
+            p_dn += 5;
+            p_rrv += 5;
+            p_r6 += 5;
+         } while ( p_dn <= p_dn_max );
+         p_r0 += 5;
+         p_r1 += 5;
+         p_r2 += 5;
+         p_r3 += 5;
+         p_r4 += 205;
+         p_r5 += 200;
+         p_dn0 += 5;
+      } while ( p_dn0 < p_dn_max );
+      i4 = ia;
+      i5 = ib;
+
+      /* i6 and i7 loop	*/
+      p_rrv = rrv + i7;
+      p_r0 = &rr[i0][i7];
+      p_r1 = &rr[i1][i7];
+      p_r2 = &rr[i2][i7];
+      p_r3 = &rr[i3][i7];
+      p_r4 = &rr[i4][i7];
+      p_r5 = &rr[i5][i7];
+      p_r7 = &rr[i7][i7];
+      *p_rrv = *p_r7 + 2.0F * ( *p_r0 + *p_r1 + *p_r2 + *p_r3 + *p_r4 + *p_r5 );
+      *( p_rrv + 5 ) = *( p_r7 + 205 ) + 2.0F * ( *( p_r0 + 5 ) + *( p_r1 + 5 )
+            + *( p_r2 + 5 ) + *( p_r3 + 5 ) + *( p_r4 + 5 ) + *( p_r5 + 5 ) );
+      *( p_rrv + 10 ) = *( p_r7 + 410 ) + 2.0F * ( *( p_r0 + 10 ) + *( p_r1 + 10
+            ) + *( p_r2 + 10 ) + *( p_r3 + 10 ) + *( p_r4 + 10 ) + *( p_r5 + 10
+            ) );
+      *( p_rrv + 15 ) = *( p_r7 + 615 ) + 2.0F * ( *( p_r0 + 15 ) + *( p_r1 + 15
+            ) + *( p_r2 + 15 ) + *( p_r3 + 15 ) + *( p_r4 + 15 ) + *( p_r5 + 15
+            ) );
+      *( p_rrv + 20 ) = *( p_r7 + 820 ) + 2.0F * ( *( p_r0 + 20 ) + *( p_r1 + 20
+            ) + *( p_r2 + 20 ) + *( p_r3 + 20 ) + *( p_r4 + 20 ) + *( p_r5 + 20
+            ) );
+      *( p_rrv + 25 ) = *( p_r7 + 1025 ) + 2.0F * ( *( p_r0 + 25 ) + *( p_r1 +
+            25 ) + *( p_r2 + 25 ) + *( p_r3 + 25 ) + *( p_r4 + 25 ) + *( p_r5 +
+            25 ) );
+      *( p_rrv + 30 ) = *( p_r7 + 1230 ) + 2.0F * ( *( p_r0 + 30 ) + *( p_r1 +
+            30 ) + *( p_r2 + 30 ) + *( p_r3 + 30 ) + *( p_r4 + 30 ) + *( p_r5 +
+            30 ) );
+      *( p_rrv + 35 ) = *( p_r7 + 1435 ) + 2.0F * ( *( p_r0 + 35 ) + *( p_r1 +
+            35 ) + *( p_r2 + 35 ) + *( p_r3 + 35 ) + *( p_r4 + 35 ) + *( p_r5 +
+            35 ) );
+
+      /* Default value */
+      ps0 = ps;
+      alp0 = alp;
+      sq = -1;
+      alp = 1;
+      ps = 0;
+      ia = i6;
+      ib = i7;
+      p_dn0 = dn + i6;
+      p_dn1 = dn + i7;
+      p_r0 = &rr[i0][i6];
+      p_r1 = &rr[i1][i6];
+      p_r2 = &rr[i2][i6];
+      p_r3 = &rr[i3][i6];
+      p_r4 = &rr[i4][i6];
+      p_r5 = &rr[i5][i6];
+      p_r6 = &rr[i6][i6];
+      p_r7 = &rr[i6][i7];
+      p_rrv0 = rrv + i7;
+
+      do {
+         ps1 = ps0 + *p_dn0;
+         alp1 = alp0 + *p_r6 + 2.0F * ( *p_r0 + *p_r1 + *p_r2 + *p_r3 + *p_r4 +
+               *p_r5 );
+         p_dn = p_dn1;
+         p_r8 = p_r7;
+         p_rrv = p_rrv0;
+
+         do {
+            ps2 = ps1 + *p_dn;
+            sq2 = ps2 * ps2;
+            alp2 = alp1 + *p_rrv + 2.0F * *p_r8;
+
+            if ( ( alp * sq2 ) > ( sq * alp2 ) ) {
+               sq = sq2;
+               ps = ps2;
+               alp = alp2;
+               ia = ( Word16 )( p_dn0 - dn );
+               ib = ( Word16 )( p_dn - dn );
+            }
+            p_dn += 5;
+            p_rrv += 5;
+            p_r8 += 5;
+         } while ( p_dn <= p_dn_max );
+         p_r0 += 5;
+         p_r1 += 5;
+         p_r2 += 5;
+         p_r3 += 5;
+         p_r4 += 5;
+         p_r5 += 5;
+         p_r6 += 205;
+         p_r7 += 200;
+         p_dn0 += 5;
+      } while ( p_dn0 < p_dn_max );
+      i6 = ia;
+      i7 = ib;
+
+      /* i8 and i9 loop	*/
+      p_rrv = rrv + i9;
+      p_r0 = &rr[i0][i9];
+      p_r1 = &rr[i1][i9];
+      p_r2 = &rr[i2][i9];
+      p_r3 = &rr[i3][i9];
+      p_r4 = &rr[i4][i9];
+      p_r5 = &rr[i5][i9];
+      p_r6 = &rr[i6][i9];
+      p_r7 = &rr[i7][i9];
+      p_r9 = &rr[i9][i9];
+      *p_rrv = *p_r9 + 2.0F * ( *p_r0 + *p_r1 + *p_r2 + *p_r3 + *p_r4 + *p_r5 +
+            *p_r6 + *p_r7 );
+      *( p_rrv + 5 ) = *( p_r9 + 205 ) + 2.0F * ( *( p_r0 + 5 ) + *( p_r1 + 5 )
+            + *( p_r2 + 5 ) + *( p_r3 + 5 ) + *( p_r4 + 5 ) + *( p_r5 + 5 ) + *(
+            p_r6 + 5 ) + *( p_r7 + 5 ) );
+      *( p_rrv + 10 ) = *( p_r9 + 410 ) + 2.0F * ( *( p_r0 + 10 ) + *( p_r1 + 10
+            ) + *( p_r2 + 10 ) + *( p_r3 + 10 ) + *( p_r4 + 10 ) + *( p_r5 + 10
+            ) + *( p_r6 + 10 ) + *( p_r7 + 10 ) );
+      *( p_rrv + 15 ) = *( p_r9 + 615 ) + 2.0F * ( *( p_r0 + 15 ) + *( p_r1 + 15
+            ) + *( p_r2 + 15 ) + *( p_r3 + 15 ) + *( p_r4 + 15 ) + *( p_r5 + 15
+            ) + *( p_r6 + 15 ) + *( p_r7 + 15 ) );
+      *( p_rrv + 20 ) = *( p_r9 + 820 ) + 2.0F * ( *( p_r0 + 20 ) + *( p_r1 + 20
+            ) + *( p_r2 + 20 ) + *( p_r3 + 20 ) + *( p_r4 + 20 ) + *( p_r5 + 20
+            ) + *( p_r6 + 20 ) + *( p_r7 + 20 ) );
+      *( p_rrv + 25 ) = *( p_r9 + 1025 ) + 2.0F * ( *( p_r0 + 25 ) + *( p_r1 +
+            25 ) + *( p_r2 + 25 ) + *( p_r3 + 25 ) + *( p_r4 + 25 ) + *( p_r5 +
+            25 ) + *( p_r6 + 25 ) + *( p_r7 + 25 ) );
+      *( p_rrv + 30 ) = *( p_r9 + 1230 ) + 2.0F * ( *( p_r0 + 30 ) + *( p_r1 +
+            30 ) + *( p_r2 + 30 ) + *( p_r3 + 30 ) + *( p_r4 + 30 ) + *( p_r5 +
+            30 ) + *( p_r6 + 30 ) + *( p_r7 + 30 ) );
+      *( p_rrv + 35 ) = *( p_r9 + 1435 ) + 2.0F * ( *( p_r0 + 35 ) + *( p_r1 +
+            35 ) + *( p_r2 + 35 ) + *( p_r3 + 35 ) + *( p_r4 + 35 ) + *( p_r5 +
+            35 ) + *( p_r6 + 35 ) + *( p_r7 + 35 ) );
+
+      /* Default value */
+      ps0 = ps;
+      alp0 = alp;
+      sq = -1;
+      alp = 1;
+      ps = 0;
+      ia = i8;
+      ib = i9;
+      p_dn0 = dn + i8;
+      p_dn1 = dn + i9;
+      p_r0 = &rr[i0][i8];
+      p_r1 = &rr[i1][i8];
+      p_r2 = &rr[i2][i8];
+      p_r3 = &rr[i3][i8];
+      p_r4 = &rr[i4][i8];
+      p_r5 = &rr[i5][i8];
+      p_r6 = &rr[i6][i8];
+      p_r7 = &rr[i7][i8];
+      p_r8 = &rr[i8][i8];
+      p_r9 = &rr[i8][i9];
+      p_rrv0 = rrv + i9;
+
+      do {
+         ps1 = ps0 + *p_dn0;
+         alp1 = alp0 + *p_r8 + 2.0F * ( *p_r0 + *p_r1 + *p_r2 + *p_r3 + *p_r4 +
+               *p_r5 + *p_r6 + *p_r7 );
+         p_dn = p_dn1;
+         p_r10 = p_r9;
+         p_rrv = p_rrv0;
+
+         do {
+            ps2 = ps1 + *p_dn;
+            sq2 = ps2 * ps2;
+            alp2 = alp1 + *p_rrv + 2.0F * *p_r10;
+
+            if ( ( alp * sq2 ) > ( sq * alp2 ) ) {
+               sq = sq2;
+               ps = ps2;
+               alp = alp2;
+               ia = ( Word16 )( p_dn0 - dn );
+               ib = ( Word16 )( p_dn - dn );
+            }
+            p_dn += 5;
+            p_rrv += 5;
+            p_r10 += 5;
+         } while ( p_dn <= p_dn_max );
+         p_r0 += 5;
+         p_r1 += 5;
+         p_r2 += 5;
+         p_r3 += 5;
+         p_r4 += 5;
+         p_r5 += 5;
+         p_r6 += 5;
+         p_r7 += 5;
+         p_r8 += 205;
+         p_r9 += 200;
+         p_dn0 += 5;
+      } while ( p_dn0 < p_dn_max );
+
+      /*
+       * test and memorise if this combination is better than the last one.
+       */
+      if ( ( alpk * sq ) > ( psk * alp ) ) {
+         psk = sq;
+         alpk = alp;
+         codvec[0] = ( Word16 )i0;
+         codvec[1] = ( Word16 )i1;
+         codvec[2] = ( Word16 )i2;
+         codvec[3] = ( Word16 )i3;
+         codvec[4] = ( Word16 )i4;
+         codvec[5] = ( Word16 )i5;
+         codvec[6] = ( Word16 )i6;
+         codvec[7] = ( Word16 )i7;
+         codvec[8] = ( Word16 )ia;
+         codvec[9] = ( Word16 )ib;
+      }
+
+      /*
+       * Cyclic permutation of i1,i2,i3,i4,i5,i6,i7,(i8 and i9).
+       */
+      pos = ipos[1];
+
+      for ( j = 1, k = 2; k < 10; j++, k++ ) {
+         ipos[j] = ipos[k];
+      }
+      ipos[9] = pos;
+   }   /* end 1..nb_tracks  loop*/
+}
+
+
+/*
+ * build_code_10i40_35bits
+ *
+ *
+ * Parameters:
+ *    codvec            I: position of pulses
+ *    dn_sign           I: sign of pulses
+ *    cod               O: algebraic codebook vector
+ *    h                 I: impulse response of weighted synthesis filter
+ *    y                 O: filtered innovative code
+ *    indx              O: index of 10 pulses (sign+position)
+ *
+ * Function:
+ *    Builds the codeword, the filtered codeword and index of the
+ *    codevector, based on the signs and positions of 10 pulses.
+ *
+ * Returns:
+ *    void
+ */
+static void build_code_10i40_35bits( Word32 codvec[], Float32 dn_sign[], Float32
+      cod[], Float32 h[], Float32 y[], Word16 indx[] )
+{
+   Word32 i, j, k, track, index, sign[10];
+   Float32 *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7, *p8, *p9;
+   Float64 s;
+
+
+   memset( cod, 0, 160 );
+   memset( y, 0, 160 );
+
+   for ( i = 0; i < NB_TRACK; i++ ) {
+      indx[i] = -1;
+   }
+
+   for ( k = 0; k < 10; k++ ) {
+      /* read pulse position */
+      i = codvec[k];
+
+      /* read sign */
+      j = ( Word16 )dn_sign[i];
+
+      /* index = pos/5 */
+      index = ( Word16 )( i / 5 );
+
+      /* track = pos%5 */
+      track = ( Word16 )( i % 5 );
+
+      if ( j > 0 ) {
+         cod[i] = cod[i] + 1;
+         sign[k] = 1;
+      }
+      else {
+         cod[i] = cod[i] - 1;
+         sign[k] = -1;
+         index = index + 8;
+      }
+
+      if ( indx[track] < 0 ) {
+         indx[track] = ( Word16 )index;
+      }
+      else {
+         if ( ( ( index ^ indx[track] ) & 8 ) == 0 ) {
+            /* sign of 1st pulse == sign of 2nd pulse */
+            if ( indx[track] <= index ) {
+               indx[track + 5] = ( Word16 )index;
+            }
+            else {
+               indx[track + 5] = ( Word16 )indx[track];
+               indx[track] = ( Word16 )index;
+            }
+         }
+         else {
+            /* sign of 1st pulse != sign of 2nd pulse */
+            if ( ( indx[track] & 7 ) <= ( index & 7 ) ) {
+               indx[track + 5] = ( Word16 )indx[track];
+               indx[track] = ( Word16 )index;
+            }
+            else {
+               indx[track + 5] = ( Word16 )index;
+            }
+         }
+      }
+   }
+   p0 = h - codvec[0];
+   p1 = h - codvec[1];
+   p2 = h - codvec[2];
+   p3 = h - codvec[3];
+   p4 = h - codvec[4];
+   p5 = h - codvec[5];
+   p6 = h - codvec[6];
+   p7 = h - codvec[7];
+   p8 = h - codvec[8];
+   p9 = h - codvec[9];
+
+   for ( i = 0; i < L_CODE; i++ ) {
+      s = *p0++ * sign[0];
+      s += *p1++ * sign[1];
+      s += *p2++ * sign[2];
+      s += *p3++ * sign[3];
+      s += *p4++ * sign[4];
+      s += *p5++ * sign[5];
+      s += *p6++ * sign[6];
+      s += *p7++ * sign[7];
+      s += *p8++ * sign[8];
+      s += *p9++ * sign[9];
+      y[i] = ( Float32 )( s );
+   }
+}
+
+
+/*
+ * q_p
+ *
+ *
+ * Parameters:
+ *    ind               B: Pulse position
+ *    n                 I: Pulse number
+ *
+ * Function:
+ *    Gray coding
+ *
+ * Returns:
+ *    void
+ */
+static void q_p( Word16 *ind, Word32 n )
+{
+   Word16 tmp;
+
+
+   tmp = *ind;
+
+   if ( n < 5 ) {
+      *ind = ( Word16 )( ( tmp & 0x8 ) | gray[tmp & 0x7] );
+   }
+   else {
+      *ind = gray[tmp & 0x7];
+   }
+}
+
+
+/*
+ * code_10i40_35bits
+ *
+ *
+ * Parameters:
+ *    x                 I: target vector
+ *    cn                I: residual after long term prediction
+ *    h                 I: impulse response of weighted synthesis filter
+ *    gain_pit          I: quantified adaptive codebook gain
+ *    code              O: algebraic (fixed) codebook excitation
+ *    y                 O: filtered fixed codebook excitation
+ *    anap              O: 7 Word16, index of 8 pulses (signs+positions)
+ *
+ * Function:
+ *    Searches a 35 bit algebraic codebook containing 10 pulses
+ *    in a frame of 40 samples.
+ *
+ *    The code contains 10 nonzero pulses: i0...i9.
+ *    All pulses can have two possible amplitudes: +1 or -1.
+ *    The 40 positions in a subframe are divided into 5 tracks of
+ *    interleaved positions. Each track contains two pulses.
+ *    The pulses can have the following possible positions:
+ *       Track    Pulse       Positions
+ *          1     i0, i5      0, 5, 10, 15, 20, 25, 30, 35.
+ *          2     i1, i6      1, 6, 11, 16, 21, 26, 31, 36.
+ *          3     i2, i       2, 7, 12, 17, 22, 27, 32, 37.
+ *          4     i3, i8      3, 8, 13, 18, 23, 28, 33, 38.
+ *          5     i4, i9      4, 9, 14, 19, 24, 29, 34, 39.
+ *
+ *    Each pair of pulses require 1 bit for their signs and 6 bits for their
+ *    positions (3 bits + 3 bits). This results in a 35 bit codebook.
+ *    The function determines the optimal pulse signs and positions, builds
+ *    the codevector, and computes the filtered codevector.
+ *
+ *    The algebraic codebook is searched by minimizing the mean square error
+ *    between the weighted input speech and the weighted synthesized speech.
+ *    The target signal used in the closed-loop pitch search is updated by
+ *    subtracting the adaptive codebook contribution. That is:
+ *
+ *    x2(n) = x(n) - Gp' * y(n), n = 0, ..., 39
+ *
+ *    where y(n) = v(n) * h(n) is the filtered adaptive codebook vector
+ *    and Gp' is the quantified adaptive codebook gain. This is done
+ *    already in function cl_ltp.
+ *
+ *    If c(k) is the algebraic codevector at index k, then
+ *    the algebraic codebook is searched by maximizing the term:
+ *
+ *    A(k) = (C(k) * C(k)) / Ed(k) =
+ *
+ *                     39
+ *                   [SUM sb(i)*d(i)]^2
+ *                    i=0
+ *                  ---------------------
+ *                 transpose(sb) * PI * sb
+ *
+ *    where d(n) is the correlation between the target signal x2(n)
+ *    and the impulse response h(n), H is a the lower triangular Toepliz
+ *    convolution matrix with diagonal h(0) and lower diagonals
+ *    h(1), ..., h(39), and PI = H_transpose * H is the matrix of
+ *    correlations of h(n).
+ *
+ *    The pulse amplitudes are preset by the mere quantization of an signal
+ *    b(n) used for presetting the amplitudes.
+ *
+ *                           39
+ *    b(n) = res(n) / SQRT[ SUM[ res(i) * res(i) ] ]
+ *                          i=0
+ *                          39
+ *          + d(n) / SQRT[ SUM [ d(i) * d(i) ] ], n = 0, ..., 39,
+ *                         i=0
+ *
+ *    where res(n) is normalized long-term prediction residual and
+ *    d(n) is normalized vector.
+ *
+ *            39
+ *    d(n) = SUM[ x2(i) * h(i-n) ], n = 0, ..., 39,
+ *           i=n
+ *
+ *    This is simply done by setting the amplitude of a pulse at
+ *    a certain position equal to the sign of b(n) at that position.
+ *    The simplification proceeds as follows (prior to the codebook search).
+ *    First, the sign signal sb(n) = SIGN[ b(n) ] and
+ *    the signal d'(n) = sb(n) * d(n) are computed.
+ *
+ * Returns:
+ *    void
+ */
+static void code_10i40_35bits( Float32 x[], Float32 cn[], Float32 h[],
+    Word32 T0, Float32 gain_pit, Float32 code[],
+    Float32 y[], Word16 anap[] )
+ {
+    Float32 rr[L_CODE][L_CODE];
+    Float32 dn[L_CODE], sign[L_CODE];
+    Word32 ipos[10], pos_max[NB_TRACK], codvec[10];
+    Word32 i;
+
+    /* include pitch contribution into impulse resp. */
+    if ( gain_pit > 1.0F )
+       gain_pit = 1.0F;
+
+    if ( gain_pit != 0 ) {
+       for ( i = T0; i < L_SUBFR; i++ ) {
+          h[i] += h[i - T0] * gain_pit;
+       }
+    }
+    /*
+    *            39
+    *    d(n) = SUM[ x2(i) * h(i-n) ], n = 0, ..., 39
+    *           i=n
+    */
+    cor_h_x( h, x, dn );
+
+    /* sb(n) and d'(n) */
+    set_sign12k2( dn, cn, sign, pos_max, NB_TRACK, ipos, STEP );
+
+    /* Matrix of correlations */
+    cor_h( h, sign, rr );
+    search_10i40( dn, rr, ipos, pos_max, codvec );
+    build_code_10i40_35bits( codvec, sign, code, h, y, anap );
+
+    for ( i = 0; i < 10; i++ ) {
+       q_p( &anap[i], i );
+    }
+
+    /*  Add the pitch contribution to code[]. */
+    if ( gain_pit != 0 ) {
+       for ( i = T0; i < L_SUBFR; i++ ) {
+          code[i] += code[i - T0] * gain_pit;
+       }
+    }
+    return;
+ }
+
+
+/*
+ * cbsearch
+ *
+ *
+ * Parameters:
+ *    mode              I: AMR mode
+ *    subnr             I: Subframe
+ *    x                 I: Target vector
+ *    h                 B: Impulse response of weighted synthesis filter
+ *    T0                I: Pitch lag
+ *    pitch_sharp       I: Last quantized pitch gain
+ *    gain_pit          I: Algebraic codebook gain
+ *    code              O: Innovative codebook
+ *    y                 O: Filtered fixed codebook excitation
+ *    res2              I: residual after long term prediction
+ *    anap              O: Signs and positions of the pulses
+ *
+ * Function:
+ *    Innovative codebook search (find index and gain)
+ *
+ * Returns:
+ *    void
+ */
+static void cbsearch( enum Mode mode, Word16 subnr, Float32 x[],
+                     Float32 h[], Word32 T0, Float32 pitch_sharp,
+                     Float32 gain_pit, Float32 code[], Float32 y[],
+                     Float32 *res2, Word16 **anap )
+{
+   switch (mode){
+   case MR475:
+   case MR515:
+      code_2i40_9bits( subnr, x, h, T0, pitch_sharp, code, y, *anap );
+      ( *anap ) += 2;
+      break;
+   case MR59:
+      code_2i40_11bits( x, h, T0, pitch_sharp, code, y, *anap );
+      ( *anap ) += 2;
+      break;
+   case MR67:
+      code_3i40_14bits( x, h, T0, pitch_sharp, code, y, *anap );
+      ( *anap ) += 2;
+      break;
+   case MR74:
+   case MR795:
+      code_4i40_17bits( x, h, T0, pitch_sharp, code, y, *anap );
+      ( *anap ) += 2;
+      break;
+   case MR102:
+      code_8i40_31bits( x, res2, h, T0, pitch_sharp, code, y, *anap );
+      *anap += 7;
+      break;
+   default:
+      code_10i40_35bits( x, res2, h, T0, gain_pit, code, y, *anap );
+      *anap += 10;
+   }
+}
+
+/*
+ * Log2_norm
+ *
+ *
+ * Parameters:
+ *    x                 I: input value
+ *    exp               I: exponent
+ *    exponent          O: Integer part of Log2. (range: 0<=val<=30)
+ *    fraction          O: Fractional part of Log2. (range: 0<=val<1)
+ *
+ * Function:
+ *    Computes log2
+ *
+ *    Computes log2(L_x, exp),  where   L_x is positive and
+ *    normalized, and exp is the normalisation exponent
+ *    If L_x is negative or zero, the result is 0.
+ *
+ *    The function Log2(L_x) is approximated by a table and linear
+ *    interpolation. The following steps are used to compute Log2(L_x)
+ *
+ *    exponent = 30-normExponent
+ *    i = bit25-b31 of L_x;  32<=i<=63  (because of normalization).
+ *    a = bit10-b24
+ *    i -=32
+ *    fraction = table[i]<<16 - (table[i] - table[i+1]) * a * 2
+ *
+ * Returns:
+ *    void
+ */
+static void Log2_norm( Word32 x, Word32 exp, Word32 *exponent, Word32 *
+      fraction )
+{
+   Word32 y, i, a;
+
+   if ( x <= 0 ) {
+      *exponent = 0;
+      *fraction = 0;
+      return;
+   }
+
+   /* Extract b25-b31 */
+   i = x >> 25;
+   i = i - 32;
+
+   /* Extract b10-b24 of fraction */
+   a = x >> 9;
+   a = a & 0xFFFE;   /* 2a */
+
+   /* fraction */
+   y = ( log2_table[i] << 16 ) - a * ( log2_table[i] - log2_table[i + 1] );
+   *fraction = y >> 16;
+   *exponent = 30 - exp;
+   return;
+}
+
+/*
+ * Log2
+ *
+ *
+ * Parameters:
+ *    x                 I: input value
+ *    exponent          O: Integer part of Log2. (range: 0<=val<=30)
+ *    fraction          O: Fractional part of Log2. (range: 0<=val<1)
+ *
+ * Function:
+ *    Computes log2(L_x)
+ *    If x is negative or zero, the result is 0.
+ *
+ * Returns:
+ *    void
+ */
+static void Log2( Word32 x, Word32 *exponent, Word32 *fraction )
+{
+   int exp;
+
+
+   frexp( ( Float64 )x, &exp );
+   exp = 31 - exp;
+   Log2_norm( x <<exp, exp, exponent, fraction );
+}
+
+/*
+ * Pow2
+ *
+ *
+ * Parameters:
+ *    exponent          I: Integer part. (range: 0<=val<=30)
+ *    fraction          O: Fractional part. (range: 0.0<=val<1.0)
+ *
+ * Function:
+ *    pow(2.0, exponent.fraction)
+ *
+ *    The function Pow2(L_x) is approximated by a table and linear interpolation.
+ *
+ *    i = bit10-b15 of fraction, 0 <= i <= 31
+ *    a = biT0-b9   of fraction
+ *    x = table[i]<<16 - (table[i] - table[i+1]) * a * 2
+ *    x = L_x >> (30-exponent) (with rounding)
+ *
+ * Returns:
+ *    result (range: 0<=val<=0x7fffffff)
+ */
+static Word32 Pow2( Word32 exponent, Word32 fraction )
+{
+   Word32 i, a, tmp, x, exp;
+
+   /* Extract b10-b16 of fraction */
+   i = fraction >> 10;
+
+   /* Extract b0-b9 of fraction */
+   a = ( fraction << 5 ) & 0x7fff;
+
+   /* table[i] << 16 */
+   x = pow2_table[i] << 16;
+
+   /* table[i] - table[i+1] */
+   tmp = pow2_table[i] - pow2_table[i + 1];
+
+   /* L_x -= tmp*a*2 */
+   x -= ( tmp * a ) << 1;
+
+   if ( exponent >= -1 ) {
+      exp = ( 30 - exponent );
+
+      /* Rounding */
+      if ( ( x & ( ( Word32 )1 << ( exp - 1 ) ) ) != 0 ) {
+         x = ( x >> exp ) + 1;
+      }
+      else
+         x = x >> exp;
+   }
+   else
+      x = 0;
+   return( x );
+}
+
+/*
+ * gc_pred
+ *
+ *
+ * Parameters:
+ *    past_qua_en       I: MA predictor
+ *    mode              I: AMR mode
+ *    code              I: innovative codebook vector
+ *    gcode0            O: predicted gain factor
+ *    en                I: innovation energy (only calculated for MR795)
+ *
+ * Function:
+ *    MA prediction of the innovation energy
+ *
+ *    Mean removed innovation energy (dB) in subframe n
+ *                          N-1
+ *    E(n) = 10*log(gc*gc * SUM[(code(i) * code(i)]/N) - E_mean
+ *                          i=0
+ *    N=40
+ *
+ *    Mean innovation energy (dB)
+ *                   N-1
+ *    Ei(n) = 10*log(SUM[(code(i) * code(i)]/N)
+ *                   i=0
+ *
+ *    Predicted energy
+ *             4
+ *    Ep(n) = SUM[b(i) * R(n-i)]
+ *            i=1
+ *    b = [0.68 0.58 0.34 0.19]
+ *    R(k) is quantified prediction error at subframe k
+ *
+ *    E_Mean = 36 dB (MR122)
+ *
+ *    Predicted gain gc is found by
+ *
+ *    gc = POW[10, 0.05 * (Ep(n) + E_mean - Ei)]
+ *
+ * Returns:
+ *    void
+ */
+static void gc_pred( Word32 *past_qua_en, enum Mode mode, Float32 *code,
+      Word32 *gcode0_exp, Word32 *gcode0_fra, Float32 *en )
+{
+   Float64 ener_code;
+   Word32 exp, frac, ener, ener_tmp, tmp;
+   int exp_code;
+
+
+   /* energy of code */
+   ener_code = Dotproduct40( code, code );
+
+   if ( mode == MR122 ) {
+
+      ener = (Word32)(ener_code * 33554432);
+      /* ener_code = ener_code / lcode; lcode = 40; 1/40 = 26214 Q20       */
+      ener = ( ( ener + 0x00008000L ) >> 16 ) * 52428;
+
+      Log2( ener, &exp, &frac );
+      ener = ( ( exp - 30 ) << 16 ) + ( frac << 1 );
+
+      ener_tmp = 44 * qua_gain_code_MR122[past_qua_en[0]];
+      ener_tmp += 37 * qua_gain_code_MR122[past_qua_en[1]];
+      ener_tmp += 22 * qua_gain_code_MR122[past_qua_en[2]];
+      ener_tmp += 12 * qua_gain_code_MR122[past_qua_en[3]];
+
+      ener_tmp = ener_tmp << 1;
+      ener_tmp += 783741L;
+
+      /*
+       * predicted codebook gain
+       * gc0 = Pow10( (ener*constant - ener_code*constant) / 20 )
+       *     = Pow2(ener-ener_code)
+       *     = Pow2(int(d)+frac(d))
+       */
+      ener = ( ener_tmp - ener ) >> 1;   /* Q16 */
+      *gcode0_exp = ener >> 16;
+      *gcode0_fra = ( ener >> 1 ) - ( *gcode0_exp << 15 );
+   }
+   else {
+      ener = (Word32)(ener_code * 134217728);
+      if (ener < 0)
+         ener = 0x7fffffff;
+
+      frexp( ( Float64 )ener, &exp_code );
+      exp_code = 31 - exp_code;
+      ener <<= exp_code;
+
+      Log2_norm( ener, exp_code, &exp, &frac );
+
+      tmp = ( exp * ( -49320 ) ) + ( ( ( frac * ( -24660 ) ) >> 15 ) << 1 );
+
+      if ( mode == MR102 ) {
+         /* mean = 33 dB */
+         tmp += 2134784;   /* Q14 */
+      }
+      else if ( mode == MR795 ) {
+         /* mean = 36 dB */
+         tmp += 2183936;   /* Q14 */
+
+         *en = (Float32)ener_code;
+      }
+      else if ( mode == MR74 ) {
+         /* mean = 30 dB */
+         tmp += 2085632;   /* Q14 */
+      }
+      else if ( mode == MR67 ) {
+         /* mean = 28.75 dB */
+         tmp += 2065152;   /* Q14 */
+      }
+      else /* MR59, MR515, MR475 */ {
+         /* mean = 33 dB */
+         tmp += 2134784;   /* Q14 */
+      }
+
+      tmp = tmp << 9;
+
+      tmp += 5571 * qua_gain_code[past_qua_en[0]];
+      tmp += 4751 * qua_gain_code[past_qua_en[1]];
+      tmp += 2785 * qua_gain_code[past_qua_en[2]];
+      tmp += 1556 * qua_gain_code[past_qua_en[3]];
+
+      tmp = tmp >> 15;   /* Q8  */
+
+      /*
+       * gcode0 = pow(10.0, gcode0/20)
+       *        = pow(2, 3.3219*gcode0/20)
+       *        = pow(2, 0.166*gcode0)
+       */
+      /* 5439 Q15 = 0.165985                                        */
+      /* (correct: 1/(20*log10(2)) 0.166096 = 5443 Q15)             */
+      /* For IS641 bitexactness */
+      if ( mode == MR74 ) {
+         /* Q8 * Q15 -> Q24 */
+         tmp = tmp * 10878;
+      }
+      else {
+         /* Q8 * Q15 -> Q24 */
+         tmp = tmp * 10886;
+      }
+      tmp = tmp >> 9;   /* -> Q15 */
+
+      *gcode0_exp = tmp >> 15;
+      *gcode0_fra = tmp - ( *gcode0_exp * 32768 );
+   }
+}
+
+/*
+ * calc_filt_energies
+ *
+ *
+ * Parameters:
+ *    mode              I: AMR mode
+ *    xn                I: LTP target vector
+ *    xn2               I: CB target vector
+ *    y1                I: Adaptive codebook
+ *    y2                I: Filtered innovative vector
+ *    gCoeff            I: Correlations <xn y1> <y1 y1>
+ *    coeff             O: energy coefficients
+ *    cod_gain          O: optimum codebook gain
+ *
+ * Function:
+ *    Calculation of several energy coefficients for filtered excitation signals
+ *
+ *    Compute coefficients need for the quantization and the optimum
+ *    codebook gain gcu (for MR475 only).
+ *
+ *       coeff[0] =    y1 y1
+ *       coeff[1] = -2 xn y1
+ *       coeff[2] =    y2 y2
+ *       coeff[3] = -2 xn y2
+ *       coeff[4] =  2 y1 y2
+ *
+ *
+ *       gcu = <xn2, y2> / <y2, y2> (0 if <xn2, y2> <= 0)
+ *
+ *    Product <y1 y1> and <xn y1> have been computed in G_pitch() and
+ *    are in vector gCoeff[].
+ *
+ * Returns:
+ *    void
+ */
+static void calc_filt_energies( enum Mode mode, Float32 xn[], Float32 xn2[],
+      Float32 y1[], Float32 y2[], Float32 gCoeff[], Float32 coeff[], Float32 *
+      cod_gain )
+{
+   Float32 sum, ener_init = 0.01F;
+
+
+   if ( ( mode == MR795 ) || ( mode == MR475 ) )
+      ener_init = 0;
+   coeff[0] = gCoeff[0];
+   coeff[1] = -2.0F * gCoeff[1];
+
+   /* Compute scalar product <y2[],y2[]> */
+   sum = (Float32)Dotproduct40( y2, y2 );
+   sum += ener_init;
+   coeff[2] = sum;
+
+   /* Compute scalar product -2*<xn[],y2[]> */
+   sum = (Float32)Dotproduct40( xn, y2 );
+   sum += ener_init;
+   coeff[3] = -2.0F * sum;
+
+   /* Compute scalar product 2*<y1[],y2[]> */
+   sum = (Float32)Dotproduct40( y1, y2 );
+   sum += ener_init;
+   coeff[4] = 2.0F * sum;
+
+   if ( ( mode == MR475 ) || ( mode == MR795 ) ) {
+      /* Compute scalar product <xn2[],y2[]> */
+      sum = (Float32)Dotproduct40( xn2, y2 );
+
+      if ( sum <= 0 ) {
+         *cod_gain = 0;
+      }
+      else {
+      /*
+       * gcu = <xn2, y2> / <y2, y2>
+       */
+         *cod_gain = sum / coeff[2];
+      }
+   }
+}
+
+
+/*
+ * MR475_update_unq_pred
+ *
+ *
+ * Parameters:
+ *    past_qua_en       I: MA predictor memory, 20*log10(qua_err)
+ *    gcode0            I: predicted CB gain
+ *    cod_gain          I: optimum codebook gain
+ *
+ * Function:
+ *    Use optimum codebook gain and update "unquantized"
+ *    gain predictor with the (bounded) prediction error
+ *
+ *    Prediction error is given by:
+ *
+ *       R(n) = E(n) - E_pred(n) = 20 * log(cf),
+ *
+ *    where correction factor cf between the gain Gc and
+ *    the estimated pne Gc' is given by:
+ *
+ *       cf = Gc/Gc'.
+ *
+ * Returns:
+ *    void
+ */
+static void MR475_update_unq_pred( Word32 *past_qua_en, Float32 gcode0, Float32
+      cod_gain )
+{
+   Float32 qua_ener, pred_err_fact;
+   Word32 i, index, energy, max, s;
+
+
+   if ( cod_gain <= 0 ) {
+      /*MIN_QUA_ENER*/
+      qua_ener = -32.0F;
+   }
+   else {
+      if (gcode0 != 0) {
+         pred_err_fact = cod_gain / gcode0;
+      }
+      else {
+         pred_err_fact = 10.0F;
+      }
+
+      if ( pred_err_fact < 0.0251189F ) {
+         /*MIN_QUA_ENER*/
+         qua_ener = -32.0F;
+      }
+      else if ( pred_err_fact > 7.8125F ) {
+         /*MAX_QUA_ENER*/
+         qua_ener = 17.8558F;
+      }
+      else {
+         qua_ener = ( Float32 )( 20.0F*log10( pred_err_fact ) );
+      }
+   }
+   energy = (Word32)(qua_ener * 1024 + 0.5F);
+   max = abs(energy - qua_gain_code[0]);
+   index = 0;
+   /* find match from table */
+   for ( i = 1; i < NB_QUA_CODE+VQ_SIZE_HIGHRATES+VQ_SIZE_LOWRATES+MR475_VQ_SIZE*2+3; i++ )
+   {
+      s = abs(energy - qua_gain_code[i]);
+      if (s < max){
+         max = s;
+         index = i;
+         if (s == 0) {
+            break;
+         }
+      }
+   }
+   /* update MA predictor memory */
+   for ( i = 3; i > 0; i-- ) {
+      past_qua_en[i] = past_qua_en[i - 1];
+   }
+   past_qua_en[0] = index;
+}
+
+
+/*
+ * MR475_gain_quant
+ *
+ *
+ * Parameters:
+ *    past_qua_en          B: MA predictor memory, 20*log10(qua_err)
+ *    sf0_gcode0_exp(fra)  I: predicted CB gain from subframe 0 (or 2)
+ *    sf0_coeff            I: energy coeff. from subframe 0 (or 2)
+ *    sf0_target_en        I: target energy from subframe 0 (or 2)
+ *    sf1_code_nosharp     I: innovative codebook vector (L_SUBFR)
+ *                            (without pitch sharpening)
+ *                            from subframe 1 (or 3)
+ *    sf1_gcode0_exp(fra)  I: predicted CB gain from subframe 1 (or 3)
+ *    sf1_coeff            I: energy coeff. subframe 1 (or 3)
+ *    sf1_target_en        I: target energy from subframe 1 (or 3)
+ *    gp_limit             I: pitch gain limit
+ *    sf0_gain_pit         O: Pitch gain subframe 0 (or 2)
+ *    sf0_gain_cod         O: Code gain subframe 0 (or 2)
+ *    sf1_gain_pit         O: Pitch gain subframe 1 (or 3)
+ *    sf1_gain_cod         O: Code gain subframe 1 (or 3)
+ *
+ * Function:
+ *    Quantization of pitch and codebook gains for two subframes
+ *    (using predicted codebook gain)
+ *
+ * Returns:
+ *    index             index of quantization
+ */
+static Word16 MR475_gain_quant( Word32 *past_qua_en, Word32 sf0_gcode0_exp, Word32
+                               sf0_gcode0_fra, Float32 sf0_coeff[], Float32 sf0_target_en,
+                               Float32 sf1_code_nosharp[], Word32 sf1_gcode0_exp, Word32
+                               sf1_gcode0_fra, Float32 sf1_coeff[], Float32 sf1_target_en,
+                               Float32 gp_limit, Float32 *sf0_gain_pit, Float32
+                               *sf0_gain_cod, Float32 *sf1_gain_pit, Float32 *sf1_gain_cod )
+{
+   Float32 temp, temp2, g_pitch, g2_pitch, g_code, g2_code, g_pit_cod, dist_min, sf0_gcode0, sf1_gcode0;
+   const Float32 *p;
+   Word32 i, tmp, g_code_tmp, gcode0, index = 0;
+
+   sf0_gcode0 = (Float32)Pow2(sf0_gcode0_exp, sf0_gcode0_fra);
+   sf1_gcode0 = (Float32)Pow2(sf1_gcode0_exp, sf1_gcode0_fra);
+
+   if ( ( sf0_target_en * 2.0F ) < sf1_target_en ) {
+      sf0_coeff[0] *= 2.0F;
+      sf0_coeff[1] *= 2.0F;
+      sf0_coeff[2] *= 2.0F;
+      sf0_coeff[3] *= 2.0F;
+      sf0_coeff[4] *= 2.0F;
+   }
+   else if ( sf0_target_en > ( sf1_target_en * 4.0F ) ) {
+      sf1_coeff[0] *= 2.0F;
+      sf1_coeff[1] *= 2.0F;
+      sf1_coeff[2] *= 2.0F;
+      sf1_coeff[3] *= 2.0F;
+      sf1_coeff[4] *= 2.0F;
+   }
+
+   /*
+    * Codebook search:
+    * For each pair (g_pitch, g_fac) in the table calculate the
+    * terms t[0..4] and sum them up; the result is the mean squared
+    * error for the quantized gains from the table. The index for the
+    * minimum MSE is stored and finally used to retrieve the quantized
+    * gains
+    */
+   dist_min = FLT_MAX;
+   p = &table_gain_MR475[0];
+
+   for ( i = 0; i < MR475_VQ_SIZE; i++ ) {
+      /* subframe 0 (and 2) calculations */
+      g_pitch = *p++;
+      g_code = *p++;
+      g_code *= sf0_gcode0;
+      g2_pitch = g_pitch * g_pitch;
+      g2_code = g_code * g_code;
+      g_pit_cod = g_code * g_pitch;
+      temp = sf0_coeff[0] * g2_pitch;
+      temp += sf0_coeff[1] * g_pitch;
+      temp += sf0_coeff[2] * g2_code;
+      temp += sf0_coeff[3] * g_code;
+      temp += sf0_coeff[4] * g_pit_cod;
+      temp2 = g_pitch - gp_limit;
+
+      /* subframe 1 (and 3) calculations */
+      g_pitch = *p++;
+      g_code = *p++;
+
+      if ( temp2 <= 0 && ( g_pitch <= gp_limit ) ) {
+         g_code *= sf1_gcode0;
+         g2_pitch = g_pitch * g_pitch;
+         g2_code = g_code * g_code;
+         g_pit_cod = g_code * g_pitch;
+         temp += sf1_coeff[0] * g2_pitch;
+         temp += sf1_coeff[1] * g_pitch;
+         temp += sf1_coeff[2] * g2_code;
+         temp += sf1_coeff[3] * g_code;
+         temp += sf1_coeff[4] * g_pit_cod;
+
+         /*
+          * store table index if MSE for this index is lower
+          * than the minimum MSE seen so far
+          */
+         if ( temp < dist_min ) {
+            dist_min = temp;
+            index = i;
+         }
+      }
+   }
+
+   /*
+    *  read quantized gains and update MA predictor memories
+    *
+    * for subframe 0, the pre-calculated gcode0 is the same
+    * as one calculated from the "real" predictor using quantized gains
+    */
+   tmp = index << 2;
+   p = &table_gain_MR475[tmp];
+   *sf0_gain_pit = *p++;
+   g_code_tmp = (Word32)(*p++ * 4096 + 0.5F);
+
+   gcode0 = Pow2( 14, sf0_gcode0_fra );
+   if ( sf0_gcode0_exp < 11 ) {
+      *sf0_gain_cod = (Float32)(( g_code_tmp * gcode0 ) >> ( 25 - sf0_gcode0_exp ));
+   }
+   else {
+      i = ( ( g_code_tmp * gcode0 ) << ( sf0_gcode0_exp - 9 ) );
+
+      if ( ( i >> ( sf0_gcode0_exp - 9 ) ) != ( g_code_tmp * gcode0 ) ) {
+         *sf0_gain_cod = (Float32)0x7FFF;
+      }
+      else {
+         *sf0_gain_cod = (Float32)(i >> 16);
+      }
+   }
+
+   *sf0_gain_cod *= 0.5F;
+
+   for ( i = 3; i > 0; i-- ) {
+      past_qua_en[i] = past_qua_en[i - 1];
+   }
+   past_qua_en[0] = NB_QUA_CODE+VQ_SIZE_HIGHRATES+VQ_SIZE_LOWRATES + (index << 1);
+
+
+   /*
+    * calculate new predicted gain for subframe 1 (this time using
+    * the real, quantized gains)
+    */
+   gc_pred( past_qua_en, MR475, sf1_code_nosharp, &sf1_gcode0_exp, &sf1_gcode0_fra, &sf0_gcode0 );
+
+   tmp += 2;
+   p = &table_gain_MR475[tmp];
+   *sf1_gain_pit = *p++;
+   g_code_tmp = (Word32)(*p++ * 4096 + 0.5F);
+
+   gcode0 = Pow2( 14, sf1_gcode0_fra );
+   if ( sf1_gcode0_exp < 11 ) {
+      *sf1_gain_cod = (Float32)(( g_code_tmp * gcode0 ) >> ( 25 - sf1_gcode0_exp ));
+   }
+   else {
+      i = ( ( g_code_tmp * gcode0 ) << ( sf1_gcode0_exp - 9 ) );
+
+      if ( ( i >> ( sf1_gcode0_exp - 9 ) ) != ( g_code_tmp * gcode0 ) ) {
+         *sf1_gain_cod = (Float32)0x7FFF;
+      }
+      else {
+         *sf1_gain_cod = (Float32)(i >> 16);
+      }
+   }
+
+   *sf1_gain_cod *= 0.5F;
+
+   for ( i = 3; i > 0; i-- ) {
+      past_qua_en[i] = past_qua_en[i - 1];
+   }
+   past_qua_en[0] = NB_QUA_CODE+VQ_SIZE_HIGHRATES+VQ_SIZE_LOWRATES + (index << 1) + 1;
+
+   return( Word16 )index;
+}
+
+
+/*
+ * q_gain_code
+ *
+ *
+ * Parameters:
+ *    gcode0            I: predicted CB gain
+ *    gain              B: quantized fixed codebook gain
+ *    qua_ener_index    O: quantized energy error index
+ *
+ * Function:
+ *    Scalar quantization of the innovative codebook gain.
+ *
+ *    A correction factor between the gain gc and the estimated one gc'
+ *    is given by:
+ *
+ *    cf = gc/gc'
+ *
+ *    The quantization table search is performed by minimizing the error:
+ *
+ *    Eq = POW[gc - cf' * gc', 2]
+ *
+ *    Once the optimum value cf' is chosen,
+ *    the quantified fixed codebook gain is given by
+ *
+ *    gc_q = cf' * gc'
+ *
+ * Returns:
+ *    index             quantization index
+ */
+static Word16 q_gain_code( Float32 gcode0, Float32 *gain, Word32 *qua_ener_index)
+{
+   Float64 err_min, err;
+   const Float32 *p;
+   Word32 i, index;
+
+
+   p = &gain_factor[0];
+
+   /* using abs instead pow */
+   err_min = fabs( *gain - ( gcode0 * *p++ ) );
+   index = 0;
+
+   for ( i = 1; i < NB_QUA_CODE; i++ ) {
+      err = fabs( *gain - ( gcode0 * *p++ ) );
+
+      if ( err < err_min ) {
+         err_min = err;
+         index = i;
+      }
+   }
+   p = &gain_factor[index];
+   *gain = (Float32)floor(gcode0 * *p);
+   *qua_ener_index = index;
+
+   return( Word16 )index;
+}
+
+
+/*
+ * MR795_gain_code_quant3
+ *
+ *
+ * Parameters:
+ *    gcode0            I: Predicted CB gain
+ *    g_pitch_cand      I: Pitch gain candidates (3)
+ *    g_pitch_cind      I: Pitch gain cand. indices (3)
+ *    coeff             I: Energy coefficients
+ *    gain_pit          O: Pitch gain
+ *    gain_pit_ind      O: Pitch gain index
+ *    gain_cod          O: Code gain
+ *    gain_cod_ind      O: Code gain index
+ *    qua_ener_index    O: quantized energy error index
+ *
+ * Function:
+ *    Pre-quantization of codebook gains, given three possible
+ *    LTP gains (using predicted codebook gain)
+ *
+ * Returns:
+ *    void
+ */
+static void MR795_gain_code_quant3( Word32 gcode0_exp, Word32 gcode0_fra, Float32 g_pitch_cand[],
+      Word32 g_pitch_cind[], Float32 coeff[], Float32 *gain_pit, Word32 *
+      gain_pit_ind, Float32 *gain_cod, Word32 *gain_cod_ind, Word32 *qua_ener_index )
+{
+   Float32 gcode0, dist_min, g_pitch, g2_pitch, g_code, g2_code, g_pit_cod, tmp0, tmp;
+   const Float32 *p;
+   Word32 i, j, cod_ind, pit_ind, g_code0, g_code_tmp;
+
+   gcode0 = (Float32)Pow2( gcode0_exp, gcode0_fra);
+   /*
+    * The error energy (sum) to be minimized consists of five terms, t[0..4].
+    *
+    * t[0] =    gp^2  * <y1 y1>
+    * t[1] = -2*gp    * <xn y1>
+    * t[2] =    gc^2  * <y2 y2>
+    * t[3] = -2*gc    * <xn y2>
+    * t[4] =  2*gp*gc * <y1 y2>
+    */
+   /*
+    * Codebook search:
+    * For each of the candiates LTP gains in g_pitch_cand[], the terms
+    * t[0..4] are calculated from the values in the table (and the
+    * pitch gain candidate) and summed up; the result is the mean
+    * squared error for the LPT/CB gain pair. The index for the mini-
+    * mum MSE is stored and finally used to retrieve the quantized CB
+    * gain
+    */
+   dist_min = FLT_MAX;
+   cod_ind = 0;
+   pit_ind = 0;
+
+   /* loop through LTP gain candidates */
+   for ( j = 0; j < 3; j++ ) {
+      /* pre-calculate terms only dependent on pitch gain */
+      g_pitch = g_pitch_cand[j];
+      g2_pitch = g_pitch * g_pitch;
+      tmp0 = coeff[0] * g2_pitch;
+      tmp0 += coeff[1] * g_pitch;
+      p = &gain_factor[0];
+
+      for ( i = 0; i < NB_QUA_CODE; i++ ) {
+         /* this is g_fac */
+         g_code = *p++;
+         g_code = g_code * gcode0;
+         g2_code = g_code * g_code;
+         g_pit_cod = g_code * g_pitch;
+         tmp = tmp0 + coeff[2] * g2_code;
+         tmp += coeff[3] * g_code;
+         tmp += coeff[4] * g_pit_cod;
+
+         /*
+          * store table index if MSE for this index is lower
+          * than the minimum MSE seen so far; also store the
+          * pitch gain for this (so far) lowest MSE
+          */
+         if ( tmp < dist_min ) {
+            dist_min = tmp;
+            cod_ind = i;
+            pit_ind = j;
+         }
+      }
+   }
+
+   /*
+    *  read quantized gains and new values for MA predictor memories
+    */
+   p = &gain_factor[cod_ind];
+   g_code_tmp = (Word32)(2048 * *p);
+   *qua_ener_index = cod_ind;
+
+   /*
+    *  calculate final fixed codebook gain:
+    *   gc = gc0 * g
+    */
+   g_code0 = Pow2( 14, gcode0_fra);
+   i = ( g_code_tmp * g_code0 ) << 1;
+      gcode0_exp = 9 - gcode0_exp;
+
+      if ( gcode0_exp > 0 )
+         i = i >> gcode0_exp;
+      else
+         i = i << ( -gcode0_exp );
+      *gain_cod = (Float32)(i >> 16);
+     if (*gain_cod > 32767)
+        *gain_cod = 32767;
+
+     *gain_cod *= 0.5F;
+
+   *gain_cod_ind = ( Word16 )cod_ind;
+   *gain_pit = g_pitch_cand[pit_ind];
+   *gain_pit_ind = g_pitch_cind[pit_ind];
+}
+
+
+/*
+ * calc_unfilt_energies
+ *
+ *
+ * Parameters:
+ *    res               I: LP residual
+ *    exc               I: LTP excitation (unfiltered)
+ *    code              I: CB innovation (unfiltered)
+ *    gain_pit          I: pitch gain
+ *    en                O: energy coefficients [4]
+ *    ltpg              O: LTP coding gain (log2())
+ *
+ * Function:
+ *    Calculation of several energy coefficients for unfiltered
+ *    excitation signals and the LTP coding gain
+ *
+ *    en[0] = <res res>    LP residual energy
+ *    en[1] = <exc exc>    LTP residual energy
+ *    en[2] = <exc code>   LTP/CB innovation dot product
+ *    en[3] = <lres lres>  LTP residual energy
+ *                         (lres = res - gain_pit*exc)
+ *    ltpg = log2(LP_res_en / LTP_res_en)
+ *
+ * Returns:
+ *    void
+ */
+static void calc_unfilt_energies( Float32 res[], Float32 exc[], Float32 code[],
+      Float32 gain_pit, Float32 en[], Float32 *ltpg )
+{
+   Float32 sum, pred_gain;
+   Word32 i;
+
+
+   /* Compute residual energy */
+   en[0] = (Float32)Dotproduct40( res, res );
+
+   /* ResEn := 0 if ResEn < 200.0 */
+   if ( en[0] < 200 ) {
+      en[0] = 0;
+   }
+
+   /* Compute ltp excitation energy */
+   en[1] = (Float32)Dotproduct40( exc, exc );
+
+   /* Compute scalar product <exc[],code[]> */
+   en[2] = (Float32)Dotproduct40( exc, code );
+
+   /* Compute energy of LTP residual */
+   en[3] = 0;
+
+   for ( i = 0; i < L_SUBFR; i++ ) {
+      /* LTP residual */
+      sum = res[i] - ( exc[i] * gain_pit );
+      en[3] += sum * sum;
+   }
+
+   /* calculate LTP coding gain, i.e. energy reduction LP res -> LTP res */
+   if ( en[3] > 0 && en[0] != 0 ) {
+      /* gain = ResEn / LTPResEn */
+      pred_gain = en[0] / en[3];
+      *ltpg = ( Float32 )( log10( pred_gain ) / log10( 2 ) );
+   }
+   else {
+      *ltpg = 0;
+   }
+}
+
+
+/*
+ * gmed_n_f
+ *
+ *
+ * Parameters:
+ *    ind               I: values
+ *    n                 I: The number of gains
+ *
+ * Function:
+ *    Calculates N-point median (float).
+ *
+ * Returns:
+ *    index of the median value
+ */
+static Float32 gmed_n_f( Float32 ind[], Word16 n )
+{
+   Word32 medianIndex;
+   Word32 i, j, ix = 0;
+   Word32 tmp[9];
+   Float32 tmp2[9];
+   Float32 max;
+
+
+   for ( i = 0; i < n; i++ ) {
+      tmp2[i] = ind[i];
+   }
+
+   for ( i = 0; i < n; i++ ) {
+      max = -FLT_MAX;
+
+      for ( j = 0; j < n; j++ ) {
+         if ( tmp2[j] >= max ) {
+            max = tmp2[j];
+            ix = j;
+         }
+      }
+      tmp2[ix] = -FLT_MAX;
+      tmp[i] = ix;
+   }
+   medianIndex = tmp[n >> 1];
+   return( ind[medianIndex] );
+}
+
+
+/*
+ * gain_adapt
+ *
+ *
+ * Parameters:
+ *    prev_gc           B: previous code gain
+ *    onset             B: onset indicator
+ *    ltpg_mem          B: stored past LTP coding gains
+ *    prev_alpha        B: revious gain adaptation factor
+ *    ltpg              I: ltp coding gain (log2())
+ *    gain_cod          I: code gain
+ *    alpha             O: gain adaptation factor
+ *
+ * Function:
+ *    Calculate pitch/codebook gain adaptation factor alpha
+ *    (and update the adaptor state)
+ *
+ *    If the coding gain ag is less than 1 dB, the modified criterion is
+ *    employed, except when an onset is detected. An onset is said to be
+ *    detected if the fixed codebook gain in the current subframe is more
+ *    than twice the value of the fixed codebook gain in the previous
+ *    subframe. A hangover of 8 subframes is used in the onset detection
+ *    so that the modified criterion is not used for the next 7 subframes
+ *    either if an onset is detected. The balance factor a is computed from
+ *    the median filtered adaptive coding gain. The current and
+ *    the ag-values for the previous 4 subframes are median filtered to get
+ *    agm. The  a-factor is computed by:
+ *
+ *          /  0                       ,  2 < agm
+ *       a =   0.5 * (1 - 0.5 * agm)   ,  0 < agm < 2
+ *          \  0.5                     ,      agm < 0
+ *
+ * Returns:
+ *    void
+ */
+static void gain_adapt( Float32 *prev_gc, Word16 *onset, Float32 *ltpg_mem,
+      Float32 *prev_alpha, Float32 ltpg, Float32 gain_cod, Float32 *alpha )
+{
+   Float32 result, filt;   /* alpha factor, median-filtered LTP coding gain */
+   Word32 i;
+   Word16 adapt;   /* adaptdation status; 0, 1, or 2 */
+
+
+   /* basic adaptation */
+   if ( ltpg <= 0.3321928F /*LTP_GAIN_THR1*/ ) {
+      adapt = 0;
+   }
+   else {
+      if ( ltpg <= 0.6643856 /*LTP_GAIN_THR2*/ ) {
+         adapt = 1;
+      }
+      else {
+         adapt = 2;
+      }
+   }
+
+   /*
+    * onset indicator:
+    */
+   if ( ( gain_cod > 2.0F * *prev_gc ) && ( gain_cod > 100 ) ) {
+      *onset = 8;
+   }
+   else {
+      if ( *onset != 0 ) {
+         (*onset)--;
+      }
+   }
+
+   /*
+    * if onset, increase adaptor state
+    */
+   if ( ( *onset != 0 ) && ( adapt < 2 ) ) {
+      adapt++;
+   }
+   ltpg_mem[0] = ltpg;
+   filt = gmed_n_f( ltpg_mem, 5 );
+
+   if ( adapt == 0 ) {
+      if ( filt > 0.66443 ) {
+         result = 0;
+      }
+      else {
+         if ( filt < 0 ) {
+            result = 0.5;
+         }
+         else {
+            result = ( Float32 )( 0.5-0.75257499*filt );
+         }
+      }
+   }
+   else {
+      result = 0;
+   }
+
+   /*
+    * if (prev_alpha == 0.0) result = 0.5 * (result + prev_alpha);
+    */
+   if ( *prev_alpha == 0 ) {
+      result = 0.5F * result;
+   }
+
+   /* store the result */
+   *alpha = result;
+
+   /* update adapter state memory */
+   *prev_alpha = result;
+   *prev_gc = gain_cod;
+
+   for ( i = LTPG_MEM_SIZE - 1; i > 0; i-- ) {
+      ltpg_mem[i] = ltpg_mem[i - 1];
+   }
+
+   /* mem[0] is just present for convenience in calling the gmed_n[5]
+    * function above. The memory depth is really LTPG_MEM_SIZE-1.
+    */
+}
+
+
+/*
+ * MR795_gain_code_quant_mod
+ *
+ *
+ * Parameters:
+ *    gain_pit          I: Pitch gain
+ *    gcode0            I: Predicted CB gain
+ *    en                I: energy coefficients
+ *    alpha             I: gain adaptation factor
+ *    gain_cod_unq      I: Code gain (unquantized)
+ *    gain_cod          I: Code gain
+ *    qua_ener_index    O: quantized energy error index
+ *
+ * Function:
+ *   Modified quantization of the MR795 codebook gain
+ *
+ *   Uses pre-computed energy coefficients in frac_en[]/exp_en[]
+ *
+ *   frac_en[0]*2^exp_en[0] = <res res>     LP residual energy
+ *   frac_en[1]*2^exp_en[1] = <exc exc>     LTP residual energy
+ *   frac_en[2]*2^exp_en[2] = <exc code>    LTP/CB innovation dot product
+ *   frac_en[3]*2^exp_en[3] = <code code>   CB innovation energy
+ *
+ * Returns:
+ *    index             codebook index
+ */
+static Word16 MR795_gain_code_quant_mod( Float32 gain_pit, Word32 gcode0_exp, Word32 gcode0_fra,
+      Float32 en[], Float32 alpha, Float32 gain_cod_unq, Float32 *gain_cod,
+      Word32 *qua_ener_index )
+{
+   Float32 coeff[5];
+   Float32 gcode0, g2_pitch, g_code, g2_code, d2_code, dist_min, gain_code, tmp;
+   const Float32 *p;
+   Word32 i, index, g_code_tmp, g_code0;
+
+   gcode0 = (Float32)Pow2(gcode0_exp, gcode0_fra);
+
+   gain_code = *gain_cod;
+   g2_pitch = gain_pit * gain_pit;
+   coeff[0] = ( Float32 )( sqrt( alpha * en[0] ) );
+   coeff[1] = alpha * en[1] * g2_pitch;
+   coeff[2] = 2.0F * alpha * en[2] * gain_pit;
+   coeff[3] = alpha * en[3];
+   coeff[4] = ( 1.0F - alpha ) * en[3];
+
+   /* search the quantizer table for the lowest value of the search criterion */
+   dist_min = FLT_MAX;
+   index = 0;
+   p = &gain_factor[0];
+
+   for ( i = 0; i < NB_QUA_CODE; i++ ) {
+      /* this is g_fac */
+      g_code = *p++;
+      g_code = g_code * gcode0;
+
+      /*
+       * only continue if gc[i] < 2.0*gc
+       */
+      if ( g_code >= ( 2.0F * gain_code ) )
+         break;
+      g2_code = g_code * g_code;
+      d2_code = g_code - gain_cod_unq;
+      d2_code = d2_code * d2_code;
+      tmp = coeff[1] + coeff[2] * g_code;
+      tmp += coeff[3] * g2_code;
+      tmp = ( Float32 )sqrt( tmp );
+      tmp = tmp - coeff[0];
+      tmp = tmp * tmp;
+      tmp += coeff[4] * d2_code;
+
+      /*
+       * store table index if distance measure for this
+       * index is lower than the minimum seen so far
+       */
+      if ( tmp < dist_min ) {
+         dist_min = tmp;
+         index = i;
+      }
+   }
+
+   /*
+    *  read quantized gains and new values for MA predictor memories
+    */
+   p = &gain_factor[index];
+   g_code_tmp = (Word32)(2048 * *p);
+   *qua_ener_index = index;
+
+   /* calculate final fixed codebook gain:
+    * gc = gc0 * g
+    */
+   g_code0 = Pow2( 14, gcode0_fra);
+   i = ( g_code_tmp * g_code0 ) << 1;
+      gcode0_exp = 9 - gcode0_exp;
+
+      if ( gcode0_exp > 0 )
+         i = i >> gcode0_exp;
+      else
+         i = i << ( -gcode0_exp );
+      *gain_cod = (Float32)(i >> 16);
+      if (*gain_cod > 32767)
+        *gain_cod = 32767;
+
+     *gain_cod *= 0.5F;
+   return( Word16 )index;
+}
+
+
+/*
+ * MR795_gain_quant
+ *
+ *
+ * Parameters:
+ *    prev_gc           B: previous code gain
+ *    onset             B: onset indicator
+ *    ltpg_mem          B: stored past LTP coding gains
+ *    prev_alpha        B: previous gain adaptation factor
+ *    res               I: LP residual
+ *    exc               I: LTP excitation (unfiltered)
+ *    code              I: CB innovation (unfiltered)
+ *    coeff             I: energy coefficients (5)
+ *    code_en           I: innovation energy
+ *    gcode0            I: predicted CB gain
+ *    cod_gain          I: codebook gain
+ *    gp_limit          I: pitch gain limit
+ *    gain_pit          B: Pitch gain
+ *    gain_cod          O: Code gain
+ *    qua_ener          O: quantized energy error
+ *    anap              O: Index of quantization
+ *    gain_pit          I: Pitch gain
+ *    gcode0            I: Predicted CB gain
+ *    en                I: energy coefficients
+ *    alpha             I: gain adaptation factor
+ *    gain_cod_unq      I: Code gain (unquantized)
+ *    gain_cod          I: Code gain
+ *    qua_ener          O: quantized energy error_index
+ *
+ * Function:
+ *    Pitch and codebook quantization for MR795
+ *
+ * Returns:
+ *    void
+ */
+static void MR795_gain_quant( Float32 *prev_gc, Word16 *onset, Float32 *ltpg_mem
+      , Float32 *prev_alpha, Float32 res[], Float32 exc[], Float32 code[],
+      Float32 coeff[], Float32 code_en, Word32 gcode0_exp, Word32 gcode0_fra, Float32 cod_gain,
+      Float32 gp_limit, Float32 *gain_pit, Float32 *gain_cod, Word32 *qua_ener_index,
+      Word16 **anap )
+{
+   Float32 en[4], g_pitch_cand[3];
+   Float32 ltpg, alpha, gain_cod_unq;   /* code gain (unq.) */
+   Word32 g_pitch_cind[3];   /* pitch gain indices */
+   Word32 gain_pit_index, gain_cod_index;
+
+
+   /*
+    * get list of candidate quantized pitch gain values
+    * and corresponding quantization indices
+    */
+   gain_pit_index = q_gain_pitch( MR795, gp_limit, gain_pit, g_pitch_cand,
+         g_pitch_cind );
+
+   /*
+    * pre-quantization of codebook gain
+    * (using three pitch gain candidates);
+    * result: best guess of pitch gain and code gain
+    */
+   MR795_gain_code_quant3( gcode0_exp, gcode0_fra, g_pitch_cand, g_pitch_cind, coeff, gain_pit,
+         &gain_pit_index, gain_cod, &gain_cod_index, qua_ener_index );
+
+   /* calculation of energy coefficients and LTP coding gain */
+   calc_unfilt_energies( res, exc, code, *gain_pit, en, &ltpg );
+
+   /*
+    * run gain adaptor, calculate alpha factor to balance LTP/CB gain
+    * (this includes the gain adaptor update)
+    */
+   gain_adapt( prev_gc, onset, ltpg_mem, prev_alpha, ltpg, *gain_cod, &alpha );
+
+   /*
+    * if this is a very low energy signal (threshold: see
+    * calc_unfilt_energies) or alpha <= 0 then don't run the modified quantizer
+    */
+   if ( ( en[0] != 0 ) && ( alpha > 0 ) ) {
+      /*
+       * innovation energy <cod cod> was already computed in gc_pred()
+       * (this overwrites the LtpResEn which is no longer needed)
+       */
+      en[3] = code_en;
+
+      /*
+       * store optimum codebook gain
+       */
+      gain_cod_unq = cod_gain;
+
+      /* run quantization with modified criterion */
+      gain_cod_index = MR795_gain_code_quant_mod( *gain_pit, gcode0_exp, gcode0_fra, en, alpha,
+            gain_cod_unq, gain_cod, qua_ener_index );
+   }
+   *( *anap )++ = ( Word16 )gain_pit_index;
+   *( *anap )++ = ( Word16 )gain_cod_index;
+}
+
+
+/*
+ * Qua_gain
+ *
+ *
+ * Parameters:
+ *    mode              I: AMR mode
+ *    gcode0            I: predicted CB gain
+ *    coeff             I: energy coefficients (5)
+ *    gp_limit          I: pitch gain limit
+ *    gain_pit          O: Pitch gain
+ *    gain_cod          O: Code gain
+ *    qua_ener_index    O: quantized energy error index
+ *
+ * Function:
+ *    Quantization of pitch and codebook gains (using predicted codebook gain)
+ *
+ * Returns:
+ *    index             index of quantization
+ */
+static Word16 Qua_gain( enum Mode mode, Word32 gcode0_exp, Word32 gcode0_fra, Float32 coeff[], Float32
+      gp_limit, Float32 *gain_pit, Float32 *gain_cod, Word32 *qua_ener_index)
+{
+   Float32 g_pitch, g2_pitch, g_code, g2_code, g_pit_cod, tmp, dist_min, gcode0;
+   const Float32 *table_gain, *p;
+   Word32 i, index = 0, gcode_0, g_code_tmp;
+   Word16 table_len;
+
+   gcode0 = (Float32)Pow2( gcode0_exp, gcode0_fra );
+
+
+   if ( ( mode == MR102 ) || ( mode == MR74 ) || ( mode == MR67 ) ) {
+      table_len = VQ_SIZE_HIGHRATES;
+      table_gain = table_highrates;
+      *qua_ener_index = NB_QUA_CODE;
+   }
+   else {
+      table_len = VQ_SIZE_LOWRATES;
+      table_gain = table_lowrates;
+      *qua_ener_index = NB_QUA_CODE + VQ_SIZE_HIGHRATES;
+   }
+
+   /*
+    * Codebook search:
+    * For each pair (g_pitch, g_fac) in the table calculate the
+    * terms t[0..4] and sum them up; the result is the mean squared
+    * error for the quantized gains from the table. The index for the
+    * minimum MSE is stored and finally used to retrieve the quantized
+    * gains
+    */
+   dist_min = FLT_MAX;
+   p = &table_gain[0];
+
+   for ( i = 0; i < table_len; i++ ) {
+      g_pitch = *p++;
+
+      /* this is g_fac */
+      g_code = *p++;
+
+      if ( g_pitch <= gp_limit ) {
+         g_code *= gcode0;
+         g2_pitch = g_pitch * g_pitch;
+         g2_code = g_code * g_code;
+         g_pit_cod = g_code * g_pitch;
+         tmp = coeff[0] * g2_pitch;
+         tmp += coeff[1] * g_pitch;
+         tmp += coeff[2] * g2_code;
+         tmp += coeff[3] * g_code;
+         tmp += coeff[4] * g_pit_cod;
+
+         /*
+          * store table index if MSE for this index is lower
+          * than the minimum MSE seen so far
+          */
+         if ( tmp < dist_min ) {
+            dist_min = tmp;
+            index = i;
+         }
+      }
+   }
+
+   /*
+    * read quantized gains and new values for MA predictor memories
+    */
+   p = &table_gain[index << 1];
+   *gain_pit = *p++;
+   g_code_tmp = (Word32)(4096 * *p);
+
+   /*
+    * calculate final fixed codebook gain:
+    * gc = gc0 * g
+    */
+
+   gcode_0 = Pow2( 14, gcode0_fra );
+   if ( gcode0_exp < 11 ) {
+      *gain_cod = (Float32)((g_code_tmp * gcode_0) >> ( 25 - gcode0_exp ));
+   }
+   else {
+      i = ( ( g_code_tmp * gcode_0) << ( gcode0_exp - 9 ) );
+
+      if ( ( i >> ( gcode0_exp - 9 ) ) != ( g_code_tmp * gcode_0) ) {
+         *gain_cod = 0x7FFF;
+      }
+      else {
+         *gain_cod = (Float32)(i >> 16);
+      }
+   }
+   *gain_cod = *gain_cod * 0.5F;
+   *qua_ener_index += index;
+
+   return( Word16 )index;
+}
+
+
+/*
+ * gainQuant
+ *
+ *
+ * Parameters:
+ *    gcode0            I: predicted CB gain
+ *    coeff             I: energy coefficients (5)
+ *    gp_limit          I: pitch gain limit
+ *    gain_pit          O: Pitch gain
+ *    gain_cod          O: Code gain
+ *    qua_ener          O: quantized energy error,
+ *    mode              I: AMR mode
+ *    even_subframe     I: even subframe indicator flag
+ *    past_qua_en       B: past quantized energies [4]
+ *    past_qua_en_unq   B: past energies [4]
+ *    sf0_coeff         B: energy coefficients subframe 0 (or 2)
+ *    sf0_target_en     B: target energy from subframe 0 (or 2)
+ *    sf0_gcode0        B: predicted gain factor subframe 0 (or 2)
+ *    gain_idx_ptr      B: gain index pointer
+ *    sf0_gain_pit      B: Pitch gain subframe 0 (or 2)
+ *    sf0_gain_cod      B: Code gain subframe 0 (or 2)
+ *    res               I: LP residual
+ *    exc               I: LTP excitation (unfiltered)
+ *    code              I: innovative codebook vector
+ *    xn                I: Target vector
+ *    xn2               I: CB target vector
+ *    y1                I: Adaptive codebook
+ *    y2                I: Filtered innovative vector
+ *    gCoeff            I: Correlations <xn y1> <y1 y1>
+ *    gp_limit          I: pitch gain limit
+ *    gain_pit          O: Pitch gain
+ *    gain_cod          O: Code gain
+ *    prev_gc           B: B: previous code gain
+ *    onset             B: onset indicator
+ *    ltpg_mem          B: stored past LTP coding gains
+ *    prev_alpha        B: previous gain adaptation factor
+ *    anap              B: Index of quantization
+ *
+ * Function:
+ *    Quantization of gains
+ *
+ * Returns:
+ *    index             index of quantization
+ */
+static void gainQuant( enum Mode mode, Word32 even_subframe, Word32 *
+      past_qua_en, Word32 *past_qua_en_unq, Float32 *sf0_coeff, Float32 *
+      sf0_target_en, Word32 *sf0_gcode0_exp, Word32 *sf0_gcode0_fra,Word16 **gain_idx_ptr, Float32 *
+      sf0_gain_pit, Float32 *sf0_gain_cod, Float32 *res, Float32 *exc, Float32
+      code[], Float32 xn[], Float32 xn2[], Float32 y1[], Float32 y2[], Float32
+      gCoeff[], Float32 gp_limit, Float32 *gain_pit, Float32 *gain_cod, Float32
+      *prev_gc, Word16 *onset, Float32 *ltpg_mem, Float32 *prev_alpha, Word16 **
+      anap )
+{
+   Float32 coeff[5];
+   Float32 gcode0, cod_gain, en = 0;
+   Word32 i, exp, frac, qua_ener_index;
+
+
+   if ( mode == MR475 ) {
+      if ( even_subframe != 0 ) {
+      /*
+       * save position in output parameter stream and current
+       * state of codebook gain predictor
+       */
+         *gain_idx_ptr = ( *anap )++;
+         past_qua_en_unq[0] = past_qua_en[0];
+         past_qua_en_unq[1] = past_qua_en[1];
+         past_qua_en_unq[2] = past_qua_en[2];
+         past_qua_en_unq[3] = past_qua_en[3];
+
+         /*
+          * predict codebook gain (using "unquantized" predictor)
+          * (note that code[] is unsharpened in MR475)
+          */
+         gc_pred( past_qua_en, mode, code, sf0_gcode0_exp, sf0_gcode0_fra, &en );
+         gcode0 = (Float32)Pow2(*sf0_gcode0_exp, *sf0_gcode0_fra);
+
+         /*
+          * calculate energy coefficients for quantization
+          * and store them in state structure (will be used
+          * in next subframe when real quantizer is run)
+          */
+         calc_filt_energies( mode, xn, xn2, y1, y2, gCoeff, sf0_coeff, &cod_gain
+               );
+
+         /* store optimum codebook gain */
+         *gain_cod = cod_gain;
+         *sf0_target_en = (Float32)Dotproduct40( xn, xn );
+
+         /*
+          * calculate optimum codebook gain and update
+          * "unquantized" predictor
+          */
+         MR475_update_unq_pred( past_qua_en_unq, gcode0, cod_gain );
+
+         /* the real quantizer is not run here... */
+      }
+      else {
+         /*
+          * predict codebook gain (using "unquantized" predictor)
+          * (note that code[] is unsharpened in MR475)
+          */
+         gc_pred( past_qua_en_unq, mode, code, &exp, &frac, &en );
+
+         /* calculate energy coefficients for quantization */
+         calc_filt_energies( mode, xn, xn2, y1, y2, gCoeff, coeff, &cod_gain );
+         en = (Float32)Dotproduct40( xn, xn );
+
+         /* run real (4-dim) quantizer and update real gain predictor */
+         **gain_idx_ptr = MR475_gain_quant( past_qua_en, *sf0_gcode0_exp, *sf0_gcode0_fra, sf0_coeff,
+               *sf0_target_en, code, exp, frac, coeff, en, gp_limit, sf0_gain_pit,
+               sf0_gain_cod, gain_pit, gain_cod );
+      }
+   }
+   else {
+      /*
+       * predict codebook gain and quantize
+       *  (also compute normalized CB innovation energy for MR795)
+       */
+      gc_pred( past_qua_en, mode, code, &exp, &frac, &en );
+
+      if ( mode == MR122 ) {
+         /*
+          * Compute the innovative codebook gain.
+          * The innovative codebook gain is given by
+          * g = <xn2[], y2[]> / <y2[], y2[]>
+          * where xn2[] is the target vector,
+          * y2[] is the filtered innovative
+          * codevector
+          */
+
+         gcode0 = (Float32)Pow2( exp, frac );
+         /* saturation at decoder */
+         if (gcode0 > 2047.9375F) gcode0 = 2047.9375F;
+
+         *gain_cod = (Float32)(Dotproduct40( xn2, y2 ) / ( Dotproduct40( y2, y2 )+ 0.01F ));
+
+         if ( *gain_cod < 0 )
+            *gain_cod = 0.0F;
+         *( *anap )++ = q_gain_code( gcode0, gain_cod,&qua_ener_index);
+      }
+      else {
+         /* calculate energy coefficients for quantization */
+         calc_filt_energies( mode, xn, xn2, y1, y2, gCoeff, coeff, &cod_gain );
+
+         if ( mode == MR795 ) {
+            MR795_gain_quant( prev_gc, onset, ltpg_mem, prev_alpha, res, exc,
+                  code, coeff, en, exp, frac , cod_gain, gp_limit, gain_pit,
+                  gain_cod, &qua_ener_index, anap );
+         }
+         else {
+
+            *( *anap )++ = Qua_gain( mode, exp, frac, coeff, gp_limit, gain_pit,
+                  gain_cod, &qua_ener_index);
+         }
+      }
+
+      /*
+       * update table of past quantized energies
+       */
+      for ( i = 3; i > 0; i-- ) {
+         past_qua_en[i] = past_qua_en[i - 1];
+      }
+      past_qua_en[0] = qua_ener_index;
+
+   }
+}
+
+
+/*
+ * subframePostProc
+ *
+ *
+ * Parameters:
+ *    speech            I: Speech segment
+ *    i_subfr           I: Subframe number
+ *    gain_pit          I: Pitch gain
+ *    gain_code         I: Decoded innovation gain
+ *    a_q               I: A(z) quantized for the 4 subframes
+ *    synth             I: Local synthesis
+ *    xn                I: Target vector for pitch search
+ *    code              I: Fixed codebook exitation
+ *    y1                I: Filtered adaptive exitation
+ *    y2                I: Filtered fixed codebook excitation
+ *    mem_syn           B: memory of synthesis filter
+ *    mem_err           O: pointer to error signal
+ *    mem_w0            O: memory of weighting filter
+ *    exc               O: long term prediction residual
+ *    sharp             O: pitch sharpening value
+ *
+ * Function:
+ *    Subframe post processing
+ *
+ *    Memory update (all modes)
+ *    An update of the states of the synthesis and weighting filters is needed
+ *   in order to compute the target signal in the next subframe.
+ *   After the two gains are quantified, the excitation signal, u(n),
+ *   in the present subframe is found by:
+ *
+ *   u(n) = Gp_q * v(n) + Gc_q * c(n), n = 0, ..., 39,
+ *
+ *   where Gp_q and Gc_q are the quantified adaptive and fixed codebook gains,
+ *   respectively, v(n) the adaptive codebook vector
+ *   (interpolated past excitation), and c(n) is the fixed codebook vector
+ *   (algebraic code including pitch sharpening). The states of the filters
+ *   can be updated by filtering the signal res_lp(n) - u(n)
+ *   (difference between residual and excitation) through the filters
+ *   1 / A_q(z) and A(z/g1) / A(z/g2) for the 40-sample subframe and saving
+ *   the states of the filters. This would require 3 filterings.
+ *   A simpler approach which requires only one filtering is as follows.
+ *   The local synthesized speech, S_s(n), is computed by filtering
+ *   the excitation signal through 1 / A_q(z). The output of the filter
+ *   due to the input res_lp(n) - u(n) is equivalent to e(n) = S(n) - S_s(n).
+ *   So the states of the synthesis filter 1 / A_q(z) are given by
+ *   e(n), n = 30, ..., 39. Updating the states of the filter A(z/g1) / A(z/g2)
+ *   can be done by filtering the error signal e(n) through this filter
+ *   to find the perceptually weighted error ew(n). However, the signal ew(n)
+ *   can be equivalently found by:
+ *
+ *   ew(n) = x(n) - Gp_q * y(n) - Gc_q(n) * z(n)
+ *
+ *   Since the signals x(n), y(n) and z(n) are available, the states of
+ *   the weighting filter are updated by computing ew(n) for n = 30, ..., 39.
+ *   This saves two filterings.
+ *
+ * Returns:
+ *    void
+ */
+static void subframePostProc( Float32 *speech, Word16 i_subfr, Float32 gain_pit,
+      Float32 gain_code, Float32 *a_q, Float32 synth[], Float32 xn[], Float32
+      code[], Float32 y1[], Float32 y2[], Float32 *mem_syn, Float32 *mem_err,
+      Float32 *mem_w0, Float32 *exc, Float32 *sharp )
+{
+   Word32 i, j;
+
+
+   /*
+    * Update pitch sharpening "sharp" with quantized gain_pit
+    */
+   *sharp = gain_pit;
+   if ( *sharp > 0.794556F ) {
+      *sharp = 0.794556F;
+   }
+
+   /* Find the total excitation */
+   for ( i = 0; i < L_SUBFR; i += 4 ) {
+      exc[i + i_subfr] = (Float32)floor((gain_pit * exc[i + i_subfr] + gain_code * code[i]) + 0.5F);
+      exc[i + i_subfr + 1] = (Float32)floor((gain_pit * exc[i + i_subfr + 1] + gain_code * code[i
+            + 1]) + 0.5F);
+      exc[i + i_subfr + 2] = (Float32)floor((gain_pit * exc[i + i_subfr + 2] + gain_code * code[
+            i + 2]) + 0.5F);
+      exc[i + i_subfr + 3] = (Float32)floor((gain_pit * exc[i + i_subfr + 3] + gain_code * code[
+            i + 3]) + 0.5F);
+   }
+
+
+   /* The local synthesis speech */
+   Syn_filt( a_q, &exc[i_subfr], &synth[i_subfr], mem_syn, 1 );
+
+   for ( i = L_SUBFR - M, j = 0; i < L_SUBFR; i++, j++ ) {
+      /* e(n) = S(n) - S_s(n) */
+      mem_err[j] = speech[i_subfr + i] - synth[i_subfr + i];
+
+      /* ew(n) = x(n) - Gp_q * y(n) - Gc_q(n) * z(n) */
+      mem_w0[j] = xn[i] - y1[i] * gain_pit - y2[i] * gain_code;
+   }
+}
+
+
+/*
+ * Convolve
+ *
+ *
+ * Parameters:
+ *    x                 I: First input
+ *    h                 I: second input
+ *    y                 O: output
+ *
+ * Function:
+ *    Convolution
+ *
+ * Returns:
+ *    void
+ */
+static void Convolve( Float32 x[], Float32 h[], Float32 y[] )
+{
+   Word32 i, n;
+   Float32 s;
+
+
+   for ( n = 0; n < L_SUBFR; n++ ) {
+      s = 0.0F;
+
+      for ( i = 0; i <= n; i++ ) {
+         s += x[i] * h[n - i];
+      }
+      y[n] = s;
+   }
+   return;
+}
+
+
+/*
+ * tx_dtx_handler
+ *
+ *
+ * Parameters:
+ *    vad_flag             I:vad decision
+ *    decAnaElapsedCount   B: state machine that synch with the GSMEFR txDtx machine
+ *    dtxHangoverCount     B: dtx hangover counter
+ *    used_mode            O: used mode
+ *
+ * Function:
+ *    Adds extra speech hangover to analyze speech on the decoding side
+ *
+ * Returns:
+ *    compute_new_sid_possible
+ */
+static Word16 tx_dtx_handler( Word16 vad_flag, Word16 *decAnaElapsedCount,
+      Word16 *dtxHangoverCount, enum Mode *used_mode )
+{
+   Word16 compute_new_sid_possible;
+
+
+   /* this state machine is in synch with the GSMEFR txDtx machine */
+   *decAnaElapsedCount += 1;
+   compute_new_sid_possible = 0;
+
+   if ( vad_flag != 0 ) {
+      *dtxHangoverCount = DTX_HANG_CONST;
+   }
+
+   /* non-speech */
+   else {
+      /* out of decoder analysis hangover */
+      if ( *dtxHangoverCount == 0 ) {
+         *decAnaElapsedCount = 0;
+         *used_mode = MRDTX;
+         compute_new_sid_possible = 1;
+      }
+
+      /* in possible analysis hangover */
+      else {
+         *dtxHangoverCount -= 1;
+
+         /* decAnaElapsedCount + dtxHangoverCount < DTX_ELAPSED_FRAMES_THRESH */
+         if ( ( *decAnaElapsedCount + *dtxHangoverCount ) <
+               DTX_ELAPSED_FRAMES_THRESH ) {
+            *used_mode = MRDTX;
+
+            /* if short time since decoder update, do not add extra HO */
+         }
+
+         /*
+          * else
+          * override VAD and stay in
+          * speech mode *used_mode
+          * and add extra hangover
+          */
+      }
+   }
+   return compute_new_sid_possible;
+}
+
+
+/*
+ * dtx_buffer
+ *
+ *
+ * Parameters:
+ *    hist_ptr       B: Circular buffer pointer
+ *    lsp_hist       O: LSP history
+ *    lsp_new        I: LSP vector
+ *    speech         I: input speech
+ *    log_en_hist    O: frame energy
+ *
+ * Function:
+ *    Handles the DTX buffer
+ *
+ *    The frame energy is computed for each frame marked with VAD=0
+ *    according to the equation:
+ *
+ *                                       N-1
+ *    en_log(i) = 0.5 * log2 ( (1 / N) * SUM[ s(n) * s(n) ] )
+ *                                       N=0
+ *
+ *    where s(n) is the HP-filtered input speech signal of
+ *    the current frame i.
+ *
+ * Returns:
+ *    void
+ */
+static void dtx_buffer( Word16 *hist_ptr, Float32 *lsp_hist, Float32 lsp_new[],
+      Float32 speech[], Float32 *log_en_hist )
+{
+   Float64 frame_en;
+
+
+   /* update pointer to circular buffer */
+   *hist_ptr += 1;
+
+   if ( *hist_ptr == DTX_HIST_SIZE ) {
+      *hist_ptr = 0;
+   }
+
+   /* copy lsp vector into buffer */
+   memcpy( &lsp_hist[ * hist_ptr * M], lsp_new, sizeof( Float32 )*M );
+
+   /* compute log energy based on frame energy */
+   frame_en = Dotproduct40( speech, speech );
+   frame_en += Dotproduct40( &speech[40], &speech[40] );
+   frame_en += Dotproduct40( &speech[80], &speech[80] );
+   frame_en += Dotproduct40( &speech[120], &speech[120] );
+
+   if ( frame_en > 1 ) {
+      log_en_hist[ * hist_ptr] = ( Float32 )( log10( frame_en * 0.00625F )*
+            1.660964F );
+   }
+   else {
+      log_en_hist[ * hist_ptr] = -3.660965F;
+   }
+}
+
+
+/*
+ * dtx_enc
+ *
+ *
+ * Parameters:
+ *    log_en_index      O: logarithmic energy quantized
+ *    log_en_hist       I: history of logarithmic energy
+ *    lsp_hist          I: history of LSP
+ *    lsp_index         O: quantization indices of 3 LSP vectors
+ *    init_lsf_vq_index O: init index for MA prediction
+ *    compute_sid_flag  I: SID flag
+ *    past_rq           I: past quantized residual
+ *    past_qua_en       O: gain predictor memory
+ *    anap              O: analysis parameters
+ *
+ * Function:
+ *    DTX encoder
+ *
+ *    The averaged logarithmic energy is computed by:
+ *
+ *                          7
+ *    en_log_mean(i) = (1 / 8) * SUM[ en_log(i - n) ]
+ *                         n=0
+ *
+ *    The averaged logarithmic energy is quantized means of a 6 bit
+ *    algorithmic quantizer. The 6 bits for the energy index are
+ *    transmitted in the SID frame.
+ *
+ * Returns:
+ *    void
+ */
+static Word32 dtx_enc( Word16 *log_en_index, Float32 log_en_hist[], Float32
+      lsp_hist[], Word16 *lsp_index, Word32 *init_lsf_vq_index, Word16
+      compute_sid_flag, Float32 past_rq[], Word32 *past_qua_en, Word16 **anap )
+{
+   Float32 log_en, lsf[M], lsp[M], lsp_q[M];
+   Word32 i, j;
+
+
+   /* VOX mode computation of SID parameters */
+   if ( ( compute_sid_flag != 0 ) ) {
+   /*
+    * compute new SID frame if safe i.e don't
+    * compute immediately after a talk spurt
+    */
+      log_en = 0;
+      memset( lsp, 0, sizeof( Float32 )*M );
+
+      /* average energy and lsp */
+      for ( i = 0; i < DTX_HIST_SIZE; i++ ) {
+         log_en += log_en_hist[i];
+
+         for ( j = 0; j < M; j++ ) {
+            lsp[j] += lsp_hist[i * M + j];
+         }
+      }
+      log_en = log_en * 0.125F;
+
+      for ( j = 0; j < M; j++ ) {
+         /* divide by 8 */
+         lsp[j] = lsp[j] * 0.125F;
+      }
+
+      /*  quantize logarithmic energy to 6 bits */
+      log_en = log_en + 2.5F;
+      *log_en_index = ( Word16 )( ( log_en * 4 ) + 0.5F );   /* 6 bits */
+
+      /* *log_en_index = ( Word16 )( ( log_en + 2.5F + 0.125F ) * 4.0F ); */
+      if ( *log_en_index > 63 ) {
+         *log_en_index = 63;
+      }
+
+      if ( *log_en_index < 0 ) {
+         *log_en_index = 0;
+      }
+
+      if (*log_en_index > 46){
+         past_qua_en[0] = NB_QUA_CODE+VQ_SIZE_HIGHRATES+VQ_SIZE_LOWRATES+(MR475_VQ_SIZE*2) + 46;
+         past_qua_en[1] = NB_QUA_CODE+VQ_SIZE_HIGHRATES+VQ_SIZE_LOWRATES+(MR475_VQ_SIZE*2) + 46;
+         past_qua_en[2] = NB_QUA_CODE+VQ_SIZE_HIGHRATES+VQ_SIZE_LOWRATES+(MR475_VQ_SIZE*2) + 46;
+         past_qua_en[3] = NB_QUA_CODE+VQ_SIZE_HIGHRATES+VQ_SIZE_LOWRATES+(MR475_VQ_SIZE*2) + 46;
+      }
+      else {
+         past_qua_en[0] = NB_QUA_CODE+VQ_SIZE_HIGHRATES+VQ_SIZE_LOWRATES+(MR475_VQ_SIZE*2) + *log_en_index;
+         past_qua_en[1] = NB_QUA_CODE+VQ_SIZE_HIGHRATES+VQ_SIZE_LOWRATES+(MR475_VQ_SIZE*2) + *log_en_index;
+         past_qua_en[2] = NB_QUA_CODE+VQ_SIZE_HIGHRATES+VQ_SIZE_LOWRATES+(MR475_VQ_SIZE*2) + *log_en_index;
+         past_qua_en[3] = NB_QUA_CODE+VQ_SIZE_HIGHRATES+VQ_SIZE_LOWRATES+(MR475_VQ_SIZE*2) + *log_en_index;
+      }
+
+      /* make sure that LSP's are ordered */
+      Lsp_lsf( lsp, lsf );
+      Reorder_lsf( lsf, 0.00625F );
+      Lsf_lsp( lsf, lsp );
+
+      /* Quantize lsp and put on parameter list */
+      Q_plsf_3( MRDTX, past_rq, lsp, lsp_q, lsp_index, init_lsf_vq_index );
+   }
+
+   /* 3 bits */
+   *( *anap )++ = ( Word16 )*init_lsf_vq_index;
+
+   /* 8 bits */
+   *( *anap )++ = lsp_index[0];
+
+   /* 9 bits */
+   *( *anap )++ = lsp_index[1];
+
+   /* 9 bits */
+   *( *anap )++ = lsp_index[2];
+
+   /* 6 bits */
+   *( *anap )++ = *log_en_index;
+
+   /* = 35 bits */
+   return 0;
+}
+
+
+/*
+ * complex_estimate_adapt
+ *
+ *
+ * Parameters:
+ *    st->best_corr_hp  I: complex background detector
+ *    st->corr_hp_fast  B: long term complex signal estimate
+ *    low_power         I: very low level flag of the input frame
+ *
+ * Function:
+ *    Update/adapt of complex signal estimate
+ *
+ * Returns:
+ *    void
+ */
+#ifndef VAD2
+static void complex_estimate_adapt( vadState *st, Word16 low_power )
+{
+   Float32 alpha;
+
+
+   /* adapt speed on own state */
+   /* decrease */
+   if ( st->best_corr_hp < st->corr_hp_fast ) {
+      /* low state */
+      if ( st->corr_hp_fast < CVAD_THRESH_ADAPT_HIGH ) {
+         alpha = CVAD_ADAPT_FAST;
+      }
+
+      /* high state */
+      else {
+         alpha = CVAD_ADAPT_REALLY_FAST;
+      }
+   }
+
+   /* increase */
+   else {
+      if ( st->corr_hp_fast < CVAD_THRESH_ADAPT_HIGH ) {
+         alpha = CVAD_ADAPT_FAST;
+      }
+      else {
+         alpha = CVAD_ADAPT_SLOW;
+      }
+   }
+   st->corr_hp_fast = st->corr_hp_fast - alpha * st->corr_hp_fast + alpha * st->
+         best_corr_hp;
+
+   if ( st->corr_hp_fast < CVAD_MIN_CORR ) {
+      st->corr_hp_fast = CVAD_MIN_CORR;
+   }
+
+   if ( low_power != 0 ) {
+      st->corr_hp_fast = CVAD_MIN_CORR;
+   }
+}
+#endif
+
+/*
+ * complex_vad
+ *
+ *
+ * Parameters:
+ *    st->complex_high        B: 1 if (corr_hp_fast > CVAD_THRESH_ADAPT_HIGH)
+ *    st->complex_low         B: 1 if (corr_hp_fast > CVAD_THRESH_ADAPT_LOW)
+ *    low_power               I: flag power of the input frame
+ *    st->best_corr_hp        I: complex background detector
+ *    st->corr_hp_fast        B: long term complex signal estimate
+ *    st->complex_hang_timer  B: complex hang timer
+ *
+ *
+ * Function:
+ *    Complex background decision
+ *
+ * Returns:
+ *    void
+ */
+#ifndef VAD2
+static Word32 complex_vad( vadState *st, Word16 low_power )
+{
+   st->complex_high = st->complex_high >> 1;
+   st->complex_low = st->complex_low >> 1;
+
+   if ( low_power == 0 ) {
+      if ( st->corr_hp_fast > CVAD_THRESH_ADAPT_HIGH ) {
+         st->complex_high = st->complex_high | 0x00004000;
+      }
+
+      if ( st->corr_hp_fast > CVAD_THRESH_ADAPT_LOW ) {
+         st->complex_low = st->complex_low | 0x00004000;
+      }
+   }
+
+   if ( st->corr_hp_fast > CVAD_THRESH_HANG ) {
+      st->complex_hang_timer += 1;
+   }
+   else {
+      st->complex_hang_timer = 0;
+   }
+   return( Word16 )( ( ( st->complex_high & 0x00007f80 ) == 0x00007f80 ) || ( (
+         st->complex_low & 0x00007fff ) == 0x00007fff ) );
+}
+#endif
+
+/*
+ * complex_vad
+ *
+ *
+ * Parameters:
+ *    st->complex_warning  I: flags for complex detection
+ *    st->stat_count       B: stationary counter
+ *    st->pitch            I: flags for pitch detection
+ *    st->tone             I: flags indicating presence of a tone
+ *    st->vadreg           I: intermediate VAD flags
+ *    level                I: sub-band levels of the input frame
+ *    st->ave_level        B: Average amplitude estimate
+ *
+ * Function:
+ *    Control update of the background noise estimate
+ *
+ * Returns:
+ *    void
+ */
+#ifndef VAD2
+static void update_cntrl( vadState *st, Float32 level[] )
+{
+   Float32 stat_rat, num, denom;
+   Float32 alpha;
+   Word32 i;
+
+
+   /*
+    * handle highband complex signal input  separately
+    * if ther has been highband correlation for some time
+    * make sure that the VAD update speed is low for a while
+    */
+   if ( st->complex_warning != 0 ) {
+      if ( st->stat_count < CAD_MIN_STAT_COUNT ) {
+         st->stat_count = CAD_MIN_STAT_COUNT;
+      }
+   }
+
+   /*
+    * NB stat_count is allowed to be decreased by one below again
+    * deadlock in speech is not possible unless the signal is very
+    * complex and need a high rate
+    * if fullband pitch or tone have been detected for a while, initialize stat_count
+    */
+   if ( ( ( st->pitch & 0x6000 ) == 0x6000 ) || ( ( st->tone & 0x00007c00 ) ==
+         0x7c00 ) ) {
+      st->stat_count = STAT_COUNT;
+   }
+   else {
+      /* if 8 last vad-decisions have been "0", reinitialize stat_count */
+      if ( ( st->vadreg & 0x7f80 ) == 0 ) {
+         st->stat_count = STAT_COUNT;
+      }
+      else {
+         stat_rat = 0;
+
+         for ( i = 0; i < COMPLEN; i++ ) {
+            if ( level[i] > st->ave_level[i] ) {
+               num = level[i];
+               denom = st->ave_level[i];
+            }
+            else {
+               num = st->ave_level[i];
+               denom = level[i];
+            }
+
+            /* Limit nimimum value of num and denom to STAT_THR_LEVEL */
+            if ( num < STAT_THR_LEVEL ) {
+               num = STAT_THR_LEVEL;
+            }
+
+            if ( denom < STAT_THR_LEVEL ) {
+               denom = STAT_THR_LEVEL;
+            }
+            stat_rat += num / denom * 64;
+         }
+
+         /* compare stat_rat with a threshold and update stat_count */
+         if ( stat_rat > STAT_THR ) {
+            st->stat_count = STAT_COUNT;
+         }
+         else {
+            if ( ( st->vadreg & 0x4000 ) != 0 ) {
+               if ( st->stat_count != 0 ) {
+                  st->stat_count -= 1;
+               }
+            }
+         }
+      }
+   }
+
+   /* Update average amplitude estimate for stationarity estimation */
+   alpha = ALPHA4;
+
+   if ( st->stat_count == STAT_COUNT ) {
+      alpha = 1.0F;
+   }
+   else if ( ( st->vadreg & 0x4000 ) == 0 ) {
+      alpha = ALPHA5;
+   }
+
+   for ( i = 0; i < COMPLEN; i++ ) {
+      st->ave_level[i] += alpha * ( level[i] - st->ave_level[i] );
+   }
+}
+#endif
+
+/*
+ * noise_estimate_update
+ *
+ *
+ * Parameters:
+ *    st                      B: State struct
+ *    level                   I: sub-band levels of the input frame
+ *    st->vadreg              I: intermediate VAD flags
+ *    st->pitch               I: flags for pitch detection
+ *    st->complex_hang_count  I: signal is too complex for VAD
+ *    st->stat_count          B: stationary counter
+ *    st->old_level           B: signal levels of the previous frame
+ *    st->bckr_est            B: noise estimate
+ *
+ * Function:
+ *    Update of background noise estimate
+ *
+ * Returns:
+ *    void
+ */
+#ifndef VAD2
+static void noise_estimate_update( vadState *st, Float32 level[] )
+{
+   Float32 alpha_up, alpha_down, bckr_add;
+   Word32 i;
+
+
+   /* Control update of bckr_est[] */
+   update_cntrl( st, level );
+
+   /* Choose update speed */
+   bckr_add = 2;
+
+   if ( ( ( 0x7800 & st->vadreg ) == 0 ) && ( ( st->pitch & 0x7800 ) == 0 ) && (
+         st->complex_hang_count == 0 ) ) {
+      alpha_up = ALPHA_UP1;
+      alpha_down = ALPHA_DOWN1;
+   }
+   else {
+      if ( ( st->stat_count == 0 ) && ( st->complex_hang_count == 0 ) ) {
+         alpha_up = ALPHA_UP2;
+         alpha_down = ALPHA_DOWN2;
+      }
+      else {
+         alpha_up = 0;
+         alpha_down = ALPHA3;
+         bckr_add = 0;
+      }
+   }
+
+   /* Update noise estimate (bckr_est) */
+   for ( i = 0; i < COMPLEN; i++ ) {
+      Float32 temp;
+
+
+      temp = st->old_level[i] - st->bckr_est[i];
+
+      /* update downwards*/
+      if ( temp < 0 ) {
+         st->bckr_est[i] = ( -2 + ( st->bckr_est[i] + ( alpha_down * temp ) ) );
+
+         /* limit minimum value of the noise estimate to NOISE_MIN */
+         if ( st->bckr_est[i] < NOISE_MIN ) {
+            st->bckr_est[i] = NOISE_MIN;
+         }
+      }
+
+      /* update upwards */
+      else {
+         st->bckr_est[i] = ( bckr_add + ( st->bckr_est[i] + ( alpha_up * temp )
+               ) );
+
+         /* limit maximum value of the noise estimate to NOISE_MAX */
+         if ( st->bckr_est[i] > NOISE_MAX ) {
+            st->bckr_est[i] = NOISE_MAX;
+         }
+      }
+   }
+
+   /* Update signal levels of the previous frame (old_level) */
+   for ( i = 0; i < COMPLEN; i++ ) {
+      st->old_level[i] = level[i];
+   }
+}
+#endif
+
+/*
+ * hangover_addition
+ *
+ *
+ * Parameters:
+ *    noise_level             I: average level of the noise estimates
+ *    low_power               I: flag power of the input frame
+ *    st->burst_count         O: counter for the length of speech bursts
+ *    st->hang_count          O: hangover counter
+ *    st->complex_hang_count  B: signal is too complex for VAD
+ *    st->complex_hang_timer  B: complex hang timer
+ *    st->vadreg              I: intermediate VAD flags
+ *    st->corr_hp_fast        I: long term complex signal estimate
+ *
+ * Function:
+ *    Add hangover for complex signal or after speech bursts
+ *
+ * Returns:
+ *    VAD_flag indicating final VAD decision
+ */
+#ifndef VAD2
+static Word16 hangover_addition( vadState *st, Float32 noise_level, Word16
+      low_power )
+{
+   Word16 hang_len, burst_len;
+
+
+   /*
+    * Calculate burst_len and hang_len
+    * burst_len: number of consecutive intermediate vad flags with "1"-decision
+    * required for hangover addition
+    * hang_len:  length of the hangover
+    */
+   if ( noise_level > HANG_NOISE_THR ) {
+      burst_len = BURST_LEN_HIGH_NOISE;
+      hang_len = HANG_LEN_HIGH_NOISE;
+   }
+   else {
+      burst_len = BURST_LEN_LOW_NOISE;
+      hang_len = HANG_LEN_LOW_NOISE;
+   }
+
+   /*
+    * if the input power (pow_sum) is lower than a threshold, clear
+    * counters and set VAD_flag to "0"  "fast exit"
+    */
+   if ( low_power != 0 ) {
+      st->burst_count = 0;
+      st->hang_count = 0;
+      st->complex_hang_count = 0;
+      st->complex_hang_timer = 0;
+      return 0;
+   }
+
+   if ( st->complex_hang_timer > CVAD_HANG_LIMIT ) {
+      if ( st->complex_hang_count < CVAD_HANG_LENGTH ) {
+         st->complex_hang_count = CVAD_HANG_LENGTH;
+      }
+   }
+
+   /* long time very complex signal override VAD output function */
+   if ( st->complex_hang_count != 0 ) {
+      st->burst_count = BURST_LEN_HIGH_NOISE;
+      st->complex_hang_count -= 1;
+      return 1;
+   }
+   else {
+      /* let hp_corr work in from a noise_period indicated by the VAD */
+      if ( ( ( st->vadreg & 0x3ff0 ) == 0 ) && ( st->corr_hp_fast >
+            CVAD_THRESH_IN_NOISE ) ) {
+         return 1;
+      }
+   }
+
+   /* update the counters (hang_count, burst_count) */
+   if ( ( st->vadreg & 0x4000 ) != 0 ) {
+      st->burst_count += 1;
+
+      if ( st->burst_count >= burst_len ) {
+         st->hang_count = hang_len;
+      }
+      return 1;
+   }
+   else {
+      st->burst_count = 0;
+
+      if ( st->hang_count > 0 ) {
+         st->hang_count -= 1;
+         return 1;
+      }
+   }
+   return 0;
+}
+#endif
+
+/*
+ * vad_decision
+ *
+ *
+ * Parameters:
+ *    st                      B: State struct
+ *    level                   I: sub-band levels of the input frame
+ *    pow_sum                 I: power of the input frame
+ *    st->bckr_est            I: background noise components
+ *    st->vadreg              I: intermediate VAD flags
+ *    st->complex_warning     O: flags for complex detection
+ *    st->speech_vad_decision O: speech VAD flag
+ *
+ * Function:
+ *    Calculates VAD_flag
+ *
+ * Returns:
+ *    VAD_flag indicating final VAD decision
+ */
+#ifndef VAD2
+static Word16 vad_decision( vadState *st, Float32 level[COMPLEN], Float32
+      pow_sum )
+{
+   Float32 snr_sum, temp, vad_thr, noise_level;
+   Word32 i;
+   Word16 low_power_flag;
+
+
+   /*
+    * Calculate squared sum of the input levels (level)
+    * divided by the background noise components (bckr_est).
+    */
+   snr_sum = 0;
+
+   for ( i = 0; i < COMPLEN; i++ ) {
+      temp = level[i] / st->bckr_est[i];
+      snr_sum += temp * temp;
+   }
+   snr_sum = snr_sum * 56.8889F;
+
+   /* Calculate average level of estimated background noise */
+   noise_level = st->bckr_est[0] + st->bckr_est[1] + st->bckr_est[2] + st->
+         bckr_est[3] + st->bckr_est[4] + st->bckr_est[5] + st->bckr_est[6] + st
+         ->bckr_est[7] + st->bckr_est[8];
+   noise_level = noise_level * 0.111111F;
+
+   /* Calculate VAD threshold */
+   vad_thr = VAD_SLOPE * ( noise_level - VAD_P1 ) + VAD_THR_HIGH;
+
+   if ( vad_thr < VAD_THR_LOW ) {
+      vad_thr = VAD_THR_LOW;
+   }
+
+   /* Shift VAD decision register */
+   st->vadreg >>= 1;
+
+   /* Make intermediate VAD decision */
+   if ( snr_sum > vad_thr ) {
+      st->vadreg = st->vadreg | 0x4000;
+   }
+
+   /*
+    * primary vad decision made
+    * check if the input power (pow_sum) is lower than a threshold"
+    */
+   if ( pow_sum < VAD_POW_LOW ) {
+      low_power_flag = 1;
+   }
+   else {
+      low_power_flag = 0;
+   }
+
+   /*
+    * update complex signal estimate st->corr_hp_fast and hangover reset timer using
+    * low_power_flag and corr_hp_fast and various adaptation speeds
+    */
+   complex_estimate_adapt( st, low_power_flag );
+
+   /* check multiple thresholds of the st->corr_hp_fast value */
+   st->complex_warning = complex_vad( st, low_power_flag );
+
+   /* Update speech subband vad background noise estimates */
+   noise_estimate_update( st, level );
+
+   /*
+    *  Add speech and complex hangover and return speech VAD_flag
+    *  long term complex hangover may be added
+    */
+   st->speech_vad_decision = hangover_addition( st, noise_level, low_power_flag
+         );
+   return( st->speech_vad_decision );
+}
+#endif
+
+/*
+ * level_calculation
+ *
+ *
+ * Parameters:
+ *    data              I: signal buffer
+ *    sub_level         B: level calculate at the end of the previous frame/
+ *                         level of signal calculated from the last
+ *                         (count2 - count1) samples
+ *    count1            I: number of samples to be counted
+ *    count2            I: number of samples to be counted
+ *    ind_m             I: step size for the index of the data buffer
+ *    ind_a             I: starting index of the data buffer
+ *    scale             I: scaling for the level calculation
+ *
+ * Function:
+ *    Calculate signal level in a sub-band.
+ *
+ *    Level is calculated by summing absolute values of the input data.
+ *
+ * Returns:
+ *    signal level
+ */
+#ifndef VAD2
+static Float32 level_calculation( Float32 data[], Float32 *sub_level, Word16
+      count1, Word16 count2, Word16 ind_m, Word16 ind_a, Word16 scale )
+{
+   Float32 level, temp1;
+   Word32 i;
+
+
+   temp1 = 0;
+
+   for ( i = count1; i < count2; i++ ) {
+      temp1 += ( Float32 )fabs( data[ind_m * i + ind_a] );
+   }
+   level = temp1 + *sub_level;
+   *sub_level = temp1;
+
+   for ( i = 0; i < count1; i++ ) {
+      level += ( Float32 )fabs( data[ind_m * i + ind_a] );
+   }
+   return( scale * level );
+}
+#endif
+
+/*
+ * filter3
+ *
+ *
+ * Parameters:
+ *    in0               B: input values; output low-pass part
+ *    in1               B: input values; output high-pass part
+ *    data              B: updated filter memory
+ *
+ * Function:
+ *    Third-order half-band lowpass/highpass filter pair.
+ *
+ * Returns:
+ *   void
+ */
+#ifndef VAD2
+static void filter3( Float32 *in0, Float32 *in1, Float32 *data )
+{
+   Float32 temp1, temp2;
+
+
+   temp1 = *in1 - ( COEFF3 * *data );
+   temp2 = *data + ( COEFF3 * temp1 );
+   *data = temp1;
+   *in1 = ( *in0 - temp2 ) * 0.5F;
+   *in0 = ( *in0 + temp2 ) * 0.5F;
+}
+#endif
+
+/*
+ * filter5
+ *
+ *
+ * Parameters:
+ *    in0               B: input values; output low-pass part
+ *    in1               B: input values; output high-pass part
+ *    data              B: updated filter memory
+ *
+ * Function:
+ *    Fifth-order half-band lowpass/highpass filter pair.
+ *
+ * Returns:
+ *   void
+ */
+#ifndef VAD2
+static void filter5( Float32 *in0, Float32 *in1, Float32 data[] )
+{
+   Float32 temp0, temp1, temp2;
+
+
+   temp0 = *in0 - ( COEFF5_1 * data[0] );
+   temp1 = data[0] + ( COEFF5_1 * temp0 );
+   data[0] = temp0;
+   temp0 = *in1 - ( COEFF5_2 * data[1] );
+   temp2 = data[1] + ( COEFF5_2 * temp0 );
+   data[1] = temp0;
+   *in0 = ( temp1 + temp2 ) * 0.5F;
+   *in1 = ( temp1 - temp2 ) * 0.5F;
+}
+#endif
+
+/*
+ * first_filter_stage
+ *
+ *
+ * Parameters:
+ *    in                I: input signal
+ *    out               O: output values,
+ *                         every other output is low-pass part and
+ *                         every other output is high-pass part
+ *    data              B: updated filter memory
+ *
+ * Function:
+ *    Calculate 5th order half-band lowpass/highpass filter pair
+ *
+ * Returns:
+ *   void
+ */
+#ifndef VAD2
+static void first_filter_stage( Float32 in[], Float32 out[], Float32 data[] )
+{
+   Float32 temp0, temp1, temp2, temp3;
+   Float32 data0, data1;
+   Word32 i;
+
+
+   data0 = data[0];
+   data1 = data[1];
+
+   for ( i = 0; i < L_SUBFR; i++ ) {
+      temp0 = ( in[4 * i + 0] * 0.25F ) - ( COEFF5_1 * data0 );
+      temp1 = data0 + ( COEFF5_1 * temp0 );
+      temp3 = ( in[4*i+1]*0.25F )-( COEFF5_2 * data1 );
+      temp2 = data1 + ( COEFF5_2 * temp3 );
+      out[4 * i + 0] = temp1 + temp2;
+      out[4 * i + 1] = temp1 - temp2;
+      data0 = ( in[4 * i + 2] * 0.25F ) - ( COEFF5_1 * temp0 );
+      temp1 = temp0 + ( COEFF5_1 * data0 );
+      data1 = ( in[4 * i + 3] * 0.25F ) - ( COEFF5_2 * temp3 );
+      temp2 = temp3 + ( COEFF5_2 * data1 );
+      out[4 * i + 2] = temp1 + temp2;
+      out[4 * i + 3] = temp1 - temp2;
+   }
+   data[0] = data0;
+   data[1] = data1;
+}
+#endif
+
+/*
+ * filter_bank
+ *
+ *
+ * Parameters:
+ *    in                I: input frame
+ *    st->a_data5       B: filter memory
+ *    st->a_data3       B: filter memory
+ *    st->sub_level     B: level memory
+ *    level             O: signal levels at each band
+ *
+ * Function:
+ *    Divides input signal into 9-bands and calcultes level of the signal in each band
+ *
+ * Returns:
+ *    void
+ */
+#ifndef VAD2
+static void filter_bank( vadState *st, Float32 in[], Float32 level[] )
+{
+   Word32 i;
+   Float32 tmp_buf[FRAME_LEN];
+
+
+   /* calculate the filter bank */
+   first_filter_stage( in, tmp_buf, st->a_data5[0] );
+
+   for ( i = 0; i < FRAME_LEN / 4; i++ ) {
+      filter5( &tmp_buf[4 * i], &tmp_buf[4 * i + 2], st->a_data5[1] );
+      filter5( &tmp_buf[4 * i +1], &tmp_buf[4 * i + 3], st->a_data5[2] );
+   }
+
+   for ( i = 0; i < FRAME_LEN / 8; i++ ) {
+      filter3( &tmp_buf[8 * i + 0], &tmp_buf[8 * i + 4], &st->a_data3[0] );
+      filter3( &tmp_buf[8 * i + 2], &tmp_buf[8 * i + 6], &st->a_data3[1] );
+      filter3( &tmp_buf[8 * i + 3], &tmp_buf[8 * i + 7], &st->a_data3[4] );
+   }
+
+   for ( i = 0; i < FRAME_LEN / 16; i++ ) {
+      filter3( &tmp_buf[16 * i + 0], &tmp_buf[16 * i + 8], &st->a_data3[2] );
+      filter3( &tmp_buf[16 * i + 4], &tmp_buf[16 * i + 12], &st->a_data3[3] );
+   }
+
+   /* calculate levels in each frequency band */
+   /* 3000 - 4000 Hz*/
+   level[8] = level_calculation( tmp_buf, &st->sub_level[8], FRAME_LEN /4 - 8,
+         FRAME_LEN /4, 4, 1, 1 );
+
+   /* 2500 - 3000 Hz*/
+   level[7] = level_calculation( tmp_buf, &st->sub_level[7], FRAME_LEN /8 - 4,
+         FRAME_LEN /8, 8, 7, 2 );
+
+   /* 2000 - 2500 Hz*/
+   level[6] = level_calculation( tmp_buf, &st->sub_level[6], FRAME_LEN /8 - 4,
+         FRAME_LEN /8, 8, 3, 2 );
+
+   /* 1500 - 2000 Hz*/
+   level[5] = level_calculation( tmp_buf, &st->sub_level[5], FRAME_LEN /8 - 4,
+         FRAME_LEN /8, 8, 2, 2 );
+
+   /* 1000 - 1500 Hz*/
+   level[4] = level_calculation( tmp_buf, &st->sub_level[4], FRAME_LEN /8 - 4,
+         FRAME_LEN /8, 8, 6, 2 );
+
+   /* 750 - 1000 Hz*/
+   level[3] = level_calculation( tmp_buf, &st->sub_level[3], FRAME_LEN /16 - 2,
+         FRAME_LEN /16, 16, 4, 2 );
+
+   /* 500 - 750 Hz*/
+   level[2] = level_calculation( tmp_buf, &st->sub_level[2], FRAME_LEN /16 - 2,
+         FRAME_LEN /16, 16, 12, 2 );
+
+   /* 250 - 500 Hz*/
+   level[1] = level_calculation( tmp_buf, &st->sub_level[1], FRAME_LEN /16 - 2,
+         FRAME_LEN /16, 16, 8, 2 );
+
+   /* 0 - 250 Hz*/
+   level[0] = level_calculation( tmp_buf, &st->sub_level[0], FRAME_LEN /16 - 2,
+         FRAME_LEN /16, 16, 0, 2 );
+}
+#endif
+
+/*
+ * vad
+ *
+ *
+ * Parameters:
+ *    in_buf            I: samples of the input frame
+ *    st                B: State struct
+ *    st->pitch         B: flags for pitch detection
+ *    st->complex_low   B: complex flag
+ *
+ * Function:
+ *    Voice Activity Detection (VAD)
+ *
+ * Returns:
+ *    VAD Decision, 1 = speech, 0 = noise
+ */
+#ifndef VAD2
+static Word16 vad( vadState *st, Float32 in_buf[] )
+{
+   Float32 level[COMPLEN];
+   Float32 pow_sum;
+   Word32 i;
+
+
+   /* Calculate power of the input frame. */
+   pow_sum = 0L;
+
+   for ( i = -40; i < 120; i += 8 ) {
+      pow_sum += in_buf[i] * in_buf[i];
+      pow_sum += in_buf[i + 1] *in_buf[i + 1];
+      pow_sum += in_buf[i + 2] * in_buf[i + 2];
+      pow_sum += in_buf[i + 3] * in_buf[i + 3];
+      pow_sum += in_buf[i + 4] * in_buf[i + 4];
+      pow_sum += in_buf[i + 5] * in_buf[i + 5];
+      pow_sum += in_buf[i + 6] * in_buf[i + 6];
+      pow_sum += in_buf[i + 7] * in_buf[i + 7];
+   }
+
+   /*
+    * If input power is very low, clear pitch flag of the current frame
+    */
+   if ( pow_sum < POW_PITCH_THR ) {
+      st->pitch = ( Word16 )( st->pitch & 0x3fff );
+   }
+
+   /*
+    * If input power is very low, clear complex flag of the "current" frame
+    */
+   if ( pow_sum < POW_COMPLEX_THR ) {
+      st->complex_low = ( Word16 )( st->complex_low & 0x3fff );
+   }
+
+   /*
+    * Run the filter bank which calculates signal levels at each band
+    */
+   filter_bank( st, in_buf, level );
+   return( vad_decision( st, level, pow_sum ) );
+}
+#endif
+
+/*
+ * vad_pitch_detection
+ *
+ *
+ * Parameters:
+ *    st->oldlag        B: old LTP lag
+ *    T_op              I: speech encoder open loop lags
+ *    st->pitch         B: flags for pitch detection
+ *    st                B: State struct
+ *    st->pitch         B: flags for pitch detection
+ *    st->oldlag_count  B: lag count
+ *
+ * Function:
+ *    Test if signal contains pitch or other periodic component.
+ *
+ * Returns:
+ *    Boolean voiced / unvoiced decision in state variable
+ */
+#ifndef VAD2
+static void vad_pitch_detection( vadState *st, Word32 T_op[] )
+{
+   Word32 lagcount, i;
+
+
+   lagcount = 0;
+
+   for ( i = 0; i < 2; i++ ) {
+      if ( abs( st->oldlag - T_op[i] ) < LTHRESH ) {
+         lagcount += 1;
+      }
+
+      /* Save the current LTP lag */
+      st->oldlag = T_op[i];
+   }
+
+   /*
+    * Make pitch decision.
+    * Save flag of the pitch detection to the variable pitch.
+    */
+   st->pitch = st->pitch >> 1;
+
+   if ( ( st->oldlag_count + lagcount ) >= NTHRESH ) {
+      st->pitch = st->pitch | 0x4000;
+   }
+
+   /* Update oldlagcount */
+   st->oldlag_count = lagcount;
+}
+#endif
+
+
+#ifdef VAD2
+
+/***************************************************************************
+ *
+ *   FUNCTION NAME: vad2()
+ *
+ *   PURPOSE:
+ *     This function provides the Voice Activity Detection function option 2
+ *     for the Adaptive Multi-rate (AMR) codec.
+ *
+ *   INPUTS:
+ *
+ *     vadState
+ *                     pointer to vadState state structure
+ *     farray_ptr
+ *                     pointer to Float32[80] input array
+ *
+ *   OUTPUTS:
+ *
+ *     state variables in vadState are updated
+ *
+ *   RETURN VALUE:
+ *
+ *     Word16
+ *                     VAD(m) - two successive calls to vad2() yield
+ *                     the VAD decision for the 20 ms frame:
+ *                     VAD_flag = VAD(m-1) || VAD(m)
+ *
+ *
+ *************************************************************************/
+
+int		vad2 (vadState *st, Float32 *farray_ptr)
+{
+
+  /* Static variables */
+
+  /* The channel table is defined below.  In this table, the
+     lower and higher frequency coefficients for each of the 16
+     channels are specified.  The table excludes the coefficients
+     with numbers 0 (DC), 1, and 64 (Foldover frequency).  For
+     these coefficients, the gain is always set at 1.0 (0 dB). */
+
+  static int	ch_tbl [NUM_CHAN][2] = {
+
+    { 2,  3},
+    { 4,  5},
+    { 6,  7},
+    { 8,  9},
+    {10, 11},
+    {12, 13},
+    {14, 16},
+    {17, 19},
+    {20, 22},
+    {23, 26},
+    {27, 30},
+    {31, 35},
+    {36, 41},
+    {42, 48},
+    {49, 55},
+    {56, 63}
+
+  };
+
+  /* The voice metric table is defined below.  It is a non-
+     linear table with a deadband near zero.  It maps the SNR
+     index (quantized SNR value) to a number that is a measure
+     of voice quality. */
+
+  static int	vm_tbl [90] = {
+    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+    3, 3, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 7, 7, 7,
+    8, 8, 9, 9, 10, 10, 11, 12, 12, 13, 13, 14, 15,
+    15, 16, 17, 17, 18, 19, 20, 20, 21, 22, 23, 24,
+    24, 25, 26, 27, 28, 28, 29, 30, 31, 32, 33, 34,
+    35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45,
+    46, 47, 48, 49, 50, 50, 50, 50, 50, 50, 50, 50,
+    50, 50
+  };
+
+  /* hangover as a function of peak SNR (3 dB steps) */
+  static Word16 hangover_table[20] =
+  {
+    30, 30, 30, 30, 30, 30, 28, 26, 24, 22, 20, 18, 16, 14, 12, 10, 8, 8, 8, 8
+  };
+
+  /* burst sensitivity as a function of peak SNR (3 dB steps) */
+  static Word16 burstcount_table[20] =
+  {
+    8, 8, 8, 8, 8, 8, 8, 8, 7, 6, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4
+  };
+
+  /* voice metric sensitivity as a function of peak SNR (3 dB steps) */
+  static Word16 vm_threshold_table[20] =
+  {
+    34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 40, 51, 71, 100, 139, 191, 257, 337, 432
+  };
+
+
+  /* Automatic variables */
+
+  float		data_buffer [FFT_LEN1], enrg, snr;
+  float		tne, tce, ftmp;
+  int		ch_snr [NUM_CHAN];
+  int		i, j, j1, j2;
+  int		vm_sum;
+  int		update_flag;
+
+  float		ch_enrg_dev;		/* for forced update... */
+  float		ch_enrg_db [NUM_CHAN];
+  float		alpha;
+
+
+  /* For detecting sine waves */
+  float		peak, avg, peak2avg;
+  int		sine_wave_flag;
+
+  /* For computing frame SNR and long-term SNR */
+  float		tce_db, tne_db;
+  float		xt;
+
+  /* More VAD stuff */
+  int	tsnrq;
+  int	ivad;
+
+
+  /* Functions */
+
+  void real_fft (float *, int);
+
+
+  /****** Executable code starts here ******/
+
+  /* Increment frame counter */
+  st->Lframe_cnt++;
+
+  /* Preemphasize the input data and store in the data buffer with
+     appropriate delay */
+
+  for (i = 0; i < DELAY0; i++)
+    data_buffer [i] = 0.0;
+
+  data_buffer [DELAY0] = *farray_ptr + PRE_EMP_FAC1 * st->pre_emp_mem;
+
+  for (i = DELAY0+1, j = 1; i < DELAY0+FRM_LEN1; i++, j++)
+    data_buffer [i] = *(farray_ptr + j) + PRE_EMP_FAC1 *
+      *(farray_ptr + j - 1);
+
+  st->pre_emp_mem = *(farray_ptr + FRM_LEN1 - 1);
+
+  for (i = DELAY0+FRM_LEN1; i < FFT_LEN1; i++)
+    data_buffer [i] = 0.0;
+
+  /* Perform FFT on the data buffer */
+  real_fft (data_buffer, +1);
+
+  /* Estimate the energy in each channel */
+  alpha = (st->Lframe_cnt == 1) ? 1.0 : CEE_SM_FAC1;
+  for (i = LO_CHAN; i <= HI_CHAN; i++)
+    {
+      enrg = 0.0;
+      j1 = ch_tbl [i][0], j2 = ch_tbl [i][1];
+      for (j = j1; j <= j2; j++)
+	enrg += square(data_buffer [2*j]) + square(data_buffer [2*j+1]);
+      enrg /= (float) (j2 - j1 + 1);
+      st->ch_enrg [i] = (1 - alpha) * st->ch_enrg [i] + alpha * enrg;
+      if (st->ch_enrg [i] < MIN_CHAN_ENRG) st->ch_enrg [i] = MIN_CHAN_ENRG;
+    }
+
+  /* Compute the total channel energy estimate (tce) */
+  tce = 0.0;
+  for (i = LO_CHAN; i <= HI_CHAN; i++)
+    tce += st->ch_enrg [i];
+
+  /* Calculate spectral peak-to-average ratio */
+  peak = avg = 0.;
+  for (i = LO_CHAN; i <= HI_CHAN; i++) {
+    /* Sine waves not valid for low frequencies: */
+    if (i >= SINE_START_CHAN && st->ch_enrg [i] > peak)
+      peak = st->ch_enrg [i];
+    avg += st->ch_enrg [i];
+  }
+  avg /= HI_CHAN - LO_CHAN + 1;
+  peak2avg = (avg < 1./NORM_ENRG) ? 0. : 10.*log10 (peak/avg);
+
+  /* Detect sine waves */
+  if (peak2avg > 10.)
+    sine_wave_flag = TRUE;
+  else
+    sine_wave_flag = FALSE;
+
+  /* Initialize channel noise estimate to channel energy of first few frames
+     (if sufficiently low Peak-to-Average ratio) */
+  if (st->Lframe_cnt <= INIT_FRAMES) {
+    if (sine_wave_flag == TRUE) {
+      for (i = LO_CHAN; i <= HI_CHAN; i++)
+        st->ch_noise [i] = INE;
+    }
+    else {
+      for (i = LO_CHAN; i <= HI_CHAN; i++)
+        st->ch_noise [i] = max(st->ch_enrg [i], INE);
+    }
+  }
+
+  /* Compute the channel SNR indices */
+  for (i = LO_CHAN; i <= HI_CHAN; i++) {
+    snr = 10.0 * log10 ((double)st->ch_enrg [i] / st->ch_noise [i]);
+    if (snr < 0.0) snr = 0.0;
+    ch_snr [i] = (snr + 0.1875) / 0.375;
+  }
+
+  /* Compute the sum of voice metrics */
+  vm_sum = 0;
+  for (i = LO_CHAN; i <= HI_CHAN; i++) {
+    j = min(ch_snr[i],89);
+    vm_sum += vm_tbl [j];
+  }
+
+  /* Initialize voice energy to nominal value */
+  if (st->Lframe_cnt <= INIT_FRAMES  || st->fupdate_flag == TRUE ) {
+#if NORM_ENERG==4
+    tce_db = 49.918;
+#elif NORM_ENERG==1
+    tce_db = 55.938;
+#else
+    tce_db = (96. - 22. - 10*log10 (FFT_LEN1/2) - 10.*log10 (NORM_ENRG));
+#endif
+
+    st->negSNRvar = 0.0;
+    st->negSNRbias = 0.0;
+
+    /* Compute the total noise energy estimate (tne) */
+    tne = 0.0;
+    for (i = LO_CHAN; i <= HI_CHAN; i++)
+      tne += st->ch_noise [i];
+
+    /* Get total noise in dB */
+    tne_db = 10 * log10 (tne);
+
+    /* Initialise instantaneous and long-term peak signal-to-noise ratios */
+    xt = tce_db - tne_db;
+    st->tsnr = xt;
+
+  }
+  else {
+
+    /* Calculate instantaneous signal-to-noise ratio */
+    xt = 0;
+    for (i=LO_CHAN; i<=HI_CHAN; i++)
+      xt += st->ch_enrg[i]/st->ch_noise[i];
+    xt = 10*log10(xt/NUM_CHAN);
+
+    /* Estimate long-term "peak" SNR */
+    if (xt > st->tsnr)
+      st->tsnr = 0.9*st->tsnr + 0.1*xt;
+    else if (xt > 0.625*st->tsnr)
+      st->tsnr = 0.998*st->tsnr + 0.002*xt;
+  }
+
+  /* Quantize the long-term SNR in 3 dB steps */
+  tsnrq = (int)(st->tsnr/3.);
+  tsnrq = min(19, max(0, tsnrq));
+
+  /* Calculate the negative SNR sensitivity bias */
+  if (xt < 0) {
+    st->negSNRvar = min (0.99*st->negSNRvar + 0.01*xt*xt, 4.0);
+    st->negSNRbias = max (12.0*(st->negSNRvar - 0.65), 0.0);
+  }
+
+  /* Determine VAD as a function of the voice metric sum and quantized SNR */
+  if (vm_sum > vm_threshold_table[tsnrq] + st->negSNRbias) {
+    ivad = 1;
+    if (++st->burstcount > burstcount_table[tsnrq]) {
+      st->hangover = hangover_table[tsnrq];
+    }
+  } else {
+    st->burstcount = 0;
+    if (--st->hangover <= 0) {
+      ivad = 0;
+      st->hangover = 0;
+    } else {
+      ivad = 1;
+    }
+  }
+
+  /* Calculate log spectral deviation */
+  for (i = LO_CHAN; i <= HI_CHAN; i++)
+    ch_enrg_db [i] = 10.*log10( st->ch_enrg [i] );
+
+  ch_enrg_dev = 0.;
+  if (st->Lframe_cnt == 1)
+    for (i = LO_CHAN; i <= HI_CHAN; i++)
+      st->ch_enrg_long_db [i] = ch_enrg_db [i];
+  else
+    for (i = LO_CHAN; i <= HI_CHAN; i++)
+      ch_enrg_dev += fabs( st->ch_enrg_long_db [i] - ch_enrg_db [i] );
+
+
+  /*
+   * Calculate long term integration constant as a function of instantaneous SNR
+   * (i.e., high SNR (tsnr dB) -> slower integration (alpha = HIGH_ALPHA),
+   *         low SNR (0 dB) -> faster integration (alpha = LOW_ALPHA)
+   */
+
+  /* alpha = HIGH_ALPHA - ALPHA_RANGE * (tsnr - xt) / tsnr, low <= alpha <= high */
+  ftmp = st->tsnr - xt;
+  if (ftmp <= 0.0 || st->tsnr <= 0.0)
+    alpha = HIGH_ALPHA1;
+  else if (ftmp > st->tsnr)
+    alpha = LOW_ALPHA1;
+  else
+    alpha = HIGH_ALPHA1 - (ALPHA_RANGE1 * ftmp / st->tsnr);
+
+  /* Calc long term log spectral energy */
+  for (i = LO_CHAN; i <= HI_CHAN; i++) {
+    st->ch_enrg_long_db[i] = alpha*st->ch_enrg_long_db[i] + (1.-alpha)*ch_enrg_db[i];
+  }
+
+  /* Set or reset the update flag */
+  update_flag = FALSE;
+  st->fupdate_flag = FALSE;
+  if ((vm_sum <= UPDATE_THLD) ||
+      (st->Lframe_cnt <= INIT_FRAMES && sine_wave_flag == FALSE)) {
+    update_flag = TRUE;
+    st->update_cnt = 0;
+  }
+  else if (tce > NOISE_FLOOR && ch_enrg_dev < DEV_THLD1 &&
+           sine_wave_flag == FALSE && st->LTP_flag == FALSE) {
+    st->update_cnt++;
+    if (st->update_cnt >= UPDATE_CNT_THLD1) {
+      update_flag = TRUE;
+      st->fupdate_flag = TRUE;
+    }
+  }
+
+  if ( st->update_cnt == st->last_update_cnt )
+    st->hyster_cnt++;
+  else
+    st->hyster_cnt = 0;
+  st->last_update_cnt = st->update_cnt;
+
+  if ( st->hyster_cnt > HYSTER_CNT_THLD1 )
+    st->update_cnt = 0;
+
+  /* Update the channel noise estimates */
+  if (update_flag == TRUE) {
+    for (i = LO_CHAN; i <= HI_CHAN; i++) {
+      st->ch_noise [i] = (1.0 - CNE_SM_FAC1) * st->ch_noise [i] +
+	CNE_SM_FAC1 * st->ch_enrg [i];
+      if (st->ch_noise [i] < MIN_CHAN_ENRG) st->ch_noise [i] = MIN_CHAN_ENRG;
+    }
+  }
+
+  return (ivad);
+
+}		/* end vad2 () */
+
+
+/**************************************************************************
+ *
+ *   FUNCTION NAME: real_fft()
+ *
+ *   PURPOSE: FFT/IFFT function for real sequences
+ *
+ **************************************************************************
+ *
+ * This is an implementation of decimation-in-time FFT algorithm for
+ * real sequences.  The techniques used here can be found in several
+ * books, e.g., i) Proakis and Manolakis, "Digital Signal Processing",
+ * 2nd Edition, Chapter 9, and ii) W.H. Press et. al., "Numerical
+ * Recipes in C", 2nd Ediiton, Chapter 12.
+ *
+ * Input -  There is two inputs to this function:
+ *
+ *	1) A float pointer to the input data array,
+ *	2) A control parameter (isign) specifying forward (+1) or
+ *         inverse (-1) FFT.
+ *
+ * Output - There is no return value.
+ *	The input data are replaced with transformed data.  If the
+ *	input is a real time domain sequence, it is replaced with
+ *	the complex FFT for positive frequencies.  The FFT value
+ *	for DC and the foldover frequency are combined to form the
+ *	first complex number in the array.  The remaining complex
+ *	numbers correspond to increasing frequencies.  If the input
+ *	is a complex frequency domain sequence arranged	as above,
+ *	it is replaced with the corresponding time domain sequence.
+ *
+ * Notes:
+ *
+ *	1) This function is designed to be a part of a VAD
+ *	   algorithm that requires 128-point FFT of real
+ *	   sequences.  This is achieved here through a 64-point
+ *	   complex FFT.  Consequently, the FFT size information is
+ *	   not transmitted explicitly.  However, some flexibility
+ *	   is provided in the function to change the size of the
+ *	   FFT by specifying the size information through "define"
+ *	   statements.
+ *
+ *	2) The values of the complex sinusoids used in the FFT
+ *	   algorithm are stored in a ROM table.
+ *
+ *	3) In the c_fft function, the FFT values are divided by
+ *	   2 after each stage of computation thus dividing the
+ *	   final FFT values by 64.  This is somewhat different
+ *         from the usual definition of FFT where the factor 1/N,
+ *         i.e., 1/64, used for the IFFT and not the FFT.  No factor
+ *         is used in the r_fft function.
+ *
+ *************************************************************************/
+
+static double	phs_tbl [SIZE];		/* holds the complex sinusoids */
+
+void		real_fft (float *farray_ptr, int isign)
+{
+
+  float		ftmp1_real, ftmp1_imag, ftmp2_real, ftmp2_imag;
+  int		i, j;
+  static int	first = TRUE;
+
+  void		cmplx_fft (float *, int);
+  void		fill_tbl ();
+
+  /* If this is the first call to the function, fill up the
+     phase table  */
+  if (first == TRUE) {
+    fill_tbl ();
+    first = FALSE;
+  }
+
+  /* The FFT part */
+  if (isign == 1) {
+
+    /* Perform the complex FFT */
+    cmplx_fft (farray_ptr, isign);
+
+    /* First, handle the DC and foldover frequencies */
+    ftmp1_real = *farray_ptr;
+    ftmp2_real = *(farray_ptr + 1);
+    *farray_ptr = ftmp1_real + ftmp2_real;
+    *(farray_ptr + 1) = ftmp1_real - ftmp2_real;
+
+    /* Now, handle the remaining positive frequencies */
+    for (i = 2, j = SIZE - i; i <= SIZE_BY_TWO; i = i + 2, j = SIZE - i) {
+
+      ftmp1_real = *(farray_ptr + i) + *(farray_ptr + j);
+      ftmp1_imag = *(farray_ptr + i + 1) - *(farray_ptr + j + 1);
+      ftmp2_real = *(farray_ptr + i + 1) + *(farray_ptr + j + 1);
+      ftmp2_imag = *(farray_ptr + j) - *(farray_ptr + i);
+
+      *(farray_ptr + i) = (ftmp1_real + phs_tbl [i] * ftmp2_real -
+			   phs_tbl [i + 1] * ftmp2_imag) / 2.0;
+      *(farray_ptr + i + 1) = (ftmp1_imag + phs_tbl [i] * ftmp2_imag +
+			       phs_tbl [i + 1] * ftmp2_real) / 2.0;
+      *(farray_ptr + j) = (ftmp1_real + phs_tbl [j] * ftmp2_real +
+			   phs_tbl [j + 1] * ftmp2_imag) / 2.0;
+      *(farray_ptr + j + 1) = (-ftmp1_imag - phs_tbl [j] * ftmp2_imag +
+			       phs_tbl [j + 1] * ftmp2_real) / 2.0;
+    }
+  }
+
+  /* The IFFT part */
+  else {
+
+    /* First, handle the DC and foldover frequencies */
+
+    ftmp1_real = *farray_ptr;
+    ftmp2_real = *(farray_ptr + 1);
+    *farray_ptr = (ftmp1_real + ftmp2_real) / 2.0;
+    *(farray_ptr + 1) = (ftmp1_real - ftmp2_real) / 2.0;
+
+    /* Now, handle the remaining positive frequencies */
+
+    for (i = 2, j = SIZE - i; i <= SIZE_BY_TWO; i = i + 2, j = SIZE - i) {
+
+      ftmp1_real = *(farray_ptr + i) + *(farray_ptr + j);
+      ftmp1_imag = *(farray_ptr + i + 1) - *(farray_ptr + j + 1);
+      ftmp2_real = -(*(farray_ptr + i + 1) + *(farray_ptr + j + 1));
+      ftmp2_imag = -(*(farray_ptr + j) - *(farray_ptr + i));
+
+      *(farray_ptr + i) = (ftmp1_real + phs_tbl [i] * ftmp2_real +
+			   phs_tbl [i + 1] * ftmp2_imag) / 2.0;
+      *(farray_ptr + i + 1) = (ftmp1_imag + phs_tbl [i] * ftmp2_imag -
+			       phs_tbl [i + 1] * ftmp2_real) / 2.0;
+      *(farray_ptr + j) = (ftmp1_real + phs_tbl [j] * ftmp2_real -
+			   phs_tbl [j + 1] * ftmp2_imag) / 2.0;
+      *(farray_ptr + j + 1) = (-ftmp1_imag - phs_tbl [j] * ftmp2_imag -
+			       phs_tbl [j + 1] * ftmp2_real) / 2.0;
+    }
+
+    /* Perform the complex IFFT */
+    cmplx_fft (farray_ptr, isign);
+  }
+
+  return;
+}		/* end real_fft () */
+
+
+
+/*
+ * FFT/IFFT function for complex sequences
+ *
+ * The decimation-in-time complex FFT/IFFT is implemented below.
+ * The input complex numbers are presented as real part followed by
+ * imaginary part for each sample.  The counters are therefore
+ * incremented by two to access the complex valued samples.
+ */
+void		cmplx_fft (float *farray_ptr, int isign)
+{
+  int		i, j, k, ii, jj, kk, ji, kj;
+  float		ftmp, ftmp_real, ftmp_imag;
+
+  /* Rearrange the input array in bit reversed order */
+  for (i = 0, j = 0; i < SIZE-2; i = i + 2) {
+    if (j > i) {
+      ftmp = *(farray_ptr+i);
+      *(farray_ptr+i) = *(farray_ptr+j);
+      *(farray_ptr+j) = ftmp;
+
+      ftmp = *(farray_ptr+i+1);
+      *(farray_ptr+i+1) = *(farray_ptr+j+1);
+      *(farray_ptr+j+1) = ftmp;
+    }
+    k = SIZE_BY_TWO;
+    while (j >= k) {
+      j -= k;
+      k >>= 1;
+    }
+    j += k;
+  }
+
+  /* The FFT part */
+  if (isign == 1) {
+    for (i = 0; i < NUM_STAGE; i++) {		/* i is stage counter */
+      jj = (2 << i);				/* FFT size */
+      kk = (jj << 1);				/* 2 * FFT size */
+      ii = SIZE / jj;				/* 2 * number of FFT's */
+      for (j = 0; j < jj; j = j + 2) {		/* j is sample counter */
+        ji = j * ii;				/* ji is phase table index */
+        for (k = j; k < SIZE; k = k + kk) {	/* k is butterfly top */
+          kj = k + jj;				/* kj is butterfly bottom */
+
+	  /* Butterfly computations */
+          ftmp_real = *(farray_ptr + kj) * phs_tbl [ji] -
+	    *(farray_ptr + kj + 1) * phs_tbl [ji + 1];
+
+          ftmp_imag = *(farray_ptr + kj + 1) * phs_tbl [ji] +
+	    *(farray_ptr + kj) * phs_tbl [ji + 1];
+
+          *(farray_ptr + kj) = (*(farray_ptr + k) - ftmp_real) / 2.0;
+          *(farray_ptr + kj + 1) = (*(farray_ptr + k + 1) - ftmp_imag) / 2.0;
+
+          *(farray_ptr + k) = (*(farray_ptr + k) + ftmp_real) / 2.0;
+          *(farray_ptr + k + 1) = (*(farray_ptr + k + 1) + ftmp_imag) / 2.0;
+        }
+      }
+    }
+  }
+
+  /* The IFFT part */
+  else {
+    for (i = 0; i < NUM_STAGE; i++) {		/* i is stage counter */
+      jj = (2 << i);				/* FFT size */
+      kk = (jj << 1);				/* 2 * FFT size */
+      ii = SIZE / jj;				/* 2 * number of FFT's */
+      for (j = 0; j < jj; j = j + 2) {		/* j is sample counter */
+        ji = j * ii;				/* ji is phase table index */
+        for (k = j; k < SIZE; k = k + kk) {	/* k is butterfly top */
+          kj = k + jj;				/* kj is butterfly bottom */
+
+	  /* Butterfly computations */
+          ftmp_real = *(farray_ptr + kj) * phs_tbl [ji] +
+	    *(farray_ptr + kj + 1) * phs_tbl [ji + 1];
+
+          ftmp_imag = *(farray_ptr + kj + 1) * phs_tbl [ji] -
+	    *(farray_ptr + kj) * phs_tbl [ji + 1];
+
+          *(farray_ptr + kj) = *(farray_ptr + k) - ftmp_real;
+          *(farray_ptr + kj + 1) = *(farray_ptr + k + 1) - ftmp_imag;
+
+          *(farray_ptr + k) = *(farray_ptr + k) + ftmp_real;
+          *(farray_ptr + k + 1) = *(farray_ptr + k + 1) + ftmp_imag;
+        }
+      }
+    }
+  }
+  return;
+}		/* end of cmplx_fft () */
+
+
+/* Function to fill the phase table values
+ */
+
+void		fill_tbl ()
+{
+  int		i;
+  double	delta_f, theta;
+
+  delta_f = - PI / (double) SIZE_BY_TWO;
+  for (i = 0; i < SIZE_BY_TWO; i++) {
+    theta = delta_f * (double) i;
+    phs_tbl[2*i] = cos(theta);
+    phs_tbl[2*i+1] = sin(theta);
+  }
+  return;
+}		/* end fill_tbl () */
+
+
+/***************************************************************************
+ *
+ *   FUNCTION NAME: LTP_flag_update
+ *
+ *   PURPOSE:
+ *     Set LTP_flag if the LTP gain > LTP_THRESHOLD, where the value of
+ *     LTP_THRESHOLD depends on the LTP analysis window length.
+ *
+ *   INPUTS:
+ *
+ *     mode
+ *                     AMR mode
+ *     vadState->R0
+ *                     LTP energy
+ *     vadState->Rmax
+ *                     LTP maximum autocorrelation
+ *   OUTPUTS:
+ *
+ *     vadState->LTP_flag
+ *                     Set if LTP gain > LTP_THRESHOLD
+ *
+ *   RETURN VALUE:
+ *
+ *     none
+ *
+ *************************************************************************/
+
+void LTP_flag_update (vadState * st, Word16 mode)
+{
+  Float32 thresh;
+
+  if ((mode == MR475) || (mode == MR515))
+    thresh = 0.55;
+  else if (mode == MR102)
+    thresh = 0.60;
+  else
+    thresh = 0.65;
+
+  if (st->Rmax  > thresh*st->R0)
+    st->LTP_flag = TRUE;
+  else
+    st->LTP_flag = FALSE;
+
+  return;
+}
+
+/***************************************************************************/
+#endif
+
+/*
+ * cod_amr
+ *
+ *
+ * Parameters:
+ *    st          B: state structure
+ *    mode        I: encoder mode
+ *    new_speech  I: input speech frame, size L_FRAME
+ *    st          B: State struct
+ *    ana         O: Analysis parameters
+ *    used_mode   B: In: -1 forces VAD on, Out:used encoder mode
+ *    synth       O: local synthesis, size L_FRAME
+ *
+ * Function:
+ *    GSM adaptive multi rate speech encoder
+ *
+ * Returns:
+ *    void
+ */
+static void cod_amr( cod_amrState *st, enum Mode mode, Float32 new_speech[],
+      Word16 ana[], enum Mode *used_mode, Float32 synth[] )
+{
+   /* LPC coefficients */
+   Float32 A_t[( MP1 ) * 4];   /* A(z) unquantized for the 4 subframes */
+   Float32 Aq_t[( MP1 ) * 4];   /* A(z)   quantized for the 4 subframes */
+   Float32 *A, *Aq;   /* Pointer on Aq_t */
+   Float32 lsp_new[M];
+
+
+   /* Other vectors */
+   Float32 xn[L_SUBFR];   /* Target vector for pitch search */
+   Float32 xn2[L_SUBFR];   /* Target vector for codebook search */
+   Float32 code[L_SUBFR];   /* Fixed codebook excitation */
+   Float32 y1[L_SUBFR];   /* Filtered adaptive excitation */
+   Float32 y2[L_SUBFR];   /* Filtered fixed codebook excitation */
+   Float32 gCoeff[3];   /* Correlations between xn, y1, & y2: */
+   Float32 res[L_SUBFR];   /* Short term (LPC) prediction residual */
+   Float32 res2[L_SUBFR];   /* Long term (LTP) prediction residual */
+
+
+   /* Vector and scalars needed for the MR475 */
+   Float32 xn_sf0[L_SUBFR];   /* Target vector for pitch search */
+   Float32 y2_sf0[L_SUBFR];   /* Filtered codebook innovation */
+   Float32 code_sf0[L_SUBFR];   /* Fixed codebook excitation */
+   Float32 h1_sf0[L_SUBFR];   /* The impulse response of sf0 */
+   Float32 mem_syn_save[M];   /* Filter memory */
+   Float32 mem_w0_save[M];   /* Filter memory */
+   Float32 mem_err_save[M];   /* Filter memory */
+   Float32 sharp_save = 0;   /* Sharpening */
+   Float32 gain_pit_sf0;   /* Quantized pitch gain for sf0 */
+   Float32 gain_code_sf0;   /* Quantized codebook gain for sf0 */
+   Word16 i_subfr_sf0 = 0;   /* Position in exc[] for sf0 */
+
+
+   /* Scalars & Flags */
+   Float32 gain_pit, gain_code;
+   Float32 gp_limit;   /* pitch gain limit value */
+   Word32 T0_sf0 = 0;   /* Integer pitch lag of sf0 */
+   Word32 T0_frac_sf0 = 0;   /* Fractional pitch lag of sf0 */
+   Word32 T0, T0_frac;
+   Word32 T_op[2];
+   Word32 evenSubfr;
+   Word32 i;
+   Word16 i_subfr, subfrNr;
+   Word16 lsp_flag = 0;   /* indicates resonance in LPC filter */
+   Word16 compute_sid_flag;
+   Word16 vad_flag;
+
+
+   memcpy( st->new_speech, new_speech, L_FRAME <<2 );
+
+   if ( st->dtx ) {
+#ifdef VAD2
+     /* Find VAD decision (option 2) */
+     vad_flag = vad2 (st->vadSt, st->new_speech);
+     vad_flag = vad2 (st->vadSt, st->new_speech+80) || vad_flag;
+#else
+      /* Find VAD decision (option 1) */
+      vad_flag = vad( st->vadSt, st->new_speech );
+#endif
+      /* force VAD on   */
+      if ( *used_mode < 0 )
+         vad_flag = 1;
+      *used_mode = mode;
+
+      /* NB! used_mode may change here */
+      compute_sid_flag = tx_dtx_handler( vad_flag, &st->dtxEncSt->
+            decAnaElapsedCount, &st->dtxEncSt->dtxHangoverCount, used_mode );
+   }
+   else {
+      compute_sid_flag = 0;
+      *used_mode = mode;
+   }
+
+   /*
+    * Perform LPC analysis:
+    * Autocorrelation + Lag windowing.
+    * Levinson-durbin algorithm to find a[].
+    * Convert a[] to lsp[].
+    * Quantize and code the LSPs.
+    * find the interpolated LSPs and convert to a[] for all
+    * subframes (both quantized and unquantized).
+    */
+   /* LP analysis */
+   lpc( st->lpcSt->LevinsonSt->old_A, st->p_window, st->p_window_12k2, A_t, mode
+         );
+
+   /*
+    * The LP filter coefficients, are converted to
+    * the line spectral pair (LSP) representation for
+    * quantization and interpolation purposes.
+    */
+   lsp( mode, *used_mode, st->lspSt->lsp_old, st->lspSt->lsp_old_q, st->lspSt->
+         qSt->past_rq, A_t, Aq_t, lsp_new, &ana );
+
+   /* Buffer lsp's and energy */
+   dtx_buffer( &st->dtxEncSt->hist_ptr, st->dtxEncSt->lsp_hist, lsp_new, st->
+         new_speech, st->dtxEncSt->log_en_hist );
+
+   if ( *used_mode == MRDTX ) {
+      dtx_enc( &st->dtxEncSt->log_en_index, st->dtxEncSt->log_en_hist, st->
+            dtxEncSt->lsp_hist, st->dtxEncSt->lsp_index, &st->dtxEncSt->
+            init_lsf_vq_index, compute_sid_flag, &st->lspSt->qSt->past_rq[0], st
+            ->gainQuantSt->gc_predSt->past_qua_en, &ana );
+      memset( st->old_exc, 0, ( PIT_MAX + L_INTERPOL )<<2 );
+      memset( st->mem_w0, 0, M <<2 );
+      memset( st->mem_err, 0, M <<2 );
+      memset( st->zero, 0, L_SUBFR <<2 );
+      memset( st->hvec, 0, L_SUBFR <<2 );
+      memset( st->lspSt->qSt->past_rq, 0, M <<2 );
+      memcpy( st->lspSt->lsp_old, lsp_new, M <<2 );
+      memcpy( st->lspSt->lsp_old_q, lsp_new, M <<2 );
+
+      /* Reset clLtp states */
+      st->clLtpSt->pitchSt->T0_prev_subframe = 0;
+      st->sharp = 0;
+   }
+   else {
+      /* check resonance in the filter */
+      lsp_flag = check_lsp( &st->tonStabSt->count, st->lspSt->lsp_old );
+   }
+
+#ifdef VAD2
+   if (st->dtx) {
+      st->vadSt->Rmax = 0.0;
+      st->vadSt->R0 = 0.0;
+   }
+#endif
+
+   for ( subfrNr = 0, i_subfr = 0; subfrNr < 2; subfrNr++, i_subfr +=
+         L_FRAME_BY2 ) {
+      /*
+       * Pre-processing on 80 samples
+       * Find the weighted input speech for the whole speech frame
+       */
+      pre_big( mode, gamma1, gamma1_12k2, gamma2, A_t, i_subfr, st->speech, st->
+            mem_w, st->wsp );
+
+      /* Find open loop pitch lag for two subframes */
+      if ( ( mode != MR475 ) && ( mode != MR515 ) ) {
+         ol_ltp( mode, st->vadSt, &st->wsp[i_subfr], &T_op[subfrNr], st->
+               ol_gain_flg, &st->pitchOLWghtSt->old_T0_med, &st->pitchOLWghtSt->
+               wght_flg, &st->pitchOLWghtSt->ada_w, st->old_lags, st->dtx,
+               subfrNr );
+      }
+   }
+
+   if ( ( mode == MR475 ) || ( mode == MR515 ) ) {
+      /*
+       * Find open loop pitch lag for ONE FRAME ONLY
+       * search on 160 samples
+       */
+      ol_ltp( mode, st->vadSt, &st->wsp[0], &T_op[0], st->ol_gain_flg, &st->
+            pitchOLWghtSt->old_T0_med, &st->pitchOLWghtSt->wght_flg, &st->
+            pitchOLWghtSt->ada_w, st->old_lags, st->dtx, 1 );
+      T_op[1] = T_op[0];
+   }
+
+#ifdef VAD2
+   if (st->dtx) {
+      LTP_flag_update(st->vadSt, mode);
+   }
+#endif
+
+#ifndef VAD2
+   if ( st->dtx ) {
+      vad_pitch_detection( st->vadSt, T_op );
+   }
+#endif
+
+   if ( *used_mode == MRDTX ) {
+      goto the_end;
+   }
+
+   /*
+    * Loop for every subframe in the analysis frame
+    *
+    * To find the pitch and innovation parameters. The subframe size is
+    * L_SUBFR and the loop is repeated L_FRAME/L_SUBFR times.
+    *     - find the weighted LPC coefficients
+    *     - find the LPC residual signal res[]
+    *     - compute the target signal for pitch search
+    *     - compute impulse response of weighted synthesis filter (h1[])
+    *     - find the closed-loop pitch parameters
+    *     - encode the pitch dealy
+    *     - update the impulse response h1[] by including fixed-gain pitch
+    *     - find target vector for codebook search
+    *     - codebook search
+    *     - encode codebook address
+    *     - VQ of pitch and codebook gains
+    *     - find synthesis speech
+    *     - update states of weighting filter
+    */
+   /* pointer to interpolated LPC parameters */
+   A = A_t;
+
+   /* pointer to interpolated quantized LPC parameters */
+   Aq = Aq_t;
+   evenSubfr = 0;
+   subfrNr = -1;
+
+   for ( i_subfr = 0; i_subfr < L_FRAME; i_subfr += L_SUBFR ) {
+      subfrNr += 1;
+      evenSubfr = 1 - evenSubfr;
+
+      if ( ( evenSubfr != 0 ) && ( *used_mode == MR475 ) ) {
+         memcpy( mem_syn_save, st->mem_syn, M <<2 );
+         memcpy( mem_w0_save, st->mem_w0, M <<2 );
+         memcpy( mem_err_save, st->mem_err, M <<2 );
+         sharp_save = st->sharp;
+      }
+
+      /* Preprocessing of subframe */
+      if ( *used_mode != MR475 ) {
+         subframePreProc( *used_mode, gamma1, gamma1_12k2, gamma2, A, Aq, &st->
+               speech[i_subfr], st->mem_err, st->mem_w0, st->zero, st->ai_zero,
+               &st->exc[i_subfr], st->h1, xn, res, st->error );
+      }
+
+      /* MR475 */
+      else {
+         subframePreProc( *used_mode, gamma1, gamma1_12k2, gamma2, A, Aq, &st->
+               speech[i_subfr], st->mem_err, mem_w0_save, st->zero, st->ai_zero,
+               &st->exc[i_subfr], st->h1, xn, res, st->error );
+
+         if ( evenSubfr != 0 ) {
+            memcpy( h1_sf0, st->h1, L_SUBFR <<2 );
+         }
+      }
+
+      /* copy the LP residual (res2 is modified in the CL LTP search) */
+      memcpy( res2, res, L_SUBFR <<2 );
+
+      /* Closed-loop LTP search */
+      cl_ltp( &st->clLtpSt->pitchSt->T0_prev_subframe, st->tonStabSt->gp, *
+            used_mode, i_subfr, T_op, st->h1, &st->exc[i_subfr], res2, xn,
+            lsp_flag, xn2, y1, &T0, &T0_frac, &gain_pit, gCoeff, &ana, &gp_limit
+            );
+
+      /* update LTP lag history */
+      if ( ( subfrNr == 0 ) && ( st->ol_gain_flg[0] > 0 ) ) {
+         st->old_lags[1] = T0;
+      }
+
+      if ( ( subfrNr == 3 ) && ( st->ol_gain_flg[1] > 0 ) ) {
+         st->old_lags[0] = T0;
+      }
+
+      /* Innovative codebook search (find index and gain) */
+      cbsearch( *used_mode, subfrNr, xn2, st->h1, T0, st->sharp, gain_pit, code,
+            y2, res2, &ana );
+
+      /* Quantization of gains. */
+      gainQuant( *used_mode, evenSubfr, st->gainQuantSt->gc_predSt->past_qua_en,
+            st->gainQuantSt->gc_predUncSt->past_qua_en, st->gainQuantSt->
+            sf0_coeff, &st->gainQuantSt->sf0_target_en, &st->gainQuantSt->
+            sf0_gcode0_exp, &st->gainQuantSt->
+            sf0_gcode0_fra, &st->gainQuantSt->gain_idx_ptr, &gain_pit_sf0, &
+            gain_code_sf0, res, &st->exc[i_subfr], code, xn, xn2, y1, y2, gCoeff
+            , gp_limit, &gain_pit, &gain_code, &st->gainQuantSt->adaptSt->
+            prev_gc, &st->gainQuantSt->adaptSt->onset, st->gainQuantSt->adaptSt
+            ->ltpg_mem, &st->gainQuantSt->adaptSt->prev_alpha, &ana );
+
+      /* update gain history */
+      for ( i = 0; i < N_FRAME - 1; i++ ) {
+         st->tonStabSt->gp[i] = st->tonStabSt->gp[i + 1];
+      }
+      st->tonStabSt->gp[N_FRAME - 1] = gain_pit;
+
+      /* Subframe Post Processing */
+      if ( *used_mode != MR475 ) {
+         subframePostProc( st->speech, i_subfr, gain_pit, gain_code, Aq, synth,
+               xn, code, y1, y2, st->mem_syn, st->mem_err, st->mem_w0, st->exc,
+               &st->sharp );
+      }
+      else {
+         if ( evenSubfr != 0 ) {
+            i_subfr_sf0 = i_subfr;
+            memcpy( xn_sf0, xn, L_SUBFR <<2 );
+            memcpy( y2_sf0, y2, L_SUBFR <<2 );
+            memcpy( code_sf0, code, L_SUBFR <<2 );
+            T0_sf0 = T0;
+            T0_frac_sf0 = T0_frac;
+
+            /* Subframe Post Porcessing */
+            subframePostProc( st->speech, i_subfr, gain_pit, gain_code, Aq,
+                  synth, xn, code, y1, y2, mem_syn_save, st->mem_err,
+                  mem_w0_save, st->exc, &st->sharp );
+            st->sharp = sharp_save;
+         }
+         else {
+            /*
+             * update both subframes for the MR475
+             * Restore states for the MR475 mode
+             */
+            memcpy( st->mem_err, mem_err_save, M <<2 );
+
+            /* re-build excitation for sf 0 */
+            Pred_lt_3or6( &st->exc[i_subfr_sf0], T0_sf0, T0_frac_sf0, 1 );
+            Convolve( &st->exc[i_subfr_sf0], h1_sf0, y1 );
+            Aq -= MP1;
+            subframePostProc( st->speech, i_subfr_sf0, gain_pit_sf0,
+                  gain_code_sf0, Aq, synth, xn_sf0, code_sf0, y1, y2_sf0, st->
+                  mem_syn, st->mem_err, st->mem_w0, st->exc, &sharp_save );
+
+            /* overwrites sharp_save */
+            Aq += MP1;
+
+            /*
+             * re-run pre-processing to get xn right (needed by postproc)
+             * (this also reconstructs the unsharpened h1 for sf 1)
+             */
+            subframePreProc( *used_mode, gamma1, gamma1_12k2, gamma2, A, Aq, &st
+                  ->speech[i_subfr], st->mem_err, st->mem_w0, st->zero, st->
+                  ai_zero, &st->exc[i_subfr], st->h1, xn, res, st->error );
+
+            /* re-build excitation sf 1 (changed if lag < L_SUBFR) */
+            Pred_lt_3or6( &st->exc[i_subfr], T0, T0_frac, 1 );
+            Convolve( &st->exc[i_subfr], st->h1, y1 );
+            subframePostProc( st->speech, i_subfr, gain_pit, gain_code, Aq,
+                  synth, xn, code, y1, y2, st->mem_syn, st->mem_err, st->mem_w0,
+                  st->exc, &st->sharp );
+         }
+      }
+
+      /* interpolated LPC parameters for next subframe */
+      A += MP1;
+      Aq += MP1;
+   }
+the_end:
+
+   /* Update signal for next frame. */
+   for ( i = 0; i < PIT_MAX; i++ ) {
+      st->old_wsp[i] = st->old_wsp[L_FRAME + i];
+   }
+
+   for ( i = 0; i < PIT_MAX + L_INTERPOL; i++ ) {
+      st->old_exc[i] = st->old_exc[L_FRAME + i];
+   }
+
+   for ( i = 0; i < L_TOTAL - L_FRAME; i++ ) {
+      st->old_speech[i] = st->old_speech[L_FRAME + i];
+   }
+}
+
+
+/*
+ * Pre_Process_reset
+ *
+ *
+ * Parameters:
+ *    state                O: state structure
+ *
+ * Function:
+ *    Initializes state memory to zero
+ *
+ * Returns:
+ *
+ */
+static Word32 Pre_Process_reset( Pre_ProcessState *state )
+{
+   if ( state == ( Pre_ProcessState * )NULL ) {
+      fprintf( stderr, "Pre_Process_reset: invalid parameter\n" );
+      return-1;
+   }
+   state->y2 = 0;
+   state->y1 = 0;
+   state->x0 = 0;
+   state->x1 = 0;
+   return 0;
+}
+
+
+/*
+ * Pre_Process_exit
+ *
+ *
+ * Parameters:
+ *    state             I: state structure
+ *
+ * Function:
+ *    The memory used for state memory is freed
+ *
+ * Returns:
+ *    Void
+ */
+static void Pre_Process_exit( Pre_ProcessState **state )
+{
+   if ( state == NULL || *state == NULL )
+      return;
+
+   /* deallocate memory */
+   free( *state );
+   *state = NULL;
+   return;
+}
+
+
+/*
+ * Pre_Process_init
+ *
+ *
+ * Parameters:
+ *    state             O: state structure
+ *
+ * Function:
+ *    Allocates state memory and initializes state memory
+ *
+ * Returns:
+ *    succeed = 0
+ */
+static Word32 Pre_Process_init( Pre_ProcessState **state )
+{
+   Pre_ProcessState * s;
+
+   if ( state == ( Pre_ProcessState * * )NULL ) {
+      fprintf( stderr, "Pre_Process_init: invalid parameter\n" );
+      return-1;
+   }
+   *state = NULL;
+
+   /* allocate memory */
+   if ( ( s = ( Pre_ProcessState * ) malloc( sizeof( Pre_ProcessState ) ) ) ==
+         NULL ) {
+      fprintf( stderr, "Pre_Process_init: can not malloc state structure\n" );
+      return-1;
+   }
+   Pre_Process_reset( s );
+   *state = s;
+   return 0;
+}
+
+
+/*
+ * Pre_Process
+ *
+ *
+ * Parameters:
+ *    y2, y1, x0, x1    B: filter memory
+ *    speech            I: speech vector to be processed
+ *    fspeech           O: processed vector
+ *    size              I: size of the vector
+ *
+ * Function:
+ *    Pre-processing
+ *
+ *    Two pre-processing functions are applied prior to
+ *    the encoding process: high-pass filtering and signal down-scaling.
+ *    Down-scaling consists of dividing the input by a factor of 2
+ *    to reduce the possibility of overflows in the fixed-point
+ *    implementation. The high-pass filter serves as a precaution
+ *    against undesired low frequency components. A filter with
+ *    a cut off frequency of 80 Hz is used, and it is given by:
+ *
+ *            0.927246093 - 1.8544941z^-1 + 0.927246903z^-2
+ *    H(z) = -----------------------------------------------
+ *                1 - 1.906005859z^-1 + 0.911376953z^-2
+ *
+ *    Down-scaling and high-pass filtering are combined by dividing
+ *    the coefficients at the numerator by 2.
+ *
+ * Returns:
+ *    void
+ */
+static void Pre_Process( Float32 *y2, Float32 *y1, Float32 *x0, Float32
+      *x1, Word16 *speech, Float32 *f_speech )
+{
+   Word32 i;
+   Float32 x2;
+   Float32 tmp;
+
+
+   for ( i = 0; i < 160; i++ ) {
+      x2 = *x1;
+      *x1 = *x0;
+      *x0 = speech[i];
+      tmp = ( Float32 )( 0.4636230465* *x0 - 0.92724705 * *x1 + 0.4636234515 *
+            x2 + 1.906005859 * *y1 - 0.911376953 * *y2 );
+      f_speech[i] = tmp;
+      *y2 = *y1;
+      *y1 = tmp;
+   }
+
+   if ( ( fabs( *y1 )+fabs( *y2 ) ) < 0.0000000001 )
+      *y2 = *y1 = 0;
+}
+
+
+/*
+ * cod_amr_reset
+ *
+ *
+ * Parameters:
+ *    s                 B: state structure
+ *    dtx               I: dtx on/off
+ *
+ * Function:
+ *    Resets state memory
+ *
+ * Returns:
+ *    void
+ */
+static void cod_amr_reset( cod_amrState *s, Word32 dtx )
+{
+   Word32 i;
+
+
+   /* reset DTX */
+   s->dtx = dtx;
+
+   /* reset Pitch_frState */
+   s->clLtpSt->pitchSt->T0_prev_subframe = 0;
+
+   /* reset Q_plsfState */
+   memset( s->lspSt->qSt->past_rq, 0, sizeof( Float32 )*M );
+   memcpy( s->lspSt->lsp_old, lsp_init_data, sizeof( lsp_init_data ) );
+   memcpy( s->lspSt->lsp_old_q, lsp_init_data, sizeof( lsp_init_data ) );
+
+   /* reset gc_predState */
+   for ( i = 0; i < NPRED; i++ ) {
+      s->gainQuantSt->gc_predSt->past_qua_en[i] = NB_QUA_CODE+VQ_SIZE_HIGHRATES+VQ_SIZE_LOWRATES+MR475_VQ_SIZE*2+DTX_VQ_SIZE;
+      s->gainQuantSt->gc_predUncSt->past_qua_en[i] = NB_QUA_CODE+VQ_SIZE_HIGHRATES+VQ_SIZE_LOWRATES+MR475_VQ_SIZE*2+DTX_VQ_SIZE;
+   }
+
+   /* reset gain_adaptState */
+   s->gainQuantSt->adaptSt->onset = 0;
+   s->gainQuantSt->adaptSt->prev_alpha = 0.0F;
+   s->gainQuantSt->adaptSt->prev_gc = 0.0F;
+   memset( s->gainQuantSt->adaptSt->ltpg_mem, 0, sizeof( Float32 )*LTPG_MEM_SIZE
+         );
+   s->gainQuantSt->sf0_gcode0_exp = 0;
+   s->gainQuantSt->sf0_gcode0_fra = 0;
+   s->gainQuantSt->sf0_target_en = 0.0F;
+   memset( s->gainQuantSt->sf0_coeff, 0, sizeof( Float32 )*5 );
+   s->gainQuantSt->gain_idx_ptr = NULL;
+
+   /* reset pitchOLWghtState */
+   s->pitchOLWghtSt->old_T0_med = 40;
+   s->pitchOLWghtSt->ada_w = 0.0F;
+   s->pitchOLWghtSt->wght_flg = 0;
+
+   /* reset tonStabState */
+   s->tonStabSt->count = 0;
+   memset( s->tonStabSt->gp, 0, sizeof( Float32 )*N_FRAME );
+
+   /* reset LevinsonState */
+   s->lpcSt->LevinsonSt->old_A[0] = 1.0F;
+   memset( &s->lpcSt->LevinsonSt->old_A[1], 0, sizeof( Float32 )*M );
+
+#ifdef VAD2
+   /* reset vadState */
+   s->vadSt->pre_emp_mem = 0.0;
+   s->vadSt->update_cnt = 0;
+   s->vadSt->hyster_cnt = 0;
+   s->vadSt->last_update_cnt = 0;
+   for ( i = 0; i < NUM_CHAN; i++ ) {
+     s->vadSt->ch_enrg_long_db[i] = 0.0;
+     s->vadSt->ch_enrg[i] = 0.0;
+     s->vadSt->ch_noise[i] = 0.0;
+   }
+   s->vadSt->Lframe_cnt = 0L;
+   s->vadSt->tsnr = 0.0;
+   s->vadSt->hangover = 0;
+   s->vadSt->burstcount = 0;
+   s->vadSt->fupdate_flag = 0;
+   s->vadSt->negSNRvar = 0.0;
+   s->vadSt->negSNRbias = 0.0;
+   s->vadSt->R0 = 0.0;
+   s->vadSt->Rmax = 0.0;
+   s->vadSt->LTP_flag = 0;
+#else
+   /* reset vadState */
+   s->vadSt->oldlag_count = 0;
+   s->vadSt->oldlag = 0;
+   s->vadSt->pitch = 0;
+   s->vadSt->tone = 0;
+   s->vadSt->complex_high = 0;
+   s->vadSt->complex_low = 0;
+   s->vadSt->complex_hang_timer = 0;
+   s->vadSt->vadreg = 0;
+   s->vadSt->burst_count = 0;
+   s->vadSt->hang_count = 0;
+   s->vadSt->complex_hang_count = 0;
+
+   /* initialize memory used by the filter bank */
+   for ( i = 0; i < 3; i++ ) {
+      s->vadSt->a_data5[i][0] = 0;
+      s->vadSt->a_data5[i][1] = 0;
+   }
+
+   for ( i = 0; i < 5; i++ ) {
+      s->vadSt->a_data3[i] = 0;
+   }
+
+   /* reset dtx_encState */
+   /* initialize the rest of the memory */
+   for ( i = 0; i < COMPLEN; i++ ) {
+      s->vadSt->bckr_est[i] = NOISE_INIT;
+      s->vadSt->old_level[i] = NOISE_INIT;
+      s->vadSt->ave_level[i] = NOISE_INIT;
+      s->vadSt->sub_level[i] = 0;
+   }
+   s->vadSt->best_corr_hp = CVAD_LOWPOW_RESET;
+   s->vadSt->speech_vad_decision = 0;
+   s->vadSt->complex_warning = 0;
+   s->vadSt->sp_burst_count = 0;
+   s->vadSt->corr_hp_fast = CVAD_LOWPOW_RESET;
+#endif
+
+   s->dtxEncSt->hist_ptr = 0;
+   s->dtxEncSt->log_en_index = 0;
+   s->dtxEncSt->init_lsf_vq_index = 0;
+   s->dtxEncSt->lsp_index[0] = 0;
+   s->dtxEncSt->lsp_index[1] = 0;
+   s->dtxEncSt->lsp_index[2] = 0;
+
+   for ( i = 0; i < DTX_HIST_SIZE; i++ ) {
+      memcpy( &s->dtxEncSt->lsp_hist[i * M], lsp_init_data, sizeof( Float32 )*M
+            );
+   }
+   memset( s->dtxEncSt->log_en_hist, 0, M * sizeof( Float32 ) );
+   s->dtxEncSt->dtxHangoverCount = DTX_HANG_CONST;
+   s->dtxEncSt->decAnaElapsedCount = DTX_ELAPSED_FRAMES_THRESH;
+
+   /* init speech pointers */
+   /* New speech */
+   s->new_speech = s->old_speech + L_TOTAL - L_FRAME;
+
+   /* Present frame */
+   s->speech = s->new_speech - L_NEXT;
+   s->p_window = s->old_speech + L_TOTAL - L_WINDOW;
+
+   /* For LPC window				*/
+   s->p_window_12k2 = s->p_window - L_NEXT;
+
+   /* Initialize static pointers */
+   s->wsp = s->old_wsp + PIT_MAX;
+   s->exc = s->old_exc + PIT_MAX + L_INTERPOL;
+   s->zero = s->ai_zero + MP1;
+   s->error = s->mem_err + M;
+   s->h1 = &s->hvec[L_SUBFR];
+
+   /* Static vectors to zero */
+   memset( s->old_speech, 0, sizeof( Float32 )*L_TOTAL );
+   memset( s->old_exc, 0, sizeof( Float32 )*( PIT_MAX + L_INTERPOL ) );
+   memset( s->old_wsp, 0, sizeof( Float32 )*PIT_MAX );
+   memset( s->mem_syn, 0, sizeof( Float32 )*M );
+   memset( s->mem_w, 0, sizeof( Float32 )*M );
+   memset( s->mem_w0, 0, sizeof( Float32 )*M );
+   memset( s->mem_err, 0, sizeof( Float32 )*M );
+   memset( s->ai_zero, 0, sizeof( Float32 )*L_SUBFR );
+   memset( s->hvec, 0, sizeof( Float32 )*L_SUBFR );
+
+   for ( i = 0; i < 5; i++ ) {
+      s->old_lags[i] = 40;
+   }
+   s->sharp = 0.0F;
+}
+
+
+/*
+ * cod_amr_init
+ *
+ *
+ * Parameters:
+ *    state             O: state structure
+ *    dtx               I: dtx mode used
+ *
+ * Function:
+ *    Allocates state memory and initializes state memory
+ *
+ * Returns:
+ *    succeed = 0
+ */
+static Word32 cod_amr_init( cod_amrState **state, Word32 dtx )
+{
+   cod_amrState * s;
+
+   if ( ( s = ( cod_amrState * ) malloc( sizeof( cod_amrState ) ) ) == NULL ) {
+      fprintf( stderr, "can not malloc state structure\n" );
+      return-1;
+   }
+
+   /* init clLtpState */
+   if ( ( s->clLtpSt = ( clLtpState * ) malloc( sizeof( clLtpState ) ) ) == NULL
+         ) {
+      fprintf( stderr, "can not malloc state structure\n" );
+      return-1;
+   }
+
+   /* init Pitch_frState */
+   if ( ( s->clLtpSt->pitchSt = ( Pitch_frState * ) malloc( sizeof(
+         Pitch_frState ) ) ) == NULL ) {
+      fprintf( stderr, "can not malloc state structure\n" );
+      return-1;
+   }
+
+   /* init lspState */
+   if ( ( s->lspSt = ( lspState * ) malloc( sizeof( lspState ) ) ) == NULL ) {
+      fprintf( stderr, "can not malloc state structure\n" );
+      return-1;
+   }
+
+   /* init Q_plsfState */
+   if ( ( s->lspSt->qSt = ( Q_plsfState * ) malloc( sizeof( Q_plsfState ) ) ) ==
+         NULL ) {
+      fprintf( stderr, "can not malloc state structure\n" );
+      return-1;
+   }
+
+   /* init gainQuantState */
+   if ( ( s->gainQuantSt = ( gainQuantState * ) malloc( sizeof( gainQuantState )
+         ) ) == NULL ) {
+      fprintf( stderr, "can not malloc state structure\n" );
+      return-1;
+   }
+
+   /* init gc_predState x2 */
+   if ( ( s->gainQuantSt->gc_predSt = ( gc_predState * ) malloc( sizeof(
+         gc_predState ) ) ) == NULL ) {
+      fprintf( stderr, "can not malloc state structure\n" );
+      return-1;
+   }
+
+   if ( ( s->gainQuantSt->gc_predUncSt = ( gc_predState * ) malloc( sizeof(
+         gc_predState ) ) ) == NULL ) {
+      fprintf( stderr, "can not malloc state structure\n" );
+      return-1;
+   }
+
+   /* init gain_adaptState */
+   if ( ( s->gainQuantSt->adaptSt = ( gain_adaptState * ) malloc( sizeof(
+         gain_adaptState ) ) ) == NULL ) {
+      fprintf( stderr, "can not malloc state structure\n" );
+      return-1;
+   }
+
+   /* init pitchOLWghtState */
+   if ( ( s->pitchOLWghtSt = ( pitchOLWghtState * ) malloc( sizeof(
+         pitchOLWghtState ) ) ) == NULL ) {
+      fprintf( stderr, "can not malloc state structure\n" );
+      return-1;
+   }
+
+   /* init tonStabState */
+   if ( ( s->tonStabSt = ( tonStabState * ) malloc( sizeof( tonStabState ) ) )
+         == NULL ) {
+      fprintf( stderr, "can not malloc state structure\n" );
+      return-1;
+   }
+
+   /* init lpcState */
+   if ( ( s->lpcSt = ( lpcState * ) malloc( sizeof( lpcState ) ) ) == NULL ) {
+      fprintf( stderr, "can not malloc state structure\n" );
+      return-1;
+   }
+
+   /* init LevinsonState */
+   if ( ( s->lpcSt->LevinsonSt = ( LevinsonState * ) malloc( sizeof(
+         LevinsonState ) ) ) == NULL ) {
+      fprintf( stderr, "can not malloc state structure\n" );
+      return-1;
+   }
+
+   if ( ( s->vadSt = ( vadState * ) malloc( sizeof( vadState ) ) ) == NULL ) {
+      fprintf( stderr, "can not malloc state structure\n" );
+      return-1;
+   }
+
+   /* Init dtx_encState */
+   if ( ( s->dtxEncSt = ( dtx_encState * ) malloc( sizeof( dtx_encState ) ) ) ==
+         NULL ) {
+      fprintf( stderr, "can not malloc state structure\n" );
+      return-1;
+   }
+   cod_amr_reset( s, dtx );
+   *state = s;
+   return 0;
+}
+
+
+/*
+ * cod_amr_exit
+ *
+ *
+ * Parameters:
+ *    state             I: state structure
+ *
+ * Function:
+ *    The memory used for state memory is freed
+ *
+ * Returns:
+ *    Void
+ */
+static void cod_amr_exit( cod_amrState **state )
+{
+   if ( state == NULL || *state == NULL )
+      return;
+
+   /* deallocate memory */
+   free( ( *state )->vadSt );
+   free( ( *state )->gainQuantSt->gc_predSt );
+   free( ( *state )->gainQuantSt->gc_predUncSt );
+   free( ( *state )->gainQuantSt->adaptSt );
+   free( ( *state )->clLtpSt->pitchSt );
+   free( ( *state )->lspSt->qSt );
+   free( ( *state )->lpcSt->LevinsonSt );
+   free( ( *state )->lpcSt );
+   free( ( *state )->lspSt );
+   free( ( *state )->clLtpSt );
+   free( ( *state )->gainQuantSt );
+   free( ( *state )->pitchOLWghtSt );
+   free( ( *state )->tonStabSt );
+   free( ( *state )->dtxEncSt );
+   free( *state );
+   *state = NULL;
+   return;
+}
+
+
+/*
+ * Speech_Encode_Frame_init
+ *
+ *
+ * Parameters:
+ *    state             O: state structure
+ *    dtx               I: dtx mode used
+ *
+ * Function:
+ *    Allocates state memory and initializes state memory
+ *
+ * Returns:
+ *    succeed = 0
+ */
+void * Speech_Encode_Frame_init( int dtx )
+{
+   Speech_Encode_FrameState * s;
+
+   /* allocate memory */
+   if ( ( s = ( Speech_Encode_FrameState * ) malloc( sizeof(
+         Speech_Encode_FrameState ) ) ) == NULL ) {
+      fprintf( stderr, "Speech_Encode_Frame_init: can not malloc state "
+            "structure\n" );
+      return NULL;
+   }
+   s->pre_state = NULL;
+   s->cod_amr_state = NULL;
+   s->dtx = dtx;
+
+   if ( Pre_Process_init( &s->pre_state ) || cod_amr_init( &s->cod_amr_state,
+         dtx ) ) {
+      Speech_Encode_Frame_exit( ( void ** )( &s ) );
+      return NULL;
+   }
+   return s;
+}
+
+
+/*
+ * Speech_Encode_Frame_reset
+ *
+ *
+ * Parameters:
+ *    state          O: state structure
+ *
+ * Function:
+ *    Resets state memory
+ *
+ * Returns:
+ *
+ */
+int Speech_Encode_Frame_reset( void *st, int dtx )
+{
+   Speech_Encode_FrameState * state;
+   state = ( Speech_Encode_FrameState * )st;
+
+   if ( ( Speech_Encode_FrameState * )state == NULL ) {
+      fprintf( stderr, "Speech_Encode_Frame_reset: invalid parameter\n" );
+      return-1;
+   }
+   Pre_Process_reset( state->pre_state );
+   cod_amr_reset( state->cod_amr_state, dtx );
+   return 0;
+}
+
+
+/*
+ * Speech_Encode_Frame_exit
+ *
+ *
+ * Parameters:
+ *    state            I: state structure
+ *
+ * Function:
+ *    The memory used for state memory is freed
+ *
+ * Returns:
+ *    Void
+ */
+void Speech_Encode_Frame_exit( void **st )
+{
+   if ( ( Speech_Encode_FrameState * )( *st ) == NULL )
+      return;
+   Pre_Process_exit( &( ( ( Speech_Encode_FrameState * )( *st ) )->pre_state ) )
+   ;
+   cod_amr_exit( &( ( ( Speech_Encode_FrameState * )( *st ) )->cod_amr_state ) )
+   ;
+
+   /* deallocate memory */
+   free( *st );
+   *st = NULL;
+   return;
+}
+
+
+/*
+ * Speech_Encode_Frame
+ *
+ *
+ * Parameters:
+ *    st                B: state structure
+ *    mode              I: speech coder mode
+ *    new_speech        I: speech input, size L_FRAME
+ *    prm               O: Analysis parameters
+ *    used_mode         B: force VAD/used_mode
+ * Function:
+ *    Encode one frame
+ *
+ * Returns:
+ *    Void
+ */
+void Speech_Encode_Frame( void *st, enum Mode mode, Word16 *new_speech, Word16 *
+      prm, enum Mode *used_mode )
+{
+   Float32 syn[L_FRAME];   /* Buffer for synthesis speech */
+   Float32 speech[160];
+   Word32 i;
+
+
+   Speech_Encode_FrameState * state;
+   state = ( Speech_Encode_FrameState * )st;
+
+   for ( i = 0; i < 160; i++ ) {
+      new_speech[i] = ( Word16 )( new_speech[i] & 0xfff8 );
+   }
+
+   /* filter + downscaling */
+   Pre_Process( &state->pre_state->y2, &state->pre_state->y1, &state->pre_state
+         ->x0, &state->pre_state->x1, new_speech, speech );
+
+   /* Call the speech encoder */
+   cod_amr( state->cod_amr_state, mode, speech, prm, used_mode, syn );
+
+}
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/amr/sp_enc.h asterisk-1.8.3.2_com_amr/codecs/amr/sp_enc.h
--- asterisk-1.8.3.2_com_rtsp/codecs/amr/sp_enc.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/amr/sp_enc.h	2012-03-26 16:29:06.000000000 +0100
@@ -0,0 +1,74 @@
+/*
+ * ===================================================================
+ *  TS 26.104
+ *  REL-5 V5.4.0 2004-03
+ *  REL-6 V6.1.0 2004-03
+ *  3GPP AMR Floating-point Speech Codec
+ * ===================================================================
+ *
+ */
+
+/*
+ * sp_enc.h
+ *
+ *
+ * Project:
+ *    AMR Floating-Point Codec
+ *
+ * Contains:
+ *    Defines interface to AMR encoder
+ *
+ */
+#ifndef _SP_ENC_H
+#define _SP_ENC_H
+
+/*
+ * include files
+ */
+#include "typedef.h"
+
+/*
+ * definition of modes for encoder
+ */
+enum Mode { MR475 = 0,
+            MR515,
+            MR59,
+            MR67,
+            MR74,
+            MR795,
+            MR102,
+            MR122,
+            MRDTX
+};
+
+/*
+ * Function prototypes
+ */
+
+/*
+ * initialize one instance of the speech encoder
+ * Stores pointer to filter status struct in *st. This pointer has to
+ * be passed to Speech_Encode_Frame in each call.
+ * returns 0 on success
+ */
+void *Speech_Encode_Frame_init (int dtx);
+/*
+ * reset speech encoder (i.e. set state memory to zero)
+ * returns 0 on success
+ */
+int Speech_Encode_Frame_reset(void *st, int dtx);
+
+/*
+ * de-initialize speech encoder (i.e. free status struct)
+ * stores NULL in *st
+ */
+void Speech_Encode_Frame_exit (void **st);
+
+/*
+ * Encodes one speech frame
+ * Returns analysis parameters
+ */
+void Speech_Encode_Frame (void *st, enum Mode mode, short *newSpeech,
+                   short *prm, enum Mode *usedMode);
+
+#endif
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/amr/.sp_enc.o.d asterisk-1.8.3.2_com_amr/codecs/amr/.sp_enc.o.d
--- asterisk-1.8.3.2_com_rtsp/codecs/amr/.sp_enc.o.d	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/amr/.sp_enc.o.d	2012-03-28 11:20:22.000000000 +0100
@@ -0,0 +1,107 @@
+sp_enc.o sp_enc.o: sp_enc.c /usr/include/stdlib.h /usr/include/features.h \
+  /usr/include/sys/cdefs.h /usr/include/bits/wordsize.h \
+  /usr/include/gnu/stubs.h /usr/include/gnu/stubs-32.h \
+  /usr/lib/gcc/i386-redhat-linux/4.1.2/include/stddef.h \
+  /usr/include/sys/types.h /usr/include/bits/types.h \
+  /usr/include/bits/typesizes.h /usr/include/time.h /usr/include/endian.h \
+  /usr/include/bits/endian.h /usr/include/sys/select.h \
+  /usr/include/bits/select.h /usr/include/bits/sigset.h \
+  /usr/include/bits/time.h /usr/include/sys/sysmacros.h \
+  /usr/include/bits/pthreadtypes.h /usr/include/alloca.h \
+  /usr/include/stdio.h /usr/include/libio.h /usr/include/_G_config.h \
+  /usr/include/wchar.h /usr/include/bits/wchar.h /usr/include/gconv.h \
+  /usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h \
+  /usr/include/bits/stdio_lim.h /usr/include/bits/sys_errlist.h \
+  /usr/include/bits/stdio.h /usr/include/memory.h /usr/include/string.h \
+  /usr/include/bits/string.h /usr/include/bits/string2.h \
+  /usr/include/math.h /usr/include/bits/huge_val.h \
+  /usr/include/bits/mathdef.h /usr/include/bits/mathcalls.h \
+  /usr/include/bits/mathinline.h \
+  /usr/lib/gcc/i386-redhat-linux/4.1.2/include/float.h sp_enc.h typedef.h \
+  rom_enc.h
+
+/usr/include/stdlib.h:
+
+/usr/include/features.h:
+
+/usr/include/sys/cdefs.h:
+
+/usr/include/bits/wordsize.h:
+
+/usr/include/gnu/stubs.h:
+
+/usr/include/gnu/stubs-32.h:
+
+/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stddef.h:
+
+/usr/include/sys/types.h:
+
+/usr/include/bits/types.h:
+
+/usr/include/bits/typesizes.h:
+
+/usr/include/time.h:
+
+/usr/include/endian.h:
+
+/usr/include/bits/endian.h:
+
+/usr/include/sys/select.h:
+
+/usr/include/bits/select.h:
+
+/usr/include/bits/sigset.h:
+
+/usr/include/bits/time.h:
+
+/usr/include/sys/sysmacros.h:
+
+/usr/include/bits/pthreadtypes.h:
+
+/usr/include/alloca.h:
+
+/usr/include/stdio.h:
+
+/usr/include/libio.h:
+
+/usr/include/_G_config.h:
+
+/usr/include/wchar.h:
+
+/usr/include/bits/wchar.h:
+
+/usr/include/gconv.h:
+
+/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h:
+
+/usr/include/bits/stdio_lim.h:
+
+/usr/include/bits/sys_errlist.h:
+
+/usr/include/bits/stdio.h:
+
+/usr/include/memory.h:
+
+/usr/include/string.h:
+
+/usr/include/bits/string.h:
+
+/usr/include/bits/string2.h:
+
+/usr/include/math.h:
+
+/usr/include/bits/huge_val.h:
+
+/usr/include/bits/mathdef.h:
+
+/usr/include/bits/mathcalls.h:
+
+/usr/include/bits/mathinline.h:
+
+/usr/lib/gcc/i386-redhat-linux/4.1.2/include/float.h:
+
+sp_enc.h:
+
+typedef.h:
+
+rom_enc.h:
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/amr/typedef.h asterisk-1.8.3.2_com_amr/codecs/amr/typedef.h
--- asterisk-1.8.3.2_com_rtsp/codecs/amr/typedef.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/amr/typedef.h	2012-03-26 16:29:06.000000000 +0100
@@ -0,0 +1,22 @@
+/*
+ * ===================================================================
+ *  TS 26.104
+ *  REL-5 V5.4.0 2004-03
+ *  REL-6 V6.1.0 2004-03
+ *  3GPP AMR Floating-point Speech Codec
+ * ===================================================================
+ *
+ */
+/* This is valid for PC */
+
+#ifndef _TYPEDEF_H
+#define _TYPEDEF_H
+
+typedef char Word8;
+typedef unsigned char UWord8;
+typedef short Word16;
+typedef int Word32;
+typedef float Float32;
+typedef double Float64;
+
+#endif
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/amr_slin_ex.h asterisk-1.8.3.2_com_amr/codecs/amr_slin_ex.h
--- asterisk-1.8.3.2_com_rtsp/codecs/amr_slin_ex.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/amr_slin_ex.h	2012-03-26 16:29:06.000000000 +0100
@@ -0,0 +1,16 @@
+/*! \file
+  * \brief 8-bit raw data
+  *
+  * Source: gsm.example
+  *
+  * Copyright (C) 1999-2005, Digium Inc.
+  *
+  * Distributed under the terms of the GNU General Public License
+  *
+  */
+
+/* Got this by converting ex_slin16 to amr (in RTP Format) */
+static unsigned char amr_slin_ex[] = {
+     0x10,0x0c,0x46,0xEF,0x18,0xE0,0xF0,0x84,0xD3,0x43,0xDE,0x56,0xCA,0x4E,0x8E
+};
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/codec_amr.c asterisk-1.8.3.2_com_amr/codecs/codec_amr.c
--- asterisk-1.8.3.2_com_rtsp/codecs/codec_amr.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/codec_amr.c	2012-03-26 16:29:06.000000000 +0100
@@ -0,0 +1,507 @@
+/*
+ * Asterisk -- An open source telephony toolkit.
+ *
+ * The AMR code is from 3GPP TS 26.104.  Copyright information for that package is available
+ * in the amr directory.
+ *
+ * Copyright (C) 2007, 2010 Digital Solutions
+ * Paul Bagyenda <bagyenda@dsmagic.com>
+ * 
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+/*! \file
+ *
+ * \brief Translate between signed linear and Adaptive Multi-Rate (AMR) Narrow Band (RFC 3267 format).
+ *
+ * \ingroup codecs
+ */
+
+/*** MODULEINFO
+	
+ ***/
+
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <netinet/in.h>
+#include <string.h>
+#include <stdio.h>
+#include <assert.h>
+
+#include "asterisk/lock.h"
+#include "asterisk/translate.h"
+#include "asterisk/config.h"
+#include "asterisk/options.h"
+#include "asterisk/module.h"
+#include "asterisk/logger.h"
+#include "asterisk/channel.h"
+#include "asterisk/utils.h"
+
+#include "amr/typedef.h"
+#include "amr/interf_enc.h"
+#include "amr/interf_dec.h"
+
+
+/* Sample frame data */
+#include "amr_slin_ex.h"
+#include "asterisk/slin.h"
+
+#define SAMPLES_PER_SEC_NB   8000 /* 8kHz speech gives us 8000 samples per second */
+#define BUFFER_SAMPLES	     8000 /* maximum number of samples we will process at a go. */
+#define AMR_SAMPLES	     160
+#define AMR_MAX_FRAME_LEN    32
+#define AMR_MAX_FRAMES_NB (BUFFER_SAMPLES*1000)/(SAMPLES_PER_SEC_NB*20) /* each frame is 20ms, hence max frames = samples/samples_per_sec*/
+
+static int dtx = 0;
+static enum Mode enc_mode = MR122; 
+
+/* whether we are parsing/encoding using octet-aligned mode -- XXX not very clean 
+ * Note: We don't handle crc or inter-leaving for now
+ */
+static int octet_aligned = 0;
+
+/* Size of (octet-aligned) speech block for each mode */
+/* static short block_size[16]={12, 13, 15, 17, 19, 20, 26, 31, 5}; */
+
+/* Taken from Table 2, of 3GPP TS 26.101, v5.0.0 */
+static int num_bits[16] = {95, 103, 118, 134,148,159,204,244};
+
+/* Mapping of encoding mode to AMR codec mode */
+static const short modeConv[]={475, 515, 59, 67, 74, 795, 102, 122};
+
+struct amr_translator_pvt {	/* both amr2lin and lin2amr */
+	int *destate;  /* decoder state */
+	int *enstate;  /* encoder state. */
+	enum Mode enc_mode;                /* Currrently requested mode */
+	int16_t buf[BUFFER_SAMPLES];	/* lin2amr, temporary storage */
+#if 0
+	unsigned char pheader[AMR_MAX_FRAMES_NB + 1]; /* lin2amr temporary storage for Pay load header + Table of Contents */
+#endif
+	unsigned char speech_bits[AMR_MAX_FRAMES_NB*AMR_MAX_FRAME_LEN + 1]; /* storage for packed bits. */
+};
+
+
+/* Pack bits into dst, advance ptr */
+static int pack_bits(unsigned char **dst, int d_offset, unsigned char *src,  unsigned sbits)
+{
+     unsigned char *p = *dst;
+     unsigned s_offset, x,y,sbytes = (sbits+7)/8; /* Number of bytes. */
+     unsigned char *end_ptr = src + sbytes;
+     
+     assert(d_offset >= 0 && d_offset < 8);
+#if 0     
+     ast_verbose("pack_bits: off=%d,sbits=%d\n",d_offset,sbits);
+#endif
+
+   /* Fill first dst byte, then we proceed */    
+     x = d_offset + 1;  
+     /* *p &= (1<<x) - 1; Clear top bits. */
+     
+     *p = (*p  & (~0 << x)) |  (*src >> (8 - x)); /* Clear bits, then set */
+     if (d_offset == 7) 
+	  src++;           
+     /* Now fill whole dst bytes in each pass */
+     s_offset = (d_offset == 7) ? 7 : 7 - x;
+     y = s_offset + 1;
+     while (src < end_ptr) {
+	  p++; /* Go to next; Only do so here, because we need to go to next only if octet is used up. */	  
+	  *p = (*src & ((1<<y) - 1)) << (8 - y); 
+	  if (s_offset < 7) /* Need part of next byte. Redundant check? I think so */
+	       *p |= (src[1] >> y) & ((1<<(8 - s_offset)) - 1);	  
+	  src++;
+     }
+     
+     if (*dst == p && (sbits % 8 ) == 0)
+	     p++; /* Terrible kludge, but... */
+
+     *dst = p;
+     
+     /* Compute new d_offset */
+     if (sbits > x) {
+	  sbits = (sbits - x) % 8; /* We'd have filled in first byte, and X full bytes */
+	  
+	  /* We now have a remainder set of bits, which are fewer than 8, time to fill them in and calculate */
+	  d_offset = 7 - sbits;
+     } else {
+	  d_offset  -= sbits; /* We stayed in same byte, or just filled it: Subtract # of bits added */
+	  if (d_offset < 0)
+	       d_offset = 7;
+     }
+     return d_offset;
+}
+
+/* unpack bits from src, advance src */
+static int unpack_bits(unsigned char **src, int s_offset, unsigned char *dst, unsigned sbits)
+{
+     
+     unsigned char *q = *src;;
+
+     assert(s_offset >= 0 && s_offset <= 7);
+     while (sbits > 0) {	
+	  int bits = sbits >= 8 ? 8 : sbits;
+	  unsigned mask = ~((1<<(8-bits)) - 1);	  
+	  int x = s_offset + 1;
+
+	  *dst = (*q << (8 - x));  /* Set */
+	  if (x - bits < 0)  /* Get bit off next byte */
+	       *dst |= (q[1] >> x) /*  & ((1 << (8-s_offset)) - 1) */;	  /* right shift of unsigned left pads with zeros*/
+	  
+	  *dst &= mask; /* Clear all other bits */
+
+	  s_offset -= bits;
+	  if (s_offset < 0) { /* This means we got a bit off next byte or all of current byte, so move. */
+	       q++;
+	       s_offset  += 8;
+	  } 
+	  dst++;
+	  sbits -= bits;
+     }
+
+     *src = q;
+
+     return s_offset;
+}
+
+static int amr_new(struct ast_trans_pvt *pvt)
+{
+	struct amr_translator_pvt *tmp = pvt->pvt;
+	
+	tmp->enstate = Encoder_Interface_init(dtx);
+	tmp->destate = Decoder_Interface_init();
+	tmp->enc_mode = enc_mode;
+	return 0;
+}
+
+static struct ast_frame *amrtolin_sample(void)
+{
+	static struct ast_frame f = {0};
+	f.frametype = AST_FRAME_VOICE;
+	f.subclass.codec = AST_FORMAT_AMRNB;
+	f.datalen = sizeof(amr_slin_ex);
+	/* All frames are 20 ms long */
+	f.samples = AMR_SAMPLES;
+	f.len = 20;
+	f.mallocd = 0;
+	f.offset = 0;
+	f.src = __PRETTY_FUNCTION__;
+	f.data.ptr = amr_slin_ex;
+	return &f;
+}
+
+/*! \brief decode and store in outbuf. */
+static int amrtolin_framein(struct ast_trans_pvt *pvt, struct ast_frame *f)
+{
+	struct amr_translator_pvt *tmp = pvt->pvt;
+	int x = 0, more_frames = 1, nframes = 0;
+	int16_t *dst = pvt->outbuf.i16;
+	unsigned char *src = f->data.ptr, cmr, buffer[AMR_MAX_FRAME_LEN+1];
+	struct { 
+		unsigned char ft;
+		unsigned char q;
+	} toc[AMR_MAX_FRAMES_NB];
+	
+	unsigned char *end_ptr = src + f->datalen;
+	int pos; /* position in current byte in the bit stream. */
+	
+	int xoctet_aligned = octet_aligned;
+	
+	/* Massive kludge, but we need it to stay alive. Here goes: */
+	if (f->data.ptr == amr_slin_ex)
+		xoctet_aligned = 1;
+	
+	pos = unpack_bits(&src, 7, &cmr,  xoctet_aligned ? 8 : 4);
+	cmr >>= 4;     /* So we get correct one */
+
+	/* Get the table of contents first... */
+	while (src < end_ptr && more_frames) {
+		unsigned char ch;
+		/* get table of contents. */
+		pos = unpack_bits(&src, pos, &ch, xoctet_aligned ? 8 : 6); 
+		
+		more_frames = (ch>>7);	     
+		toc[nframes].ft = (ch >> 3) & 0x0F; /* Kill Q bit */
+		toc[nframes].q  = (ch >> 2) & 0x01; 
+#if 0
+		ast_verbose("amrtolin_framein: cmr=%02hhx, toc.ft=%02hhx,toc.q=%d more=%d, datalen=%d\n",
+			    cmr, toc[nframes].ft, toc[nframes].q, more_frames, f->datalen); 
+#endif     
+		nframes++;
+	}
+	
+	/* Now get the speech bits, and decode as we go. */
+	for (x = 0; x<nframes; x++) {
+		unsigned char ft = toc[x].ft, q = toc[x].q;
+	     int bits = xoctet_aligned ? (num_bits[ft]+7)&~7 : num_bits[ft];
+	     
+	     if (ft == 14 || ft == 15) /* No data */
+		     goto loop; 
+
+	     if (pvt->samples + AMR_SAMPLES > BUFFER_SAMPLES) {	
+		  ast_log(LOG_WARNING, "Out of buffer space\n");
+		  return -1;
+	     }
+#if 0
+	     memset(buffer, 0, sizeof buffer); /* clear it. */
+#endif
+	     /* for octet-aligned mode, the speech frames are octet aligned as well */
+	     pos = unpack_bits(&src, pos, &buffer[1], bits);
+	     buffer[0] = (ft<<3) | (q<<2);
+	     Decoder_Interface_Decode(tmp->destate,buffer, dst + pvt->samples,0);
+	     
+	     pvt->samples += AMR_SAMPLES;
+	     pvt->datalen += 2 * AMR_SAMPLES;
+
+	loop:
+	     (void)0;
+#if 0
+	     ast_verbose("amr2lin: %d/%d Decode ft=%u, num_bits=%d\n", x,nframes, ft, bits); 
+#endif
+	}
+
+	/* Honour the requested codec? */
+	if (cmr < tmp->enc_mode)
+	     tmp->enc_mode = cmr;
+	
+	return 0;
+}
+
+/*! \brief store samples into working buffer for later decode */
+static int lintoamr_framein(struct ast_trans_pvt *pvt, struct ast_frame *f)
+{
+	struct amr_translator_pvt *tmp = pvt->pvt;
+
+	/* XXX We should look at how old the rest of our stream is, and if it
+	   is too old, then we should overwrite it entirely, otherwise we can
+	   get artifacts of earlier talk that do not belong */
+
+	/* ast_verbose("lintoamr_framein: %d samples\n", f->samples);*/
+
+	if (pvt->samples + f->samples > BUFFER_SAMPLES) {
+		ast_log(LOG_WARNING, "Out of buffer space\n");
+		return -1;
+	}
+	memcpy(tmp->buf + pvt->samples, f->data.ptr, f->datalen);
+	pvt->samples += f->samples;
+#if 0
+	ast_verbose("lintoamr_framein: %d/%d samples\n", f->samples, pvt->samples);
+#endif
+	return 0;
+}
+
+/*! \brief encode and produce a frame */
+static struct ast_frame *lintoamr_frameout(struct ast_trans_pvt *pvt)
+{
+	struct amr_translator_pvt *tmp = pvt->pvt;
+	int datalen = 0, samples = 0, npad, h_offset, d_offset;
+	int pbits = 0, sbits = 0; /* header and body bit count */
+	unsigned char buffer[AMR_MAX_FRAME_LEN+1], cmr = tmp->enc_mode, toc_entry, *phdr, *pdata;
+	const unsigned char xzero = 0;
+
+	/* We can't work on anything less than a frame in size */
+	if (pvt->samples < AMR_SAMPLES)
+		return NULL;
+
+#if 0
+	ast_verbose("lintoamr_frameout: %d samples\n", pvt->samples);
+#endif
+
+	/* First, put the CMR into the header. */
+	cmr <<= 4; /* Put in higher order nibble. */
+	phdr = pvt->outbuf.uc;	
+	pdata = tmp->speech_bits;
+	d_offset = h_offset = 7;
+	h_offset = pack_bits(&phdr, h_offset, &cmr, octet_aligned ? 8 : 4);
+	pbits += octet_aligned ? 8 : 4;
+#if 0
+	memset(tmp->speech_bits, 0, sizeof tmp->speech_bits);
+	memset(buffer, 0, sizeof buffer);
+#endif
+	while (pvt->samples >= AMR_SAMPLES) {	     
+		unsigned int mode, bits, q;
+		/* Encode a frame of data */
+		Encoder_Interface_Encode(tmp->enstate, tmp->enc_mode, 
+							  tmp->buf + samples, 
+							  buffer, 0);
+
+		
+		samples += AMR_SAMPLES;
+		pvt->samples -= AMR_SAMPLES;
+		
+		mode = (buffer[0]>>3)&0x0F; 
+		q = (buffer[0]>>2)&0x01;
+		
+		toc_entry = (mode<<3) | (q<<2);
+
+		bits = octet_aligned ? (num_bits[mode]+7)&~7 : num_bits[mode];
+		
+		/* Set the F bit */
+		if (pvt->samples >= AMR_SAMPLES) /* then we have another frame to  pack, so... */
+			toc_entry |= (1<<7);
+		h_offset = pack_bits(&phdr, h_offset, 
+				     &toc_entry, octet_aligned ? 8 : 6); /* put in the table of contents element. */
+		pbits += octet_aligned ? 8 : 6;
+		
+
+		/* Pack the bits of the speech. */
+		d_offset = pack_bits(&pdata, d_offset, &buffer[1], bits);
+		sbits += bits;	
+#if 0
+		ast_verbose("lin2amr[1]: mode=%d,q=%d,enc_mode=%d,byte_count=%d,bits=%d,more=%d\n",
+			    mode, q, tmp->enc_mode,byte_count,bits, 
+			    toc_entry & (1<<7) ? 1 : 0); 	
+#endif
+	}
+	
+        /* CMR+TOC  is already in outbuf. So: Add speech bits */
+	
+	h_offset = pack_bits(&phdr, h_offset, tmp->speech_bits, sbits);
+	npad = (8 - ((sbits + pbits) & 7))&0x7; /* Number of padding bits */
+
+	if (octet_aligned && npad != 0)
+		ast_log(LOG_ERROR,"Padding bits cannot be > 0 in octet aligned mode!\n");
+	
+	pack_bits(&phdr, h_offset, (void *)&xzero, npad); /* zero out the rest of the padding bits. */
+	datalen = (sbits + pbits + npad + 7)/8; /* Round up to nearest octet. */
+	
+#if 0
+	ast_verbose("lin2amr: toc_bit_count=%d,body_bit_count=%d, npad=%d,p[0]=0X%02hhX,p[1]=0X%02hhX,data_len=%d\n", 
+		    pbits, sbits, npad, (unsigned)pvt->outbuf.uc[0], (unsigned)pvt->outbuf.uc[1], datalen); 
+#endif
+	/* Move the data at the end of the buffer to the front */
+	if (pvt->samples)
+		memmove(tmp->buf, tmp->buf + samples, pvt->samples * 2);
+	
+	return ast_trans_frameout(pvt, datalen, samples);
+}
+
+static void amr_destroy_stuff(struct ast_trans_pvt *pvt)
+{
+	struct amr_translator_pvt *tmp = pvt->pvt;
+	Encoder_Interface_exit(tmp->enstate);
+	Decoder_Interface_exit(tmp->destate);
+}
+
+static struct ast_translator amrtolin = {
+	.name = "amrtolin", 
+	.srcfmt = AST_FORMAT_AMRNB,
+	.dstfmt = AST_FORMAT_SLINEAR,
+	.newpvt = amr_new,
+	.framein = amrtolin_framein,
+	.destroy = amr_destroy_stuff,
+	.sample = amrtolin_sample,
+	.buffer_samples = BUFFER_SAMPLES,
+	.buf_size = BUFFER_SAMPLES * 2,
+	.desc_size = sizeof (struct amr_translator_pvt )
+};
+
+static struct ast_translator lintoamr = {
+	.name = "lintoamr", 
+	.srcfmt = AST_FORMAT_SLINEAR,
+	.dstfmt = AST_FORMAT_AMRNB,
+	.newpvt = amr_new,
+	.framein = lintoamr_framein,
+	.frameout = lintoamr_frameout,
+	.destroy = amr_destroy_stuff,
+	.sample = slin16_sample,
+	.desc_size = sizeof (struct amr_translator_pvt ),
+	.buf_size = (BUFFER_SAMPLES * AMR_MAX_FRAME_LEN + AMR_SAMPLES - 1)/AMR_SAMPLES,
+};
+
+
+static int parse_config(int reload)
+{    
+	struct ast_variable *var;
+	struct ast_flags config_flags = { reload ? CONFIG_FLAG_FILEUNCHANGED : 0 };
+	struct ast_config *cfg = ast_config_load("codecs.conf", config_flags);
+
+	if (cfg == CONFIG_STATUS_FILEMISSING || cfg == CONFIG_STATUS_FILEUNCHANGED || cfg == CONFIG_STATUS_FILEINVALID)
+		return 0;
+	for (var = ast_variable_browse(cfg, "amr"); var; var = var->next) {
+	     if (!strcasecmp(var->name, "octet-aligned")) {
+		  octet_aligned = atoi(var->value);
+		  if (option_verbose > 2)
+			  ast_verbose(VERBOSE_PREFIX_3 "codec_amr: octet-align mode set to %d\n", octet_aligned);
+	     } else if (!strcasecmp(var->name, "dtx")) {
+		  dtx = atoi(var->value);
+		  if (option_verbose > 2)
+		       ast_verbose(VERBOSE_PREFIX_3 "codec_amr: set dtx mode to %d\n", dtx);
+	     } else if (!strcasecmp(var->name, "mode")) {
+		  int mode_tmp = strtol(var->value + 2, NULL, 10);
+		  int req_mode;
+		  for (req_mode = 0; req_mode < 8; req_mode++)
+		       if (mode_tmp == modeConv[req_mode])
+			    break;
+		  if (req_mode == 8) {
+		       ast_log(LOG_ERROR, "Error, unknown mode %s. Must be one of MR475, MR515, MR59, MR67, MR74, MR795, MR102, MR122\n",
+			       var->value);
+		  } else {
+		       enc_mode = req_mode;
+		       if (option_verbose > 2)
+			    ast_verbose(VERBOSE_PREFIX_3 "codec_amr: AMR mode set to MR%d\n", mode_tmp);
+		  }
+	       }
+	}
+	ast_config_destroy(cfg);
+	ast_verbose("codec_amr: enc_mode = %d, dtx = %d\n", enc_mode, dtx);
+
+	return 0;
+}
+
+/*! \brief standard module glue */
+static int reload(void)
+{
+	if (parse_config(1))
+		return AST_MODULE_LOAD_DECLINE;
+	return AST_MODULE_LOAD_SUCCESS;
+}
+
+static int unload_module(void)
+{
+	int res;
+
+	res = ast_unregister_translator(&lintoamr);
+	if (!res)
+		res = ast_unregister_translator(&amrtolin);
+
+	return res;
+}
+
+static int load_module(void)
+{
+	int res;
+
+	if (parse_config(0))
+		return AST_MODULE_LOAD_DECLINE;
+
+	res = ast_register_translator(&amrtolin);
+	if (!res) 
+		res=ast_register_translator(&lintoamr);
+	else
+		ast_unregister_translator(&amrtolin);
+
+	if (res)
+		return AST_MODULE_LOAD_FAILURE;
+	return AST_MODULE_LOAD_SUCCESS;
+}
+
+AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_DEFAULT, "AMR Coder/Decoder",
+		.load = load_module,
+		.unload = unload_module,
+		.reload = reload,
+	       );
+
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/anaFilter.c asterisk-1.8.3.2_com_amr/codecs/ilbc/anaFilter.c
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/anaFilter.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/anaFilter.c	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,72 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       anaFilter.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <string.h>
+   #include "iLBC_define.h"
+
+   /*----------------------------------------------------------------*
+    *  LP analysis filter.
+    *---------------------------------------------------------------*/
+
+   void anaFilter(
+       float *In,  /* (i) Signal to be filtered */
+       float *a,   /* (i) LP parameters */
+       int len,/* (i) Length of signal */
+       float *Out, /* (o) Filtered signal */
+       float *mem  /* (i/o) Filter state */
+   ){
+       int i, j;
+       float *po, *pi, *pm, *pa;
+
+       po = Out;
+
+       /* Filter first part using memory from past */
+
+       for (i=0; i<LPC_FILTERORDER; i++) {
+           pi = &In[i];
+           pm = &mem[LPC_FILTERORDER-1];
+           pa = a;
+           *po=0.0;
+
+
+
+
+
+           for (j=0; j<=i; j++) {
+               *po+=(*pa++)*(*pi--);
+           }
+           for (j=i+1; j<LPC_FILTERORDER+1; j++) {
+
+               *po+=(*pa++)*(*pm--);
+           }
+           po++;
+       }
+
+       /* Filter last part where the state is entirely
+          in the input vector */
+
+       for (i=LPC_FILTERORDER; i<len; i++) {
+           pi = &In[i];
+           pa = a;
+           *po=0.0;
+           for (j=0; j<LPC_FILTERORDER+1; j++) {
+               *po+=(*pa++)*(*pi--);
+           }
+           po++;
+       }
+
+       /* Update state vector */
+
+       memcpy(mem, &In[len-LPC_FILTERORDER],
+           LPC_FILTERORDER*sizeof(float));
+   }
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/anaFilter.h asterisk-1.8.3.2_com_amr/codecs/ilbc/anaFilter.h
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/anaFilter.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/anaFilter.h	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,30 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       anaFilter.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_ANAFILTER_H
+   #define __iLBC_ANAFILTER_H
+
+   void anaFilter(
+
+
+
+
+
+       float *In,  /* (i) Signal to be filtered */
+       float *a,   /* (i) LP parameters */
+       int len,/* (i) Length of signal */
+       float *Out, /* (o) Filtered signal */
+       float *mem  /* (i/o) Filter state */
+   );
+
+   #endif
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/constants.c asterisk-1.8.3.2_com_amr/codecs/ilbc/constants.c
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/constants.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/constants.c	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,770 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       constants.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include "iLBC_define.h"
+
+   /* ULP bit allocation */
+
+       /* 20 ms frame */
+
+   const iLBC_ULP_Inst_t ULP_20msTbl = {
+       /* LSF */
+       {   {6,0,0,0,0}, {7,0,0,0,0}, {7,0,0,0,0},
+           {0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}},
+       /* Start state location, gain and samples */
+       {2,0,0,0,0},
+       {1,0,0,0,0},
+       {6,0,0,0,0},
+       {0,1,2,0,0},
+       /* extra CB index and extra CB gain */
+       {{6,0,1,0,0}, {0,0,7,0,0}, {0,0,7,0,0}},
+       {{2,0,3,0,0}, {1,1,2,0,0}, {0,0,3,0,0}},
+       /* CB index and CB gain */
+       {   {{7,0,1,0,0}, {0,0,7,0,0}, {0,0,7,0,0}},
+           {{0,0,8,0,0}, {0,0,8,0,0}, {0,0,8,0,0}},
+           {{0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}},
+           {{0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}}},
+       {   {{1,2,2,0,0}, {1,1,2,0,0}, {0,0,3,0,0}},
+           {{1,1,3,0,0}, {0,2,2,0,0}, {0,0,3,0,0}},
+           {{0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}},
+           {{0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}}}
+   };
+
+       /* 30 ms frame */
+
+   const iLBC_ULP_Inst_t ULP_30msTbl = {
+       /* LSF */
+
+
+
+
+
+       {   {6,0,0,0,0}, {7,0,0,0,0}, {7,0,0,0,0},
+           {6,0,0,0,0}, {7,0,0,0,0}, {7,0,0,0,0}},
+       /* Start state location, gain and samples */
+       {3,0,0,0,0},
+       {1,0,0,0,0},
+       {6,0,0,0,0},
+       {0,1,2,0,0},
+       /* extra CB index and extra CB gain */
+       {{4,2,1,0,0}, {0,0,7,0,0}, {0,0,7,0,0}},
+       {{1,1,3,0,0}, {1,1,2,0,0}, {0,0,3,0,0}},
+       /* CB index and CB gain */
+       {   {{6,1,1,0,0}, {0,0,7,0,0}, {0,0,7,0,0}},
+           {{0,7,1,0,0}, {0,0,8,0,0}, {0,0,8,0,0}},
+           {{0,7,1,0,0}, {0,0,8,0,0}, {0,0,8,0,0}},
+           {{0,7,1,0,0}, {0,0,8,0,0}, {0,0,8,0,0}}},
+       {   {{1,2,2,0,0}, {1,2,1,0,0}, {0,0,3,0,0}},
+           {{0,2,3,0,0}, {0,2,2,0,0}, {0,0,3,0,0}},
+           {{0,1,4,0,0}, {0,1,3,0,0}, {0,0,3,0,0}},
+           {{0,1,4,0,0}, {0,1,3,0,0}, {0,0,3,0,0}}}
+   };
+
+   /* HP Filters */
+
+   float hpi_zero_coefsTbl[3] = {
+       (float)0.92727436, (float)-1.8544941, (float)0.92727436
+   };
+   float hpi_pole_coefsTbl[3] = {
+       (float)1.0, (float)-1.9059465, (float)0.9114024
+   };
+   float hpo_zero_coefsTbl[3] = {
+       (float)0.93980581, (float)-1.8795834, (float)0.93980581
+   };
+   float hpo_pole_coefsTbl[3] = {
+       (float)1.0, (float)-1.9330735, (float)0.93589199
+   };
+
+   /* LP Filter */
+
+   float lpFilt_coefsTbl[FILTERORDER_DS]={
+       (float)-0.066650, (float)0.125000, (float)0.316650,
+       (float)0.414063, (float)0.316650,
+       (float)0.125000, (float)-0.066650
+   };
+
+   /* State quantization tables */
+
+   float state_sq3Tbl[8] = {
+       (float)-3.719849, (float)-2.177490, (float)-1.130005,
+
+
+
+
+
+       (float)-0.309692, (float)0.444214, (float)1.329712,
+       (float)2.436279, (float)3.983887
+   };
+
+   float state_frgqTbl[64] = {
+       (float)1.000085, (float)1.071695, (float)1.140395,
+       (float)1.206868, (float)1.277188, (float)1.351503,
+       (float)1.429380, (float)1.500727, (float)1.569049,
+       (float)1.639599, (float)1.707071, (float)1.781531,
+       (float)1.840799, (float)1.901550, (float)1.956695,
+       (float)2.006750, (float)2.055474, (float)2.102787,
+       (float)2.142819, (float)2.183592, (float)2.217962,
+       (float)2.257177, (float)2.295739, (float)2.332967,
+       (float)2.369248, (float)2.402792, (float)2.435080,
+       (float)2.468598, (float)2.503394, (float)2.539284,
+       (float)2.572944, (float)2.605036, (float)2.636331,
+       (float)2.668939, (float)2.698780, (float)2.729101,
+       (float)2.759786, (float)2.789834, (float)2.818679,
+       (float)2.848074, (float)2.877470, (float)2.906899,
+       (float)2.936655, (float)2.967804, (float)3.000115,
+       (float)3.033367, (float)3.066355, (float)3.104231,
+       (float)3.141499, (float)3.183012, (float)3.222952,
+       (float)3.265433, (float)3.308441, (float)3.350823,
+       (float)3.395275, (float)3.442793, (float)3.490801,
+       (float)3.542514, (float)3.604064, (float)3.666050,
+       (float)3.740994, (float)3.830749, (float)3.938770,
+       (float)4.101764
+   };
+
+   /* CB tables */
+
+   int search_rangeTbl[5][CB_NSTAGES]={{58,58,58}, {108,44,44},
+               {108,108,108}, {108,108,108}, {108,108,108}};
+   int stMemLTbl=85;
+   int memLfTbl[NASUB_MAX]={147,147,147,147};
+
+   /* expansion filter(s) */
+
+   float cbfiltersTbl[CB_FILTERLEN]={
+       (float)-0.034180, (float)0.108887, (float)-0.184326,
+       (float)0.806152,  (float)0.713379, (float)-0.144043,
+       (float)0.083740,  (float)-0.033691
+   };
+
+   /* Gain Quantization */
+
+   float gain_sq3Tbl[8]={
+       (float)-1.000000,  (float)-0.659973,  (float)-0.330017,
+
+
+
+
+
+       (float)0.000000, (float)0.250000, (float)0.500000,
+       (float)0.750000, (float)1.00000};
+
+   float gain_sq4Tbl[16]={
+       (float)-1.049988, (float)-0.900024, (float)-0.750000,
+       (float)-0.599976, (float)-0.450012, (float)-0.299988,
+       (float)-0.150024, (float)0.000000, (float)0.150024,
+       (float)0.299988, (float)0.450012, (float)0.599976,
+       (float)0.750000, (float)0.900024, (float)1.049988,
+       (float)1.200012};
+
+   float gain_sq5Tbl[32]={
+       (float)0.037476, (float)0.075012, (float)0.112488,
+       (float)0.150024, (float)0.187500, (float)0.224976,
+       (float)0.262512, (float)0.299988, (float)0.337524,
+       (float)0.375000, (float)0.412476, (float)0.450012,
+       (float)0.487488, (float)0.525024, (float)0.562500,
+       (float)0.599976, (float)0.637512, (float)0.674988,
+       (float)0.712524, (float)0.750000, (float)0.787476,
+       (float)0.825012, (float)0.862488, (float)0.900024,
+       (float)0.937500, (float)0.974976, (float)1.012512,
+       (float)1.049988, (float)1.087524, (float)1.125000,
+       (float)1.162476, (float)1.200012};
+
+   /* Enhancer - Upsamling a factor 4 (ENH_UPS0 = 4) */
+   float polyphaserTbl[ENH_UPS0*(2*ENH_FL0+1)]={
+       (float)0.000000, (float)0.000000, (float)0.000000,
+   (float)1.000000,
+           (float)0.000000, (float)0.000000, (float)0.000000,
+       (float)0.015625, (float)-0.076904, (float)0.288330,
+   (float)0.862061,
+           (float)-0.106445, (float)0.018799, (float)-0.015625,
+       (float)0.023682, (float)-0.124268, (float)0.601563,
+   (float)0.601563,
+           (float)-0.124268, (float)0.023682, (float)-0.023682,
+       (float)0.018799, (float)-0.106445, (float)0.862061,
+   (float)0.288330,
+           (float)-0.076904, (float)0.015625, (float)-0.018799};
+
+   float enh_plocsTbl[ENH_NBLOCKS_TOT] = {(float)40.0, (float)120.0,
+               (float)200.0, (float)280.0, (float)360.0,
+               (float)440.0, (float)520.0, (float)600.0};
+
+   /* LPC analysis and quantization */
+
+   int dim_lsfCbTbl[LSF_NSPLIT] = {3, 3, 4};
+   int size_lsfCbTbl[LSF_NSPLIT] = {64,128,128};
+
+
+
+
+
+
+   float lsfmeanTbl[LPC_FILTERORDER] = {
+       (float)0.281738, (float)0.445801, (float)0.663330,
+       (float)0.962524, (float)1.251831, (float)1.533081,
+       (float)1.850586, (float)2.137817, (float)2.481445,
+       (float)2.777344};
+
+   float lsf_weightTbl_30ms[6] = {(float)(1.0/2.0), (float)1.0,
+   (float)(2.0/3.0),
+       (float)(1.0/3.0), (float)0.0, (float)0.0};
+
+   float lsf_weightTbl_20ms[4] = {(float)(3.0/4.0), (float)(2.0/4.0),
+       (float)(1.0/4.0), (float)(0.0)};
+
+   /* Hanning LPC window */
+   float lpc_winTbl[BLOCKL_MAX]={
+       (float)0.000183, (float)0.000671, (float)0.001526,
+       (float)0.002716, (float)0.004242, (float)0.006104,
+       (float)0.008301, (float)0.010834, (float)0.013702,
+       (float)0.016907, (float)0.020416, (float)0.024261,
+       (float)0.028442, (float)0.032928, (float)0.037750,
+       (float)0.042877, (float)0.048309, (float)0.054047,
+       (float)0.060089, (float)0.066437, (float)0.073090,
+       (float)0.080017, (float)0.087219, (float)0.094727,
+       (float)0.102509, (float)0.110535, (float)0.118835,
+       (float)0.127411, (float)0.136230, (float)0.145294,
+       (float)0.154602, (float)0.164154, (float)0.173920,
+       (float)0.183899, (float)0.194122, (float)0.204529,
+       (float)0.215149, (float)0.225952, (float)0.236938,
+       (float)0.248108, (float)0.259460, (float)0.270966,
+       (float)0.282654, (float)0.294464, (float)0.306396,
+       (float)0.318481, (float)0.330688, (float)0.343018,
+       (float)0.355438, (float)0.367981, (float)0.380585,
+       (float)0.393280, (float)0.406067, (float)0.418884,
+       (float)0.431763, (float)0.444702, (float)0.457672,
+       (float)0.470673, (float)0.483704, (float)0.496735,
+       (float)0.509766, (float)0.522797, (float)0.535828,
+       (float)0.548798, (float)0.561768, (float)0.574677,
+       (float)0.587524, (float)0.600342, (float)0.613068,
+       (float)0.625732, (float)0.638306, (float)0.650787,
+       (float)0.663147, (float)0.675415, (float)0.687561,
+       (float)0.699585, (float)0.711487, (float)0.723206,
+       (float)0.734802, (float)0.746216, (float)0.757477,
+       (float)0.768585, (float)0.779480, (float)0.790192,
+       (float)0.800720, (float)0.811005, (float)0.821106,
+       (float)0.830994, (float)0.840668, (float)0.850067,
+       (float)0.859253, (float)0.868225, (float)0.876892,
+       (float)0.885345, (float)0.893524, (float)0.901428,
+       (float)0.909058, (float)0.916412, (float)0.923492,
+
+
+
+
+
+       (float)0.930267, (float)0.936768, (float)0.942963,
+       (float)0.948853, (float)0.954437, (float)0.959717,
+       (float)0.964691, (float)0.969360, (float)0.973694,
+       (float)0.977692, (float)0.981384, (float)0.984741,
+       (float)0.987762, (float)0.990479, (float)0.992828,
+       (float)0.994873, (float)0.996552, (float)0.997925,
+       (float)0.998932, (float)0.999603, (float)0.999969,
+       (float)0.999969, (float)0.999603, (float)0.998932,
+       (float)0.997925, (float)0.996552, (float)0.994873,
+       (float)0.992828, (float)0.990479, (float)0.987762,
+       (float)0.984741, (float)0.981384, (float)0.977692,
+       (float)0.973694, (float)0.969360, (float)0.964691,
+       (float)0.959717, (float)0.954437, (float)0.948853,
+       (float)0.942963, (float)0.936768, (float)0.930267,
+       (float)0.923492, (float)0.916412, (float)0.909058,
+       (float)0.901428, (float)0.893524, (float)0.885345,
+       (float)0.876892, (float)0.868225, (float)0.859253,
+       (float)0.850067, (float)0.840668, (float)0.830994,
+       (float)0.821106, (float)0.811005, (float)0.800720,
+       (float)0.790192, (float)0.779480, (float)0.768585,
+       (float)0.757477, (float)0.746216, (float)0.734802,
+       (float)0.723206, (float)0.711487, (float)0.699585,
+       (float)0.687561, (float)0.675415, (float)0.663147,
+       (float)0.650787, (float)0.638306, (float)0.625732,
+       (float)0.613068, (float)0.600342, (float)0.587524,
+       (float)0.574677, (float)0.561768, (float)0.548798,
+       (float)0.535828, (float)0.522797, (float)0.509766,
+       (float)0.496735, (float)0.483704, (float)0.470673,
+       (float)0.457672, (float)0.444702, (float)0.431763,
+       (float)0.418884, (float)0.406067, (float)0.393280,
+       (float)0.380585, (float)0.367981, (float)0.355438,
+       (float)0.343018, (float)0.330688, (float)0.318481,
+       (float)0.306396, (float)0.294464, (float)0.282654,
+       (float)0.270966, (float)0.259460, (float)0.248108,
+       (float)0.236938, (float)0.225952, (float)0.215149,
+       (float)0.204529, (float)0.194122, (float)0.183899,
+       (float)0.173920, (float)0.164154, (float)0.154602,
+       (float)0.145294, (float)0.136230, (float)0.127411,
+       (float)0.118835, (float)0.110535, (float)0.102509,
+       (float)0.094727, (float)0.087219, (float)0.080017,
+       (float)0.073090, (float)0.066437, (float)0.060089,
+       (float)0.054047, (float)0.048309, (float)0.042877,
+       (float)0.037750, (float)0.032928, (float)0.028442,
+       (float)0.024261, (float)0.020416, (float)0.016907,
+       (float)0.013702, (float)0.010834, (float)0.008301,
+       (float)0.006104, (float)0.004242, (float)0.002716,
+       (float)0.001526, (float)0.000671, (float)0.000183
+   };
+
+
+
+
+
+   /* Asymmetric LPC window */
+   float lpc_asymwinTbl[BLOCKL_MAX]={
+       (float)0.000061, (float)0.000214, (float)0.000458,
+       (float)0.000824, (float)0.001282, (float)0.001831,
+       (float)0.002472, (float)0.003235, (float)0.004120,
+       (float)0.005066, (float)0.006134, (float)0.007294,
+       (float)0.008545, (float)0.009918, (float)0.011383,
+       (float)0.012939, (float)0.014587, (float)0.016357,
+       (float)0.018219, (float)0.020172, (float)0.022217,
+       (float)0.024353, (float)0.026611, (float)0.028961,
+       (float)0.031372, (float)0.033905, (float)0.036530,
+       (float)0.039276, (float)0.042084, (float)0.044983,
+       (float)0.047974, (float)0.051086, (float)0.054260,
+       (float)0.057526, (float)0.060883, (float)0.064331,
+       (float)0.067871, (float)0.071503, (float)0.075226,
+       (float)0.079010, (float)0.082916, (float)0.086884,
+       (float)0.090942, (float)0.095062, (float)0.099304,
+       (float)0.103607, (float)0.107971, (float)0.112427,
+       (float)0.116974, (float)0.121582, (float)0.126282,
+       (float)0.131073, (float)0.135895, (float)0.140839,
+       (float)0.145813, (float)0.150879, (float)0.156006,
+       (float)0.161224, (float)0.166504, (float)0.171844,
+       (float)0.177246, (float)0.182709, (float)0.188263,
+       (float)0.193848, (float)0.199524, (float)0.205231,
+       (float)0.211029, (float)0.216858, (float)0.222778,
+       (float)0.228729, (float)0.234741, (float)0.240814,
+       (float)0.246918, (float)0.253082, (float)0.259308,
+       (float)0.265564, (float)0.271881, (float)0.278259,
+       (float)0.284668, (float)0.291107, (float)0.297607,
+       (float)0.304138, (float)0.310730, (float)0.317322,
+       (float)0.323975, (float)0.330658, (float)0.337372,
+       (float)0.344147, (float)0.350922, (float)0.357727,
+       (float)0.364594, (float)0.371460, (float)0.378357,
+       (float)0.385284, (float)0.392212, (float)0.399170,
+       (float)0.406158, (float)0.413177, (float)0.420197,
+       (float)0.427246, (float)0.434296, (float)0.441376,
+       (float)0.448456, (float)0.455536, (float)0.462646,
+       (float)0.469757, (float)0.476868, (float)0.483978,
+       (float)0.491089, (float)0.498230, (float)0.505341,
+       (float)0.512451, (float)0.519592, (float)0.526703,
+       (float)0.533813, (float)0.540924, (float)0.548004,
+       (float)0.555084, (float)0.562164, (float)0.569244,
+       (float)0.576294, (float)0.583313, (float)0.590332,
+       (float)0.597321, (float)0.604309, (float)0.611267,
+       (float)0.618195, (float)0.625092, (float)0.631989,
+       (float)0.638855, (float)0.645660, (float)0.652466,
+       (float)0.659241, (float)0.665985, (float)0.672668,
+       (float)0.679352, (float)0.685974, (float)0.692566,
+
+
+
+
+
+       (float)0.699127, (float)0.705658, (float)0.712128,
+       (float)0.718536, (float)0.724945, (float)0.731262,
+       (float)0.737549, (float)0.743805, (float)0.750000,
+       (float)0.756134, (float)0.762238, (float)0.768280,
+       (float)0.774261, (float)0.780182, (float)0.786072,
+       (float)0.791870, (float)0.797638, (float)0.803314,
+       (float)0.808960, (float)0.814514, (float)0.820038,
+       (float)0.825470, (float)0.830841, (float)0.836151,
+       (float)0.841400, (float)0.846558, (float)0.851654,
+       (float)0.856689, (float)0.861633, (float)0.866516,
+       (float)0.871338, (float)0.876068, (float)0.880737,
+       (float)0.885315, (float)0.889801, (float)0.894226,
+       (float)0.898560, (float)0.902832, (float)0.907013,
+       (float)0.911102, (float)0.915100, (float)0.919037,
+       (float)0.922882, (float)0.926636, (float)0.930328,
+       (float)0.933899, (float)0.937408, (float)0.940796,
+       (float)0.944122, (float)0.947357, (float)0.950470,
+       (float)0.953522, (float)0.956482, (float)0.959351,
+       (float)0.962097, (float)0.964783, (float)0.967377,
+       (float)0.969849, (float)0.972229, (float)0.974518,
+       (float)0.976715, (float)0.978821, (float)0.980835,
+       (float)0.982727, (float)0.984528, (float)0.986237,
+       (float)0.987854, (float)0.989380, (float)0.990784,
+       (float)0.992096, (float)0.993317, (float)0.994415,
+       (float)0.995422, (float)0.996338, (float)0.997162,
+       (float)0.997864, (float)0.998474, (float)0.998962,
+       (float)0.999390, (float)0.999695, (float)0.999878,
+       (float)0.999969, (float)0.999969, (float)0.996918,
+       (float)0.987701, (float)0.972382, (float)0.951050,
+       (float)0.923889, (float)0.891022, (float)0.852631,
+       (float)0.809021, (float)0.760406, (float)0.707092,
+       (float)0.649445, (float)0.587799, (float)0.522491,
+       (float)0.453979, (float)0.382690, (float)0.309021,
+       (float)0.233459, (float)0.156433, (float)0.078461
+   };
+
+   /* Lag window for LPC */
+   float lpc_lagwinTbl[LPC_FILTERORDER + 1]={
+       (float)1.000100, (float)0.998890, (float)0.995569,
+           (float)0.990057, (float)0.982392,
+       (float)0.972623, (float)0.960816, (float)0.947047,
+           (float)0.931405, (float)0.913989, (float)0.894909};
+
+   /* LSF quantization*/
+   float lsfCbTbl[64 * 3 + 128 * 3 + 128 * 4] = {
+   (float)0.155396, (float)0.273193, (float)0.451172,
+   (float)0.390503, (float)0.648071, (float)1.002075,
+   (float)0.440186, (float)0.692261, (float)0.955688,
+
+
+
+
+
+   (float)0.343628, (float)0.642334, (float)1.071533,
+   (float)0.318359, (float)0.491577, (float)0.670532,
+   (float)0.193115, (float)0.375488, (float)0.725708,
+   (float)0.364136, (float)0.510376, (float)0.658691,
+   (float)0.297485, (float)0.527588, (float)0.842529,
+   (float)0.227173, (float)0.365967, (float)0.563110,
+   (float)0.244995, (float)0.396729, (float)0.636475,
+   (float)0.169434, (float)0.300171, (float)0.520264,
+   (float)0.312866, (float)0.464478, (float)0.643188,
+   (float)0.248535, (float)0.429932, (float)0.626099,
+   (float)0.236206, (float)0.491333, (float)0.817139,
+   (float)0.334961, (float)0.625122, (float)0.895752,
+   (float)0.343018, (float)0.518555, (float)0.698608,
+   (float)0.372803, (float)0.659790, (float)0.945435,
+   (float)0.176880, (float)0.316528, (float)0.581421,
+   (float)0.416382, (float)0.625977, (float)0.805176,
+   (float)0.303223, (float)0.568726, (float)0.915039,
+   (float)0.203613, (float)0.351440, (float)0.588135,
+   (float)0.221191, (float)0.375000, (float)0.614746,
+   (float)0.199951, (float)0.323364, (float)0.476074,
+   (float)0.300781, (float)0.433350, (float)0.566895,
+   (float)0.226196, (float)0.354004, (float)0.507568,
+   (float)0.300049, (float)0.508179, (float)0.711670,
+   (float)0.312012, (float)0.492676, (float)0.763428,
+   (float)0.329956, (float)0.541016, (float)0.795776,
+   (float)0.373779, (float)0.604614, (float)0.928833,
+   (float)0.210571, (float)0.452026, (float)0.755249,
+   (float)0.271118, (float)0.473267, (float)0.662476,
+   (float)0.285522, (float)0.436890, (float)0.634399,
+   (float)0.246704, (float)0.565552, (float)0.859009,
+   (float)0.270508, (float)0.406250, (float)0.553589,
+   (float)0.361450, (float)0.578491, (float)0.813843,
+   (float)0.342651, (float)0.482788, (float)0.622437,
+   (float)0.340332, (float)0.549438, (float)0.743164,
+   (float)0.200439, (float)0.336304, (float)0.540894,
+   (float)0.407837, (float)0.644775, (float)0.895142,
+   (float)0.294678, (float)0.454834, (float)0.699097,
+   (float)0.193115, (float)0.344482, (float)0.643188,
+   (float)0.275757, (float)0.420776, (float)0.598755,
+   (float)0.380493, (float)0.608643, (float)0.861084,
+   (float)0.222778, (float)0.426147, (float)0.676514,
+   (float)0.407471, (float)0.700195, (float)1.053101,
+   (float)0.218384, (float)0.377197, (float)0.669922,
+   (float)0.313232, (float)0.454102, (float)0.600952,
+   (float)0.347412, (float)0.571533, (float)0.874146,
+   (float)0.238037, (float)0.405396, (float)0.729492,
+   (float)0.223877, (float)0.412964, (float)0.822021,
+   (float)0.395264, (float)0.582153, (float)0.743896,
+
+
+
+
+
+   (float)0.247925, (float)0.485596, (float)0.720581,
+   (float)0.229126, (float)0.496582, (float)0.907715,
+   (float)0.260132, (float)0.566895, (float)1.012695,
+   (float)0.337402, (float)0.611572, (float)0.978149,
+   (float)0.267822, (float)0.447632, (float)0.769287,
+   (float)0.250610, (float)0.381714, (float)0.530029,
+   (float)0.430054, (float)0.805054, (float)1.221924,
+   (float)0.382568, (float)0.544067, (float)0.701660,
+   (float)0.383545, (float)0.710327, (float)1.149170,
+   (float)0.271362, (float)0.529053, (float)0.775513,
+   (float)0.246826, (float)0.393555, (float)0.588623,
+   (float)0.266846, (float)0.422119, (float)0.676758,
+   (float)0.311523, (float)0.580688, (float)0.838623,
+   (float)1.331177, (float)1.576782, (float)1.779541,
+   (float)1.160034, (float)1.401978, (float)1.768188,
+   (float)1.161865, (float)1.525146, (float)1.715332,
+   (float)0.759521, (float)0.913940, (float)1.119873,
+   (float)0.947144, (float)1.121338, (float)1.282471,
+   (float)1.015015, (float)1.557007, (float)1.804932,
+   (float)1.172974, (float)1.402100, (float)1.692627,
+   (float)1.087524, (float)1.474243, (float)1.665405,
+   (float)0.899536, (float)1.105225, (float)1.406250,
+   (float)1.148438, (float)1.484741, (float)1.796265,
+   (float)0.785645, (float)1.209839, (float)1.567749,
+   (float)0.867798, (float)1.166504, (float)1.450684,
+   (float)0.922485, (float)1.229858, (float)1.420898,
+   (float)0.791260, (float)1.123291, (float)1.409546,
+   (float)0.788940, (float)0.966064, (float)1.340332,
+   (float)1.051147, (float)1.272827, (float)1.556641,
+   (float)0.866821, (float)1.181152, (float)1.538818,
+   (float)0.906738, (float)1.373535, (float)1.607910,
+   (float)1.244751, (float)1.581421, (float)1.933838,
+   (float)0.913940, (float)1.337280, (float)1.539673,
+   (float)0.680542, (float)0.959229, (float)1.662720,
+   (float)0.887207, (float)1.430542, (float)1.800781,
+   (float)0.912598, (float)1.433594, (float)1.683960,
+   (float)0.860474, (float)1.060303, (float)1.455322,
+   (float)1.005127, (float)1.381104, (float)1.706909,
+   (float)0.800781, (float)1.363892, (float)1.829102,
+   (float)0.781860, (float)1.124390, (float)1.505981,
+   (float)1.003662, (float)1.471436, (float)1.684692,
+   (float)0.981323, (float)1.309570, (float)1.618042,
+   (float)1.228760, (float)1.554321, (float)1.756470,
+   (float)0.734375, (float)0.895752, (float)1.225586,
+   (float)0.841797, (float)1.055664, (float)1.249268,
+   (float)0.920166, (float)1.119385, (float)1.486206,
+   (float)0.894409, (float)1.539063, (float)1.828979,
+   (float)1.283691, (float)1.543335, (float)1.858276,
+
+
+
+
+
+   (float)0.676025, (float)0.933105, (float)1.490845,
+   (float)0.821289, (float)1.491821, (float)1.739868,
+   (float)0.923218, (float)1.144653, (float)1.580566,
+   (float)1.057251, (float)1.345581, (float)1.635864,
+   (float)0.888672, (float)1.074951, (float)1.353149,
+   (float)0.942749, (float)1.195435, (float)1.505493,
+   (float)1.492310, (float)1.788086, (float)2.039673,
+   (float)1.070313, (float)1.634399, (float)1.860962,
+   (float)1.253296, (float)1.488892, (float)1.686035,
+   (float)0.647095, (float)0.864014, (float)1.401855,
+   (float)0.866699, (float)1.254883, (float)1.453369,
+   (float)1.063965, (float)1.532593, (float)1.731323,
+   (float)1.167847, (float)1.521484, (float)1.884033,
+   (float)0.956055, (float)1.502075, (float)1.745605,
+   (float)0.928711, (float)1.288574, (float)1.479614,
+   (float)1.088013, (float)1.380737, (float)1.570801,
+   (float)0.905029, (float)1.186768, (float)1.371948,
+   (float)1.057861, (float)1.421021, (float)1.617432,
+   (float)1.108276, (float)1.312500, (float)1.501465,
+   (float)0.979492, (float)1.416992, (float)1.624268,
+   (float)1.276001, (float)1.661011, (float)2.007935,
+   (float)0.993042, (float)1.168579, (float)1.331665,
+   (float)0.778198, (float)0.944946, (float)1.235962,
+   (float)1.223755, (float)1.491333, (float)1.815674,
+   (float)0.852661, (float)1.350464, (float)1.722290,
+   (float)1.134766, (float)1.593140, (float)1.787354,
+   (float)1.051392, (float)1.339722, (float)1.531006,
+   (float)0.803589, (float)1.271240, (float)1.652100,
+   (float)0.755737, (float)1.143555, (float)1.639404,
+   (float)0.700928, (float)0.837280, (float)1.130371,
+   (float)0.942749, (float)1.197876, (float)1.669800,
+   (float)0.993286, (float)1.378296, (float)1.566528,
+   (float)0.801025, (float)1.095337, (float)1.298950,
+   (float)0.739990, (float)1.032959, (float)1.383667,
+   (float)0.845703, (float)1.072266, (float)1.543823,
+   (float)0.915649, (float)1.072266, (float)1.224487,
+   (float)1.021973, (float)1.226196, (float)1.481323,
+   (float)0.999878, (float)1.204102, (float)1.555908,
+   (float)0.722290, (float)0.913940, (float)1.340210,
+   (float)0.673340, (float)0.835938, (float)1.259521,
+   (float)0.832397, (float)1.208374, (float)1.394165,
+   (float)0.962158, (float)1.576172, (float)1.912842,
+   (float)1.166748, (float)1.370850, (float)1.556763,
+   (float)0.946289, (float)1.138550, (float)1.400391,
+   (float)1.035034, (float)1.218262, (float)1.386475,
+   (float)1.393799, (float)1.717773, (float)2.000244,
+   (float)0.972656, (float)1.260986, (float)1.760620,
+   (float)1.028198, (float)1.288452, (float)1.484619,
+
+
+
+
+
+   (float)0.773560, (float)1.258057, (float)1.756714,
+   (float)1.080322, (float)1.328003, (float)1.742676,
+   (float)0.823975, (float)1.450806, (float)1.917725,
+   (float)0.859009, (float)1.016602, (float)1.191895,
+   (float)0.843994, (float)1.131104, (float)1.645020,
+   (float)1.189697, (float)1.702759, (float)1.894409,
+   (float)1.346680, (float)1.763184, (float)2.066040,
+   (float)0.980469, (float)1.253784, (float)1.441650,
+   (float)1.338135, (float)1.641968, (float)1.932739,
+   (float)1.223267, (float)1.424194, (float)1.626465,
+   (float)0.765747, (float)1.004150, (float)1.579102,
+   (float)1.042847, (float)1.269165, (float)1.647461,
+   (float)0.968750, (float)1.257568, (float)1.555786,
+   (float)0.826294, (float)0.993408, (float)1.275146,
+   (float)0.742310, (float)0.950439, (float)1.430542,
+   (float)1.054321, (float)1.439819, (float)1.828003,
+   (float)1.072998, (float)1.261719, (float)1.441895,
+   (float)0.859375, (float)1.036377, (float)1.314819,
+   (float)0.895752, (float)1.267212, (float)1.605591,
+   (float)0.805420, (float)0.962891, (float)1.142334,
+   (float)0.795654, (float)1.005493, (float)1.468506,
+   (float)1.105347, (float)1.313843, (float)1.584839,
+   (float)0.792236, (float)1.221802, (float)1.465698,
+   (float)1.170532, (float)1.467651, (float)1.664063,
+   (float)0.838257, (float)1.153198, (float)1.342163,
+   (float)0.968018, (float)1.198242, (float)1.391235,
+   (float)1.250122, (float)1.623535, (float)1.823608,
+   (float)0.711670, (float)1.058350, (float)1.512085,
+   (float)1.204834, (float)1.454468, (float)1.739136,
+   (float)1.137451, (float)1.421753, (float)1.620117,
+   (float)0.820435, (float)1.322754, (float)1.578247,
+   (float)0.798706, (float)1.005005, (float)1.213867,
+   (float)0.980713, (float)1.324951, (float)1.512939,
+   (float)1.112305, (float)1.438843, (float)1.735596,
+   (float)1.135498, (float)1.356689, (float)1.635742,
+   (float)1.101318, (float)1.387451, (float)1.686523,
+   (float)0.849854, (float)1.276978, (float)1.523438,
+   (float)1.377930, (float)1.627563, (float)1.858154,
+   (float)0.884888, (float)1.095459, (float)1.287476,
+   (float)1.289795, (float)1.505859, (float)1.756592,
+   (float)0.817505, (float)1.384155, (float)1.650513,
+   (float)1.446655, (float)1.702148, (float)1.931885,
+   (float)0.835815, (float)1.023071, (float)1.385376,
+   (float)0.916626, (float)1.139038, (float)1.335327,
+   (float)0.980103, (float)1.174072, (float)1.453735,
+   (float)1.705688, (float)2.153809, (float)2.398315, (float)2.743408,
+   (float)1.797119, (float)2.016846, (float)2.445679, (float)2.701904,
+   (float)1.990356, (float)2.219116, (float)2.576416, (float)2.813477,
+
+
+
+
+
+   (float)1.849365, (float)2.190918, (float)2.611572, (float)2.835083,
+   (float)1.657959, (float)1.854370, (float)2.159058, (float)2.726196,
+   (float)1.437744, (float)1.897705, (float)2.253174, (float)2.655396,
+   (float)2.028687, (float)2.247314, (float)2.542358, (float)2.875854,
+   (float)1.736938, (float)1.922119, (float)2.185913, (float)2.743408,
+   (float)1.521606, (float)1.870972, (float)2.526855, (float)2.786987,
+   (float)1.841431, (float)2.050659, (float)2.463623, (float)2.857666,
+   (float)1.590088, (float)2.067261, (float)2.427979, (float)2.794434,
+   (float)1.746826, (float)2.057373, (float)2.320190, (float)2.800781,
+   (float)1.734619, (float)1.940552, (float)2.306030, (float)2.826416,
+   (float)1.786255, (float)2.204468, (float)2.457520, (float)2.795288,
+   (float)1.861084, (float)2.170532, (float)2.414551, (float)2.763672,
+   (float)2.001465, (float)2.307617, (float)2.552734, (float)2.811890,
+   (float)1.784424, (float)2.124146, (float)2.381592, (float)2.645508,
+   (float)1.888794, (float)2.135864, (float)2.418579, (float)2.861206,
+   (float)2.301147, (float)2.531250, (float)2.724976, (float)2.913086,
+   (float)1.837769, (float)2.051270, (float)2.261963, (float)2.553223,
+   (float)2.012939, (float)2.221191, (float)2.440186, (float)2.678101,
+   (float)1.429565, (float)1.858276, (float)2.582275, (float)2.845703,
+   (float)1.622803, (float)1.897705, (float)2.367310, (float)2.621094,
+   (float)1.581543, (float)1.960449, (float)2.515869, (float)2.736450,
+   (float)1.419434, (float)1.933960, (float)2.394653, (float)2.746704,
+   (float)1.721924, (float)2.059570, (float)2.421753, (float)2.769653,
+   (float)1.911011, (float)2.220703, (float)2.461060, (float)2.740723,
+   (float)1.581177, (float)1.860840, (float)2.516968, (float)2.874634,
+   (float)1.870361, (float)2.098755, (float)2.432373, (float)2.656494,
+   (float)2.059692, (float)2.279785, (float)2.495605, (float)2.729370,
+   (float)1.815674, (float)2.181519, (float)2.451538, (float)2.680542,
+   (float)1.407959, (float)1.768311, (float)2.343018, (float)2.668091,
+   (float)2.168701, (float)2.394653, (float)2.604736, (float)2.829346,
+   (float)1.636230, (float)1.865723, (float)2.329102, (float)2.824219,
+   (float)1.878906, (float)2.139526, (float)2.376709, (float)2.679810,
+   (float)1.765381, (float)1.971802, (float)2.195435, (float)2.586914,
+   (float)2.164795, (float)2.410889, (float)2.673706, (float)2.903198,
+   (float)2.071899, (float)2.331055, (float)2.645874, (float)2.907104,
+   (float)2.026001, (float)2.311523, (float)2.594849, (float)2.863892,
+   (float)1.948975, (float)2.180786, (float)2.514893, (float)2.797852,
+   (float)1.881836, (float)2.130859, (float)2.478149, (float)2.804199,
+   (float)2.238159, (float)2.452759, (float)2.652832, (float)2.868286,
+   (float)1.897949, (float)2.101685, (float)2.524292, (float)2.880127,
+   (float)1.856445, (float)2.074585, (float)2.541016, (float)2.791748,
+   (float)1.695557, (float)2.199097, (float)2.506226, (float)2.742676,
+   (float)1.612671, (float)1.877075, (float)2.435425, (float)2.732910,
+   (float)1.568848, (float)1.786499, (float)2.194580, (float)2.768555,
+   (float)1.953369, (float)2.164551, (float)2.486938, (float)2.874023,
+   (float)1.388306, (float)1.725342, (float)2.384521, (float)2.771851,
+   (float)2.115356, (float)2.337769, (float)2.592896, (float)2.864014,
+   (float)1.905762, (float)2.111328, (float)2.363525, (float)2.789307,
+
+
+
+
+
+   (float)1.882568, (float)2.332031, (float)2.598267, (float)2.827637,
+   (float)1.683594, (float)2.088745, (float)2.361938, (float)2.608643,
+   (float)1.874023, (float)2.182129, (float)2.536133, (float)2.766968,
+   (float)1.861938, (float)2.070435, (float)2.309692, (float)2.700562,
+   (float)1.722168, (float)2.107422, (float)2.477295, (float)2.837646,
+   (float)1.926880, (float)2.184692, (float)2.442627, (float)2.663818,
+   (float)2.123901, (float)2.337280, (float)2.553101, (float)2.777466,
+   (float)1.588135, (float)1.911499, (float)2.212769, (float)2.543945,
+   (float)2.053955, (float)2.370850, (float)2.712158, (float)2.939941,
+   (float)2.210449, (float)2.519653, (float)2.770386, (float)2.958618,
+   (float)2.199463, (float)2.474731, (float)2.718262, (float)2.919922,
+   (float)1.960083, (float)2.175415, (float)2.608032, (float)2.888794,
+   (float)1.953735, (float)2.185181, (float)2.428223, (float)2.809570,
+   (float)1.615234, (float)2.036499, (float)2.576538, (float)2.834595,
+   (float)1.621094, (float)2.028198, (float)2.431030, (float)2.664673,
+   (float)1.824951, (float)2.267456, (float)2.514526, (float)2.747925,
+   (float)1.994263, (float)2.229126, (float)2.475220, (float)2.833984,
+   (float)1.746338, (float)2.011353, (float)2.588257, (float)2.826904,
+   (float)1.562866, (float)2.135986, (float)2.471680, (float)2.687256,
+   (float)1.748901, (float)2.083496, (float)2.460938, (float)2.686279,
+   (float)1.758057, (float)2.131470, (float)2.636597, (float)2.891602,
+   (float)2.071289, (float)2.299072, (float)2.550781, (float)2.814331,
+   (float)1.839600, (float)2.094360, (float)2.496460, (float)2.723999,
+   (float)1.882202, (float)2.088257, (float)2.636841, (float)2.923096,
+   (float)1.957886, (float)2.153198, (float)2.384399, (float)2.615234,
+   (float)1.992920, (float)2.351196, (float)2.654419, (float)2.889771,
+   (float)2.012817, (float)2.262451, (float)2.643799, (float)2.903076,
+   (float)2.025635, (float)2.254761, (float)2.508423, (float)2.784058,
+   (float)2.316040, (float)2.589355, (float)2.794189, (float)2.963623,
+   (float)1.741211, (float)2.279541, (float)2.578491, (float)2.816284,
+   (float)1.845337, (float)2.055786, (float)2.348511, (float)2.822021,
+   (float)1.679932, (float)1.926514, (float)2.499756, (float)2.835693,
+   (float)1.722534, (float)1.946899, (float)2.448486, (float)2.728760,
+   (float)1.829834, (float)2.043213, (float)2.580444, (float)2.867676,
+   (float)1.676636, (float)2.071655, (float)2.322510, (float)2.704834,
+   (float)1.791504, (float)2.113525, (float)2.469727, (float)2.784058,
+   (float)1.977051, (float)2.215088, (float)2.497437, (float)2.726929,
+   (float)1.800171, (float)2.106689, (float)2.357788, (float)2.738892,
+   (float)1.827759, (float)2.170166, (float)2.525879, (float)2.852417,
+   (float)1.918335, (float)2.132813, (float)2.488403, (float)2.728149,
+   (float)1.916748, (float)2.225098, (float)2.542603, (float)2.857666,
+   (float)1.761230, (float)1.976074, (float)2.507446, (float)2.884521,
+   (float)2.053711, (float)2.367432, (float)2.608032, (float)2.837646,
+   (float)1.595337, (float)2.000977, (float)2.307129, (float)2.578247,
+   (float)1.470581, (float)2.031250, (float)2.375854, (float)2.647583,
+   (float)1.801392, (float)2.128052, (float)2.399780, (float)2.822876,
+   (float)1.853638, (float)2.066650, (float)2.429199, (float)2.751465,
+   (float)1.956299, (float)2.163696, (float)2.394775, (float)2.734253,
+
+
+
+
+
+   (float)1.963623, (float)2.275757, (float)2.585327, (float)2.865234,
+   (float)1.887451, (float)2.105469, (float)2.331787, (float)2.587402,
+   (float)2.120117, (float)2.443359, (float)2.733887, (float)2.941406,
+   (float)1.506348, (float)1.766968, (float)2.400513, (float)2.851807,
+   (float)1.664551, (float)1.981079, (float)2.375732, (float)2.774414,
+   (float)1.720703, (float)1.978882, (float)2.391479, (float)2.640991,
+   (float)1.483398, (float)1.814819, (float)2.434448, (float)2.722290,
+   (float)1.769043, (float)2.136597, (float)2.563721, (float)2.774414,
+   (float)1.810791, (float)2.049316, (float)2.373901, (float)2.613647,
+   (float)1.788330, (float)2.005981, (float)2.359131, (float)2.723145,
+   (float)1.785156, (float)1.993164, (float)2.399780, (float)2.832520,
+   (float)1.695313, (float)2.022949, (float)2.522583, (float)2.745117,
+   (float)1.584106, (float)1.965576, (float)2.299927, (float)2.715576,
+   (float)1.894897, (float)2.249878, (float)2.655884, (float)2.897705,
+   (float)1.720581, (float)1.995728, (float)2.299438, (float)2.557007,
+   (float)1.619385, (float)2.173950, (float)2.574219, (float)2.787964,
+   (float)1.883179, (float)2.220459, (float)2.474365, (float)2.825073,
+   (float)1.447632, (float)2.045044, (float)2.555542, (float)2.744873,
+   (float)1.502686, (float)2.156616, (float)2.653320, (float)2.846558,
+   (float)1.711548, (float)1.944092, (float)2.282959, (float)2.685791,
+   (float)1.499756, (float)1.867554, (float)2.341064, (float)2.578857,
+   (float)1.916870, (float)2.135132, (float)2.568237, (float)2.826050,
+   (float)1.498047, (float)1.711182, (float)2.223267, (float)2.755127,
+   (float)1.808716, (float)1.997559, (float)2.256470, (float)2.758545,
+   (float)2.088501, (float)2.402710, (float)2.667358, (float)2.890259,
+   (float)1.545044, (float)1.819214, (float)2.324097, (float)2.692993,
+   (float)1.796021, (float)2.012573, (float)2.505737, (float)2.784912,
+   (float)1.786499, (float)2.041748, (float)2.290405, (float)2.650757,
+   (float)1.938232, (float)2.264404, (float)2.529053, (float)2.796143
+   };
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/constants.h asterisk-1.8.3.2_com_amr/codecs/ilbc/constants.h
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/constants.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/constants.h	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,80 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       constants.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_CONSTANTS_H
+   #define __iLBC_CONSTANTS_H
+
+   #include "iLBC_define.h"
+
+
+   /* ULP bit allocation */
+
+
+
+
+
+
+   extern const iLBC_ULP_Inst_t ULP_20msTbl;
+   extern const iLBC_ULP_Inst_t ULP_30msTbl;
+
+   /* high pass filters */
+
+   extern float hpi_zero_coefsTbl[];
+   extern float hpi_pole_coefsTbl[];
+   extern float hpo_zero_coefsTbl[];
+   extern float hpo_pole_coefsTbl[];
+
+   /* low pass filters */
+   extern float lpFilt_coefsTbl[];
+
+   /* LPC analysis and quantization */
+
+   extern float lpc_winTbl[];
+   extern float lpc_asymwinTbl[];
+   extern float lpc_lagwinTbl[];
+   extern float lsfCbTbl[];
+   extern float lsfmeanTbl[];
+   extern int   dim_lsfCbTbl[];
+   extern int   size_lsfCbTbl[];
+   extern float lsf_weightTbl_30ms[];
+   extern float lsf_weightTbl_20ms[];
+
+   /* state quantization tables */
+
+   extern float state_sq3Tbl[];
+   extern float state_frgqTbl[];
+
+   /* gain quantization tables */
+
+   extern float gain_sq3Tbl[];
+   extern float gain_sq4Tbl[];
+   extern float gain_sq5Tbl[];
+
+   /* adaptive codebook definitions */
+
+   extern int search_rangeTbl[5][CB_NSTAGES];
+   extern int memLfTbl[];
+   extern int stMemLTbl;
+   extern float cbfiltersTbl[CB_FILTERLEN];
+
+   /* enhancer definitions */
+
+   extern float polyphaserTbl[];
+   extern float enh_plocsTbl[];
+
+
+
+
+
+
+   #endif
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/createCB.c asterisk-1.8.3.2_com_amr/codecs/ilbc/createCB.c
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/createCB.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/createCB.c	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,231 @@
+
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       createCB.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+
+
+
+
+   #include "iLBC_define.h"
+   #include "constants.h"
+   #include <string.h>
+   #include <math.h>
+
+   /*----------------------------------------------------------------*
+    *  Construct an additional codebook vector by filtering the
+    *  initial codebook buffer. This vector is then used to expand
+    *  the codebook with an additional section.
+    *---------------------------------------------------------------*/
+
+   void filteredCBvecs(
+       float *cbvectors,   /* (o) Codebook vectors for the
+                                  higher section */
+       float *mem,         /* (i) Buffer to create codebook
+                                  vector from */
+       int lMem        /* (i) Length of buffer */
+   ){
+       int j, k;
+       float *pp, *pp1;
+       float tempbuff2[CB_MEML+CB_FILTERLEN];
+       float *pos;
+
+       memset(tempbuff2, 0, (CB_HALFFILTERLEN-1)*sizeof(float));
+       memcpy(&tempbuff2[CB_HALFFILTERLEN-1], mem, lMem*sizeof(float));
+       memset(&tempbuff2[lMem+CB_HALFFILTERLEN-1], 0,
+           (CB_HALFFILTERLEN+1)*sizeof(float));
+
+       /* Create codebook vector for higher section by filtering */
+
+       /* do filtering */
+       pos=cbvectors;
+       memset(pos, 0, lMem*sizeof(float));
+       for (k=0; k<lMem; k++) {
+           pp=&tempbuff2[k];
+           pp1=&cbfiltersTbl[CB_FILTERLEN-1];
+           for (j=0;j<CB_FILTERLEN;j++) {
+               (*pos)+=(*pp++)*(*pp1--);
+           }
+           pos++;
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  Search the augmented part of the codebook to find the best
+    *  measure.
+    *----------------------------------------------------------------*/
+
+
+
+
+
+
+   void searchAugmentedCB(
+       int low,        /* (i) Start index for the search */
+       int high,           /* (i) End index for the search */
+       int stage,          /* (i) Current stage */
+       int startIndex,     /* (i) Codebook index for the first
+                                  aug vector */
+       float *target,      /* (i) Target vector for encoding */
+       float *buffer,      /* (i) Pointer to the end of the buffer for
+                                  augmented codebook construction */
+       float *max_measure, /* (i/o) Currently maximum measure */
+       int *best_index,/* (o) Currently the best index */
+       float *gain,    /* (o) Currently the best gain */
+       float *energy,      /* (o) Energy of augmented codebook
+                                  vectors */
+       float *invenergy/* (o) Inv energy of augmented codebook
+                                  vectors */
+   ) {
+       int icount, ilow, j, tmpIndex;
+       float *pp, *ppo, *ppi, *ppe, crossDot, alfa;
+       float weighted, measure, nrjRecursive;
+       float ftmp;
+
+       /* Compute the energy for the first (low-5)
+          noninterpolated samples */
+       nrjRecursive = (float) 0.0;
+       pp = buffer - low + 1;
+       for (j=0; j<(low-5); j++) {
+           nrjRecursive += ( (*pp)*(*pp) );
+           pp++;
+       }
+       ppe = buffer - low;
+
+
+       for (icount=low; icount<=high; icount++) {
+
+           /* Index of the codebook vector used for retrieving
+              energy values */
+           tmpIndex = startIndex+icount-20;
+
+           ilow = icount-4;
+
+           /* Update the energy recursively to save complexity */
+           nrjRecursive = nrjRecursive + (*ppe)*(*ppe);
+           ppe--;
+           energy[tmpIndex] = nrjRecursive;
+
+           /* Compute cross dot product for the first (low-5)
+              samples */
+
+
+
+
+
+           crossDot = (float) 0.0;
+           pp = buffer-icount;
+           for (j=0; j<ilow; j++) {
+               crossDot += target[j]*(*pp++);
+           }
+
+           /* interpolation */
+           alfa = (float) 0.2;
+           ppo = buffer-4;
+           ppi = buffer-icount-4;
+           for (j=ilow; j<icount; j++) {
+               weighted = ((float)1.0-alfa)*(*ppo)+alfa*(*ppi);
+               ppo++;
+               ppi++;
+               energy[tmpIndex] += weighted*weighted;
+               crossDot += target[j]*weighted;
+               alfa += (float)0.2;
+           }
+
+           /* Compute energy and cross dot product for the
+              remaining samples */
+           pp = buffer - icount;
+           for (j=icount; j<SUBL; j++) {
+               energy[tmpIndex] += (*pp)*(*pp);
+               crossDot += target[j]*(*pp++);
+           }
+
+           if (energy[tmpIndex]>0.0) {
+               invenergy[tmpIndex]=(float)1.0/(energy[tmpIndex]+EPS);
+           } else {
+               invenergy[tmpIndex] = (float) 0.0;
+           }
+
+           if (stage==0) {
+               measure = (float)-10000000.0;
+
+               if (crossDot > 0.0) {
+                   measure = crossDot*crossDot*invenergy[tmpIndex];
+               }
+           }
+           else {
+               measure = crossDot*crossDot*invenergy[tmpIndex];
+           }
+
+           /* check if measure is better */
+           ftmp = crossDot*invenergy[tmpIndex];
+
+           if ((measure>*max_measure) && (fabs(ftmp)<CB_MAXGAIN)) {
+
+
+
+
+
+               *best_index = tmpIndex;
+               *max_measure = measure;
+               *gain = ftmp;
+           }
+       }
+   }
+
+
+   /*----------------------------------------------------------------*
+    *  Recreate a specific codebook vector from the augmented part.
+    *
+    *----------------------------------------------------------------*/
+
+   void createAugmentedVec(
+       int index,      /* (i) Index for the augmented vector
+                              to be created */
+       float *buffer,  /* (i) Pointer to the end of the buffer for
+                              augmented codebook construction */
+       float *cbVec/* (o) The construced codebook vector */
+   ) {
+       int ilow, j;
+       float *pp, *ppo, *ppi, alfa, alfa1, weighted;
+
+       ilow = index-5;
+
+       /* copy the first noninterpolated part */
+
+       pp = buffer-index;
+       memcpy(cbVec,pp,sizeof(float)*index);
+
+       /* interpolation */
+
+       alfa1 = (float)0.2;
+       alfa = 0.0;
+       ppo = buffer-5;
+       ppi = buffer-index-5;
+       for (j=ilow; j<index; j++) {
+           weighted = ((float)1.0-alfa)*(*ppo)+alfa*(*ppi);
+           ppo++;
+           ppi++;
+           cbVec[j] = weighted;
+           alfa += alfa1;
+       }
+
+       /* copy the second noninterpolated part */
+
+       pp = buffer - index;
+       memcpy(cbVec+index,pp,sizeof(float)*(SUBL-index));
+
+
+
+
+
+   }
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/createCB.h asterisk-1.8.3.2_com_amr/codecs/ilbc/createCB.h
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/createCB.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/createCB.h	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,58 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       createCB.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_CREATECB_H
+   #define __iLBC_CREATECB_H
+
+   void filteredCBvecs(
+       float *cbvectors,   /* (o) Codebook vector for the
+                                  higher section */
+
+
+
+
+
+       float *mem,         /* (i) Buffer to create codebook
+                                  vectors from */
+       int lMem        /* (i) Length of buffer */
+   );
+
+   void searchAugmentedCB(
+       int low,        /* (i) Start index for the search */
+       int high,           /* (i) End index for the search */
+       int stage,          /* (i) Current stage */
+       int startIndex,     /* (i) CB index for the first
+                                  augmented vector */
+       float *target,      /* (i) Target vector for encoding */
+       float *buffer,      /* (i) Pointer to the end of the
+                                  buffer for augmented codebook
+                                  construction */
+       float *max_measure, /* (i/o) Currently maximum measure */
+       int *best_index,/* (o) Currently the best index */
+       float *gain,    /* (o) Currently the best gain */
+       float *energy,      /* (o) Energy of augmented
+                                  codebook vectors */
+       float *invenergy/* (o) Inv energy of aug codebook
+                                  vectors */
+   );
+
+   void createAugmentedVec(
+       int index,          /* (i) Index for the aug vector
+                                  to be created */
+       float *buffer,      /* (i) Pointer to the end of the
+                                  buffer for augmented codebook
+                                  construction */
+       float *cbVec    /* (o) The construced codebook vector */
+   );
+
+   #endif
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/doCPLC.c asterisk-1.8.3.2_com_amr/codecs/ilbc/doCPLC.c
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/doCPLC.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/doCPLC.c	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,270 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       doCPLC.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <math.h>
+   #include <string.h>
+   #include <stdio.h>
+
+
+
+
+
+   #include "iLBC_define.h"
+
+   /*----------------------------------------------------------------*
+    *  Compute cross correlation and pitch gain for pitch prediction
+    *  of last subframe at given lag.
+    *---------------------------------------------------------------*/
+
+   void compCorr(
+       float *cc,      /* (o) cross correlation coefficient */
+       float *gc,      /* (o) gain */
+       float *pm,
+       float *buffer,  /* (i) signal buffer */
+       int lag,    /* (i) pitch lag */
+       int bLen,       /* (i) length of buffer */
+       int sRange      /* (i) correlation search length */
+   ){
+       int i;
+       float ftmp1, ftmp2, ftmp3;
+
+       /* Guard against getting outside buffer */
+       if ((bLen-sRange-lag)<0) {
+           sRange=bLen-lag;
+       }
+
+       ftmp1 = 0.0;
+       ftmp2 = 0.0;
+       ftmp3 = 0.0;
+       for (i=0; i<sRange; i++) {
+           ftmp1 += buffer[bLen-sRange+i] *
+               buffer[bLen-sRange+i-lag];
+           ftmp2 += buffer[bLen-sRange+i-lag] *
+                   buffer[bLen-sRange+i-lag];
+           ftmp3 += buffer[bLen-sRange+i] *
+                   buffer[bLen-sRange+i];
+       }
+
+       if (ftmp2 > 0.0) {
+           *cc = ftmp1*ftmp1/ftmp2;
+           *gc = (float)fabs(ftmp1/ftmp2);
+           *pm=(float)fabs(ftmp1)/
+               ((float)sqrt(ftmp2)*(float)sqrt(ftmp3));
+       }
+       else {
+           *cc = 0.0;
+           *gc = 0.0;
+           *pm=0.0;
+       }
+   }
+
+
+
+
+
+   /*----------------------------------------------------------------*
+    *  Packet loss concealment routine. Conceals a residual signal
+    *  and LP parameters. If no packet loss, update state.
+    *---------------------------------------------------------------*/
+
+   void doThePLC(
+       float *PLCresidual, /* (o) concealed residual */
+       float *PLClpc,      /* (o) concealed LP parameters */
+       int PLI,        /* (i) packet loss indicator
+                                  0 - no PL, 1 = PL */
+       float *decresidual, /* (i) decoded residual */
+       float *lpc,         /* (i) decoded LPC (only used for no PL) */
+       int inlag,          /* (i) pitch lag */
+       iLBC_Dec_Inst_t *iLBCdec_inst
+                           /* (i/o) decoder instance */
+   ){
+       int lag=20, randlag;
+       float gain, maxcc;
+       float use_gain;
+       float gain_comp, maxcc_comp, per, max_per;
+       int i, pick, use_lag;
+       float ftmp, randvec[BLOCKL_MAX], pitchfact, energy;
+
+       /* Packet Loss */
+
+       if (PLI == 1) {
+
+           iLBCdec_inst->consPLICount += 1;
+
+           /* if previous frame not lost,
+              determine pitch pred. gain */
+
+           if (iLBCdec_inst->prevPLI != 1) {
+
+               /* Search around the previous lag to find the
+                  best pitch period */
+
+               lag=inlag-3;
+               compCorr(&maxcc, &gain, &max_per,
+                   iLBCdec_inst->prevResidual,
+                   lag, iLBCdec_inst->blockl, 60);
+               for (i=inlag-2;i<=inlag+3;i++) {
+                   compCorr(&maxcc_comp, &gain_comp, &per,
+                       iLBCdec_inst->prevResidual,
+                       i, iLBCdec_inst->blockl, 60);
+
+                   if (maxcc_comp>maxcc) {
+                       maxcc=maxcc_comp;
+
+
+
+
+
+                       gain=gain_comp;
+                       lag=i;
+                       max_per=per;
+                   }
+               }
+
+           }
+
+           /* previous frame lost, use recorded lag and periodicity */
+
+           else {
+               lag=iLBCdec_inst->prevLag;
+               max_per=iLBCdec_inst->per;
+           }
+
+           /* downscaling */
+
+           use_gain=1.0;
+           if (iLBCdec_inst->consPLICount*iLBCdec_inst->blockl>320)
+               use_gain=(float)0.9;
+           else if (iLBCdec_inst->consPLICount*
+                           iLBCdec_inst->blockl>2*320)
+               use_gain=(float)0.7;
+           else if (iLBCdec_inst->consPLICount*
+                           iLBCdec_inst->blockl>3*320)
+               use_gain=(float)0.5;
+           else if (iLBCdec_inst->consPLICount*
+                           iLBCdec_inst->blockl>4*320)
+               use_gain=(float)0.0;
+
+           /* mix noise and pitch repeatition */
+           ftmp=(float)sqrt(max_per);
+           if (ftmp>(float)0.7)
+               pitchfact=(float)1.0;
+           else if (ftmp>(float)0.4)
+               pitchfact=(ftmp-(float)0.4)/((float)0.7-(float)0.4);
+           else
+               pitchfact=0.0;
+
+
+           /* avoid repetition of same pitch cycle */
+           use_lag=lag;
+           if (lag<80) {
+               use_lag=2*lag;
+           }
+
+           /* compute concealed residual */
+
+
+
+
+
+
+           energy = 0.0;
+           for (i=0; i<iLBCdec_inst->blockl; i++) {
+
+               /* noise component */
+
+               iLBCdec_inst->seed=(iLBCdec_inst->seed*69069L+1) &
+                   (0x80000000L-1);
+               randlag = 50 + ((signed long) iLBCdec_inst->seed)%70;
+               pick = i - randlag;
+
+               if (pick < 0) {
+                   randvec[i] =
+                       iLBCdec_inst->prevResidual[
+                                   iLBCdec_inst->blockl+pick];
+               } else {
+                   randvec[i] =  randvec[pick];
+               }
+
+               /* pitch repeatition component */
+               pick = i - use_lag;
+
+               if (pick < 0) {
+                   PLCresidual[i] =
+                       iLBCdec_inst->prevResidual[
+                                   iLBCdec_inst->blockl+pick];
+               } else {
+                   PLCresidual[i] = PLCresidual[pick];
+               }
+
+               /* mix random and periodicity component */
+
+               if (i<80)
+                   PLCresidual[i] = use_gain*(pitchfact *
+                               PLCresidual[i] +
+                               ((float)1.0 - pitchfact) * randvec[i]);
+               else if (i<160)
+                   PLCresidual[i] = (float)0.95*use_gain*(pitchfact *
+                               PLCresidual[i] +
+                               ((float)1.0 - pitchfact) * randvec[i]);
+               else
+                   PLCresidual[i] = (float)0.9*use_gain*(pitchfact *
+                               PLCresidual[i] +
+                               ((float)1.0 - pitchfact) * randvec[i]);
+
+               energy += PLCresidual[i] * PLCresidual[i];
+           }
+
+           /* less than 30 dB, use only noise */
+
+
+
+
+
+
+           if (sqrt(energy/(float)iLBCdec_inst->blockl) < 30.0) {
+               gain=0.0;
+               for (i=0; i<iLBCdec_inst->blockl; i++) {
+                   PLCresidual[i] = randvec[i];
+               }
+           }
+
+           /* use old LPC */
+
+           memcpy(PLClpc,iLBCdec_inst->prevLpc,
+               (LPC_FILTERORDER+1)*sizeof(float));
+
+       }
+
+       /* no packet loss, copy input */
+
+       else {
+           memcpy(PLCresidual, decresidual,
+               iLBCdec_inst->blockl*sizeof(float));
+           memcpy(PLClpc, lpc, (LPC_FILTERORDER+1)*sizeof(float));
+           iLBCdec_inst->consPLICount = 0;
+       }
+
+       /* update state */
+
+       if (PLI) {
+           iLBCdec_inst->prevLag = lag;
+           iLBCdec_inst->per=max_per;
+       }
+
+       iLBCdec_inst->prevPLI = PLI;
+       memcpy(iLBCdec_inst->prevLpc, PLClpc,
+           (LPC_FILTERORDER+1)*sizeof(float));
+       memcpy(iLBCdec_inst->prevResidual, PLCresidual,
+           iLBCdec_inst->blockl*sizeof(float));
+   }
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/doCPLC.h asterisk-1.8.3.2_com_amr/codecs/ilbc/doCPLC.h
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/doCPLC.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/doCPLC.h	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,29 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       doCPLC.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_DOLPC_H
+   #define __iLBC_DOLPC_H
+
+   void doThePLC(
+       float *PLCresidual, /* (o) concealed residual */
+       float *PLClpc,      /* (o) concealed LP parameters */
+       int PLI,        /* (i) packet loss indicator
+                                  0 - no PL, 1 = PL */
+       float *decresidual, /* (i) decoded residual */
+       float *lpc,         /* (i) decoded LPC (only used for no PL) */
+       int inlag,          /* (i) pitch lag */
+       iLBC_Dec_Inst_t *iLBCdec_inst
+                           /* (i/o) decoder instance */
+   );
+
+   #endif
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/enhancer.c asterisk-1.8.3.2_com_amr/codecs/ilbc/enhancer.c
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/enhancer.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/enhancer.c	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,701 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       enhancer.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <math.h>
+   #include <string.h>
+   #include "iLBC_define.h"
+   #include "constants.h"
+   #include "filter.h"
+
+   /*----------------------------------------------------------------*
+    * Find index in array such that the array element with said
+    * index is the element of said array closest to "value"
+    * according to the squared-error criterion
+    *---------------------------------------------------------------*/
+
+   void NearestNeighbor(
+
+
+
+
+
+       int   *index,   /* (o) index of array element closest
+                              to value */
+       float *array,   /* (i) data array */
+       float value,/* (i) value */
+       int arlength/* (i) dimension of data array */
+   ){
+       int i;
+       float bestcrit,crit;
+
+       crit=array[0]-value;
+       bestcrit=crit*crit;
+       *index=0;
+       for (i=1; i<arlength; i++) {
+           crit=array[i]-value;
+           crit=crit*crit;
+
+           if (crit<bestcrit) {
+               bestcrit=crit;
+               *index=i;
+           }
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    * compute cross correlation between sequences
+    *---------------------------------------------------------------*/
+
+   void mycorr1(
+       float* corr,    /* (o) correlation of seq1 and seq2 */
+       float* seq1,    /* (i) first sequence */
+       int dim1,           /* (i) dimension first seq1 */
+       const float *seq2,  /* (i) second sequence */
+       int dim2        /* (i) dimension seq2 */
+   ){
+       int i,j;
+
+       for (i=0; i<=dim1-dim2; i++) {
+           corr[i]=0.0;
+           for (j=0; j<dim2; j++) {
+               corr[i] += seq1[i+j] * seq2[j];
+           }
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    * upsample finite array assuming zeros outside bounds
+    *---------------------------------------------------------------*/
+
+
+
+
+
+
+   void enh_upsample(
+       float* useq1,   /* (o) upsampled output sequence */
+       float* seq1,/* (i) unupsampled sequence */
+       int dim1,       /* (i) dimension seq1 */
+       int hfl         /* (i) polyphase filter length=2*hfl+1 */
+   ){
+       float *pu,*ps;
+       int i,j,k,q,filterlength,hfl2;
+       const float *polyp[ENH_UPS0]; /* pointers to
+                                        polyphase columns */
+       const float *pp;
+
+       /* define pointers for filter */
+
+       filterlength=2*hfl+1;
+
+       if ( filterlength > dim1 ) {
+           hfl2=(int) (dim1/2);
+           for (j=0; j<ENH_UPS0; j++) {
+               polyp[j]=polyphaserTbl+j*filterlength+hfl-hfl2;
+           }
+           hfl=hfl2;
+           filterlength=2*hfl+1;
+       }
+       else {
+           for (j=0; j<ENH_UPS0; j++) {
+               polyp[j]=polyphaserTbl+j*filterlength;
+           }
+       }
+
+       /* filtering: filter overhangs left side of sequence */
+
+       pu=useq1;
+       for (i=hfl; i<filterlength; i++) {
+           for (j=0; j<ENH_UPS0; j++) {
+               *pu=0.0;
+               pp = polyp[j];
+               ps = seq1+i;
+               for (k=0; k<=i; k++) {
+                   *pu += *ps-- * *pp++;
+               }
+               pu++;
+           }
+       }
+
+       /* filtering: simple convolution=inner products */
+
+       for (i=filterlength; i<dim1; i++) {
+
+
+
+
+
+           for (j=0;j<ENH_UPS0; j++){
+               *pu=0.0;
+               pp = polyp[j];
+               ps = seq1+i;
+               for (k=0; k<filterlength; k++) {
+                   *pu += *ps-- * *pp++;
+               }
+               pu++;
+           }
+       }
+
+       /* filtering: filter overhangs right side of sequence */
+
+       for (q=1; q<=hfl; q++) {
+           for (j=0; j<ENH_UPS0; j++) {
+               *pu=0.0;
+               pp = polyp[j]+q;
+               ps = seq1+dim1-1;
+               for (k=0; k<filterlength-q; k++) {
+                   *pu += *ps-- * *pp++;
+               }
+               pu++;
+           }
+       }
+   }
+
+
+   /*----------------------------------------------------------------*
+    * find segment starting near idata+estSegPos that has highest
+    * correlation with idata+centerStartPos through
+    * idata+centerStartPos+ENH_BLOCKL-1 segment is found at a
+    * resolution of ENH_UPSO times the original of the original
+    * sampling rate
+    *---------------------------------------------------------------*/
+
+   void refiner(
+       float *seg,         /* (o) segment array */
+       float *updStartPos, /* (o) updated start point */
+       float* idata,       /* (i) original data buffer */
+       int idatal,         /* (i) dimension of idata */
+       int centerStartPos, /* (i) beginning center segment */
+       float estSegPos,/* (i) estimated beginning other segment */
+       float period    /* (i) estimated pitch period */
+   ){
+       int estSegPosRounded,searchSegStartPos,searchSegEndPos,corrdim;
+       int tloc,tloc2,i,st,en,fraction;
+       float vect[ENH_VECTL],corrVec[ENH_CORRDIM],maxv;
+       float corrVecUps[ENH_CORRDIM*ENH_UPS0];
+
+
+
+
+
+       /* defining array bounds */
+
+       estSegPosRounded=(int)(estSegPos - 0.5);
+
+       searchSegStartPos=estSegPosRounded-ENH_SLOP;
+
+       if (searchSegStartPos<0) {
+           searchSegStartPos=0;
+       }
+       searchSegEndPos=estSegPosRounded+ENH_SLOP;
+
+       if (searchSegEndPos+ENH_BLOCKL >= idatal) {
+           searchSegEndPos=idatal-ENH_BLOCKL-1;
+       }
+       corrdim=searchSegEndPos-searchSegStartPos+1;
+
+       /* compute upsampled correlation (corr33) and find
+          location of max */
+
+       mycorr1(corrVec,idata+searchSegStartPos,
+           corrdim+ENH_BLOCKL-1,idata+centerStartPos,ENH_BLOCKL);
+       enh_upsample(corrVecUps,corrVec,corrdim,ENH_FL0);
+       tloc=0; maxv=corrVecUps[0];
+       for (i=1; i<ENH_UPS0*corrdim; i++) {
+
+           if (corrVecUps[i]>maxv) {
+               tloc=i;
+               maxv=corrVecUps[i];
+           }
+       }
+
+       /* make vector can be upsampled without ever running outside
+          bounds */
+
+       *updStartPos= (float)searchSegStartPos +
+           (float)tloc/(float)ENH_UPS0+(float)1.0;
+       tloc2=(int)(tloc/ENH_UPS0);
+
+       if (tloc>tloc2*ENH_UPS0) {
+           tloc2++;
+       }
+       st=searchSegStartPos+tloc2-ENH_FL0;
+
+       if (st<0) {
+           memset(vect,0,-st*sizeof(float));
+           memcpy(&vect[-st],idata, (ENH_VECTL+st)*sizeof(float));
+       }
+       else {
+
+
+
+
+
+           en=st+ENH_VECTL;
+
+           if (en>idatal) {
+               memcpy(vect, &idata[st],
+                   (ENH_VECTL-(en-idatal))*sizeof(float));
+               memset(&vect[ENH_VECTL-(en-idatal)], 0,
+                   (en-idatal)*sizeof(float));
+           }
+           else {
+               memcpy(vect, &idata[st], ENH_VECTL*sizeof(float));
+           }
+       }
+       fraction=tloc2*ENH_UPS0-tloc;
+
+       /* compute the segment (this is actually a convolution) */
+
+       mycorr1(seg,vect,ENH_VECTL,polyphaserTbl+(2*ENH_FL0+1)*fraction,
+           2*ENH_FL0+1);
+   }
+
+   /*----------------------------------------------------------------*
+    * find the smoothed output data
+    *---------------------------------------------------------------*/
+
+   void smath(
+       float *odata,   /* (o) smoothed output */
+       float *sseq,/* (i) said second sequence of waveforms */
+       int hl,         /* (i) 2*hl+1 is sseq dimension */
+       float alpha0/* (i) max smoothing energy fraction */
+   ){
+       int i,k;
+       float w00,w10,w11,A,B,C,*psseq,err,errs;
+       float surround[BLOCKL_MAX]; /* shape contributed by other than
+                                      current */
+       float wt[2*ENH_HL+1];       /* waveform weighting to get
+                                      surround shape */
+       float denom;
+
+       /* create shape of contribution from all waveforms except the
+          current one */
+
+       for (i=1; i<=2*hl+1; i++) {
+           wt[i-1] = (float)0.5*(1 - (float)cos(2*PI*i/(2*hl+2)));
+       }
+       wt[hl]=0.0; /* for clarity, not used */
+       for (i=0; i<ENH_BLOCKL; i++) {
+           surround[i]=sseq[i]*wt[0];
+       }
+
+
+
+
+
+       for (k=1; k<hl; k++) {
+           psseq=sseq+k*ENH_BLOCKL;
+           for(i=0;i<ENH_BLOCKL; i++) {
+               surround[i]+=psseq[i]*wt[k];
+           }
+       }
+       for (k=hl+1; k<=2*hl; k++) {
+           psseq=sseq+k*ENH_BLOCKL;
+           for(i=0;i<ENH_BLOCKL; i++) {
+               surround[i]+=psseq[i]*wt[k];
+           }
+       }
+
+       /* compute some inner products */
+
+       w00 = w10 = w11 = 0.0;
+       psseq=sseq+hl*ENH_BLOCKL; /* current block  */
+       for (i=0; i<ENH_BLOCKL;i++) {
+           w00+=psseq[i]*psseq[i];
+           w11+=surround[i]*surround[i];
+           w10+=surround[i]*psseq[i];
+       }
+
+       if (fabs(w11) < 1.0) {
+           w11=1.0;
+       }
+       C = (float)sqrt( w00/w11);
+
+       /* first try enhancement without power-constraint */
+
+       errs=0.0;
+       psseq=sseq+hl*ENH_BLOCKL;
+       for (i=0; i<ENH_BLOCKL; i++) {
+           odata[i]=C*surround[i];
+           err=psseq[i]-odata[i];
+           errs+=err*err;
+       }
+
+       /* if constraint violated by first try, add constraint */
+
+       if (errs > alpha0 * w00) {
+           if ( w00 < 1) {
+               w00=1;
+           }
+           denom = (w11*w00-w10*w10)/(w00*w00);
+
+           if (denom > 0.0001) { /* eliminates numerical problems
+                                    for if smooth */
+
+
+
+
+
+               A = (float)sqrt( (alpha0- alpha0*alpha0/4)/denom);
+               B = -alpha0/2 - A * w10/w00;
+               B = B+1;
+           }
+           else { /* essentially no difference between cycles;
+                     smoothing not needed */
+               A= 0.0;
+               B= 1.0;
+           }
+
+           /* create smoothed sequence */
+
+           psseq=sseq+hl*ENH_BLOCKL;
+           for (i=0; i<ENH_BLOCKL; i++) {
+               odata[i]=A*surround[i]+B*psseq[i];
+           }
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    * get the pitch-synchronous sample sequence
+    *---------------------------------------------------------------*/
+
+   void getsseq(
+       float *sseq,    /* (o) the pitch-synchronous sequence */
+       float *idata,       /* (i) original data */
+       int idatal,         /* (i) dimension of data */
+       int centerStartPos, /* (i) where current block starts */
+       float *period,      /* (i) rough-pitch-period array */
+       float *plocs,       /* (i) where periods of period array
+                                  are taken */
+       int periodl,    /* (i) dimension period array */
+       int hl              /* (i) 2*hl+1 is the number of sequences */
+   ){
+       int i,centerEndPos,q;
+       float blockStartPos[2*ENH_HL+1];
+       int lagBlock[2*ENH_HL+1];
+       float plocs2[ENH_PLOCSL];
+       float *psseq;
+
+       centerEndPos=centerStartPos+ENH_BLOCKL-1;
+
+       /* present */
+
+       NearestNeighbor(lagBlock+hl,plocs,
+           (float)0.5*(centerStartPos+centerEndPos),periodl);
+
+       blockStartPos[hl]=(float)centerStartPos;
+
+
+
+
+
+       psseq=sseq+ENH_BLOCKL*hl;
+       memcpy(psseq, idata+centerStartPos, ENH_BLOCKL*sizeof(float));
+
+       /* past */
+
+       for (q=hl-1; q>=0; q--) {
+           blockStartPos[q]=blockStartPos[q+1]-period[lagBlock[q+1]];
+           NearestNeighbor(lagBlock+q,plocs,
+               blockStartPos[q]+
+               ENH_BLOCKL_HALF-period[lagBlock[q+1]], periodl);
+
+
+           if (blockStartPos[q]-ENH_OVERHANG>=0) {
+               refiner(sseq+q*ENH_BLOCKL, blockStartPos+q, idata,
+                   idatal, centerStartPos, blockStartPos[q],
+                   period[lagBlock[q+1]]);
+           } else {
+               psseq=sseq+q*ENH_BLOCKL;
+               memset(psseq, 0, ENH_BLOCKL*sizeof(float));
+           }
+       }
+
+       /* future */
+
+       for (i=0; i<periodl; i++) {
+           plocs2[i]=plocs[i]-period[i];
+       }
+       for (q=hl+1; q<=2*hl; q++) {
+           NearestNeighbor(lagBlock+q,plocs2,
+               blockStartPos[q-1]+ENH_BLOCKL_HALF,periodl);
+
+           blockStartPos[q]=blockStartPos[q-1]+period[lagBlock[q]];
+           if (blockStartPos[q]+ENH_BLOCKL+ENH_OVERHANG<idatal) {
+               refiner(sseq+ENH_BLOCKL*q, blockStartPos+q, idata,
+                   idatal, centerStartPos, blockStartPos[q],
+                   period[lagBlock[q]]);
+           }
+           else {
+               psseq=sseq+q*ENH_BLOCKL;
+               memset(psseq, 0, ENH_BLOCKL*sizeof(float));
+           }
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    * perform enhancement on idata+centerStartPos through
+    * idata+centerStartPos+ENH_BLOCKL-1
+    *---------------------------------------------------------------*/
+
+
+
+
+
+   void enhancer(
+       float *odata,       /* (o) smoothed block, dimension blockl */
+       float *idata,       /* (i) data buffer used for enhancing */
+       int idatal,         /* (i) dimension idata */
+       int centerStartPos, /* (i) first sample current block
+                                  within idata */
+       float alpha0,       /* (i) max correction-energy-fraction
+                                 (in [0,1]) */
+       float *period,      /* (i) pitch period array */
+       float *plocs,       /* (i) locations where period array
+                                  values valid */
+       int periodl         /* (i) dimension of period and plocs */
+   ){
+       float sseq[(2*ENH_HL+1)*ENH_BLOCKL];
+
+       /* get said second sequence of segments */
+
+       getsseq(sseq,idata,idatal,centerStartPos,period,
+           plocs,periodl,ENH_HL);
+
+       /* compute the smoothed output from said second sequence */
+
+       smath(odata,sseq,ENH_HL,alpha0);
+
+   }
+
+   /*----------------------------------------------------------------*
+    * cross correlation
+    *---------------------------------------------------------------*/
+
+   float xCorrCoef(
+       float *target,      /* (i) first array */
+       float *regressor,   /* (i) second array */
+       int subl        /* (i) dimension arrays */
+   ){
+       int i;
+       float ftmp1, ftmp2;
+
+       ftmp1 = 0.0;
+       ftmp2 = 0.0;
+       for (i=0; i<subl; i++) {
+           ftmp1 += target[i]*regressor[i];
+           ftmp2 += regressor[i]*regressor[i];
+       }
+
+       if (ftmp1 > 0.0) {
+           return (float)(ftmp1*ftmp1/ftmp2);
+       }
+
+
+
+
+
+       else {
+           return (float)0.0;
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    * interface for enhancer
+    *---------------------------------------------------------------*/
+
+   int enhancerInterface(
+       float *out,                     /* (o) enhanced signal */
+       float *in,                      /* (i) unenhanced signal */
+       iLBC_Dec_Inst_t *iLBCdec_inst   /* (i) buffers etc */
+   ){
+       float *enh_buf, *enh_period;
+       int iblock, isample;
+       int lag=0, ilag, i, ioffset;
+       float cc, maxcc;
+       float ftmp1, ftmp2;
+       float *inPtr, *enh_bufPtr1, *enh_bufPtr2;
+       float plc_pred[ENH_BLOCKL];
+
+       float lpState[6], downsampled[(ENH_NBLOCKS*ENH_BLOCKL+120)/2];
+       int inLen=ENH_NBLOCKS*ENH_BLOCKL+120;
+       int start, plc_blockl, inlag;
+
+       enh_buf=iLBCdec_inst->enh_buf;
+       enh_period=iLBCdec_inst->enh_period;
+
+       memmove(enh_buf, &enh_buf[iLBCdec_inst->blockl],
+           (ENH_BUFL-iLBCdec_inst->blockl)*sizeof(float));
+
+       memcpy(&enh_buf[ENH_BUFL-iLBCdec_inst->blockl], in,
+           iLBCdec_inst->blockl*sizeof(float));
+
+       if (iLBCdec_inst->mode==30)
+           plc_blockl=ENH_BLOCKL;
+       else
+           plc_blockl=40;
+
+       /* when 20 ms frame, move processing one block */
+       ioffset=0;
+       if (iLBCdec_inst->mode==20) ioffset=1;
+
+       i=3-ioffset;
+       memmove(enh_period, &enh_period[i],
+           (ENH_NBLOCKS_TOT-i)*sizeof(float));
+
+
+
+
+
+
+       /* Set state information to the 6 samples right before
+          the samples to be downsampled. */
+
+       memcpy(lpState,
+           enh_buf+(ENH_NBLOCKS_EXTRA+ioffset)*ENH_BLOCKL-126,
+           6*sizeof(float));
+
+       /* Down sample a factor 2 to save computations */
+
+       DownSample(enh_buf+(ENH_NBLOCKS_EXTRA+ioffset)*ENH_BLOCKL-120,
+                   lpFilt_coefsTbl, inLen-ioffset*ENH_BLOCKL,
+                   lpState, downsampled);
+
+       /* Estimate the pitch in the down sampled domain. */
+       for (iblock = 0; iblock<ENH_NBLOCKS-ioffset; iblock++) {
+
+           lag = 10;
+           maxcc = xCorrCoef(downsampled+60+iblock*
+               ENH_BLOCKL_HALF, downsampled+60+iblock*
+               ENH_BLOCKL_HALF-lag, ENH_BLOCKL_HALF);
+           for (ilag=11; ilag<60; ilag++) {
+               cc = xCorrCoef(downsampled+60+iblock*
+                   ENH_BLOCKL_HALF, downsampled+60+iblock*
+                   ENH_BLOCKL_HALF-ilag, ENH_BLOCKL_HALF);
+
+               if (cc > maxcc) {
+                   maxcc = cc;
+                   lag = ilag;
+               }
+           }
+
+           /* Store the estimated lag in the non-downsampled domain */
+           enh_period[iblock+ENH_NBLOCKS_EXTRA+ioffset] = (float)lag*2;
+
+
+       }
+
+
+       /* PLC was performed on the previous packet */
+       if (iLBCdec_inst->prev_enh_pl==1) {
+
+           inlag=(int)enh_period[ENH_NBLOCKS_EXTRA+ioffset];
+
+           lag = inlag-1;
+           maxcc = xCorrCoef(in, in+lag, plc_blockl);
+           for (ilag=inlag; ilag<=inlag+1; ilag++) {
+               cc = xCorrCoef(in, in+ilag, plc_blockl);
+
+
+
+
+
+
+               if (cc > maxcc) {
+                   maxcc = cc;
+                   lag = ilag;
+               }
+           }
+
+           enh_period[ENH_NBLOCKS_EXTRA+ioffset-1]=(float)lag;
+
+           /* compute new concealed residual for the old lookahead,
+              mix the forward PLC with a backward PLC from
+              the new frame */
+
+           inPtr=&in[lag-1];
+
+           enh_bufPtr1=&plc_pred[plc_blockl-1];
+
+           if (lag>plc_blockl) {
+               start=plc_blockl;
+           } else {
+               start=lag;
+           }
+
+           for (isample = start; isample>0; isample--) {
+               *enh_bufPtr1-- = *inPtr--;
+           }
+
+           enh_bufPtr2=&enh_buf[ENH_BUFL-1-iLBCdec_inst->blockl];
+           for (isample = (plc_blockl-1-lag); isample>=0; isample--) {
+               *enh_bufPtr1-- = *enh_bufPtr2--;
+           }
+
+           /* limit energy change */
+           ftmp2=0.0;
+           ftmp1=0.0;
+           for (i=0;i<plc_blockl;i++) {
+               ftmp2+=enh_buf[ENH_BUFL-1-iLBCdec_inst->blockl-i]*
+                   enh_buf[ENH_BUFL-1-iLBCdec_inst->blockl-i];
+               ftmp1+=plc_pred[i]*plc_pred[i];
+           }
+           ftmp1=(float)sqrt(ftmp1/(float)plc_blockl);
+           ftmp2=(float)sqrt(ftmp2/(float)plc_blockl);
+           if (ftmp1>(float)2.0*ftmp2 && ftmp1>0.0) {
+               for (i=0;i<plc_blockl-10;i++) {
+                   plc_pred[i]*=(float)2.0*ftmp2/ftmp1;
+               }
+               for (i=plc_blockl-10;i<plc_blockl;i++) {
+                   plc_pred[i]*=(float)(i-plc_blockl+10)*
+                       ((float)1.0-(float)2.0*ftmp2/ftmp1)/(float)(10)+
+
+
+
+
+
+                       (float)2.0*ftmp2/ftmp1;
+               }
+           }
+
+           enh_bufPtr1=&enh_buf[ENH_BUFL-1-iLBCdec_inst->blockl];
+           for (i=0; i<plc_blockl; i++) {
+               ftmp1 = (float) (i+1) / (float) (plc_blockl+1);
+               *enh_bufPtr1 *= ftmp1;
+               *enh_bufPtr1 += ((float)1.0-ftmp1)*
+                                   plc_pred[plc_blockl-1-i];
+               enh_bufPtr1--;
+           }
+       }
+
+       if (iLBCdec_inst->mode==20) {
+           /* Enhancer with 40 samples delay */
+           for (iblock = 0; iblock<2; iblock++) {
+               enhancer(out+iblock*ENH_BLOCKL, enh_buf,
+                   ENH_BUFL, (5+iblock)*ENH_BLOCKL+40,
+                   ENH_ALPHA0, enh_period, enh_plocsTbl,
+                       ENH_NBLOCKS_TOT);
+           }
+       } else if (iLBCdec_inst->mode==30) {
+           /* Enhancer with 80 samples delay */
+           for (iblock = 0; iblock<3; iblock++) {
+               enhancer(out+iblock*ENH_BLOCKL, enh_buf,
+                   ENH_BUFL, (4+iblock)*ENH_BLOCKL,
+                   ENH_ALPHA0, enh_period, enh_plocsTbl,
+                       ENH_NBLOCKS_TOT);
+           }
+       }
+
+       return (lag*2);
+   }
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/enhancer.h asterisk-1.8.3.2_com_amr/codecs/ilbc/enhancer.h
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/enhancer.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/enhancer.h	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,36 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       enhancer.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+
+
+
+
+   ******************************************************************/
+
+   #ifndef __ENHANCER_H
+   #define __ENHANCER_H
+
+   #include "iLBC_define.h"
+
+   float xCorrCoef(
+       float *target,      /* (i) first array */
+       float *regressor,   /* (i) second array */
+       int subl        /* (i) dimension arrays */
+   );
+
+   int enhancerInterface(
+       float *out,         /* (o) the enhanced recidual signal */
+       float *in,          /* (i) the recidual signal to enhance */
+       iLBC_Dec_Inst_t *iLBCdec_inst
+                           /* (i/o) the decoder state structure */
+   );
+
+   #endif
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/extract-cfile.awk asterisk-1.8.3.2_com_amr/codecs/ilbc/extract-cfile.awk
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/extract-cfile.awk	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/extract-cfile.awk	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,24 @@
+BEGIN { srcname = "nothing"; }
+{ if (/^A\.[0-9][0-9]*\.* *[a-zA-Z][a-zA-Z_0-9]*\.[ch]/) {
+    if (srcname != "nothing")
+      close(srcname);
+    srcname = $2;
+    printf("creating source file %s\n", srcname);
+  }else if (srcname != "nothing") {
+    if (/Andersen,* *et* *al\./) 
+      printf("skipping %s\n", $0);
+    else if (//)
+      printf("skipping2 %s\n", $0);
+    else if (/Internet Low Bit Rate Codec *December 2004/)
+      printf("skipping3 %s\n", $0);
+    else if (/Authors' *Addresses/){
+      close(srcname);
+      exit;}
+    else
+      print $0 >> srcname;
+  }
+}
+END {
+  printf("ending file %s\n", srcname);
+  close(srcname);
+}
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/filter.c asterisk-1.8.3.2_com_amr/codecs/ilbc/filter.c
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/filter.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/filter.c	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,175 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       filter.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include "iLBC_define.h"
+
+   /*----------------------------------------------------------------*
+    *  all-pole filter
+    *---------------------------------------------------------------*/
+
+   void AllPoleFilter(
+       float *InOut,   /* (i/o) on entrance InOut[-orderCoef] to
+                              InOut[-1] contain the state of the
+                              filter (delayed samples). InOut[0] to
+                              InOut[lengthInOut-1] contain the filter
+                              input, on en exit InOut[-orderCoef] to
+                              InOut[-1] is unchanged and InOut[0] to
+                              InOut[lengthInOut-1] contain filtered
+                              samples */
+       float *Coef,/* (i) filter coefficients, Coef[0] is assumed
+                              to be 1.0 */
+       int lengthInOut,/* (i) number of input/output samples */
+       int orderCoef   /* (i) number of filter coefficients */
+   ){
+       int n,k;
+
+       for(n=0;n<lengthInOut;n++){
+           for(k=1;k<=orderCoef;k++){
+               *InOut -= Coef[k]*InOut[-k];
+
+
+
+
+
+           }
+           InOut++;
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  all-zero filter
+    *---------------------------------------------------------------*/
+
+   void AllZeroFilter(
+       float *In,      /* (i) In[0] to In[lengthInOut-1] contain
+                              filter input samples */
+       float *Coef,/* (i) filter coefficients (Coef[0] is assumed
+                              to be 1.0) */
+       int lengthInOut,/* (i) number of input/output samples */
+       int orderCoef,  /* (i) number of filter coefficients */
+       float *Out      /* (i/o) on entrance Out[-orderCoef] to Out[-1]
+                              contain the filter state, on exit Out[0]
+                              to Out[lengthInOut-1] contain filtered
+                              samples */
+   ){
+       int n,k;
+
+       for(n=0;n<lengthInOut;n++){
+           *Out = Coef[0]*In[0];
+           for(k=1;k<=orderCoef;k++){
+               *Out += Coef[k]*In[-k];
+           }
+           Out++;
+           In++;
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  pole-zero filter
+    *---------------------------------------------------------------*/
+
+   void ZeroPoleFilter(
+       float *In,      /* (i) In[0] to In[lengthInOut-1] contain
+                              filter input samples In[-orderCoef] to
+                              In[-1] contain state of all-zero
+                              section */
+       float *ZeroCoef,/* (i) filter coefficients for all-zero
+                              section (ZeroCoef[0] is assumed to
+                              be 1.0) */
+       float *PoleCoef,/* (i) filter coefficients for all-pole section
+                              (ZeroCoef[0] is assumed to be 1.0) */
+       int lengthInOut,/* (i) number of input/output samples */
+
+
+
+
+
+       int orderCoef,  /* (i) number of filter coefficients */
+       float *Out      /* (i/o) on entrance Out[-orderCoef] to Out[-1]
+                              contain state of all-pole section. On
+                              exit Out[0] to Out[lengthInOut-1]
+                              contain filtered samples */
+   ){
+       AllZeroFilter(In,ZeroCoef,lengthInOut,orderCoef,Out);
+       AllPoleFilter(Out,PoleCoef,lengthInOut,orderCoef);
+   }
+
+   /*----------------------------------------------------------------*
+    * downsample (LP filter and decimation)
+    *---------------------------------------------------------------*/
+
+   void DownSample (
+       float  *In,     /* (i) input samples */
+       float  *Coef,   /* (i) filter coefficients */
+       int lengthIn,   /* (i) number of input samples */
+       float  *state,  /* (i) filter state */
+       float  *Out     /* (o) downsampled output */
+   ){
+       float   o;
+       float *Out_ptr = Out;
+       float *Coef_ptr, *In_ptr;
+       float *state_ptr;
+       int i, j, stop;
+
+       /* LP filter and decimate at the same time */
+
+       for (i = DELAY_DS; i < lengthIn; i+=FACTOR_DS)
+       {
+           Coef_ptr = &Coef[0];
+           In_ptr = &In[i];
+           state_ptr = &state[FILTERORDER_DS-2];
+
+           o = (float)0.0;
+
+           stop = (i < FILTERORDER_DS) ? i + 1 : FILTERORDER_DS;
+
+           for (j = 0; j < stop; j++)
+           {
+               o += *Coef_ptr++ * (*In_ptr--);
+           }
+           for (j = i + 1; j < FILTERORDER_DS; j++)
+           {
+               o += *Coef_ptr++ * (*state_ptr--);
+           }
+
+
+
+
+
+
+           *Out_ptr++ = o;
+       }
+
+       /* Get the last part (use zeros as input for the future) */
+
+       for (i=(lengthIn+FACTOR_DS); i<(lengthIn+DELAY_DS);
+               i+=FACTOR_DS) {
+
+           o=(float)0.0;
+
+           if (i<lengthIn) {
+               Coef_ptr = &Coef[0];
+               In_ptr = &In[i];
+               for (j=0; j<FILTERORDER_DS; j++) {
+                       o += *Coef_ptr++ * (*Out_ptr--);
+               }
+           } else {
+               Coef_ptr = &Coef[i-lengthIn];
+               In_ptr = &In[lengthIn-1];
+               for (j=0; j<FILTERORDER_DS-(i-lengthIn); j++) {
+                       o += *Coef_ptr++ * (*In_ptr--);
+               }
+           }
+           *Out_ptr++ = o;
+       }
+   }
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/filter.h asterisk-1.8.3.2_com_amr/codecs/ilbc/filter.h
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/filter.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/filter.h	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,80 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       filter.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+
+
+
+
+
+   #ifndef __iLBC_FILTER_H
+   #define __iLBC_FILTER_H
+
+   void AllPoleFilter(
+       float *InOut,   /* (i/o) on entrance InOut[-orderCoef] to
+                              InOut[-1] contain the state of the
+                              filter (delayed samples). InOut[0] to
+                              InOut[lengthInOut-1] contain the filter
+                              input, on en exit InOut[-orderCoef] to
+                              InOut[-1] is unchanged and InOut[0] to
+                              InOut[lengthInOut-1] contain filtered
+                              samples */
+       float *Coef,/* (i) filter coefficients, Coef[0] is assumed
+                              to be 1.0 */
+       int lengthInOut,/* (i) number of input/output samples */
+       int orderCoef   /* (i) number of filter coefficients */
+   );
+
+   void AllZeroFilter(
+       float *In,      /* (i) In[0] to In[lengthInOut-1] contain
+                              filter input samples */
+       float *Coef,/* (i) filter coefficients (Coef[0] is assumed
+                              to be 1.0) */
+       int lengthInOut,/* (i) number of input/output samples */
+       int orderCoef,  /* (i) number of filter coefficients */
+       float *Out      /* (i/o) on entrance Out[-orderCoef] to Out[-1]
+                              contain the filter state, on exit Out[0]
+                              to Out[lengthInOut-1] contain filtered
+                              samples */
+   );
+
+   void ZeroPoleFilter(
+       float *In,      /* (i) In[0] to In[lengthInOut-1] contain filter
+                              input samples In[-orderCoef] to In[-1]
+                              contain state of all-zero section */
+       float *ZeroCoef,/* (i) filter coefficients for all-zero
+                              section (ZeroCoef[0] is assumed to
+                              be 1.0) */
+       float *PoleCoef,/* (i) filter coefficients for all-pole section
+                              (ZeroCoef[0] is assumed to be 1.0) */
+       int lengthInOut,/* (i) number of input/output samples */
+       int orderCoef,  /* (i) number of filter coefficients */
+       float *Out      /* (i/o) on entrance Out[-orderCoef] to Out[-1]
+                              contain state of all-pole section. On
+                              exit Out[0] to Out[lengthInOut-1]
+                              contain filtered samples */
+   );
+
+
+
+
+
+
+   void DownSample (
+       float  *In,     /* (i) input samples */
+       float  *Coef,   /* (i) filter coefficients */
+       int lengthIn,   /* (i) number of input samples */
+       float  *state,  /* (i) filter state */
+       float  *Out     /* (o) downsampled output */
+   );
+
+   #endif
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/FrameClassify.c asterisk-1.8.3.2_com_amr/codecs/ilbc/FrameClassify.c
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/FrameClassify.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/FrameClassify.c	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,114 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       FrameClassify.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include "iLBC_define.h"
+
+   /*---------------------------------------------------------------*
+    *  Classification of subframes to localize start state
+    *--------------------------------------------------------------*/
+
+   int FrameClassify(      /* index to the max-energy sub-frame */
+       iLBC_Enc_Inst_t *iLBCenc_inst,
+                           /* (i/o) the encoder state structure */
+       float *residual     /* (i) lpc residual signal */
+   ) {
+       float max_ssqEn, fssqEn[NSUB_MAX], bssqEn[NSUB_MAX], *pp;
+       int n, l, max_ssqEn_n;
+       const float ssqEn_win[NSUB_MAX-1]={(float)0.8,(float)0.9,
+           (float)1.0,(float)0.9,(float)0.8};
+       const float sampEn_win[5]={(float)1.0/(float)6.0,
+           (float)2.0/(float)6.0, (float)3.0/(float)6.0,
+           (float)4.0/(float)6.0, (float)5.0/(float)6.0};
+
+       /* init the front and back energies to zero */
+
+       memset(fssqEn, 0, NSUB_MAX*sizeof(float));
+       memset(bssqEn, 0, NSUB_MAX*sizeof(float));
+
+       /* Calculate front of first seqence */
+
+       n=0;
+       pp=residual;
+       for (l=0; l<5; l++) {
+           fssqEn[n] += sampEn_win[l] * (*pp) * (*pp);
+           pp++;
+       }
+       for (l=5; l<SUBL; l++) {
+
+
+
+
+
+           fssqEn[n] += (*pp) * (*pp);
+           pp++;
+       }
+
+       /* Calculate front and back of all middle sequences */
+
+       for (n=1; n<iLBCenc_inst->nsub-1; n++) {
+           pp=residual+n*SUBL;
+           for (l=0; l<5; l++) {
+               fssqEn[n] += sampEn_win[l] * (*pp) * (*pp);
+               bssqEn[n] += (*pp) * (*pp);
+               pp++;
+           }
+           for (l=5; l<SUBL-5; l++) {
+               fssqEn[n] += (*pp) * (*pp);
+               bssqEn[n] += (*pp) * (*pp);
+               pp++;
+           }
+           for (l=SUBL-5; l<SUBL; l++) {
+               fssqEn[n] += (*pp) * (*pp);
+               bssqEn[n] += sampEn_win[SUBL-l-1] * (*pp) * (*pp);
+               pp++;
+           }
+       }
+
+       /* Calculate back of last seqence */
+
+       n=iLBCenc_inst->nsub-1;
+       pp=residual+n*SUBL;
+       for (l=0; l<SUBL-5; l++) {
+           bssqEn[n] += (*pp) * (*pp);
+           pp++;
+       }
+       for (l=SUBL-5; l<SUBL; l++) {
+           bssqEn[n] += sampEn_win[SUBL-l-1] * (*pp) * (*pp);
+           pp++;
+       }
+
+       /* find the index to the weighted 80 sample with
+          most energy */
+
+       if (iLBCenc_inst->mode==20) l=1;
+       else                        l=0;
+
+       max_ssqEn=(fssqEn[0]+bssqEn[1])*ssqEn_win[l];
+       max_ssqEn_n=1;
+       for (n=2; n<iLBCenc_inst->nsub; n++) {
+
+
+
+
+
+
+           l++;
+           if ((fssqEn[n-1]+bssqEn[n])*ssqEn_win[l] > max_ssqEn) {
+               max_ssqEn=(fssqEn[n-1]+bssqEn[n]) *
+                               ssqEn_win[l];
+               max_ssqEn_n=n;
+           }
+       }
+
+       return max_ssqEn_n;
+   }
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/FrameClassify.h asterisk-1.8.3.2_com_amr/codecs/ilbc/FrameClassify.h
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/FrameClassify.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/FrameClassify.h	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,27 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       FrameClassify.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_FRAMECLASSIFY_H
+   #define __iLBC_FRAMECLASSIFY_H
+
+   int FrameClassify(      /* index to the max-energy sub-frame */
+       iLBC_Enc_Inst_t *iLBCenc_inst,
+                           /* (i/o) the encoder state structure */
+       float *residual     /* (i) lpc residual signal */
+   );
+
+
+
+
+
+   #endif
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/gainquant.c asterisk-1.8.3.2_com_amr/codecs/ilbc/gainquant.c
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/gainquant.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/gainquant.c	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,116 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+
+
+
+
+
+       gainquant.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <string.h>
+   #include <math.h>
+   #include "constants.h"
+   #include "filter.h"
+
+   /*----------------------------------------------------------------*
+    *  quantizer for the gain in the gain-shape coding of residual
+    *---------------------------------------------------------------*/
+
+   float gainquant(/* (o) quantized gain value */
+       float in,       /* (i) gain value */
+       float maxIn,/* (i) maximum of gain value */
+       int cblen,      /* (i) number of quantization indices */
+       int *index      /* (o) quantization index */
+   ){
+       int i, tindex;
+       float minmeasure,measure, *cb, scale;
+
+       /* ensure a lower bound on the scaling factor */
+
+       scale=maxIn;
+
+       if (scale<0.1) {
+           scale=(float)0.1;
+       }
+
+       /* select the quantization table */
+
+       if (cblen == 8) {
+           cb = gain_sq3Tbl;
+       } else if (cblen == 16) {
+           cb = gain_sq4Tbl;
+       } else  {
+           cb = gain_sq5Tbl;
+       }
+
+       /* select the best index in the quantization table */
+
+       minmeasure=10000000.0;
+       tindex=0;
+       for (i=0; i<cblen; i++) {
+
+
+
+
+
+           measure=(in-scale*cb[i])*(in-scale*cb[i]);
+
+           if (measure<minmeasure) {
+               tindex=i;
+               minmeasure=measure;
+           }
+       }
+       *index=tindex;
+
+       /* return the quantized value */
+
+       return scale*cb[tindex];
+   }
+
+   /*----------------------------------------------------------------*
+    *  decoder for quantized gains in the gain-shape coding of
+    *  residual
+    *---------------------------------------------------------------*/
+
+   float gaindequant(  /* (o) quantized gain value */
+       int index,      /* (i) quantization index */
+       float maxIn,/* (i) maximum of unquantized gain */
+       int cblen       /* (i) number of quantization indices */
+   ){
+       float scale;
+
+       /* obtain correct scale factor */
+
+       scale=(float)fabs(maxIn);
+
+       if (scale<0.1) {
+           scale=(float)0.1;
+       }
+
+       /* select the quantization table and return the decoded value */
+
+       if (cblen==8) {
+           return scale*gain_sq3Tbl[index];
+       } else if (cblen==16) {
+           return scale*gain_sq4Tbl[index];
+       }
+       else if (cblen==32) {
+           return scale*gain_sq5Tbl[index];
+       }
+
+       return 0.0;
+   }
+
+
+
+
+
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/gainquant.h asterisk-1.8.3.2_com_amr/codecs/ilbc/gainquant.h
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/gainquant.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/gainquant.h	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,30 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       gainquant.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_GAINQUANT_H
+   #define __iLBC_GAINQUANT_H
+
+   float gainquant(/* (o) quantized gain value */
+       float in,       /* (i) gain value */
+       float maxIn,/* (i) maximum of gain value */
+       int cblen,      /* (i) number of quantization indices */
+       int *index      /* (o) quantization index */
+   );
+
+   float gaindequant(  /* (o) quantized gain value */
+       int index,      /* (i) quantization index */
+       float maxIn,/* (i) maximum of unquantized gain */
+       int cblen       /* (i) number of quantization indices */
+   );
+
+   #endif
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/getCBvec.c asterisk-1.8.3.2_com_amr/codecs/ilbc/getCBvec.c
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/getCBvec.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/getCBvec.c	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,193 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       getCBvec.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include "iLBC_define.h"
+   #include "constants.h"
+   #include <string.h>
+
+   /*----------------------------------------------------------------*
+    *  Construct codebook vector for given index.
+    *---------------------------------------------------------------*/
+
+   void getCBvec(
+
+
+
+
+
+       float *cbvec,   /* (o) Constructed codebook vector */
+       float *mem,     /* (i) Codebook buffer */
+       int index,      /* (i) Codebook index */
+       int lMem,       /* (i) Length of codebook buffer */
+       int cbveclen/* (i) Codebook vector length */
+   ){
+       int j, k, n, memInd, sFilt;
+       float tmpbuf[CB_MEML];
+       int base_size;
+       int ilow, ihigh;
+       float alfa, alfa1;
+
+       /* Determine size of codebook sections */
+
+       base_size=lMem-cbveclen+1;
+
+       if (cbveclen==SUBL) {
+           base_size+=cbveclen/2;
+       }
+
+       /* No filter -> First codebook section */
+
+       if (index<lMem-cbveclen+1) {
+
+           /* first non-interpolated vectors */
+
+           k=index+cbveclen;
+           /* get vector */
+           memcpy(cbvec, mem+lMem-k, cbveclen*sizeof(float));
+
+       } else if (index < base_size) {
+
+           k=2*(index-(lMem-cbveclen+1))+cbveclen;
+
+           ihigh=k/2;
+           ilow=ihigh-5;
+
+           /* Copy first noninterpolated part */
+
+           memcpy(cbvec, mem+lMem-k/2, ilow*sizeof(float));
+
+           /* interpolation */
+
+           alfa1=(float)0.2;
+           alfa=0.0;
+           for (j=ilow; j<ihigh; j++) {
+               cbvec[j]=((float)1.0-alfa)*mem[lMem-k/2+j]+
+                   alfa*mem[lMem-k+j];
+
+
+
+
+
+               alfa+=alfa1;
+           }
+
+           /* Copy second noninterpolated part */
+
+           memcpy(cbvec+ihigh, mem+lMem-k+ihigh,
+               (cbveclen-ihigh)*sizeof(float));
+
+       }
+
+       /* Higher codebook section based on filtering */
+
+       else {
+
+           /* first non-interpolated vectors */
+
+           if (index-base_size<lMem-cbveclen+1) {
+               float tempbuff2[CB_MEML+CB_FILTERLEN+1];
+               float *pos;
+               float *pp, *pp1;
+
+               memset(tempbuff2, 0,
+                   CB_HALFFILTERLEN*sizeof(float));
+               memcpy(&tempbuff2[CB_HALFFILTERLEN], mem,
+                   lMem*sizeof(float));
+               memset(&tempbuff2[lMem+CB_HALFFILTERLEN], 0,
+                   (CB_HALFFILTERLEN+1)*sizeof(float));
+
+               k=index-base_size+cbveclen;
+               sFilt=lMem-k;
+               memInd=sFilt+1-CB_HALFFILTERLEN;
+
+               /* do filtering */
+               pos=cbvec;
+               memset(pos, 0, cbveclen*sizeof(float));
+               for (n=0; n<cbveclen; n++) {
+                   pp=&tempbuff2[memInd+n+CB_HALFFILTERLEN];
+                   pp1=&cbfiltersTbl[CB_FILTERLEN-1];
+                   for (j=0; j<CB_FILTERLEN; j++) {
+                       (*pos)+=(*pp++)*(*pp1--);
+                   }
+                   pos++;
+               }
+           }
+
+           /* interpolated vectors */
+
+           else {
+
+
+
+
+
+               float tempbuff2[CB_MEML+CB_FILTERLEN+1];
+
+               float *pos;
+               float *pp, *pp1;
+               int i;
+
+               memset(tempbuff2, 0,
+                   CB_HALFFILTERLEN*sizeof(float));
+               memcpy(&tempbuff2[CB_HALFFILTERLEN], mem,
+                   lMem*sizeof(float));
+               memset(&tempbuff2[lMem+CB_HALFFILTERLEN], 0,
+                   (CB_HALFFILTERLEN+1)*sizeof(float));
+
+               k=2*(index-base_size-
+                   (lMem-cbveclen+1))+cbveclen;
+               sFilt=lMem-k;
+               memInd=sFilt+1-CB_HALFFILTERLEN;
+
+               /* do filtering */
+               pos=&tmpbuf[sFilt];
+               memset(pos, 0, k*sizeof(float));
+               for (i=0; i<k; i++) {
+                   pp=&tempbuff2[memInd+i+CB_HALFFILTERLEN];
+                   pp1=&cbfiltersTbl[CB_FILTERLEN-1];
+                   for (j=0; j<CB_FILTERLEN; j++) {
+                       (*pos)+=(*pp++)*(*pp1--);
+                   }
+                   pos++;
+               }
+
+               ihigh=k/2;
+               ilow=ihigh-5;
+
+               /* Copy first noninterpolated part */
+
+               memcpy(cbvec, tmpbuf+lMem-k/2,
+                   ilow*sizeof(float));
+
+               /* interpolation */
+
+               alfa1=(float)0.2;
+               alfa=0.0;
+               for (j=ilow; j<ihigh; j++) {
+                   cbvec[j]=((float)1.0-alfa)*
+                       tmpbuf[lMem-k/2+j]+alfa*tmpbuf[lMem-k+j];
+                   alfa+=alfa1;
+               }
+
+
+
+
+
+
+               /* Copy second noninterpolated part */
+
+               memcpy(cbvec+ihigh, tmpbuf+lMem-k+ihigh,
+                   (cbveclen-ihigh)*sizeof(float));
+           }
+       }
+   }
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/getCBvec.h asterisk-1.8.3.2_com_amr/codecs/ilbc/getCBvec.h
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/getCBvec.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/getCBvec.h	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,25 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       getCBvec.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_GETCBVEC_H
+   #define __iLBC_GETCBVEC_H
+
+   void getCBvec(
+       float *cbvec,   /* (o) Constructed codebook vector */
+       float *mem,     /* (i) Codebook buffer */
+       int index,      /* (i) Codebook index */
+       int lMem,       /* (i) Length of codebook buffer */
+       int cbveclen/* (i) Codebook vector length */
+   );
+
+   #endif
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/helpfun.c asterisk-1.8.3.2_com_amr/codecs/ilbc/helpfun.c
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/helpfun.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/helpfun.c	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,326 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       helpfun.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <math.h>
+
+   #include "iLBC_define.h"
+   #include "constants.h"
+
+   /*----------------------------------------------------------------*
+    *  calculation of auto correlation
+    *---------------------------------------------------------------*/
+
+   void autocorr(
+       float *r,       /* (o) autocorrelation vector */
+       const float *x, /* (i) data vector */
+       int N,          /* (i) length of data vector */
+       int order       /* largest lag for calculated
+                          autocorrelations */
+   ){
+       int     lag, n;
+       float   sum;
+
+       for (lag = 0; lag <= order; lag++) {
+           sum = 0;
+           for (n = 0; n < N - lag; n++) {
+               sum += x[n] * x[n+lag];
+           }
+           r[lag] = sum;
+       }
+
+
+
+
+
+   }
+
+   /*----------------------------------------------------------------*
+    *  window multiplication
+    *---------------------------------------------------------------*/
+
+   void window(
+       float *z,       /* (o) the windowed data */
+       const float *x, /* (i) the original data vector */
+       const float *y, /* (i) the window */
+       int N           /* (i) length of all vectors */
+   ){
+       int     i;
+
+       for (i = 0; i < N; i++) {
+           z[i] = x[i] * y[i];
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  levinson-durbin solution for lpc coefficients
+    *---------------------------------------------------------------*/
+
+   void levdurb(
+       float *a,       /* (o) lpc coefficient vector starting
+                              with 1.0 */
+       float *k,       /* (o) reflection coefficients */
+       float *r,       /* (i) autocorrelation vector */
+       int order       /* (i) order of lpc filter */
+   ){
+       float  sum, alpha;
+       int     m, m_h, i;
+
+       a[0] = 1.0;
+
+       if (r[0] < EPS) { /* if r[0] <= 0, set LPC coeff. to zero */
+           for (i = 0; i < order; i++) {
+               k[i] = 0;
+               a[i+1] = 0;
+           }
+       } else {
+           a[1] = k[0] = -r[1]/r[0];
+           alpha = r[0] + r[1] * k[0];
+           for (m = 1; m < order; m++){
+               sum = r[m + 1];
+               for (i = 0; i < m; i++){
+                   sum += a[i+1] * r[m - i];
+               }
+
+
+
+
+
+               k[m] = -sum / alpha;
+               alpha += k[m] * sum;
+               m_h = (m + 1) >> 1;
+               for (i = 0; i < m_h; i++){
+                   sum = a[i+1] + k[m] * a[m - i];
+                   a[m - i] += k[m] * a[i+1];
+                   a[i+1] = sum;
+               }
+               a[m+1] = k[m];
+           }
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  interpolation between vectors
+    *---------------------------------------------------------------*/
+
+   void interpolate(
+       float *out,      /* (o) the interpolated vector */
+       float *in1,     /* (i) the first vector for the
+                              interpolation */
+       float *in2,     /* (i) the second vector for the
+                              interpolation */
+       float coef,      /* (i) interpolation weights */
+       int length      /* (i) length of all vectors */
+   ){
+       int i;
+       float invcoef;
+
+       invcoef = (float)1.0 - coef;
+       for (i = 0; i < length; i++) {
+           out[i] = coef * in1[i] + invcoef * in2[i];
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  lpc bandwidth expansion
+    *---------------------------------------------------------------*/
+
+   void bwexpand(
+       float *out,      /* (o) the bandwidth expanded lpc
+                              coefficients */
+       float *in,      /* (i) the lpc coefficients before bandwidth
+                              expansion */
+       float coef,     /* (i) the bandwidth expansion factor */
+       int length      /* (i) the length of lpc coefficient vectors */
+   ){
+       int i;
+
+
+
+
+
+       float  chirp;
+
+       chirp = coef;
+
+       out[0] = in[0];
+       for (i = 1; i < length; i++) {
+           out[i] = chirp * in[i];
+           chirp *= coef;
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  vector quantization
+    *---------------------------------------------------------------*/
+
+   void vq(
+       float *Xq,      /* (o) the quantized vector */
+       int *index,     /* (o) the quantization index */
+       const float *CB,/* (i) the vector quantization codebook */
+       float *X,       /* (i) the vector to quantize */
+       int n_cb,       /* (i) the number of vectors in the codebook */
+       int dim         /* (i) the dimension of all vectors */
+   ){
+       int     i, j;
+       int     pos, minindex;
+       float   dist, tmp, mindist;
+
+       pos = 0;
+       mindist = FLOAT_MAX;
+       minindex = 0;
+       for (j = 0; j < n_cb; j++) {
+           dist = X[0] - CB[pos];
+           dist *= dist;
+           for (i = 1; i < dim; i++) {
+               tmp = X[i] - CB[pos + i];
+               dist += tmp*tmp;
+           }
+
+           if (dist < mindist) {
+               mindist = dist;
+               minindex = j;
+           }
+           pos += dim;
+       }
+       for (i = 0; i < dim; i++) {
+           Xq[i] = CB[minindex*dim + i];
+       }
+       *index = minindex;
+
+
+
+
+
+   }
+
+   /*----------------------------------------------------------------*
+    *  split vector quantization
+    *---------------------------------------------------------------*/
+
+   void SplitVQ(
+       float *qX,      /* (o) the quantized vector */
+       int *index,     /* (o) a vector of indexes for all vector
+                              codebooks in the split */
+       float *X,       /* (i) the vector to quantize */
+       const float *CB,/* (i) the quantizer codebook */
+       int nsplit,     /* the number of vector splits */
+       const int *dim, /* the dimension of X and qX */
+       const int *cbsize /* the number of vectors in the codebook */
+   ){
+       int    cb_pos, X_pos, i;
+
+       cb_pos = 0;
+       X_pos= 0;
+       for (i = 0; i < nsplit; i++) {
+           vq(qX + X_pos, index + i, CB + cb_pos, X + X_pos,
+               cbsize[i], dim[i]);
+           X_pos += dim[i];
+           cb_pos += dim[i] * cbsize[i];
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  scalar quantization
+    *---------------------------------------------------------------*/
+
+   void sort_sq(
+       float *xq,      /* (o) the quantized value */
+       int *index,     /* (o) the quantization index */
+       float x,    /* (i) the value to quantize */
+       const float *cb,/* (i) the quantization codebook */
+       int cb_size      /* (i) the size of the quantization codebook */
+   ){
+       int i;
+
+       if (x <= cb[0]) {
+           *index = 0;
+           *xq = cb[0];
+       } else {
+           i = 0;
+           while ((x > cb[i]) && i < cb_size - 1) {
+               i++;
+
+
+
+
+
+           }
+
+           if (x > ((cb[i] + cb[i - 1])/2)) {
+               *index = i;
+               *xq = cb[i];
+           } else {
+               *index = i - 1;
+               *xq = cb[i - 1];
+           }
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  check for stability of lsf coefficients
+    *---------------------------------------------------------------*/
+
+   int LSF_check(    /* (o) 1 for stable lsf vectors and 0 for
+                              nonstable ones */
+       float *lsf,     /* (i) a table of lsf vectors */
+       int dim,    /* (i) the dimension of each lsf vector */
+       int NoAn    /* (i) the number of lsf vectors in the
+                              table */
+   ){
+       int k,n,m, Nit=2, change=0,pos;
+       float tmp;
+       static float eps=(float)0.039; /* 50 Hz */
+       static float eps2=(float)0.0195;
+       static float maxlsf=(float)3.14; /* 4000 Hz */
+       static float minlsf=(float)0.01; /* 0 Hz */
+
+       /* LSF separation check*/
+
+       for (n=0; n<Nit; n++) { /* Run through a couple of times */
+           for (m=0; m<NoAn; m++) { /* Number of analyses per frame */
+               for (k=0; k<(dim-1); k++) {
+                   pos=m*dim+k;
+
+                   if ((lsf[pos+1]-lsf[pos])<eps) {
+
+                       if (lsf[pos+1]<lsf[pos]) {
+                           tmp=lsf[pos+1];
+                           lsf[pos+1]= lsf[pos]+eps2;
+                           lsf[pos]= lsf[pos+1]-eps2;
+                       } else {
+                           lsf[pos]-=eps2;
+                           lsf[pos+1]+=eps2;
+                       }
+                       change=1;
+
+
+
+
+
+                   }
+
+                   if (lsf[pos]<minlsf) {
+                       lsf[pos]=minlsf;
+                       change=1;
+                   }
+
+                   if (lsf[pos]>maxlsf) {
+                       lsf[pos]=maxlsf;
+                       change=1;
+                   }
+               }
+           }
+       }
+
+       return change;
+   }
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/helpfun.h asterisk-1.8.3.2_com_amr/codecs/ilbc/helpfun.h
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/helpfun.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/helpfun.h	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,106 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       helpfun.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_HELPFUN_H
+   #define __iLBC_HELPFUN_H
+
+   void autocorr(
+       float *r,       /* (o) autocorrelation vector */
+       const float *x, /* (i) data vector */
+       int N,          /* (i) length of data vector */
+       int order       /* largest lag for calculated
+                          autocorrelations */
+   );
+
+   void window(
+       float *z,       /* (o) the windowed data */
+       const float *x, /* (i) the original data vector */
+       const float *y, /* (i) the window */
+       int N           /* (i) length of all vectors */
+   );
+
+   void levdurb(
+       float *a,       /* (o) lpc coefficient vector starting
+                              with 1.0 */
+       float *k,       /* (o) reflection coefficients */
+       float *r,       /* (i) autocorrelation vector */
+       int order       /* (i) order of lpc filter */
+   );
+
+   void interpolate(
+
+
+
+
+
+       float *out,     /* (o) the interpolated vector */
+       float *in1,     /* (i) the first vector for the
+                              interpolation */
+       float *in2,     /* (i) the second vector for the
+                              interpolation */
+       float coef,     /* (i) interpolation weights */
+       int length      /* (i) length of all vectors */
+   );
+
+   void bwexpand(
+       float *out,     /* (o) the bandwidth expanded lpc
+                              coefficients */
+       float *in,      /* (i) the lpc coefficients before bandwidth
+                              expansion */
+       float coef,     /* (i) the bandwidth expansion factor */
+       int length      /* (i) the length of lpc coefficient vectors */
+   );
+
+   void vq(
+       float *Xq,      /* (o) the quantized vector */
+       int *index,     /* (o) the quantization index */
+       const float *CB,/* (i) the vector quantization codebook */
+       float *X,       /* (i) the vector to quantize */
+       int n_cb,       /* (i) the number of vectors in the codebook */
+       int dim         /* (i) the dimension of all vectors */
+   );
+
+   void SplitVQ(
+       float *qX,      /* (o) the quantized vector */
+       int *index,     /* (o) a vector of indexes for all vector
+                              codebooks in the split */
+       float *X,       /* (i) the vector to quantize */
+       const float *CB,/* (i) the quantizer codebook */
+       int nsplit,     /* the number of vector splits */
+       const int *dim, /* the dimension of X and qX */
+       const int *cbsize /* the number of vectors in the codebook */
+   );
+
+
+   void sort_sq(
+       float *xq,      /* (o) the quantized value */
+       int *index,     /* (o) the quantization index */
+       float x,    /* (i) the value to quantize */
+       const float *cb,/* (i) the quantization codebook */
+       int cb_size     /* (i) the size of the quantization codebook */
+   );
+
+   int LSF_check(      /* (o) 1 for stable lsf vectors and 0 for
+
+
+
+
+
+                              nonstable ones */
+       float *lsf,     /* (i) a table of lsf vectors */
+       int dim,    /* (i) the dimension of each lsf vector */
+       int NoAn    /* (i) the number of lsf vectors in the
+                              table */
+   );
+
+   #endif
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/hpInput.c asterisk-1.8.3.2_com_amr/codecs/ilbc/hpInput.c
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/hpInput.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/hpInput.c	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,65 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+
+
+
+
+       hpInput.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include "constants.h"
+
+   /*----------------------------------------------------------------*
+    *  Input high-pass filter
+    *---------------------------------------------------------------*/
+
+   void hpInput(
+       float *In,  /* (i) vector to filter */
+       int len,    /* (i) length of vector to filter */
+       float *Out, /* (o) the resulting filtered vector */
+       float *mem  /* (i/o) the filter state */
+   ){
+       int i;
+       float *pi, *po;
+
+       /* all-zero section*/
+
+       pi = &In[0];
+       po = &Out[0];
+       for (i=0; i<len; i++) {
+           *po = hpi_zero_coefsTbl[0] * (*pi);
+           *po += hpi_zero_coefsTbl[1] * mem[0];
+           *po += hpi_zero_coefsTbl[2] * mem[1];
+
+           mem[1] = mem[0];
+           mem[0] = *pi;
+           po++;
+           pi++;
+
+       }
+
+       /* all-pole section*/
+
+       po = &Out[0];
+       for (i=0; i<len; i++) {
+           *po -= hpi_pole_coefsTbl[1] * mem[2];
+           *po -= hpi_pole_coefsTbl[2] * mem[3];
+
+           mem[3] = mem[2];
+           mem[2] = *po;
+           po++;
+
+
+
+
+
+       }
+   }
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/hpInput.h asterisk-1.8.3.2_com_amr/codecs/ilbc/hpInput.h
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/hpInput.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/hpInput.h	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,24 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       hpInput.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_HPINPUT_H
+   #define __iLBC_HPINPUT_H
+
+   void hpInput(
+       float *In,  /* (i) vector to filter */
+       int len,    /* (i) length of vector to filter */
+       float *Out, /* (o) the resulting filtered vector */
+       float *mem  /* (i/o) the filter state */
+   );
+
+   #endif
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/hpOutput.c asterisk-1.8.3.2_com_amr/codecs/ilbc/hpOutput.c
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/hpOutput.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/hpOutput.c	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,61 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       hpOutput.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include "constants.h"
+
+   /*----------------------------------------------------------------*
+    *  Output high-pass filter
+    *---------------------------------------------------------------*/
+
+   void hpOutput(
+
+
+
+
+
+       float *In,  /* (i) vector to filter */
+       int len,/* (i) length of vector to filter */
+       float *Out, /* (o) the resulting filtered vector */
+       float *mem  /* (i/o) the filter state */
+   ){
+       int i;
+       float *pi, *po;
+
+       /* all-zero section*/
+
+       pi = &In[0];
+       po = &Out[0];
+       for (i=0; i<len; i++) {
+           *po = hpo_zero_coefsTbl[0] * (*pi);
+           *po += hpo_zero_coefsTbl[1] * mem[0];
+           *po += hpo_zero_coefsTbl[2] * mem[1];
+
+           mem[1] = mem[0];
+           mem[0] = *pi;
+           po++;
+           pi++;
+
+       }
+
+       /* all-pole section*/
+
+       po = &Out[0];
+       for (i=0; i<len; i++) {
+           *po -= hpo_pole_coefsTbl[1] * mem[2];
+           *po -= hpo_pole_coefsTbl[2] * mem[3];
+
+           mem[3] = mem[2];
+           mem[2] = *po;
+           po++;
+       }
+   }
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/hpOutput.h asterisk-1.8.3.2_com_amr/codecs/ilbc/hpOutput.h
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/hpOutput.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/hpOutput.h	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,24 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       hpOutput.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_HPOUTPUT_H
+   #define __iLBC_HPOUTPUT_H
+
+   void hpOutput(
+       float *In,  /* (i) vector to filter */
+       int len,/* (i) length of vector to filter */
+       float *Out, /* (o) the resulting filtered vector */
+       float *mem  /* (i/o) the filter state */
+   );
+
+   #endif
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/iCBConstruct.c asterisk-1.8.3.2_com_amr/codecs/ilbc/iCBConstruct.c
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/iCBConstruct.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/iCBConstruct.c	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,112 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       iCBConstruct.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <math.h>
+
+   #include "iLBC_define.h"
+   #include "gainquant.h"
+   #include "getCBvec.h"
+
+   /*----------------------------------------------------------------*
+    *  Convert the codebook indexes to make the search easier
+    *---------------------------------------------------------------*/
+
+
+
+
+
+
+   void index_conv_enc(
+       int *index          /* (i/o) Codebook indexes */
+   ){
+       int k;
+
+       for (k=1; k<CB_NSTAGES; k++) {
+
+           if ((index[k]>=108)&&(index[k]<172)) {
+               index[k]-=64;
+           } else if (index[k]>=236) {
+               index[k]-=128;
+           } else {
+               /* ERROR */
+           }
+       }
+   }
+
+   void index_conv_dec(
+       int *index          /* (i/o) Codebook indexes */
+   ){
+       int k;
+
+       for (k=1; k<CB_NSTAGES; k++) {
+
+           if ((index[k]>=44)&&(index[k]<108)) {
+               index[k]+=64;
+           } else if ((index[k]>=108)&&(index[k]<128)) {
+               index[k]+=128;
+           } else {
+               /* ERROR */
+           }
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  Construct decoded vector from codebook and gains.
+    *---------------------------------------------------------------*/
+
+   void iCBConstruct(
+       float *decvector,   /* (o) Decoded vector */
+       int *index,         /* (i) Codebook indices */
+       int *gain_index,/* (i) Gain quantization indices */
+       float *mem,         /* (i) Buffer for codevector construction */
+       int lMem,           /* (i) Length of buffer */
+       int veclen,         /* (i) Length of vector */
+       int nStages         /* (i) Number of codebook stages */
+   ){
+       int j,k;
+
+
+
+
+
+       float gain[CB_NSTAGES];
+       float cbvec[SUBL];
+
+       /* gain de-quantization */
+
+       gain[0] = gaindequant(gain_index[0], 1.0, 32);
+       if (nStages > 1) {
+           gain[1] = gaindequant(gain_index[1],
+               (float)fabs(gain[0]), 16);
+       }
+       if (nStages > 2) {
+           gain[2] = gaindequant(gain_index[2],
+               (float)fabs(gain[1]), 8);
+       }
+
+       /* codebook vector construction and construction of
+       total vector */
+
+       getCBvec(cbvec, mem, index[0], lMem, veclen);
+       for (j=0;j<veclen;j++){
+           decvector[j] = gain[0]*cbvec[j];
+       }
+       if (nStages > 1) {
+           for (k=1; k<nStages; k++) {
+               getCBvec(cbvec, mem, index[k], lMem, veclen);
+               for (j=0;j<veclen;j++) {
+                   decvector[j] += gain[k]*cbvec[j];
+               }
+           }
+       }
+   }
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/iCBConstruct.h asterisk-1.8.3.2_com_amr/codecs/ilbc/iCBConstruct.h
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/iCBConstruct.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/iCBConstruct.h	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,40 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       iCBConstruct.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+
+
+
+
+
+   ******************************************************************/
+
+   #ifndef __iLBC_ICBCONSTRUCT_H
+   #define __iLBC_ICBCONSTRUCT_H
+
+   void index_conv_enc(
+       int *index          /* (i/o) Codebook indexes */
+   );
+
+   void index_conv_dec(
+       int *index          /* (i/o) Codebook indexes */
+   );
+
+   void iCBConstruct(
+       float *decvector,   /* (o) Decoded vector */
+       int *index,         /* (i) Codebook indices */
+       int *gain_index,/* (i) Gain quantization indices */
+       float *mem,         /* (i) Buffer for codevector construction */
+       int lMem,           /* (i) Length of buffer */
+       int veclen,         /* (i) Length of vector */
+       int nStages         /* (i) Number of codebook stages */
+   );
+
+   #endif
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/iCBSearch.c asterisk-1.8.3.2_com_amr/codecs/ilbc/iCBSearch.c
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/iCBSearch.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/iCBSearch.c	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,512 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       iCBSearch.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <math.h>
+   #include <string.h>
+
+   #include "iLBC_define.h"
+   #include "gainquant.h"
+   #include "createCB.h"
+   #include "filter.h"
+   #include "constants.h"
+
+   /*----------------------------------------------------------------*
+    *  Search routine for codebook encoding and gain quantization.
+    *---------------------------------------------------------------*/
+
+   void iCBSearch(
+       iLBC_Enc_Inst_t *iLBCenc_inst,
+                           /* (i) the encoder state structure */
+       int *index,         /* (o) Codebook indices */
+       int *gain_index,/* (o) Gain quantization indices */
+
+
+
+
+
+       float *intarget,/* (i) Target vector for encoding */
+       float *mem,         /* (i) Buffer for codebook construction */
+       int lMem,           /* (i) Length of buffer */
+       int lTarget,    /* (i) Length of vector */
+       int nStages,    /* (i) Number of codebook stages */
+       float *weightDenum, /* (i) weighting filter coefficients */
+       float *weightState, /* (i) weighting filter state */
+       int block           /* (i) the sub-block number */
+   ){
+       int i, j, icount, stage, best_index, range, counter;
+       float max_measure, gain, measure, crossDot, ftmp;
+       float gains[CB_NSTAGES];
+       float target[SUBL];
+       int base_index, sInd, eInd, base_size;
+       int sIndAug=0, eIndAug=0;
+       float buf[CB_MEML+SUBL+2*LPC_FILTERORDER];
+       float invenergy[CB_EXPAND*128], energy[CB_EXPAND*128];
+       float *pp, *ppi=0, *ppo=0, *ppe=0;
+       float cbvectors[CB_MEML];
+       float tene, cene, cvec[SUBL];
+       float aug_vec[SUBL];
+
+       memset(cvec,0,SUBL*sizeof(float));
+
+       /* Determine size of codebook sections */
+
+       base_size=lMem-lTarget+1;
+
+       if (lTarget==SUBL) {
+           base_size=lMem-lTarget+1+lTarget/2;
+       }
+
+       /* setup buffer for weighting */
+
+       memcpy(buf,weightState,sizeof(float)*LPC_FILTERORDER);
+       memcpy(buf+LPC_FILTERORDER,mem,lMem*sizeof(float));
+       memcpy(buf+LPC_FILTERORDER+lMem,intarget,lTarget*sizeof(float));
+
+       /* weighting */
+
+       AllPoleFilter(buf+LPC_FILTERORDER, weightDenum,
+           lMem+lTarget, LPC_FILTERORDER);
+
+       /* Construct the codebook and target needed */
+
+       memcpy(target, buf+LPC_FILTERORDER+lMem, lTarget*sizeof(float));
+
+       tene=0.0;
+
+
+
+
+
+       for (i=0; i<lTarget; i++) {
+           tene+=target[i]*target[i];
+       }
+
+       /* Prepare search over one more codebook section. This section
+          is created by filtering the original buffer with a filter. */
+
+       filteredCBvecs(cbvectors, buf+LPC_FILTERORDER, lMem);
+
+       /* The Main Loop over stages */
+
+       for (stage=0; stage<nStages; stage++) {
+
+           range = search_rangeTbl[block][stage];
+
+           /* initialize search measure */
+
+           max_measure = (float)-10000000.0;
+           gain = (float)0.0;
+           best_index = 0;
+
+           /* Compute cross dot product between the target
+              and the CB memory */
+
+           crossDot=0.0;
+           pp=buf+LPC_FILTERORDER+lMem-lTarget;
+           for (j=0; j<lTarget; j++) {
+               crossDot += target[j]*(*pp++);
+           }
+
+           if (stage==0) {
+
+               /* Calculate energy in the first block of
+                 'lTarget' samples. */
+               ppe = energy;
+               ppi = buf+LPC_FILTERORDER+lMem-lTarget-1;
+               ppo = buf+LPC_FILTERORDER+lMem-1;
+
+               *ppe=0.0;
+               pp=buf+LPC_FILTERORDER+lMem-lTarget;
+               for (j=0; j<lTarget; j++) {
+                   *ppe+=(*pp)*(*pp++);
+               }
+
+               if (*ppe>0.0) {
+                   invenergy[0] = (float) 1.0 / (*ppe + EPS);
+               } else {
+                   invenergy[0] = (float) 0.0;
+
+
+
+
+
+               }
+               ppe++;
+
+               measure=(float)-10000000.0;
+
+               if (crossDot > 0.0) {
+                      measure = crossDot*crossDot*invenergy[0];
+               }
+           }
+           else {
+               measure = crossDot*crossDot*invenergy[0];
+           }
+
+           /* check if measure is better */
+           ftmp = crossDot*invenergy[0];
+
+           if ((measure>max_measure) && (fabs(ftmp)<CB_MAXGAIN)) {
+               best_index = 0;
+               max_measure = measure;
+               gain = ftmp;
+           }
+
+           /* loop over the main first codebook section,
+              full search */
+
+           for (icount=1; icount<range; icount++) {
+
+               /* calculate measure */
+
+               crossDot=0.0;
+               pp = buf+LPC_FILTERORDER+lMem-lTarget-icount;
+
+               for (j=0; j<lTarget; j++) {
+                   crossDot += target[j]*(*pp++);
+               }
+
+               if (stage==0) {
+                   *ppe++ = energy[icount-1] + (*ppi)*(*ppi) -
+                       (*ppo)*(*ppo);
+                   ppo--;
+                   ppi--;
+
+                   if (energy[icount]>0.0) {
+                       invenergy[icount] =
+                           (float)1.0/(energy[icount]+EPS);
+                   } else {
+                       invenergy[icount] = (float) 0.0;
+                   }
+
+
+
+
+
+                   measure=(float)-10000000.0;
+
+                   if (crossDot > 0.0) {
+                       measure = crossDot*crossDot*invenergy[icount];
+                   }
+               }
+               else {
+                   measure = crossDot*crossDot*invenergy[icount];
+               }
+
+               /* check if measure is better */
+               ftmp = crossDot*invenergy[icount];
+
+               if ((measure>max_measure) && (fabs(ftmp)<CB_MAXGAIN)) {
+                   best_index = icount;
+                   max_measure = measure;
+                   gain = ftmp;
+               }
+           }
+
+           /* Loop over augmented part in the first codebook
+            * section, full search.
+            * The vectors are interpolated.
+            */
+
+           if (lTarget==SUBL) {
+
+               /* Search for best possible cb vector and
+                  compute the CB-vectors' energy. */
+               searchAugmentedCB(20, 39, stage, base_size-lTarget/2,
+                   target, buf+LPC_FILTERORDER+lMem,
+                   &max_measure, &best_index, &gain, energy,
+                   invenergy);
+           }
+
+           /* set search range for following codebook sections */
+
+           base_index=best_index;
+
+           /* unrestricted search */
+
+           if (CB_RESRANGE == -1) {
+               sInd=0;
+               eInd=range-1;
+               sIndAug=20;
+               eIndAug=39;
+           }
+
+
+
+
+
+
+           /* restricted search around best index from first
+           codebook section */
+
+           else {
+               /* Initialize search indices */
+               sIndAug=0;
+               eIndAug=0;
+               sInd=base_index-CB_RESRANGE/2;
+               eInd=sInd+CB_RESRANGE;
+
+               if (lTarget==SUBL) {
+
+                   if (sInd<0) {
+
+                       sIndAug = 40 + sInd;
+                       eIndAug = 39;
+                       sInd=0;
+
+                   } else if ( base_index < (base_size-20) ) {
+
+                       if (eInd > range) {
+                           sInd -= (eInd-range);
+                           eInd = range;
+                       }
+                   } else { /* base_index >= (base_size-20) */
+
+                       if (sInd < (base_size-20)) {
+                           sIndAug = 20;
+                           sInd = 0;
+                           eInd = 0;
+                           eIndAug = 19 + CB_RESRANGE;
+
+                           if(eIndAug > 39) {
+                               eInd = eIndAug-39;
+                               eIndAug = 39;
+                           }
+                       } else {
+                           sIndAug = 20 + sInd - (base_size-20);
+                           eIndAug = 39;
+                           sInd = 0;
+                           eInd = CB_RESRANGE - (eIndAug-sIndAug+1);
+                       }
+                   }
+
+               } else { /* lTarget = 22 or 23 */
+
+                   if (sInd < 0) {
+                       eInd -= sInd;
+
+
+
+
+
+                       sInd = 0;
+                   }
+
+                   if(eInd > range) {
+                       sInd -= (eInd - range);
+                       eInd = range;
+                   }
+               }
+           }
+
+           /* search of higher codebook section */
+
+           /* index search range */
+           counter = sInd;
+           sInd += base_size;
+           eInd += base_size;
+
+
+           if (stage==0) {
+               ppe = energy+base_size;
+               *ppe=0.0;
+
+               pp=cbvectors+lMem-lTarget;
+               for (j=0; j<lTarget; j++) {
+                   *ppe+=(*pp)*(*pp++);
+               }
+
+               ppi = cbvectors + lMem - 1 - lTarget;
+               ppo = cbvectors + lMem - 1;
+
+               for (j=0; j<(range-1); j++) {
+                   *(ppe+1) = *ppe + (*ppi)*(*ppi) - (*ppo)*(*ppo);
+                   ppo--;
+                   ppi--;
+                   ppe++;
+               }
+           }
+
+           /* loop over search range */
+
+           for (icount=sInd; icount<eInd; icount++) {
+
+               /* calculate measure */
+
+               crossDot=0.0;
+               pp=cbvectors + lMem - (counter++) - lTarget;
+
+               for (j=0;j<lTarget;j++) {
+
+
+
+
+
+                   crossDot += target[j]*(*pp++);
+               }
+
+               if (energy[icount]>0.0) {
+                   invenergy[icount] =(float)1.0/(energy[icount]+EPS);
+               } else {
+                   invenergy[icount] =(float)0.0;
+               }
+
+               if (stage==0) {
+
+                   measure=(float)-10000000.0;
+
+                   if (crossDot > 0.0) {
+                       measure = crossDot*crossDot*
+                           invenergy[icount];
+                   }
+               }
+               else {
+                   measure = crossDot*crossDot*invenergy[icount];
+               }
+
+               /* check if measure is better */
+               ftmp = crossDot*invenergy[icount];
+
+               if ((measure>max_measure) && (fabs(ftmp)<CB_MAXGAIN)) {
+                   best_index = icount;
+                   max_measure = measure;
+                   gain = ftmp;
+               }
+           }
+
+           /* Search the augmented CB inside the limited range. */
+
+           if ((lTarget==SUBL)&&(sIndAug!=0)) {
+               searchAugmentedCB(sIndAug, eIndAug, stage,
+                   2*base_size-20, target, cbvectors+lMem,
+                   &max_measure, &best_index, &gain, energy,
+                   invenergy);
+           }
+
+           /* record best index */
+
+           index[stage] = best_index;
+
+           /* gain quantization */
+
+           if (stage==0){
+
+
+
+
+
+
+               if (gain<0.0){
+                   gain = 0.0;
+               }
+
+               if (gain>CB_MAXGAIN) {
+                   gain = (float)CB_MAXGAIN;
+               }
+               gain = gainquant(gain, 1.0, 32, &gain_index[stage]);
+           }
+           else {
+               if (stage==1) {
+                   gain = gainquant(gain, (float)fabs(gains[stage-1]),
+                       16, &gain_index[stage]);
+               } else {
+                   gain = gainquant(gain, (float)fabs(gains[stage-1]),
+                       8, &gain_index[stage]);
+               }
+           }
+
+           /* Extract the best (according to measure)
+              codebook vector */
+
+           if (lTarget==(STATE_LEN-iLBCenc_inst->state_short_len)) {
+
+               if (index[stage]<base_size) {
+                   pp=buf+LPC_FILTERORDER+lMem-lTarget-index[stage];
+               } else {
+                   pp=cbvectors+lMem-lTarget-
+                       index[stage]+base_size;
+               }
+           } else {
+
+               if (index[stage]<base_size) {
+                   if (index[stage]<(base_size-20)) {
+                       pp=buf+LPC_FILTERORDER+lMem-
+                           lTarget-index[stage];
+                   } else {
+                       createAugmentedVec(index[stage]-base_size+40,
+                               buf+LPC_FILTERORDER+lMem,aug_vec);
+                       pp=aug_vec;
+                   }
+               } else {
+                   int filterno, position;
+
+                   filterno=index[stage]/base_size;
+                   position=index[stage]-filterno*base_size;
+
+
+
+
+
+
+
+                   if (position<(base_size-20)) {
+                       pp=cbvectors+filterno*lMem-lTarget-
+                           index[stage]+filterno*base_size;
+                   } else {
+                       createAugmentedVec(
+                           index[stage]-(filterno+1)*base_size+40,
+                           cbvectors+filterno*lMem,aug_vec);
+                       pp=aug_vec;
+                   }
+               }
+           }
+
+           /* Subtract the best codebook vector, according
+              to measure, from the target vector */
+
+           for (j=0;j<lTarget;j++) {
+               cvec[j] += gain*(*pp);
+               target[j] -= gain*(*pp++);
+           }
+
+           /* record quantized gain */
+
+           gains[stage]=gain;
+
+       }/* end of Main Loop. for (stage=0;... */
+
+       /* Gain adjustment for energy matching */
+       cene=0.0;
+       for (i=0; i<lTarget; i++) {
+           cene+=cvec[i]*cvec[i];
+       }
+       j=gain_index[0];
+
+       for (i=gain_index[0]; i<32; i++) {
+           ftmp=cene*gain_sq5Tbl[i]*gain_sq5Tbl[i];
+
+           if ((ftmp<(tene*gains[0]*gains[0])) &&
+               (gain_sq5Tbl[j]<(2.0*gains[0]))) {
+               j=i;
+           }
+       }
+       gain_index[0]=j;
+   }
+
+
+
+
+
+
+
+
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/iCBSearch.h asterisk-1.8.3.2_com_amr/codecs/ilbc/iCBSearch.h
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/iCBSearch.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/iCBSearch.h	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,37 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       iCBSearch.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_ICBSEARCH_H
+   #define __iLBC_ICBSEARCH_H
+
+
+
+
+
+
+   void iCBSearch(
+       iLBC_Enc_Inst_t *iLBCenc_inst,
+                           /* (i) the encoder state structure */
+       int *index,         /* (o) Codebook indices */
+       int *gain_index,/* (o) Gain quantization indices */
+       float *intarget,/* (i) Target vector for encoding */
+       float *mem,         /* (i) Buffer for codebook construction */
+       int lMem,           /* (i) Length of buffer */
+       int lTarget,    /* (i) Length of vector */
+       int nStages,    /* (i) Number of codebook stages */
+       float *weightDenum, /* (i) weighting filter coefficients */
+       float *weightState, /* (i) weighting filter state */
+       int block           /* (i) the sub-block number */
+   );
+
+   #endif
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/iLBC_decode.c asterisk-1.8.3.2_com_amr/codecs/ilbc/iLBC_decode.c
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/iLBC_decode.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/iLBC_decode.c	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,652 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       iLBC_decode.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <math.h>
+   #include <stdlib.h>
+
+   #include "iLBC_define.h"
+   #include "StateConstructW.h"
+   #include "LPCdecode.h"
+   #include "iCBConstruct.h"
+   #include "doCPLC.h"
+   #include "helpfun.h"
+   #include "constants.h"
+   #include "packing.h"
+   #include "string.h"
+   #include "enhancer.h"
+   #include "hpOutput.h"
+   #include "syntFilter.h"
+
+   /*----------------------------------------------------------------*
+    *  Initiation of decoder instance.
+    *---------------------------------------------------------------*/
+
+   short initDecode(                   /* (o) Number of decoded
+                                              samples */
+       iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) Decoder instance */
+       int mode,                       /* (i) frame size mode */
+       int use_enhancer                /* (i) 1 to use enhancer
+                                              0 to run without
+                                                enhancer */
+   ){
+       int i;
+
+       iLBCdec_inst->mode = mode;
+
+
+
+
+
+       if (mode==30) {
+           iLBCdec_inst->blockl = BLOCKL_30MS;
+           iLBCdec_inst->nsub = NSUB_30MS;
+           iLBCdec_inst->nasub = NASUB_30MS;
+           iLBCdec_inst->lpc_n = LPC_N_30MS;
+           iLBCdec_inst->no_of_bytes = NO_OF_BYTES_30MS;
+           iLBCdec_inst->no_of_words = NO_OF_WORDS_30MS;
+           iLBCdec_inst->state_short_len=STATE_SHORT_LEN_30MS;
+           /* ULP init */
+           iLBCdec_inst->ULP_inst=&ULP_30msTbl;
+       }
+       else if (mode==20) {
+           iLBCdec_inst->blockl = BLOCKL_20MS;
+           iLBCdec_inst->nsub = NSUB_20MS;
+           iLBCdec_inst->nasub = NASUB_20MS;
+           iLBCdec_inst->lpc_n = LPC_N_20MS;
+           iLBCdec_inst->no_of_bytes = NO_OF_BYTES_20MS;
+           iLBCdec_inst->no_of_words = NO_OF_WORDS_20MS;
+           iLBCdec_inst->state_short_len=STATE_SHORT_LEN_20MS;
+           /* ULP init */
+           iLBCdec_inst->ULP_inst=&ULP_20msTbl;
+       }
+       else {
+           exit(2);
+       }
+
+       memset(iLBCdec_inst->syntMem, 0,
+           LPC_FILTERORDER*sizeof(float));
+       memcpy((*iLBCdec_inst).lsfdeqold, lsfmeanTbl,
+           LPC_FILTERORDER*sizeof(float));
+
+       memset(iLBCdec_inst->old_syntdenum, 0,
+           ((LPC_FILTERORDER + 1)*NSUB_MAX)*sizeof(float));
+       for (i=0; i<NSUB_MAX; i++)
+           iLBCdec_inst->old_syntdenum[i*(LPC_FILTERORDER+1)]=1.0;
+
+       iLBCdec_inst->last_lag = 20;
+
+       iLBCdec_inst->prevLag = 120;
+       iLBCdec_inst->per = 0.0;
+       iLBCdec_inst->consPLICount = 0;
+       iLBCdec_inst->prevPLI = 0;
+       iLBCdec_inst->prevLpc[0] = 1.0;
+       memset(iLBCdec_inst->prevLpc+1,0,
+           LPC_FILTERORDER*sizeof(float));
+       memset(iLBCdec_inst->prevResidual, 0, BLOCKL_MAX*sizeof(float));
+       iLBCdec_inst->seed=777;
+
+
+
+
+
+
+       memset(iLBCdec_inst->hpomem, 0, 4*sizeof(float));
+
+       iLBCdec_inst->use_enhancer = use_enhancer;
+       memset(iLBCdec_inst->enh_buf, 0, ENH_BUFL*sizeof(float));
+       for (i=0;i<ENH_NBLOCKS_TOT;i++)
+           iLBCdec_inst->enh_period[i]=(float)40.0;
+
+       iLBCdec_inst->prev_enh_pl = 0;
+
+       return (iLBCdec_inst->blockl);
+   }
+
+   /*----------------------------------------------------------------*
+    *  frame residual decoder function (subrutine to iLBC_decode)
+    *---------------------------------------------------------------*/
+
+   void Decode(
+       iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) the decoder state
+                                                structure */
+       float *decresidual,             /* (o) decoded residual frame */
+       int start,                      /* (i) location of start
+                                              state */
+       int idxForMax,                  /* (i) codebook index for the
+                                              maximum value */
+       int *idxVec,                /* (i) codebook indexes for the
+                                              samples  in the start
+                                              state */
+       float *syntdenum,               /* (i) the decoded synthesis
+                                              filter coefficients */
+       int *cb_index,                  /* (i) the indexes for the
+                                              adaptive codebook */
+       int *gain_index,            /* (i) the indexes for the
+                                              corresponding gains */
+       int *extra_cb_index,        /* (i) the indexes for the
+                                              adaptive codebook part
+                                              of start state */
+       int *extra_gain_index,          /* (i) the indexes for the
+                                              corresponding gains */
+       int state_first                 /* (i) 1 if non adaptive part
+                                              of start state comes
+                                              first 0 if that part
+                                              comes last */
+   ){
+       float reverseDecresidual[BLOCKL_MAX], mem[CB_MEML];
+       int k, meml_gotten, Nfor, Nback, i;
+       int diff, start_pos;
+       int subcount, subframe;
+
+
+
+
+
+
+       diff = STATE_LEN - iLBCdec_inst->state_short_len;
+
+       if (state_first == 1) {
+           start_pos = (start-1)*SUBL;
+       } else {
+           start_pos = (start-1)*SUBL + diff;
+       }
+
+       /* decode scalar part of start state */
+
+       StateConstructW(idxForMax, idxVec,
+           &syntdenum[(start-1)*(LPC_FILTERORDER+1)],
+           &decresidual[start_pos], iLBCdec_inst->state_short_len);
+
+
+       if (state_first) { /* put adaptive part in the end */
+
+           /* setup memory */
+
+           memset(mem, 0,
+               (CB_MEML-iLBCdec_inst->state_short_len)*sizeof(float));
+           memcpy(mem+CB_MEML-iLBCdec_inst->state_short_len,
+               decresidual+start_pos,
+               iLBCdec_inst->state_short_len*sizeof(float));
+
+           /* construct decoded vector */
+
+           iCBConstruct(
+               &decresidual[start_pos+iLBCdec_inst->state_short_len],
+               extra_cb_index, extra_gain_index, mem+CB_MEML-stMemLTbl,
+               stMemLTbl, diff, CB_NSTAGES);
+
+       }
+       else {/* put adaptive part in the beginning */
+
+           /* create reversed vectors for prediction */
+
+           for (k=0; k<diff; k++) {
+               reverseDecresidual[k] =
+                   decresidual[(start+1)*SUBL-1-
+                           (k+iLBCdec_inst->state_short_len)];
+           }
+
+           /* setup memory */
+
+           meml_gotten = iLBCdec_inst->state_short_len;
+           for (k=0; k<meml_gotten; k++){
+               mem[CB_MEML-1-k] = decresidual[start_pos + k];
+
+
+
+
+
+           }
+           memset(mem, 0, (CB_MEML-k)*sizeof(float));
+
+           /* construct decoded vector */
+
+           iCBConstruct(reverseDecresidual, extra_cb_index,
+               extra_gain_index, mem+CB_MEML-stMemLTbl, stMemLTbl,
+               diff, CB_NSTAGES);
+
+           /* get decoded residual from reversed vector */
+
+           for (k=0; k<diff; k++) {
+               decresidual[start_pos-1-k] = reverseDecresidual[k];
+           }
+       }
+
+       /* counter for predicted sub-frames */
+
+       subcount=0;
+
+       /* forward prediction of sub-frames */
+
+       Nfor = iLBCdec_inst->nsub-start-1;
+
+       if ( Nfor > 0 ){
+
+           /* setup memory */
+
+           memset(mem, 0, (CB_MEML-STATE_LEN)*sizeof(float));
+           memcpy(mem+CB_MEML-STATE_LEN, decresidual+(start-1)*SUBL,
+               STATE_LEN*sizeof(float));
+
+           /* loop over sub-frames to encode */
+
+           for (subframe=0; subframe<Nfor; subframe++) {
+
+               /* construct decoded vector */
+
+               iCBConstruct(&decresidual[(start+1+subframe)*SUBL],
+                   cb_index+subcount*CB_NSTAGES,
+                   gain_index+subcount*CB_NSTAGES,
+                   mem+CB_MEML-memLfTbl[subcount],
+                   memLfTbl[subcount], SUBL, CB_NSTAGES);
+
+               /* update memory */
+
+               memcpy(mem, mem+SUBL, (CB_MEML-SUBL)*sizeof(float));
+               memcpy(mem+CB_MEML-SUBL,
+
+
+
+
+
+                   &decresidual[(start+1+subframe)*SUBL],
+                   SUBL*sizeof(float));
+
+               subcount++;
+
+           }
+
+       }
+
+       /* backward prediction of sub-frames */
+
+       Nback = start-1;
+
+       if ( Nback > 0 ) {
+
+           /* setup memory */
+
+           meml_gotten = SUBL*(iLBCdec_inst->nsub+1-start);
+
+           if ( meml_gotten > CB_MEML ) {
+               meml_gotten=CB_MEML;
+           }
+           for (k=0; k<meml_gotten; k++) {
+               mem[CB_MEML-1-k] = decresidual[(start-1)*SUBL + k];
+           }
+           memset(mem, 0, (CB_MEML-k)*sizeof(float));
+
+           /* loop over subframes to decode */
+
+           for (subframe=0; subframe<Nback; subframe++) {
+
+               /* construct decoded vector */
+
+               iCBConstruct(&reverseDecresidual[subframe*SUBL],
+                   cb_index+subcount*CB_NSTAGES,
+                   gain_index+subcount*CB_NSTAGES,
+                   mem+CB_MEML-memLfTbl[subcount], memLfTbl[subcount],
+                   SUBL, CB_NSTAGES);
+
+               /* update memory */
+
+               memcpy(mem, mem+SUBL, (CB_MEML-SUBL)*sizeof(float));
+               memcpy(mem+CB_MEML-SUBL,
+                   &reverseDecresidual[subframe*SUBL],
+                   SUBL*sizeof(float));
+
+               subcount++;
+           }
+
+
+
+
+
+           /* get decoded residual from reversed vector */
+
+           for (i=0; i<SUBL*Nback; i++)
+               decresidual[SUBL*Nback - i - 1] =
+               reverseDecresidual[i];
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  main decoder function
+    *---------------------------------------------------------------*/
+
+   void iLBC_decode(
+       float *decblock,            /* (o) decoded signal block */
+       unsigned char *bytes,           /* (i) encoded signal bits */
+       iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) the decoder state
+                                                structure */
+       int mode                    /* (i) 0: bad packet, PLC,
+                                              1: normal */
+   ){
+       float data[BLOCKL_MAX];
+       float lsfdeq[LPC_FILTERORDER*LPC_N_MAX];
+       float PLCresidual[BLOCKL_MAX], PLClpc[LPC_FILTERORDER + 1];
+       float zeros[BLOCKL_MAX], one[LPC_FILTERORDER + 1];
+       int k, i, start, idxForMax, pos, lastpart, ulp;
+       int lag, ilag;
+       float cc, maxcc;
+       int idxVec[STATE_LEN];
+       int check;
+       int gain_index[NASUB_MAX*CB_NSTAGES],
+           extra_gain_index[CB_NSTAGES];
+       int cb_index[CB_NSTAGES*NASUB_MAX], extra_cb_index[CB_NSTAGES];
+       int lsf_i[LSF_NSPLIT*LPC_N_MAX];
+       int state_first;
+       int last_bit;
+       unsigned char *pbytes;
+       float weightdenum[(LPC_FILTERORDER + 1)*NSUB_MAX];
+       int order_plus_one;
+       float syntdenum[NSUB_MAX*(LPC_FILTERORDER+1)];
+       float decresidual[BLOCKL_MAX];
+
+       if (mode>0) { /* the data are good */
+
+           /* decode data */
+
+           pbytes=bytes;
+           pos=0;
+
+
+
+
+
+
+           /* Set everything to zero before decoding */
+
+           for (k=0; k<LSF_NSPLIT*LPC_N_MAX; k++) {
+               lsf_i[k]=0;
+           }
+           start=0;
+           state_first=0;
+           idxForMax=0;
+           for (k=0; k<iLBCdec_inst->state_short_len; k++) {
+               idxVec[k]=0;
+           }
+           for (k=0; k<CB_NSTAGES; k++) {
+               extra_cb_index[k]=0;
+           }
+           for (k=0; k<CB_NSTAGES; k++) {
+               extra_gain_index[k]=0;
+           }
+           for (i=0; i<iLBCdec_inst->nasub; i++) {
+               for (k=0; k<CB_NSTAGES; k++) {
+                   cb_index[i*CB_NSTAGES+k]=0;
+               }
+           }
+           for (i=0; i<iLBCdec_inst->nasub; i++) {
+               for (k=0; k<CB_NSTAGES; k++) {
+                   gain_index[i*CB_NSTAGES+k]=0;
+               }
+           }
+
+           /* loop over ULP classes */
+
+           for (ulp=0; ulp<3; ulp++) {
+
+               /* LSF */
+               for (k=0; k<LSF_NSPLIT*iLBCdec_inst->lpc_n; k++){
+                   unpack( &pbytes, &lastpart,
+                       iLBCdec_inst->ULP_inst->lsf_bits[k][ulp], &pos);
+                   packcombine(&lsf_i[k], lastpart,
+                       iLBCdec_inst->ULP_inst->lsf_bits[k][ulp]);
+               }
+
+               /* Start block info */
+
+               unpack( &pbytes, &lastpart,
+                   iLBCdec_inst->ULP_inst->start_bits[ulp], &pos);
+               packcombine(&start, lastpart,
+                   iLBCdec_inst->ULP_inst->start_bits[ulp]);
+
+               unpack( &pbytes, &lastpart,
+
+
+
+
+
+                   iLBCdec_inst->ULP_inst->startfirst_bits[ulp], &pos);
+               packcombine(&state_first, lastpart,
+                   iLBCdec_inst->ULP_inst->startfirst_bits[ulp]);
+
+               unpack( &pbytes, &lastpart,
+                   iLBCdec_inst->ULP_inst->scale_bits[ulp], &pos);
+               packcombine(&idxForMax, lastpart,
+                   iLBCdec_inst->ULP_inst->scale_bits[ulp]);
+
+               for (k=0; k<iLBCdec_inst->state_short_len; k++) {
+                   unpack( &pbytes, &lastpart,
+                       iLBCdec_inst->ULP_inst->state_bits[ulp], &pos);
+                   packcombine(idxVec+k, lastpart,
+                       iLBCdec_inst->ULP_inst->state_bits[ulp]);
+               }
+
+               /* 23/22 (20ms/30ms) sample block */
+
+               for (k=0; k<CB_NSTAGES; k++) {
+                   unpack( &pbytes, &lastpart,
+                       iLBCdec_inst->ULP_inst->extra_cb_index[k][ulp],
+                       &pos);
+                   packcombine(extra_cb_index+k, lastpart,
+                       iLBCdec_inst->ULP_inst->extra_cb_index[k][ulp]);
+               }
+               for (k=0; k<CB_NSTAGES; k++) {
+                   unpack( &pbytes, &lastpart,
+                       iLBCdec_inst->ULP_inst->extra_cb_gain[k][ulp],
+                       &pos);
+                   packcombine(extra_gain_index+k, lastpart,
+                       iLBCdec_inst->ULP_inst->extra_cb_gain[k][ulp]);
+               }
+
+               /* The two/four (20ms/30ms) 40 sample sub-blocks */
+
+               for (i=0; i<iLBCdec_inst->nasub; i++) {
+                   for (k=0; k<CB_NSTAGES; k++) {
+                       unpack( &pbytes, &lastpart,
+                       iLBCdec_inst->ULP_inst->cb_index[i][k][ulp],
+                           &pos);
+                       packcombine(cb_index+i*CB_NSTAGES+k, lastpart,
+                       iLBCdec_inst->ULP_inst->cb_index[i][k][ulp]);
+                   }
+               }
+
+               for (i=0; i<iLBCdec_inst->nasub; i++) {
+                   for (k=0; k<CB_NSTAGES; k++) {
+                       unpack( &pbytes, &lastpart,
+
+
+
+
+
+                       iLBCdec_inst->ULP_inst->cb_gain[i][k][ulp],
+                           &pos);
+                       packcombine(gain_index+i*CB_NSTAGES+k, lastpart,
+                           iLBCdec_inst->ULP_inst->cb_gain[i][k][ulp]);
+                   }
+               }
+           }
+           /* Extract last bit. If it is 1 this indicates an
+              empty/lost frame */
+           unpack( &pbytes, &last_bit, 1, &pos);
+
+           /* Check for bit errors or empty/lost frames */
+           if (start<1)
+               mode = 0;
+           if (iLBCdec_inst->mode==20 && start>3)
+               mode = 0;
+           if (iLBCdec_inst->mode==30 && start>5)
+               mode = 0;
+           if (last_bit==1)
+               mode = 0;
+
+           if (mode==1) { /* No bit errors was detected,
+                             continue decoding */
+
+               /* adjust index */
+               index_conv_dec(cb_index);
+
+               /* decode the lsf */
+
+               SimplelsfDEQ(lsfdeq, lsf_i, iLBCdec_inst->lpc_n);
+               check=LSF_check(lsfdeq, LPC_FILTERORDER,
+                   iLBCdec_inst->lpc_n);
+               DecoderInterpolateLSF(syntdenum, weightdenum,
+                   lsfdeq, LPC_FILTERORDER, iLBCdec_inst);
+
+               Decode(iLBCdec_inst, decresidual, start, idxForMax,
+                   idxVec, syntdenum, cb_index, gain_index,
+                   extra_cb_index, extra_gain_index,
+                   state_first);
+
+               /* preparing the plc for a future loss! */
+
+               doThePLC(PLCresidual, PLClpc, 0, decresidual,
+                   syntdenum +
+                   (LPC_FILTERORDER + 1)*(iLBCdec_inst->nsub - 1),
+                   (*iLBCdec_inst).last_lag, iLBCdec_inst);
+
+
+
+
+
+
+
+               memcpy(decresidual, PLCresidual,
+                   iLBCdec_inst->blockl*sizeof(float));
+           }
+
+       }
+
+       if (mode == 0) {
+           /* the data is bad (either a PLC call
+            * was made or a severe bit error was detected)
+            */
+
+           /* packet loss conceal */
+
+           memset(zeros, 0, BLOCKL_MAX*sizeof(float));
+
+           one[0] = 1;
+           memset(one+1, 0, LPC_FILTERORDER*sizeof(float));
+
+           start=0;
+
+           doThePLC(PLCresidual, PLClpc, 1, zeros, one,
+               (*iLBCdec_inst).last_lag, iLBCdec_inst);
+           memcpy(decresidual, PLCresidual,
+               iLBCdec_inst->blockl*sizeof(float));
+
+           order_plus_one = LPC_FILTERORDER + 1;
+           for (i = 0; i < iLBCdec_inst->nsub; i++) {
+               memcpy(syntdenum+(i*order_plus_one), PLClpc,
+                   order_plus_one*sizeof(float));
+           }
+       }
+
+       if (iLBCdec_inst->use_enhancer == 1) {
+
+           /* post filtering */
+
+           iLBCdec_inst->last_lag =
+               enhancerInterface(data, decresidual, iLBCdec_inst);
+
+           /* synthesis filtering */
+
+           if (iLBCdec_inst->mode==20) {
+               /* Enhancer has 40 samples delay */
+               i=0;
+               syntFilter(data + i*SUBL,
+                   iLBCdec_inst->old_syntdenum +
+                   (i+iLBCdec_inst->nsub-1)*(LPC_FILTERORDER+1),
+                   SUBL, iLBCdec_inst->syntMem);
+
+
+
+
+
+               for (i=1; i < iLBCdec_inst->nsub; i++) {
+                   syntFilter(data + i*SUBL,
+                       syntdenum + (i-1)*(LPC_FILTERORDER+1),
+                       SUBL, iLBCdec_inst->syntMem);
+               }
+           } else if (iLBCdec_inst->mode==30) {
+               /* Enhancer has 80 samples delay */
+               for (i=0; i < 2; i++) {
+                   syntFilter(data + i*SUBL,
+                       iLBCdec_inst->old_syntdenum +
+                       (i+iLBCdec_inst->nsub-2)*(LPC_FILTERORDER+1),
+                       SUBL, iLBCdec_inst->syntMem);
+               }
+               for (i=2; i < iLBCdec_inst->nsub; i++) {
+                   syntFilter(data + i*SUBL,
+                       syntdenum + (i-2)*(LPC_FILTERORDER+1), SUBL,
+                       iLBCdec_inst->syntMem);
+               }
+           }
+
+       } else {
+
+           /* Find last lag */
+           lag = 20;
+           maxcc = xCorrCoef(&decresidual[BLOCKL_MAX-ENH_BLOCKL],
+               &decresidual[BLOCKL_MAX-ENH_BLOCKL-lag], ENH_BLOCKL);
+
+           for (ilag=21; ilag<120; ilag++) {
+               cc = xCorrCoef(&decresidual[BLOCKL_MAX-ENH_BLOCKL],
+                   &decresidual[BLOCKL_MAX-ENH_BLOCKL-ilag],
+                   ENH_BLOCKL);
+
+               if (cc > maxcc) {
+                   maxcc = cc;
+                   lag = ilag;
+               }
+           }
+           iLBCdec_inst->last_lag = lag;
+
+           /* copy data and run synthesis filter */
+
+           memcpy(data, decresidual,
+               iLBCdec_inst->blockl*sizeof(float));
+           for (i=0; i < iLBCdec_inst->nsub; i++) {
+               syntFilter(data + i*SUBL,
+                   syntdenum + i*(LPC_FILTERORDER+1), SUBL,
+                   iLBCdec_inst->syntMem);
+           }
+
+
+
+
+
+       }
+
+       /* high pass filtering on output if desired, otherwise
+          copy to out */
+
+       hpOutput(data, iLBCdec_inst->blockl,
+                   decblock,iLBCdec_inst->hpomem);
+
+       /* memcpy(decblock,data,iLBCdec_inst->blockl*sizeof(float));*/
+
+       memcpy(iLBCdec_inst->old_syntdenum, syntdenum,
+
+           iLBCdec_inst->nsub*(LPC_FILTERORDER+1)*sizeof(float));
+
+       iLBCdec_inst->prev_enh_pl=0;
+
+       if (mode==0) { /* PLC was used */
+           iLBCdec_inst->prev_enh_pl=1;
+       }
+   }
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/iLBC_decode.h asterisk-1.8.3.2_com_amr/codecs/ilbc/iLBC_decode.h
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/iLBC_decode.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/iLBC_decode.h	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,42 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       iLBC_decode.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_ILBCDECODE_H
+   #define __iLBC_ILBCDECODE_H
+
+   #include "iLBC_define.h"
+
+   short initDecode(                   /* (o) Number of decoded
+                                              samples */
+       iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) Decoder instance */
+       int mode,                       /* (i) frame size mode */
+       int use_enhancer                /* (i) 1 to use enhancer
+                                              0 to run without
+                                                enhancer */
+   );
+
+   void iLBC_decode(
+       float *decblock,            /* (o) decoded signal block */
+       unsigned char *bytes,           /* (i) encoded signal bits */
+       iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) the decoder state
+                                                structure */
+       int mode                    /* (i) 0: bad packet, PLC,
+                                              1: normal */
+
+
+
+
+
+   );
+
+   #endif
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/iLBC_define.h asterisk-1.8.3.2_com_amr/codecs/ilbc/iLBC_define.h
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/iLBC_define.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/iLBC_define.h	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,217 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       iLBC_define.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+   #include <string.h>
+
+   #ifndef __iLBC_ILBCDEFINE_H
+   #define __iLBC_ILBCDEFINE_H
+
+   /* general codec settings */
+
+   #define FS                      (float)8000.0
+   #define BLOCKL_20MS             160
+   #define BLOCKL_30MS             240
+   #define BLOCKL_MAX              240
+   #define NSUB_20MS               4
+   #define NSUB_30MS               6
+   #define NSUB_MAX            6
+   #define NASUB_20MS              2
+
+
+
+
+
+   #define NASUB_30MS              4
+   #define NASUB_MAX               4
+   #define SUBL                40
+   #define STATE_LEN               80
+   #define STATE_SHORT_LEN_30MS    58
+   #define STATE_SHORT_LEN_20MS    57
+
+   /* LPC settings */
+
+   #define LPC_FILTERORDER         10
+   #define LPC_CHIRP_SYNTDENUM     (float)0.9025
+   #define LPC_CHIRP_WEIGHTDENUM   (float)0.4222
+   #define LPC_LOOKBACK        60
+   #define LPC_N_20MS              1
+   #define LPC_N_30MS              2
+   #define LPC_N_MAX               2
+   #define LPC_ASYMDIFF        20
+   #define LPC_BW                  (float)60.0
+   #define LPC_WN                  (float)1.0001
+   #define LSF_NSPLIT              3
+   #define LSF_NUMBER_OF_STEPS     4
+   #define LPC_HALFORDER           (LPC_FILTERORDER/2)
+
+   /* cb settings */
+
+   #define CB_NSTAGES              3
+   #define CB_EXPAND               2
+   #define CB_MEML                 147
+   #define CB_FILTERLEN        2*4
+   #define CB_HALFFILTERLEN    4
+   #define CB_RESRANGE             34
+   #define CB_MAXGAIN              (float)1.3
+
+   /* enhancer */
+
+   #define ENH_BLOCKL              80  /* block length */
+   #define ENH_BLOCKL_HALF         (ENH_BLOCKL/2)
+   #define ENH_HL                  3   /* 2*ENH_HL+1 is number blocks
+                                          in said second sequence */
+   #define ENH_SLOP            2   /* max difference estimated and
+                                          correct pitch period */
+   #define ENH_PLOCSL              20  /* pitch-estimates and pitch-
+                                          locations buffer length */
+   #define ENH_OVERHANG        2
+   #define ENH_UPS0            4   /* upsampling rate */
+   #define ENH_FL0                 3   /* 2*FLO+1 is the length of
+                                          each filter */
+   #define ENH_VECTL               (ENH_BLOCKL+2*ENH_FL0)
+
+
+
+
+
+   #define ENH_CORRDIM             (2*ENH_SLOP+1)
+   #define ENH_NBLOCKS             (BLOCKL_MAX/ENH_BLOCKL)
+   #define ENH_NBLOCKS_EXTRA       5
+   #define ENH_NBLOCKS_TOT         8   /* ENH_NBLOCKS +
+                                          ENH_NBLOCKS_EXTRA */
+   #define ENH_BUFL            (ENH_NBLOCKS_TOT)*ENH_BLOCKL
+   #define ENH_ALPHA0              (float)0.05
+
+   /* Down sampling */
+
+   #define FILTERORDER_DS          7
+   #define DELAY_DS            3
+   #define FACTOR_DS               2
+
+   /* bit stream defs */
+
+   #define NO_OF_BYTES_20MS    38
+   #define NO_OF_BYTES_30MS    50
+   #define NO_OF_WORDS_20MS    19
+   #define NO_OF_WORDS_30MS    25
+   #define STATE_BITS              3
+   #define BYTE_LEN            8
+   #define ULP_CLASSES             3
+
+   /* help parameters */
+
+   #define FLOAT_MAX               (float)1.0e37
+   #define EPS                     (float)2.220446049250313e-016
+   #define PI                      (float)3.14159265358979323846
+   #define MIN_SAMPLE              -32768
+   #define MAX_SAMPLE              32767
+   #define TWO_PI                  (float)6.283185307
+   #define PI2                     (float)0.159154943
+
+   /* type definition encoder instance */
+   typedef struct iLBC_ULP_Inst_t_ {
+       int lsf_bits[6][ULP_CLASSES+2];
+       int start_bits[ULP_CLASSES+2];
+       int startfirst_bits[ULP_CLASSES+2];
+       int scale_bits[ULP_CLASSES+2];
+       int state_bits[ULP_CLASSES+2];
+       int extra_cb_index[CB_NSTAGES][ULP_CLASSES+2];
+       int extra_cb_gain[CB_NSTAGES][ULP_CLASSES+2];
+       int cb_index[NSUB_MAX][CB_NSTAGES][ULP_CLASSES+2];
+       int cb_gain[NSUB_MAX][CB_NSTAGES][ULP_CLASSES+2];
+   } iLBC_ULP_Inst_t;
+
+   /* type definition encoder instance */
+
+
+
+
+
+   typedef struct iLBC_Enc_Inst_t_ {
+
+       /* flag for frame size mode */
+       int mode;
+
+       /* basic parameters for different frame sizes */
+       int blockl;
+       int nsub;
+       int nasub;
+       int no_of_bytes, no_of_words;
+       int lpc_n;
+       int state_short_len;
+       const iLBC_ULP_Inst_t *ULP_inst;
+
+       /* analysis filter state */
+       float anaMem[LPC_FILTERORDER];
+
+       /* old lsf parameters for interpolation */
+       float lsfold[LPC_FILTERORDER];
+       float lsfdeqold[LPC_FILTERORDER];
+
+       /* signal buffer for LP analysis */
+       float lpc_buffer[LPC_LOOKBACK + BLOCKL_MAX];
+
+       /* state of input HP filter */
+       float hpimem[4];
+
+   } iLBC_Enc_Inst_t;
+
+   /* type definition decoder instance */
+   typedef struct iLBC_Dec_Inst_t_ {
+
+       /* flag for frame size mode */
+       int mode;
+
+       /* basic parameters for different frame sizes */
+       int blockl;
+       int nsub;
+       int nasub;
+       int no_of_bytes, no_of_words;
+       int lpc_n;
+       int state_short_len;
+       const iLBC_ULP_Inst_t *ULP_inst;
+
+       /* synthesis filter state */
+       float syntMem[LPC_FILTERORDER];
+
+       /* old LSF for interpolation */
+
+
+
+
+
+       float lsfdeqold[LPC_FILTERORDER];
+
+       /* pitch lag estimated in enhancer and used in PLC */
+       int last_lag;
+
+       /* PLC state information */
+       int prevLag, consPLICount, prevPLI, prev_enh_pl;
+       float prevLpc[LPC_FILTERORDER+1];
+       float prevResidual[NSUB_MAX*SUBL];
+       float per;
+       unsigned long seed;
+
+       /* previous synthesis filter parameters */
+       float old_syntdenum[(LPC_FILTERORDER + 1)*NSUB_MAX];
+
+       /* state of output HP filter */
+       float hpomem[4];
+
+       /* enhancer state information */
+       int use_enhancer;
+       float enh_buf[ENH_BUFL];
+       float enh_period[ENH_NBLOCKS_TOT];
+
+   } iLBC_Dec_Inst_t;
+
+   #endif
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/iLBC_encode.c asterisk-1.8.3.2_com_amr/codecs/ilbc/iLBC_encode.c
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/iLBC_encode.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/iLBC_encode.c	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,543 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       iLBC_encode.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <math.h>
+   #include <stdlib.h>
+   #include <string.h>
+
+   #include "iLBC_define.h"
+   #include "LPCencode.h"
+   #include "FrameClassify.h"
+   #include "StateSearchW.h"
+   #include "StateConstructW.h"
+   #include "helpfun.h"
+   #include "constants.h"
+   #include "packing.h"
+   #include "iCBSearch.h"
+   #include "iCBConstruct.h"
+   #include "hpInput.h"
+   #include "anaFilter.h"
+   #include "syntFilter.h"
+
+   /*----------------------------------------------------------------*
+    *  Initiation of encoder instance.
+    *---------------------------------------------------------------*/
+
+   short initEncode(                   /* (o) Number of bytes
+                                              encoded */
+       iLBC_Enc_Inst_t *iLBCenc_inst,  /* (i/o) Encoder instance */
+       int mode                    /* (i) frame size mode */
+   ){
+       iLBCenc_inst->mode = mode;
+       if (mode==30) {
+           iLBCenc_inst->blockl = BLOCKL_30MS;
+           iLBCenc_inst->nsub = NSUB_30MS;
+           iLBCenc_inst->nasub = NASUB_30MS;
+           iLBCenc_inst->lpc_n = LPC_N_30MS;
+           iLBCenc_inst->no_of_bytes = NO_OF_BYTES_30MS;
+           iLBCenc_inst->no_of_words = NO_OF_WORDS_30MS;
+
+
+
+
+
+           iLBCenc_inst->state_short_len=STATE_SHORT_LEN_30MS;
+           /* ULP init */
+           iLBCenc_inst->ULP_inst=&ULP_30msTbl;
+       }
+       else if (mode==20) {
+           iLBCenc_inst->blockl = BLOCKL_20MS;
+           iLBCenc_inst->nsub = NSUB_20MS;
+           iLBCenc_inst->nasub = NASUB_20MS;
+           iLBCenc_inst->lpc_n = LPC_N_20MS;
+           iLBCenc_inst->no_of_bytes = NO_OF_BYTES_20MS;
+           iLBCenc_inst->no_of_words = NO_OF_WORDS_20MS;
+           iLBCenc_inst->state_short_len=STATE_SHORT_LEN_20MS;
+           /* ULP init */
+           iLBCenc_inst->ULP_inst=&ULP_20msTbl;
+       }
+       else {
+           exit(2);
+       }
+
+       memset((*iLBCenc_inst).anaMem, 0,
+           LPC_FILTERORDER*sizeof(float));
+       memcpy((*iLBCenc_inst).lsfold, lsfmeanTbl,
+           LPC_FILTERORDER*sizeof(float));
+       memcpy((*iLBCenc_inst).lsfdeqold, lsfmeanTbl,
+           LPC_FILTERORDER*sizeof(float));
+       memset((*iLBCenc_inst).lpc_buffer, 0,
+           (LPC_LOOKBACK+BLOCKL_MAX)*sizeof(float));
+       memset((*iLBCenc_inst).hpimem, 0, 4*sizeof(float));
+
+       return (iLBCenc_inst->no_of_bytes);
+   }
+
+   /*----------------------------------------------------------------*
+    *  main encoder function
+    *---------------------------------------------------------------*/
+
+   void iLBC_encode(
+       unsigned char *bytes,           /* (o) encoded data bits iLBC */
+       float *block,                   /* (o) speech vector to
+                                              encode */
+       iLBC_Enc_Inst_t *iLBCenc_inst   /* (i/o) the general encoder
+                                              state */
+   ){
+
+       float data[BLOCKL_MAX];
+       float residual[BLOCKL_MAX], reverseResidual[BLOCKL_MAX];
+
+       int start, idxForMax, idxVec[STATE_LEN];
+
+
+
+
+
+       float reverseDecresidual[BLOCKL_MAX], mem[CB_MEML];
+       int n, k, meml_gotten, Nfor, Nback, i, pos;
+       int gain_index[CB_NSTAGES*NASUB_MAX],
+           extra_gain_index[CB_NSTAGES];
+       int cb_index[CB_NSTAGES*NASUB_MAX],extra_cb_index[CB_NSTAGES];
+       int lsf_i[LSF_NSPLIT*LPC_N_MAX];
+       unsigned char *pbytes;
+       int diff, start_pos, state_first;
+       float en1, en2;
+       int index, ulp, firstpart;
+       int subcount, subframe;
+       float weightState[LPC_FILTERORDER];
+       float syntdenum[NSUB_MAX*(LPC_FILTERORDER+1)];
+       float weightdenum[NSUB_MAX*(LPC_FILTERORDER+1)];
+       float decresidual[BLOCKL_MAX];
+
+       /* high pass filtering of input signal if such is not done
+              prior to calling this function */
+
+       hpInput(block, iLBCenc_inst->blockl,
+                   data, (*iLBCenc_inst).hpimem);
+
+       /* otherwise simply copy */
+
+       /*memcpy(data,block,iLBCenc_inst->blockl*sizeof(float));*/
+
+       /* LPC of hp filtered input data */
+
+       LPCencode(syntdenum, weightdenum, lsf_i, data, iLBCenc_inst);
+
+
+       /* inverse filter to get residual */
+
+       for (n=0; n<iLBCenc_inst->nsub; n++) {
+           anaFilter(&data[n*SUBL], &syntdenum[n*(LPC_FILTERORDER+1)],
+               SUBL, &residual[n*SUBL], iLBCenc_inst->anaMem);
+       }
+
+       /* find state location */
+
+       start = FrameClassify(iLBCenc_inst, residual);
+
+       /* check if state should be in first or last part of the
+       two subframes */
+
+       diff = STATE_LEN - iLBCenc_inst->state_short_len;
+       en1 = 0;
+       index = (start-1)*SUBL;
+
+
+
+
+
+       for (i = 0; i < iLBCenc_inst->state_short_len; i++) {
+           en1 += residual[index+i]*residual[index+i];
+       }
+       en2 = 0;
+       index = (start-1)*SUBL+diff;
+       for (i = 0; i < iLBCenc_inst->state_short_len; i++) {
+           en2 += residual[index+i]*residual[index+i];
+       }
+
+
+       if (en1 > en2) {
+           state_first = 1;
+           start_pos = (start-1)*SUBL;
+       } else {
+           state_first = 0;
+           start_pos = (start-1)*SUBL + diff;
+       }
+
+       /* scalar quantization of state */
+
+       StateSearchW(iLBCenc_inst, &residual[start_pos],
+           &syntdenum[(start-1)*(LPC_FILTERORDER+1)],
+           &weightdenum[(start-1)*(LPC_FILTERORDER+1)], &idxForMax,
+           idxVec, iLBCenc_inst->state_short_len, state_first);
+
+       StateConstructW(idxForMax, idxVec,
+           &syntdenum[(start-1)*(LPC_FILTERORDER+1)],
+           &decresidual[start_pos], iLBCenc_inst->state_short_len);
+
+       /* predictive quantization in state */
+
+       if (state_first) { /* put adaptive part in the end */
+
+           /* setup memory */
+
+           memset(mem, 0,
+               (CB_MEML-iLBCenc_inst->state_short_len)*sizeof(float));
+           memcpy(mem+CB_MEML-iLBCenc_inst->state_short_len,
+               decresidual+start_pos,
+               iLBCenc_inst->state_short_len*sizeof(float));
+           memset(weightState, 0, LPC_FILTERORDER*sizeof(float));
+
+           /* encode sub-frames */
+
+           iCBSearch(iLBCenc_inst, extra_cb_index, extra_gain_index,
+               &residual[start_pos+iLBCenc_inst->state_short_len],
+               mem+CB_MEML-stMemLTbl,
+               stMemLTbl, diff, CB_NSTAGES,
+
+
+
+
+
+               &weightdenum[start*(LPC_FILTERORDER+1)],
+               weightState, 0);
+
+           /* construct decoded vector */
+
+           iCBConstruct(
+               &decresidual[start_pos+iLBCenc_inst->state_short_len],
+               extra_cb_index, extra_gain_index,
+               mem+CB_MEML-stMemLTbl,
+               stMemLTbl, diff, CB_NSTAGES);
+
+       }
+       else { /* put adaptive part in the beginning */
+
+           /* create reversed vectors for prediction */
+
+           for (k=0; k<diff; k++) {
+               reverseResidual[k] = residual[(start+1)*SUBL-1
+                   -(k+iLBCenc_inst->state_short_len)];
+           }
+
+           /* setup memory */
+
+           meml_gotten = iLBCenc_inst->state_short_len;
+           for (k=0; k<meml_gotten; k++) {
+               mem[CB_MEML-1-k] = decresidual[start_pos + k];
+           }
+           memset(mem, 0, (CB_MEML-k)*sizeof(float));
+           memset(weightState, 0, LPC_FILTERORDER*sizeof(float));
+
+           /* encode sub-frames */
+
+           iCBSearch(iLBCenc_inst, extra_cb_index, extra_gain_index,
+               reverseResidual, mem+CB_MEML-stMemLTbl, stMemLTbl,
+               diff, CB_NSTAGES,
+               &weightdenum[(start-1)*(LPC_FILTERORDER+1)],
+               weightState, 0);
+
+           /* construct decoded vector */
+
+           iCBConstruct(reverseDecresidual, extra_cb_index,
+               extra_gain_index, mem+CB_MEML-stMemLTbl, stMemLTbl,
+               diff, CB_NSTAGES);
+
+           /* get decoded residual from reversed vector */
+
+           for (k=0; k<diff; k++) {
+               decresidual[start_pos-1-k] = reverseDecresidual[k];
+
+
+
+
+
+           }
+       }
+
+       /* counter for predicted sub-frames */
+
+       subcount=0;
+
+       /* forward prediction of sub-frames */
+
+       Nfor = iLBCenc_inst->nsub-start-1;
+
+
+       if ( Nfor > 0 ) {
+
+           /* setup memory */
+
+           memset(mem, 0, (CB_MEML-STATE_LEN)*sizeof(float));
+           memcpy(mem+CB_MEML-STATE_LEN, decresidual+(start-1)*SUBL,
+               STATE_LEN*sizeof(float));
+           memset(weightState, 0, LPC_FILTERORDER*sizeof(float));
+
+           /* loop over sub-frames to encode */
+
+           for (subframe=0; subframe<Nfor; subframe++) {
+
+               /* encode sub-frame */
+
+               iCBSearch(iLBCenc_inst, cb_index+subcount*CB_NSTAGES,
+                   gain_index+subcount*CB_NSTAGES,
+                   &residual[(start+1+subframe)*SUBL],
+                   mem+CB_MEML-memLfTbl[subcount],
+                   memLfTbl[subcount], SUBL, CB_NSTAGES,
+                   &weightdenum[(start+1+subframe)*
+                               (LPC_FILTERORDER+1)],
+                   weightState, subcount+1);
+
+               /* construct decoded vector */
+
+               iCBConstruct(&decresidual[(start+1+subframe)*SUBL],
+                   cb_index+subcount*CB_NSTAGES,
+                   gain_index+subcount*CB_NSTAGES,
+                   mem+CB_MEML-memLfTbl[subcount],
+                   memLfTbl[subcount], SUBL, CB_NSTAGES);
+
+               /* update memory */
+
+               memcpy(mem, mem+SUBL, (CB_MEML-SUBL)*sizeof(float));
+               memcpy(mem+CB_MEML-SUBL,
+
+
+
+
+
+                   &decresidual[(start+1+subframe)*SUBL],
+                   SUBL*sizeof(float));
+               memset(weightState, 0, LPC_FILTERORDER*sizeof(float));
+
+               subcount++;
+           }
+       }
+
+
+       /* backward prediction of sub-frames */
+
+       Nback = start-1;
+
+
+       if ( Nback > 0 ) {
+
+           /* create reverse order vectors */
+
+           for (n=0; n<Nback; n++) {
+               for (k=0; k<SUBL; k++) {
+                   reverseResidual[n*SUBL+k] =
+                       residual[(start-1)*SUBL-1-n*SUBL-k];
+                   reverseDecresidual[n*SUBL+k] =
+                       decresidual[(start-1)*SUBL-1-n*SUBL-k];
+               }
+           }
+
+           /* setup memory */
+
+           meml_gotten = SUBL*(iLBCenc_inst->nsub+1-start);
+
+
+           if ( meml_gotten > CB_MEML ) {
+               meml_gotten=CB_MEML;
+           }
+           for (k=0; k<meml_gotten; k++) {
+               mem[CB_MEML-1-k] = decresidual[(start-1)*SUBL + k];
+           }
+           memset(mem, 0, (CB_MEML-k)*sizeof(float));
+           memset(weightState, 0, LPC_FILTERORDER*sizeof(float));
+
+           /* loop over sub-frames to encode */
+
+           for (subframe=0; subframe<Nback; subframe++) {
+
+               /* encode sub-frame */
+
+               iCBSearch(iLBCenc_inst, cb_index+subcount*CB_NSTAGES,
+
+
+
+
+
+                   gain_index+subcount*CB_NSTAGES,
+                   &reverseResidual[subframe*SUBL],
+                   mem+CB_MEML-memLfTbl[subcount],
+                   memLfTbl[subcount], SUBL, CB_NSTAGES,
+                   &weightdenum[(start-2-subframe)*
+                               (LPC_FILTERORDER+1)],
+                   weightState, subcount+1);
+
+               /* construct decoded vector */
+
+               iCBConstruct(&reverseDecresidual[subframe*SUBL],
+                   cb_index+subcount*CB_NSTAGES,
+                   gain_index+subcount*CB_NSTAGES,
+                   mem+CB_MEML-memLfTbl[subcount],
+                   memLfTbl[subcount], SUBL, CB_NSTAGES);
+
+               /* update memory */
+
+               memcpy(mem, mem+SUBL, (CB_MEML-SUBL)*sizeof(float));
+               memcpy(mem+CB_MEML-SUBL,
+                   &reverseDecresidual[subframe*SUBL],
+                   SUBL*sizeof(float));
+               memset(weightState, 0, LPC_FILTERORDER*sizeof(float));
+
+               subcount++;
+
+           }
+
+           /* get decoded residual from reversed vector */
+
+           for (i=0; i<SUBL*Nback; i++) {
+               decresidual[SUBL*Nback - i - 1] =
+                   reverseDecresidual[i];
+           }
+       }
+       /* end encoding part */
+
+       /* adjust index */
+       index_conv_enc(cb_index);
+
+       /* pack bytes */
+
+       pbytes=bytes;
+       pos=0;
+
+       /* loop over the 3 ULP classes */
+
+       for (ulp=0; ulp<3; ulp++) {
+
+
+
+
+
+
+           /* LSF */
+           for (k=0; k<LSF_NSPLIT*iLBCenc_inst->lpc_n; k++) {
+               packsplit(&lsf_i[k], &firstpart, &lsf_i[k],
+                   iLBCenc_inst->ULP_inst->lsf_bits[k][ulp],
+                   iLBCenc_inst->ULP_inst->lsf_bits[k][ulp]+
+                   iLBCenc_inst->ULP_inst->lsf_bits[k][ulp+1]+
+                   iLBCenc_inst->ULP_inst->lsf_bits[k][ulp+2]);
+               dopack( &pbytes, firstpart,
+                   iLBCenc_inst->ULP_inst->lsf_bits[k][ulp], &pos);
+           }
+
+           /* Start block info */
+
+           packsplit(&start, &firstpart, &start,
+               iLBCenc_inst->ULP_inst->start_bits[ulp],
+               iLBCenc_inst->ULP_inst->start_bits[ulp]+
+               iLBCenc_inst->ULP_inst->start_bits[ulp+1]+
+               iLBCenc_inst->ULP_inst->start_bits[ulp+2]);
+           dopack( &pbytes, firstpart,
+               iLBCenc_inst->ULP_inst->start_bits[ulp], &pos);
+
+           packsplit(&state_first, &firstpart, &state_first,
+               iLBCenc_inst->ULP_inst->startfirst_bits[ulp],
+               iLBCenc_inst->ULP_inst->startfirst_bits[ulp]+
+               iLBCenc_inst->ULP_inst->startfirst_bits[ulp+1]+
+               iLBCenc_inst->ULP_inst->startfirst_bits[ulp+2]);
+           dopack( &pbytes, firstpart,
+               iLBCenc_inst->ULP_inst->startfirst_bits[ulp], &pos);
+
+           packsplit(&idxForMax, &firstpart, &idxForMax,
+               iLBCenc_inst->ULP_inst->scale_bits[ulp],
+               iLBCenc_inst->ULP_inst->scale_bits[ulp]+
+               iLBCenc_inst->ULP_inst->scale_bits[ulp+1]+
+               iLBCenc_inst->ULP_inst->scale_bits[ulp+2]);
+           dopack( &pbytes, firstpart,
+               iLBCenc_inst->ULP_inst->scale_bits[ulp], &pos);
+
+           for (k=0; k<iLBCenc_inst->state_short_len; k++) {
+               packsplit(idxVec+k, &firstpart, idxVec+k,
+                   iLBCenc_inst->ULP_inst->state_bits[ulp],
+                   iLBCenc_inst->ULP_inst->state_bits[ulp]+
+                   iLBCenc_inst->ULP_inst->state_bits[ulp+1]+
+                   iLBCenc_inst->ULP_inst->state_bits[ulp+2]);
+               dopack( &pbytes, firstpart,
+                   iLBCenc_inst->ULP_inst->state_bits[ulp], &pos);
+           }
+
+
+
+
+
+
+           /* 23/22 (20ms/30ms) sample block */
+
+           for (k=0;k<CB_NSTAGES;k++) {
+               packsplit(extra_cb_index+k, &firstpart,
+                   extra_cb_index+k,
+                   iLBCenc_inst->ULP_inst->extra_cb_index[k][ulp],
+                   iLBCenc_inst->ULP_inst->extra_cb_index[k][ulp]+
+                   iLBCenc_inst->ULP_inst->extra_cb_index[k][ulp+1]+
+                   iLBCenc_inst->ULP_inst->extra_cb_index[k][ulp+2]);
+               dopack( &pbytes, firstpart,
+                   iLBCenc_inst->ULP_inst->extra_cb_index[k][ulp],
+                   &pos);
+           }
+
+           for (k=0;k<CB_NSTAGES;k++) {
+               packsplit(extra_gain_index+k, &firstpart,
+                   extra_gain_index+k,
+                   iLBCenc_inst->ULP_inst->extra_cb_gain[k][ulp],
+                   iLBCenc_inst->ULP_inst->extra_cb_gain[k][ulp]+
+                   iLBCenc_inst->ULP_inst->extra_cb_gain[k][ulp+1]+
+                   iLBCenc_inst->ULP_inst->extra_cb_gain[k][ulp+2]);
+               dopack( &pbytes, firstpart,
+                   iLBCenc_inst->ULP_inst->extra_cb_gain[k][ulp],
+                   &pos);
+           }
+
+           /* The two/four (20ms/30ms) 40 sample sub-blocks */
+
+           for (i=0; i<iLBCenc_inst->nasub; i++) {
+               for (k=0; k<CB_NSTAGES; k++) {
+                   packsplit(cb_index+i*CB_NSTAGES+k, &firstpart,
+                       cb_index+i*CB_NSTAGES+k,
+                       iLBCenc_inst->ULP_inst->cb_index[i][k][ulp],
+                       iLBCenc_inst->ULP_inst->cb_index[i][k][ulp]+
+                       iLBCenc_inst->ULP_inst->cb_index[i][k][ulp+1]+
+                       iLBCenc_inst->ULP_inst->cb_index[i][k][ulp+2]);
+                   dopack( &pbytes, firstpart,
+                       iLBCenc_inst->ULP_inst->cb_index[i][k][ulp],
+                       &pos);
+               }
+           }
+
+           for (i=0; i<iLBCenc_inst->nasub; i++) {
+               for (k=0; k<CB_NSTAGES; k++) {
+                   packsplit(gain_index+i*CB_NSTAGES+k, &firstpart,
+                       gain_index+i*CB_NSTAGES+k,
+                       iLBCenc_inst->ULP_inst->cb_gain[i][k][ulp],
+                       iLBCenc_inst->ULP_inst->cb_gain[i][k][ulp]+
+
+
+
+
+
+                       iLBCenc_inst->ULP_inst->cb_gain[i][k][ulp+1]+
+                       iLBCenc_inst->ULP_inst->cb_gain[i][k][ulp+2]);
+                   dopack( &pbytes, firstpart,
+                       iLBCenc_inst->ULP_inst->cb_gain[i][k][ulp],
+                       &pos);
+               }
+           }
+       }
+
+       /* set the last bit to zero (otherwise the decoder
+          will treat it as a lost frame) */
+       dopack( &pbytes, 0, 1, &pos);
+   }
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/iLBC_encode.h asterisk-1.8.3.2_com_amr/codecs/ilbc/iLBC_encode.h
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/iLBC_encode.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/iLBC_encode.h	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,39 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       iLBC_encode.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_ILBCENCODE_H
+   #define __iLBC_ILBCENCODE_H
+
+   #include "iLBC_define.h"
+
+   short initEncode(                   /* (o) Number of bytes
+                                              encoded */
+       iLBC_Enc_Inst_t *iLBCenc_inst,  /* (i/o) Encoder instance */
+       int mode                    /* (i) frame size mode */
+   );
+
+   void iLBC_encode(
+
+       unsigned char *bytes,           /* (o) encoded data bits iLBC */
+       float *block,                   /* (o) speech vector to
+                                              encode */
+       iLBC_Enc_Inst_t *iLBCenc_inst   /* (i/o) the general encoder
+                                              state */
+   );
+
+   #endif
+
+
+
+
+
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/iLBC_test.c asterisk-1.8.3.2_com_amr/codecs/ilbc/iLBC_test.c
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/iLBC_test.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/iLBC_test.c	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,310 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       iLBC_test.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <math.h>
+   #include <stdlib.h>
+   #include <stdio.h>
+   #include <string.h>
+   #include "iLBC_define.h"
+   #include "iLBC_encode.h"
+   #include "iLBC_decode.h"
+
+   /* Runtime statistics */
+   #include <time.h>
+
+   #define ILBCNOOFWORDS_MAX   (NO_OF_BYTES_30MS/2)
+
+   /*----------------------------------------------------------------*
+    *  Encoder interface function
+
+
+
+
+
+    *---------------------------------------------------------------*/
+
+   short encode(   /* (o) Number of bytes encoded */
+       iLBC_Enc_Inst_t *iLBCenc_inst,
+                                   /* (i/o) Encoder instance */
+       short *encoded_data,    /* (o) The encoded bytes */
+       short *data                 /* (i) The signal block to encode*/
+   ){
+       float block[BLOCKL_MAX];
+       int k;
+
+       /* convert signal to float */
+
+       for (k=0; k<iLBCenc_inst->blockl; k++)
+           block[k] = (float)data[k];
+
+       /* do the actual encoding */
+
+       iLBC_encode((unsigned char *)encoded_data, block, iLBCenc_inst);
+
+
+       return (iLBCenc_inst->no_of_bytes);
+   }
+
+   /*----------------------------------------------------------------*
+    *  Decoder interface function
+    *---------------------------------------------------------------*/
+
+   short decode(       /* (o) Number of decoded samples */
+       iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) Decoder instance */
+       short *decoded_data,        /* (o) Decoded signal block*/
+       short *encoded_data,        /* (i) Encoded bytes */
+       short mode                       /* (i) 0=PL, 1=Normal */
+   ){
+       int k;
+       float decblock[BLOCKL_MAX], dtmp;
+
+       /* check if mode is valid */
+
+       if (mode<0 || mode>1) {
+           printf("\nERROR - Wrong mode - 0, 1 allowed\n"); exit(3);}
+
+       /* do actual decoding of block */
+
+       iLBC_decode(decblock, (unsigned char *)encoded_data,
+           iLBCdec_inst, mode);
+
+       /* convert to short */
+
+
+
+
+
+       for (k=0; k<iLBCdec_inst->blockl; k++){
+           dtmp=decblock[k];
+
+           if (dtmp<MIN_SAMPLE)
+               dtmp=MIN_SAMPLE;
+           else if (dtmp>MAX_SAMPLE)
+               dtmp=MAX_SAMPLE;
+           decoded_data[k] = (short) dtmp;
+       }
+
+       return (iLBCdec_inst->blockl);
+   }
+
+   /*---------------------------------------------------------------*
+    *  Main program to test iLBC encoding and decoding
+    *
+    *  Usage:
+    *    exefile_name.exe <infile> <bytefile> <outfile> <channel>
+    *
+    *    <infile>   : Input file, speech for encoder (16-bit pcm file)
+    *    <bytefile> : Bit stream output from the encoder
+    *    <outfile>  : Output file, decoded speech (16-bit pcm file)
+    *    <channel>  : Bit error file, optional (16-bit)
+    *                     1 - Packet received correctly
+    *                     0 - Packet Lost
+    *
+    *--------------------------------------------------------------*/
+
+   int main(int argc, char* argv[])
+   {
+
+       /* Runtime statistics */
+
+       float starttime;
+       float runtime;
+       float outtime;
+
+       FILE *ifileid,*efileid,*ofileid, *cfileid;
+       short data[BLOCKL_MAX];
+       short encoded_data[ILBCNOOFWORDS_MAX], decoded_data[BLOCKL_MAX];
+       int len;
+       short pli, mode;
+       int blockcount = 0;
+       int packetlosscount = 0;
+
+       /* Create structs */
+       iLBC_Enc_Inst_t Enc_Inst;
+       iLBC_Dec_Inst_t Dec_Inst;
+
+
+
+
+
+       /* get arguments and open files */
+
+       if ((argc!=5) && (argc!=6)) {
+           fprintf(stderr,
+           "\n*-----------------------------------------------*\n");
+           fprintf(stderr,
+           "   %s <20,30> input encoded decoded (channel)\n\n",
+               argv[0]);
+           fprintf(stderr,
+           "   mode    : Frame size for the encoding/decoding\n");
+           fprintf(stderr,
+           "                 20 - 20 ms\n");
+           fprintf(stderr,
+           "                 30 - 30 ms\n");
+           fprintf(stderr,
+           "   input   : Speech for encoder (16-bit pcm file)\n");
+           fprintf(stderr,
+           "   encoded : Encoded bit stream\n");
+           fprintf(stderr,
+           "   decoded : Decoded speech (16-bit pcm file)\n");
+           fprintf(stderr,
+           "   channel : Packet loss pattern, optional (16-bit)\n");
+           fprintf(stderr,
+           "                  1 - Packet received correctly\n");
+           fprintf(stderr,
+           "                  0 - Packet Lost\n");
+           fprintf(stderr,
+           "*-----------------------------------------------*\n\n");
+           exit(1);
+       }
+       mode=atoi(argv[1]);
+       if (mode != 20 && mode != 30) {
+           fprintf(stderr,"Wrong mode %s, must be 20, or 30\n",
+               argv[1]);
+           exit(2);
+       }
+       if ( (ifileid=fopen(argv[2],"rb")) == NULL) {
+           fprintf(stderr,"Cannot open input file %s\n", argv[2]);
+           exit(2);}
+       if ( (efileid=fopen(argv[3],"wb")) == NULL) {
+           fprintf(stderr, "Cannot open encoded file %s\n",
+               argv[3]); exit(1);}
+       if ( (ofileid=fopen(argv[4],"wb")) == NULL) {
+           fprintf(stderr, "Cannot open decoded file %s\n",
+               argv[4]); exit(1);}
+       if (argc==6) {
+           if( (cfileid=fopen(argv[5],"rb")) == NULL) {
+               fprintf(stderr, "Cannot open channel file %s\n",
+
+
+
+
+
+                   argv[5]);
+               exit(1);
+           }
+       } else {
+           cfileid=NULL;
+       }
+
+       /* print info */
+
+       fprintf(stderr, "\n");
+       fprintf(stderr,
+           "*---------------------------------------------------*\n");
+       fprintf(stderr,
+           "*                                                   *\n");
+       fprintf(stderr,
+           "*      iLBC test program                            *\n");
+       fprintf(stderr,
+           "*                                                   *\n");
+       fprintf(stderr,
+           "*                                                   *\n");
+       fprintf(stderr,
+           "*---------------------------------------------------*\n");
+       fprintf(stderr,"\nMode           : %2d ms\n", mode);
+       fprintf(stderr,"Input file     : %s\n", argv[2]);
+       fprintf(stderr,"Encoded file   : %s\n", argv[3]);
+       fprintf(stderr,"Output file    : %s\n", argv[4]);
+       if (argc==6) {
+           fprintf(stderr,"Channel file   : %s\n", argv[5]);
+       }
+       fprintf(stderr,"\n");
+
+       /* Initialization */
+
+       initEncode(&Enc_Inst, mode);
+       initDecode(&Dec_Inst, mode, 1);
+
+       /* Runtime statistics */
+
+       starttime=clock()/(float)CLOCKS_PER_SEC;
+
+       /* loop over input blocks */
+
+       while (fread(data,sizeof(short),Enc_Inst.blockl,ifileid)==
+               Enc_Inst.blockl) {
+
+           blockcount++;
+
+           /* encoding */
+
+
+
+
+
+           fprintf(stderr, "--- Encoding block %i --- ",blockcount);
+           len=encode(&Enc_Inst, encoded_data, data);
+           fprintf(stderr, "\r");
+
+           /* write byte file */
+
+           fwrite(encoded_data, sizeof(unsigned char), len, efileid);
+
+           /* get channel data if provided */
+           if (argc==6) {
+               if (fread(&pli, sizeof(short), 1, cfileid)) {
+                   if ((pli!=0)&&(pli!=1)) {
+                       fprintf(stderr, "Error in channel file\n");
+                       exit(0);
+                   }
+                   if (pli==0) {
+                       /* Packet loss -> remove info from frame */
+                       memset(encoded_data, 0,
+                           sizeof(short)*ILBCNOOFWORDS_MAX);
+                       packetlosscount++;
+                   }
+               } else {
+                   fprintf(stderr, "Error. Channel file too short\n");
+                   exit(0);
+               }
+           } else {
+               pli=1;
+           }
+
+           /* decoding */
+
+           fprintf(stderr, "--- Decoding block %i --- ",blockcount);
+
+           len=decode(&Dec_Inst, decoded_data, encoded_data, pli);
+           fprintf(stderr, "\r");
+
+           /* write output file */
+
+           fwrite(decoded_data,sizeof(short),len,ofileid);
+       }
+
+       /* Runtime statistics */
+
+       runtime = (float)(clock()/(float)CLOCKS_PER_SEC-starttime);
+       outtime = (float)((float)blockcount*(float)mode/1000.0);
+       printf("\n\nLength of speech file: %.1f s\n", outtime);
+       printf("Packet loss          : %.1f%%\n",
+           100.0*(float)packetlosscount/(float)blockcount);
+
+
+
+
+
+       printf("Time to run iLBC     :");
+       printf(" %.1f s (%.1f %% of realtime)\n\n", runtime,
+           (100*runtime/outtime));
+
+       /* close files */
+
+       fclose(ifileid);  fclose(efileid); fclose(ofileid);
+       if (argc==6) {
+           fclose(cfileid);
+       }
+       return(0);
+   }
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/LPCdecode.c asterisk-1.8.3.2_com_amr/codecs/ilbc/LPCdecode.c
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/LPCdecode.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/LPCdecode.c	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,158 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       LPC_decode.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <math.h>
+   #include <string.h>
+
+   #include "helpfun.h"
+   #include "lsf.h"
+   #include "iLBC_define.h"
+   #include "constants.h"
+
+   /*---------------------------------------------------------------*
+    *  interpolation of lsf coefficients for the decoder
+    *--------------------------------------------------------------*/
+
+   void LSFinterpolate2a_dec(
+       float *a,           /* (o) lpc coefficients for a sub-frame */
+       float *lsf1,    /* (i) first lsf coefficient vector */
+       float *lsf2,    /* (i) second lsf coefficient vector */
+       float coef,         /* (i) interpolation weight */
+       int length          /* (i) length of lsf vectors */
+   ){
+       float  lsftmp[LPC_FILTERORDER];
+
+       interpolate(lsftmp, lsf1, lsf2, coef, length);
+       lsf2a(a, lsftmp);
+   }
+
+   /*---------------------------------------------------------------*
+    *  obtain dequantized lsf coefficients from quantization index
+    *--------------------------------------------------------------*/
+
+   void SimplelsfDEQ(
+       float *lsfdeq,    /* (o) dequantized lsf coefficients */
+       int *index,         /* (i) quantization index */
+       int lpc_n           /* (i) number of LPCs */
+   ){
+       int i, j, pos, cb_pos;
+
+
+
+
+
+       /* decode first LSF */
+
+       pos = 0;
+       cb_pos = 0;
+       for (i = 0; i < LSF_NSPLIT; i++) {
+           for (j = 0; j < dim_lsfCbTbl[i]; j++) {
+               lsfdeq[pos + j] = lsfCbTbl[cb_pos +
+                   (long)(index[i])*dim_lsfCbTbl[i] + j];
+           }
+           pos += dim_lsfCbTbl[i];
+           cb_pos += size_lsfCbTbl[i]*dim_lsfCbTbl[i];
+       }
+
+       if (lpc_n>1) {
+
+           /* decode last LSF */
+
+           pos = 0;
+           cb_pos = 0;
+           for (i = 0; i < LSF_NSPLIT; i++) {
+               for (j = 0; j < dim_lsfCbTbl[i]; j++) {
+                   lsfdeq[LPC_FILTERORDER + pos + j] =
+                       lsfCbTbl[cb_pos +
+                       (long)(index[LSF_NSPLIT + i])*
+                       dim_lsfCbTbl[i] + j];
+               }
+               pos += dim_lsfCbTbl[i];
+               cb_pos += size_lsfCbTbl[i]*dim_lsfCbTbl[i];
+           }
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  obtain synthesis and weighting filters form lsf coefficients
+    *---------------------------------------------------------------*/
+
+   void DecoderInterpolateLSF(
+       float *syntdenum, /* (o) synthesis filter coefficients */
+       float *weightdenum, /* (o) weighting denumerator
+                                  coefficients */
+       float *lsfdeq,       /* (i) dequantized lsf coefficients */
+       int length,         /* (i) length of lsf coefficient vector */
+       iLBC_Dec_Inst_t *iLBCdec_inst
+                           /* (i) the decoder state structure */
+   ){
+       int    i, pos, lp_length;
+       float  lp[LPC_FILTERORDER + 1], *lsfdeq2;
+
+
+
+
+
+
+       lsfdeq2 = lsfdeq + length;
+       lp_length = length + 1;
+
+       if (iLBCdec_inst->mode==30) {
+           /* sub-frame 1: Interpolation between old and first */
+
+           LSFinterpolate2a_dec(lp, iLBCdec_inst->lsfdeqold, lsfdeq,
+               lsf_weightTbl_30ms[0], length);
+           memcpy(syntdenum,lp,lp_length*sizeof(float));
+           bwexpand(weightdenum, lp, LPC_CHIRP_WEIGHTDENUM,
+               lp_length);
+
+           /* sub-frames 2 to 6: interpolation between first
+              and last LSF */
+
+           pos = lp_length;
+           for (i = 1; i < 6; i++) {
+               LSFinterpolate2a_dec(lp, lsfdeq, lsfdeq2,
+                   lsf_weightTbl_30ms[i], length);
+               memcpy(syntdenum + pos,lp,lp_length*sizeof(float));
+               bwexpand(weightdenum + pos, lp,
+                   LPC_CHIRP_WEIGHTDENUM, lp_length);
+               pos += lp_length;
+           }
+       }
+       else {
+           pos = 0;
+           for (i = 0; i < iLBCdec_inst->nsub; i++) {
+               LSFinterpolate2a_dec(lp, iLBCdec_inst->lsfdeqold,
+                   lsfdeq, lsf_weightTbl_20ms[i], length);
+               memcpy(syntdenum+pos,lp,lp_length*sizeof(float));
+               bwexpand(weightdenum+pos, lp, LPC_CHIRP_WEIGHTDENUM,
+                   lp_length);
+               pos += lp_length;
+           }
+       }
+
+       /* update memory */
+
+       if (iLBCdec_inst->mode==30)
+           memcpy(iLBCdec_inst->lsfdeqold, lsfdeq2,
+                       length*sizeof(float));
+       else
+           memcpy(iLBCdec_inst->lsfdeqold, lsfdeq,
+                       length*sizeof(float));
+
+   }
+
+
+
+
+
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/LPCdecode.h asterisk-1.8.3.2_com_amr/codecs/ilbc/LPCdecode.h
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/LPCdecode.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/LPCdecode.h	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,52 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       LPC_decode.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_LPC_DECODE_H
+   #define __iLBC_LPC_DECODE_H
+
+   void LSFinterpolate2a_dec(
+       float *a,           /* (o) lpc coefficients for a sub-frame */
+       float *lsf1,    /* (i) first lsf coefficient vector */
+       float *lsf2,    /* (i) second lsf coefficient vector */
+       float coef,         /* (i) interpolation weight */
+       int length          /* (i) length of lsf vectors */
+   );
+
+   void SimplelsfDEQ(
+       float *lsfdeq,      /* (o) dequantized lsf coefficients */
+       int *index,         /* (i) quantization index */
+       int lpc_n           /* (i) number of LPCs */
+   );
+
+   void DecoderInterpolateLSF(
+       float *syntdenum,   /* (o) synthesis filter coefficients */
+       float *weightdenum, /* (o) weighting denumerator
+                                  coefficients */
+       float *lsfdeq,      /* (i) dequantized lsf coefficients */
+       int length,         /* (i) length of lsf coefficient vector */
+       iLBC_Dec_Inst_t *iLBCdec_inst
+                           /* (i) the decoder state structure */
+   );
+
+   #endif
+
+
+
+
+
+
+
+
+
+
+
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/LPCencode.c asterisk-1.8.3.2_com_amr/codecs/ilbc/LPCencode.c
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/LPCencode.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/LPCencode.c	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,241 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       LPCencode.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <string.h>
+
+   #include "iLBC_define.h"
+   #include "helpfun.h"
+   #include "lsf.h"
+   #include "constants.h"
+
+
+
+
+
+   /*----------------------------------------------------------------*
+    *  lpc analysis (subrutine to LPCencode)
+    *---------------------------------------------------------------*/
+
+   void SimpleAnalysis(
+       float *lsf,         /* (o) lsf coefficients */
+       float *data,    /* (i) new data vector */
+       iLBC_Enc_Inst_t *iLBCenc_inst
+                           /* (i/o) the encoder state structure */
+   ){
+       int k, is;
+       float temp[BLOCKL_MAX], lp[LPC_FILTERORDER + 1];
+       float lp2[LPC_FILTERORDER + 1];
+       float r[LPC_FILTERORDER + 1];
+
+       is=LPC_LOOKBACK+BLOCKL_MAX-iLBCenc_inst->blockl;
+       memcpy(iLBCenc_inst->lpc_buffer+is,data,
+           iLBCenc_inst->blockl*sizeof(float));
+
+       /* No lookahead, last window is asymmetric */
+
+       for (k = 0; k < iLBCenc_inst->lpc_n; k++) {
+
+           is = LPC_LOOKBACK;
+
+           if (k < (iLBCenc_inst->lpc_n - 1)) {
+               window(temp, lpc_winTbl,
+                   iLBCenc_inst->lpc_buffer, BLOCKL_MAX);
+           } else {
+               window(temp, lpc_asymwinTbl,
+                   iLBCenc_inst->lpc_buffer + is, BLOCKL_MAX);
+           }
+
+           autocorr(r, temp, BLOCKL_MAX, LPC_FILTERORDER);
+           window(r, r, lpc_lagwinTbl, LPC_FILTERORDER + 1);
+
+           levdurb(lp, temp, r, LPC_FILTERORDER);
+           bwexpand(lp2, lp, LPC_CHIRP_SYNTDENUM, LPC_FILTERORDER+1);
+
+           a2lsf(lsf + k*LPC_FILTERORDER, lp2);
+       }
+       is=LPC_LOOKBACK+BLOCKL_MAX-iLBCenc_inst->blockl;
+       memmove(iLBCenc_inst->lpc_buffer,
+           iLBCenc_inst->lpc_buffer+LPC_LOOKBACK+BLOCKL_MAX-is,
+           is*sizeof(float));
+   }
+
+   /*----------------------------------------------------------------*
+
+
+
+
+
+    *  lsf interpolator and conversion from lsf to a coefficients
+    *  (subrutine to SimpleInterpolateLSF)
+    *---------------------------------------------------------------*/
+
+   void LSFinterpolate2a_enc(
+       float *a,       /* (o) lpc coefficients */
+       float *lsf1,/* (i) first set of lsf coefficients */
+       float *lsf2,/* (i) second set of lsf coefficients */
+       float coef,     /* (i) weighting coefficient to use between
+                              lsf1 and lsf2 */
+       long length      /* (i) length of coefficient vectors */
+   ){
+       float  lsftmp[LPC_FILTERORDER];
+
+       interpolate(lsftmp, lsf1, lsf2, coef, length);
+       lsf2a(a, lsftmp);
+   }
+
+   /*----------------------------------------------------------------*
+    *  lsf interpolator (subrutine to LPCencode)
+    *---------------------------------------------------------------*/
+
+   void SimpleInterpolateLSF(
+       float *syntdenum,   /* (o) the synthesis filter denominator
+                                  resulting from the quantized
+                                  interpolated lsf */
+       float *weightdenum, /* (o) the weighting filter denominator
+                                  resulting from the unquantized
+                                  interpolated lsf */
+       float *lsf,         /* (i) the unquantized lsf coefficients */
+       float *lsfdeq,      /* (i) the dequantized lsf coefficients */
+       float *lsfold,      /* (i) the unquantized lsf coefficients of
+                                  the previous signal frame */
+       float *lsfdeqold, /* (i) the dequantized lsf coefficients of
+                                  the previous signal frame */
+       int length,         /* (i) should equate LPC_FILTERORDER */
+       iLBC_Enc_Inst_t *iLBCenc_inst
+                           /* (i/o) the encoder state structure */
+   ){
+       int    i, pos, lp_length;
+       float  lp[LPC_FILTERORDER + 1], *lsf2, *lsfdeq2;
+
+       lsf2 = lsf + length;
+       lsfdeq2 = lsfdeq + length;
+       lp_length = length + 1;
+
+       if (iLBCenc_inst->mode==30) {
+           /* sub-frame 1: Interpolation between old and first
+
+
+
+
+
+              set of lsf coefficients */
+
+           LSFinterpolate2a_enc(lp, lsfdeqold, lsfdeq,
+               lsf_weightTbl_30ms[0], length);
+           memcpy(syntdenum,lp,lp_length*sizeof(float));
+           LSFinterpolate2a_enc(lp, lsfold, lsf,
+               lsf_weightTbl_30ms[0], length);
+           bwexpand(weightdenum, lp, LPC_CHIRP_WEIGHTDENUM, lp_length);
+
+           /* sub-frame 2 to 6: Interpolation between first
+              and second set of lsf coefficients */
+
+           pos = lp_length;
+           for (i = 1; i < iLBCenc_inst->nsub; i++) {
+               LSFinterpolate2a_enc(lp, lsfdeq, lsfdeq2,
+                   lsf_weightTbl_30ms[i], length);
+               memcpy(syntdenum + pos,lp,lp_length*sizeof(float));
+
+               LSFinterpolate2a_enc(lp, lsf, lsf2,
+                   lsf_weightTbl_30ms[i], length);
+               bwexpand(weightdenum + pos, lp,
+                   LPC_CHIRP_WEIGHTDENUM, lp_length);
+               pos += lp_length;
+           }
+       }
+       else {
+           pos = 0;
+           for (i = 0; i < iLBCenc_inst->nsub; i++) {
+               LSFinterpolate2a_enc(lp, lsfdeqold, lsfdeq,
+                   lsf_weightTbl_20ms[i], length);
+               memcpy(syntdenum+pos,lp,lp_length*sizeof(float));
+               LSFinterpolate2a_enc(lp, lsfold, lsf,
+                   lsf_weightTbl_20ms[i], length);
+               bwexpand(weightdenum+pos, lp,
+                   LPC_CHIRP_WEIGHTDENUM, lp_length);
+               pos += lp_length;
+           }
+       }
+
+       /* update memory */
+
+       if (iLBCenc_inst->mode==30) {
+           memcpy(lsfold, lsf2, length*sizeof(float));
+           memcpy(lsfdeqold, lsfdeq2, length*sizeof(float));
+       }
+       else {
+           memcpy(lsfold, lsf, length*sizeof(float));
+           memcpy(lsfdeqold, lsfdeq, length*sizeof(float));
+
+
+
+
+
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  lsf quantizer (subrutine to LPCencode)
+    *---------------------------------------------------------------*/
+
+   void SimplelsfQ(
+       float *lsfdeq,    /* (o) dequantized lsf coefficients
+                              (dimension FILTERORDER) */
+       int *index,     /* (o) quantization index */
+       float *lsf,      /* (i) the lsf coefficient vector to be
+                              quantized (dimension FILTERORDER ) */
+       int lpc_n     /* (i) number of lsf sets to quantize */
+   ){
+       /* Quantize first LSF with memoryless split VQ */
+       SplitVQ(lsfdeq, index, lsf, lsfCbTbl, LSF_NSPLIT,
+           dim_lsfCbTbl, size_lsfCbTbl);
+
+       if (lpc_n==2) {
+           /* Quantize second LSF with memoryless split VQ */
+           SplitVQ(lsfdeq + LPC_FILTERORDER, index + LSF_NSPLIT,
+               lsf + LPC_FILTERORDER, lsfCbTbl, LSF_NSPLIT,
+               dim_lsfCbTbl, size_lsfCbTbl);
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  lpc encoder
+    *---------------------------------------------------------------*/
+
+   void LPCencode(
+       float *syntdenum, /* (i/o) synthesis filter coefficients
+                                  before/after encoding */
+       float *weightdenum, /* (i/o) weighting denumerator
+                                  coefficients before/after
+                                  encoding */
+       int *lsf_index,     /* (o) lsf quantization index */
+       float *data,    /* (i) lsf coefficients to quantize */
+       iLBC_Enc_Inst_t *iLBCenc_inst
+                           /* (i/o) the encoder state structure */
+   ){
+       float lsf[LPC_FILTERORDER * LPC_N_MAX];
+       float lsfdeq[LPC_FILTERORDER * LPC_N_MAX];
+       int change=0;
+
+       SimpleAnalysis(lsf, data, iLBCenc_inst);
+       SimplelsfQ(lsfdeq, lsf_index, lsf, iLBCenc_inst->lpc_n);
+
+
+
+
+
+       change=LSF_check(lsfdeq, LPC_FILTERORDER, iLBCenc_inst->lpc_n);
+       SimpleInterpolateLSF(syntdenum, weightdenum,
+           lsf, lsfdeq, iLBCenc_inst->lsfold,
+           iLBCenc_inst->lsfdeqold, LPC_FILTERORDER, iLBCenc_inst);
+   }
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/LPCencode.h asterisk-1.8.3.2_com_amr/codecs/ilbc/LPCencode.h
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/LPCencode.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/LPCencode.h	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,28 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       LPCencode.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_LPCENCOD_H
+   #define __iLBC_LPCENCOD_H
+
+   void LPCencode(
+       float *syntdenum,   /* (i/o) synthesis filter coefficients
+                                  before/after encoding */
+       float *weightdenum, /* (i/o) weighting denumerator coefficients
+                                  before/after encoding */
+       int *lsf_index,     /* (o) lsf quantization index */
+       float *data,    /* (i) lsf coefficients to quantize */
+       iLBC_Enc_Inst_t *iLBCenc_inst
+                           /* (i/o) the encoder state structure */
+   );
+
+   #endif
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/lsf.c asterisk-1.8.3.2_com_amr/codecs/ilbc/lsf.c
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/lsf.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/lsf.c	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,283 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       lsf.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <string.h>
+
+
+
+
+
+   #include <math.h>
+
+   #include "iLBC_define.h"
+
+   /*----------------------------------------------------------------*
+    *  conversion from lpc coefficients to lsf coefficients
+    *---------------------------------------------------------------*/
+
+   void a2lsf(
+       float *freq,/* (o) lsf coefficients */
+       float *a    /* (i) lpc coefficients */
+   ){
+       float steps[LSF_NUMBER_OF_STEPS] =
+           {(float)0.00635, (float)0.003175, (float)0.0015875,
+           (float)0.00079375};
+       float step;
+       int step_idx;
+       int lsp_index;
+       float p[LPC_HALFORDER];
+       float q[LPC_HALFORDER];
+       float p_pre[LPC_HALFORDER];
+       float q_pre[LPC_HALFORDER];
+       float old_p, old_q, *old;
+       float *pq_coef;
+       float omega, old_omega;
+       int i;
+       float hlp, hlp1, hlp2, hlp3, hlp4, hlp5;
+
+       for (i=0; i<LPC_HALFORDER; i++) {
+           p[i] = (float)-1.0 * (a[i + 1] + a[LPC_FILTERORDER - i]);
+           q[i] = a[LPC_FILTERORDER - i] - a[i + 1];
+       }
+
+       p_pre[0] = (float)-1.0 - p[0];
+       p_pre[1] = - p_pre[0] - p[1];
+       p_pre[2] = - p_pre[1] - p[2];
+       p_pre[3] = - p_pre[2] - p[3];
+       p_pre[4] = - p_pre[3] - p[4];
+       p_pre[4] = p_pre[4] / 2;
+
+       q_pre[0] = (float)1.0 - q[0];
+       q_pre[1] = q_pre[0] - q[1];
+       q_pre[2] = q_pre[1] - q[2];
+       q_pre[3] = q_pre[2] - q[3];
+       q_pre[4] = q_pre[3] - q[4];
+       q_pre[4] = q_pre[4] / 2;
+
+       omega = 0.0;
+
+
+
+
+
+       old_omega = 0.0;
+
+       old_p = FLOAT_MAX;
+       old_q = FLOAT_MAX;
+
+       /* Here we loop through lsp_index to find all the
+          LPC_FILTERORDER roots for omega. */
+
+       for (lsp_index = 0; lsp_index<LPC_FILTERORDER; lsp_index++) {
+
+           /* Depending on lsp_index being even or odd, we
+           alternatively solve the roots for the two LSP equations. */
+
+
+           if ((lsp_index & 0x1) == 0) {
+               pq_coef = p_pre;
+               old = &old_p;
+           } else {
+               pq_coef = q_pre;
+               old = &old_q;
+           }
+
+           /* Start with low resolution grid */
+
+           for (step_idx = 0, step = steps[step_idx];
+               step_idx < LSF_NUMBER_OF_STEPS;){
+
+               /*  cos(10piw) + pq(0)cos(8piw) + pq(1)cos(6piw) +
+               pq(2)cos(4piw) + pq(3)cod(2piw) + pq(4) */
+
+               hlp = (float)cos(omega * TWO_PI);
+               hlp1 = (float)2.0 * hlp + pq_coef[0];
+               hlp2 = (float)2.0 * hlp * hlp1 - (float)1.0 +
+                   pq_coef[1];
+               hlp3 = (float)2.0 * hlp * hlp2 - hlp1 + pq_coef[2];
+               hlp4 = (float)2.0 * hlp * hlp3 - hlp2 + pq_coef[3];
+               hlp5 = hlp * hlp4 - hlp3 + pq_coef[4];
+
+
+               if (((hlp5 * (*old)) <= 0.0) || (omega >= 0.5)){
+
+                   if (step_idx == (LSF_NUMBER_OF_STEPS - 1)){
+
+                       if (fabs(hlp5) >= fabs(*old)) {
+                           freq[lsp_index] = omega - step;
+                       } else {
+                           freq[lsp_index] = omega;
+                       }
+
+
+
+
+
+
+
+                       if ((*old) >= 0.0){
+                           *old = (float)-1.0 * FLOAT_MAX;
+                       } else {
+                           *old = FLOAT_MAX;
+                       }
+
+                       omega = old_omega;
+                       step_idx = 0;
+
+                       step_idx = LSF_NUMBER_OF_STEPS;
+                   } else {
+
+                       if (step_idx == 0) {
+                           old_omega = omega;
+                       }
+
+                       step_idx++;
+                       omega -= steps[step_idx];
+
+                       /* Go back one grid step */
+
+                       step = steps[step_idx];
+                   }
+               } else {
+
+               /* increment omega until they are of different sign,
+               and we know there is at least one root between omega
+               and old_omega */
+                   *old = hlp5;
+                   omega += step;
+               }
+           }
+       }
+
+       for (i = 0; i<LPC_FILTERORDER; i++) {
+           freq[i] = freq[i] * TWO_PI;
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  conversion from lsf coefficients to lpc coefficients
+    *---------------------------------------------------------------*/
+
+   void lsf2a(
+       float *a_coef,  /* (o) lpc coefficients */
+       float *freq     /* (i) lsf coefficients */
+
+
+
+
+
+   ){
+       int i, j;
+       float hlp;
+       float p[LPC_HALFORDER], q[LPC_HALFORDER];
+       float a[LPC_HALFORDER + 1], a1[LPC_HALFORDER],
+           a2[LPC_HALFORDER];
+       float b[LPC_HALFORDER + 1], b1[LPC_HALFORDER],
+           b2[LPC_HALFORDER];
+
+       for (i=0; i<LPC_FILTERORDER; i++) {
+           freq[i] = freq[i] * PI2;
+       }
+
+       /* Check input for ill-conditioned cases.  This part is not
+       found in the TIA standard.  It involves the following 2 IF
+       blocks.  If "freq" is judged ill-conditioned, then we first
+       modify freq[0] and freq[LPC_HALFORDER-1] (normally
+       LPC_HALFORDER = 10 for LPC applications), then we adjust
+       the other "freq" values slightly */
+
+
+       if ((freq[0] <= 0.0) || (freq[LPC_FILTERORDER - 1] >= 0.5)){
+
+
+           if (freq[0] <= 0.0) {
+               freq[0] = (float)0.022;
+           }
+
+
+           if (freq[LPC_FILTERORDER - 1] >= 0.5) {
+               freq[LPC_FILTERORDER - 1] = (float)0.499;
+           }
+
+           hlp = (freq[LPC_FILTERORDER - 1] - freq[0]) /
+               (float) (LPC_FILTERORDER - 1);
+
+           for (i=1; i<LPC_FILTERORDER; i++) {
+               freq[i] = freq[i - 1] + hlp;
+           }
+       }
+
+       memset(a1, 0, LPC_HALFORDER*sizeof(float));
+       memset(a2, 0, LPC_HALFORDER*sizeof(float));
+       memset(b1, 0, LPC_HALFORDER*sizeof(float));
+       memset(b2, 0, LPC_HALFORDER*sizeof(float));
+       memset(a, 0, (LPC_HALFORDER+1)*sizeof(float));
+       memset(b, 0, (LPC_HALFORDER+1)*sizeof(float));
+
+
+
+
+
+
+       /* p[i] and q[i] compute cos(2*pi*omega_{2j}) and
+       cos(2*pi*omega_{2j-1} in eqs. 4.2.2.2-1 and 4.2.2.2-2.
+       Note that for this code p[i] specifies the coefficients
+       used in .Q_A(z) while q[i] specifies the coefficients used
+       in .P_A(z) */
+
+       for (i=0; i<LPC_HALFORDER; i++) {
+           p[i] = (float)cos(TWO_PI * freq[2 * i]);
+           q[i] = (float)cos(TWO_PI * freq[2 * i + 1]);
+       }
+
+       a[0] = 0.25;
+       b[0] = 0.25;
+
+       for (i= 0; i<LPC_HALFORDER; i++) {
+           a[i + 1] = a[i] - 2 * p[i] * a1[i] + a2[i];
+           b[i + 1] = b[i] - 2 * q[i] * b1[i] + b2[i];
+           a2[i] = a1[i];
+           a1[i] = a[i];
+           b2[i] = b1[i];
+           b1[i] = b[i];
+       }
+
+       for (j=0; j<LPC_FILTERORDER; j++) {
+
+           if (j == 0) {
+               a[0] = 0.25;
+               b[0] = -0.25;
+           } else {
+               a[0] = b[0] = 0.0;
+           }
+
+           for (i=0; i<LPC_HALFORDER; i++) {
+               a[i + 1] = a[i] - 2 * p[i] * a1[i] + a2[i];
+               b[i + 1] = b[i] - 2 * q[i] * b1[i] + b2[i];
+               a2[i] = a1[i];
+               a1[i] = a[i];
+               b2[i] = b1[i];
+               b1[i] = b[i];
+           }
+
+           a_coef[j + 1] = 2 * (a[LPC_HALFORDER] + b[LPC_HALFORDER]);
+       }
+
+       a_coef[0] = 1.0;
+   }
+
+
+
+
+
+
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/lsf.h asterisk-1.8.3.2_com_amr/codecs/ilbc/lsf.h
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/lsf.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/lsf.h	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,27 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       lsf.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_LSF_H
+   #define __iLBC_LSF_H
+
+   void a2lsf(
+       float *freq,/* (o) lsf coefficients */
+       float *a    /* (i) lpc coefficients */
+   );
+
+   void lsf2a(
+       float *a_coef,  /* (o) lpc coefficients */
+       float *freq     /* (i) lsf coefficients */
+   );
+
+   #endif
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/packing.c asterisk-1.8.3.2_com_amr/codecs/ilbc/packing.c
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/packing.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/packing.c	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,182 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       packing.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <math.h>
+   #include <stdlib.h>
+
+   #include "iLBC_define.h"
+   #include "constants.h"
+   #include "helpfun.h"
+   #include "string.h"
+
+   /*----------------------------------------------------------------*
+    *  splitting an integer into first most significant bits and
+    *  remaining least significant bits
+    *---------------------------------------------------------------*/
+
+   void packsplit(
+       int *index,                 /* (i) the value to split */
+       int *firstpart,             /* (o) the value specified by most
+                                          significant bits */
+       int *rest,                  /* (o) the value specified by least
+                                          significant bits */
+
+
+
+
+
+       int bitno_firstpart,    /* (i) number of bits in most
+                                          significant part */
+       int bitno_total             /* (i) number of bits in full range
+                                          of value */
+   ){
+       int bitno_rest = bitno_total-bitno_firstpart;
+
+       *firstpart = *index>>(bitno_rest);
+       *rest = *index-(*firstpart<<(bitno_rest));
+   }
+
+   /*----------------------------------------------------------------*
+    *  combining a value corresponding to msb's with a value
+    *  corresponding to lsb's
+    *---------------------------------------------------------------*/
+
+   void packcombine(
+       int *index,                 /* (i/o) the msb value in the
+                                          combined value out */
+       int rest,                   /* (i) the lsb value */
+       int bitno_rest              /* (i) the number of bits in the
+                                          lsb part */
+   ){
+       *index = *index<<bitno_rest;
+       *index += rest;
+   }
+
+   /*----------------------------------------------------------------*
+    *  packing of bits into bitstream, i.e., vector of bytes
+    *---------------------------------------------------------------*/
+
+   void dopack(
+       unsigned char **bitstream,  /* (i/o) on entrance pointer to
+                                          place in bitstream to pack
+                                          new data, on exit pointer
+                                          to place in bitstream to
+                                          pack future data */
+       int index,                  /* (i) the value to pack */
+       int bitno,                  /* (i) the number of bits that the
+                                          value will fit within */
+       int *pos                /* (i/o) write position in the
+                                          current byte */
+   ){
+       int posLeft;
+
+       /* Clear the bits before starting in a new byte */
+
+       if ((*pos)==0) {
+
+
+
+
+
+           **bitstream=0;
+       }
+
+       while (bitno>0) {
+
+           /* Jump to the next byte if end of this byte is reached*/
+
+           if (*pos==8) {
+               *pos=0;
+               (*bitstream)++;
+               **bitstream=0;
+           }
+
+           posLeft=8-(*pos);
+
+           /* Insert index into the bitstream */
+
+           if (bitno <= posLeft) {
+               **bitstream |= (unsigned char)(index<<(posLeft-bitno));
+               *pos+=bitno;
+               bitno=0;
+           } else {
+               **bitstream |= (unsigned char)(index>>(bitno-posLeft));
+
+               *pos=8;
+               index-=((index>>(bitno-posLeft))<<(bitno-posLeft));
+
+               bitno-=posLeft;
+           }
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  unpacking of bits from bitstream, i.e., vector of bytes
+    *---------------------------------------------------------------*/
+
+   void unpack(
+       unsigned char **bitstream,  /* (i/o) on entrance pointer to
+                                          place in bitstream to
+                                          unpack new data from, on
+                                          exit pointer to place in
+                                          bitstream to unpack future
+                                          data from */
+       int *index,                 /* (o) resulting value */
+       int bitno,                  /* (i) number of bits used to
+                                          represent the value */
+       int *pos                /* (i/o) read position in the
+                                          current byte */
+
+
+
+
+
+   ){
+       int BitsLeft;
+
+       *index=0;
+
+       while (bitno>0) {
+
+           /* move forward in bitstream when the end of the
+              byte is reached */
+
+           if (*pos==8) {
+               *pos=0;
+               (*bitstream)++;
+           }
+
+           BitsLeft=8-(*pos);
+
+           /* Extract bits to index */
+
+           if (BitsLeft>=bitno) {
+               *index+=((((**bitstream)<<(*pos)) & 0xFF)>>(8-bitno));
+
+               *pos+=bitno;
+               bitno=0;
+           } else {
+
+               if ((8-bitno)>0) {
+                   *index+=((((**bitstream)<<(*pos)) & 0xFF)>>
+                       (8-bitno));
+                   *pos=8;
+               } else {
+                   *index+=(((int)(((**bitstream)<<(*pos)) & 0xFF))<<
+                       (bitno-8));
+                   *pos=8;
+               }
+               bitno-=BitsLeft;
+           }
+       }
+   }
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/packing.h asterisk-1.8.3.2_com_amr/codecs/ilbc/packing.h
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/packing.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/packing.h	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,68 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       packing.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __PACKING_H
+   #define __PACKING_H
+
+   void packsplit(
+       int *index,                 /* (i) the value to split */
+       int *firstpart,             /* (o) the value specified by most
+                                          significant bits */
+       int *rest,                  /* (o) the value specified by least
+                                          significant bits */
+       int bitno_firstpart,    /* (i) number of bits in most
+                                          significant part */
+       int bitno_total             /* (i) number of bits in full range
+                                          of value */
+   );
+
+   void packcombine(
+       int *index,                 /* (i/o) the msb value in the
+                                          combined value out */
+       int rest,                   /* (i) the lsb value */
+       int bitno_rest              /* (i) the number of bits in the
+                                          lsb part */
+   );
+
+   void dopack(
+       unsigned char **bitstream,  /* (i/o) on entrance pointer to
+                                          place in bitstream to pack
+                                          new data, on exit pointer
+                                          to place in bitstream to
+                                          pack future data */
+       int index,                  /* (i) the value to pack */
+       int bitno,                  /* (i) the number of bits that the
+                                          value will fit within */
+       int *pos                /* (i/o) write position in the
+                                          current byte */
+   );
+
+
+
+
+
+   void unpack(
+       unsigned char **bitstream,  /* (i/o) on entrance pointer to
+                                          place in bitstream to
+                                          unpack new data from, on
+                                          exit pointer to place in
+                                          bitstream to unpack future
+                                          data from */
+       int *index,                 /* (o) resulting value */
+       int bitno,                  /* (i) number of bits used to
+                                          represent the value */
+       int *pos                /* (i/o) read position in the
+                                          current byte */
+   );
+
+   #endif
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/rfc3951.txt asterisk-1.8.3.2_com_amr/codecs/ilbc/rfc3951.txt
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/rfc3951.txt	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/rfc3951.txt	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,10867 @@
+
+
+
+
+
+
+Network Working Group                                        S. Andersen
+Request for Comments: 3951                            Aalborg University
+Category: Experimental                                          A. Duric
+                                                                   Telio
+                                                               H. Astrom
+                                                                R. Hagen
+                                                               W. Kleijn
+                                                               J. Linden
+                                                         Global IP Sound
+                                                           December 2004
+
+
+                   Internet Low Bit Rate Codec (iLBC)
+
+Status of this Memo
+
+   This memo defines an Experimental Protocol for the Internet
+   community.  It does not specify an Internet standard of any kind.
+   Discussion and suggestions for improvement are requested.
+   Distribution of this memo is unlimited.
+
+Copyright Notice
+
+   Copyright (C) The Internet Society (2004).
+
+Abstract
+
+   This document specifies a speech codec suitable for robust voice
+   communication over IP.  The codec is developed by Global IP Sound
+   (GIPS).  It is designed for narrow band speech and results in a
+   payload bit rate of 13.33 kbit/s for 30 ms frames and 15.20 kbit/s
+   for 20 ms frames.  The codec enables graceful speech quality
+   degradation in the case of lost frames, which occurs in connection
+   with lost or delayed IP packets.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Andersen, et al.              Experimental                      [Page 1]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+Table of Contents
+
+   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4
+   2.  Outline of the Codec . . . . . . . . . . . . . . . . . . . . .  5
+       2.1.  Encoder. . . . . . . . . . . . . . . . . . . . . . . . .  5
+       2.2.  Decoder. . . . . . . . . . . . . . . . . . . . . . . . .  7
+   3.  Encoder Principles . . . . . . . . . . . . . . . . . . . . . .  7
+       3.1.  Pre-processing . . . . . . . . . . . . . . . . . . . . .  9
+       3.2.  LPC Analysis and Quantization. . . . . . . . . . . . . .  9
+             3.2.1.  Computation of Autocorrelation Coefficients. . . 10
+             3.2.2.  Computation of LPC Coefficients. . . . . . . . . 11
+             3.2.3.  Computation of LSF Coefficients from LPC
+                     Coefficients . . . . . . . . . . . . . . . . . . 11
+             3.2.4.  Quantization of LSF Coefficients . . . . . . . . 12
+             3.2.5.  Stability Check of LSF Coefficients. . . . . . . 13
+             3.2.6.  Interpolation of LSF Coefficients. . . . . . . . 13
+             3.2.7.  LPC Analysis and Quantization for 20 ms Frames . 14
+       3.3.  Calculation of the Residual. . . . . . . . . . . . . . . 15
+       3.4.  Perceptual Weighting Filter. . . . . . . . . . . . . . . 15
+       3.5.  Start State Encoder. . . . . . . . . . . . . . . . . . . 15
+             3.5.1.  Start State Estimation . . . . . . . . . . . . . 16
+             3.5.2.  All-Pass Filtering and Scale Quantization. . . . 17
+             3.5.3.  Scalar Quantization. . . . . . . . . . . . . . . 18
+       3.6.  Encoding the Remaining Samples . . . . . . . . . . . . . 19
+             3.6.1.  Codebook Memory. . . . . . . . . . . . . . . . . 20
+             3.6.2.  Perceptual Weighting of Codebook Memory
+                     and Target . . . . . . . . . . . . . . . . . . . 22
+             3.6.3.  Codebook Creation. . . . . . . . . . . . . . . . 23
+                     3.6.3.1. Creation of a Base Codebook . . . . . . 23
+                     3.6.3.2. Codebook Expansion. . . . . . . . . . . 24
+                     3.6.3.3. Codebook Augmentation . . . . . . . . . 24
+             3.6.4.  Codebook Search. . . . . . . . . . . . . . . . . 26
+                     3.6.4.1. Codebook Search at Each Stage . . . . . 26
+                     3.6.4.2. Gain Quantization at Each Stage . . . . 27
+                     3.6.4.3. Preparation of Target for Next Stage. . 28
+       3.7.  Gain Correction Encoding . . . . . . . . . . . . . . . . 28
+       3.8.  Bitstream Definition . . . . . . . . . . . . . . . . . . 29
+   4.  Decoder Principles . . . . . . . . . . . . . . . . . . . . . . 32
+       4.1.  LPC Filter Reconstruction. . . . . . . . . . . . . . . . 33
+       4.2.  Start State Reconstruction . . . . . . . . . . . . . . . 33
+       4.3.  Excitation Decoding Loop . . . . . . . . . . . . . . . . 34
+       4.4.  Multistage Adaptive Codebook Decoding. . . . . . . . . . 35
+             4.4.1.  Construction of the Decoded Excitation Signal. . 35
+       4.5.  Packet Loss Concealment. . . . . . . . . . . . . . . . . 35
+             4.5.1.  Block Received Correctly and Previous Block
+                     Also Received. . . . . . . . . . . . . . . . . . 35
+             4.5.2.  Block Not Received . . . . . . . . . . . . . . . 36
+
+
+
+
+Andersen, et al.              Experimental                      [Page 2]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+             4.5.3.  Block Received Correctly When Previous Block
+                     Not Received . . . . . . . . . . . . . . . . . . 36
+       4.6.  Enhancement. . . . . . . . . . . . . . . . . . . . . . . 37
+             4.6.1.  Estimating the Pitch . . . . . . . . . . . . . . 39
+             4.6.2.  Determination of the Pitch-Synchronous
+                     Sequences. . . . . . . . . . . . . . . . . . . . 39
+             4.6.3.  Calculation of the Smoothed Excitation . . . . . 41
+             4.6.4.  Enhancer Criterion . . . . . . . . . . . . . . . 41
+             4.6.5.  Enhancing the Excitation . . . . . . . . . . . . 42
+       4.7.  Synthesis Filtering. . . . . . . . . . . . . . . . . . . 43
+       4.8.  Post Filtering . . . . . . . . . . . . . . . . . . . . . 43
+   5.  Security Considerations. . . . . . . . . . . . . . . . . . . . 43
+   6.  Evaluation of the iLBC Implementations . . . . . . . . . . . . 43
+   7.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 43
+       7.1.  Normative References . . . . . . . . . . . . . . . . . . 43
+       7.2.  Informative References . . . . . . . . . . . . . . . . . 44
+   8.  ACKNOWLEDGEMENTS . . . . . . . . . . . . . . . . . . . . . . . 44
+   APPENDIX A: Reference Implementation . . . . . . . . . . . . . . . 45
+       A.1.  iLBC_test.c. . . . . . . . . . . . . . . . . . . . . . . 46
+       A.2   iLBC_encode.h. . . . . . . . . . . . . . . . . . . . . . 52
+       A.3.  iLBC_encode.c. . . . . . . . . . . . . . . . . . . . . . 53
+       A.4.  iLBC_decode.h. . . . . . . . . . . . . . . . . . . . . . 63
+       A.5.  iLBC_decode.c. . . . . . . . . . . . . . . . . . . . . . 64
+       A.6.  iLBC_define.h. . . . . . . . . . . . . . . . . . . . . . 76
+       A.7.  constants.h. . . . . . . . . . . . . . . . . . . . . . . 80
+       A.8.  constants.c. . . . . . . . . . . . . . . . . . . . . . . 82
+       A.9.  anaFilter.h. . . . . . . . . . . . . . . . . . . . . . . 96
+       A.10. anaFilter.c. . . . . . . . . . . . . . . . . . . . . . . 97
+       A.11. createCB.h . . . . . . . . . . . . . . . . . . . . . . . 98
+       A.12. createCB.c . . . . . . . . . . . . . . . . . . . . . . . 99
+       A.13. doCPLC.h . . . . . . . . . . . . . . . . . . . . . . . .104
+       A.14. doCPLC.c . . . . . . . . . . . . . . . . . . . . . . . .104
+       A.15. enhancer.h . . . . . . . . . . . . . . . . . . . . . . .109
+       A.16. enhancer.c . . . . . . . . . . . . . . . . . . . . . . .110
+       A.17. filter.h . . . . . . . . . . . . . . . . . . . . . . . .123
+       A.18. filter.c . . . . . . . . . . . . . . . . . . . . . . . .125
+       A.19. FrameClassify.h. . . . . . . . . . . . . . . . . . . . .128
+       A.20. FrameClassify.c. . . . . . . . . . . . . . . . . . . . .129
+       A.21. gainquant.h. . . . . . . . . . . . . . . . . . . . . . .131
+       A.22. gainquant.c. . . . . . . . . . . . . . . . . . . . . . .131
+       A.23. getCBvec.h . . . . . . . . . . . . . . . . . . . . . . .134
+       A.24. getCBvec.c . . . . . . . . . . . . . . . . . . . . . . .134
+       A.25. helpfun.h. . . . . . . . . . . . . . . . . . . . . . . .138
+       A.26. helpfun.c. . . . . . . . . . . . . . . . . . . . . . . .140
+       A.27. hpInput.h. . . . . . . . . . . . . . . . . . . . . . . .146
+       A.28. hpInput.c. . . . . . . . . . . . . . . . . . . . . . . .146
+       A.29. hpOutput.h . . . . . . . . . . . . . . . . . . . . . . .148
+       A.30. hpOutput.c . . . . . . . . . . . . . . . . . . . . . . .148
+
+
+
+Andersen, et al.              Experimental                      [Page 3]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       A.31. iCBConstruct.h . . . . . . . . . . . . . . . . . . . . .149
+       A.32. iCBConstruct.c . . . . . . . . . . . . . . . . . . . . .150
+       A.33. iCBSearch.h. . . . . . . . . . . . . . . . . . . . . . .152
+       A.34. iCBSearch.c. . . . . . . . . . . . . . . . . . . . . . .153
+       A.35. LPCdecode.h. . . . . . . . . . . . . . . . . . . . . . .163
+       A.36. LPCdecode.c. . . . . . . . . . . . . . . . . . . . . . .164
+       A.37. LPCencode.h. . . . . . . . . . . . . . . . . . . . . . .167
+       A.38. LPCencode.c. . . . . . . . . . . . . . . . . . . . . . .167
+       A.39. lsf.h. . . . . . . . . . . . . . . . . . . . . . . . . .172
+       A.40. lsf.c. . . . . . . . . . . . . . . . . . . . . . . . . .172
+       A.41. packing.h. . . . . . . . . . . . . . . . . . . . . . . .178
+       A.42. packing.c. . . . . . . . . . . . . . . . . . . . . . . .179
+       A.43. StateConstructW.h. . . . . . . . . . . . . . . . . . . .182
+       A.44. StateConstructW.c. . . . . . . . . . . . . . . . . . . .183
+       A.45. StateSearchW.h . . . . . . . . . . . . . . . . . . . . .185
+       A.46. StateSearchW.c . . . . . . . . . . . . . . . . . . . . .186
+       A.47. syntFilter.h . . . . . . . . . . . . . . . . . . . . . .190
+       A.48. syntFilter.c . . . . . . . . . . . . . . . . . . . . . .190
+   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . .192
+   Full Copyright Statement . . . . . . . . . . . . . . . . . . . . .194
+
+1.  Introduction
+
+   This document contains the description of an algorithm for the coding
+   of speech signals sampled at 8 kHz.  The algorithm, called iLBC, uses
+   a block-independent linear-predictive coding (LPC) algorithm and has
+   support for two basic frame lengths: 20 ms at 15.2 kbit/s and 30 ms
+   at 13.33 kbit/s.  When the codec operates at block lengths of 20 ms,
+   it produces 304 bits per block, which SHOULD be packetized as in [1].
+   Similarly, for block lengths of 30 ms it produces 400 bits per block,
+   which SHOULD be packetized as in [1].  The two modes for the
+   different frame sizes operate in a very similar way.  When they
+   differ it is explicitly stated in the text, usually with the notation
+   x/y, where x refers to the 20 ms mode and y refers to the 30 ms mode.
+
+   The described algorithm results in a speech coding system with a
+   controlled response to packet losses similar to what is known from
+   pulse code modulation (PCM) with packet loss concealment (PLC), such
+   as the ITU-T G.711 standard [4], which operates at a fixed bit rate
+   of 64 kbit/s.  At the same time, the described algorithm enables
+   fixed bit rate coding with a quality-versus-bit rate tradeoff close
+   to state-of-the-art.  A suitable RTP payload format for the iLBC
+   codec is specified in [1].
+
+   Some of the applications for which this coder is suitable are real
+   time communications such as telephony and videoconferencing,
+   streaming audio, archival, and messaging.
+
+
+
+
+Andersen, et al.              Experimental                      [Page 4]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   Cable Television Laboratories (CableLabs(R)) has adopted iLBC as a
+   mandatory PacketCable(TM) audio codec standard for VoIP over Cable
+   applications [3].
+
+   This document is organized as follows.  Section 2 gives a brief
+   outline of the codec.  The specific encoder and decoder algorithms
+   are explained in sections 3 and 4, respectively.  Appendix A provides
+   a c-code reference implementation.
+
+   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
+   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
+   document are to be interpreted as described in BCP 14, RFC 2119 [2].
+
+2.  Outline of the Codec
+
+   The codec consists of an encoder and a decoder as described in
+   sections 2.1 and 2.2, respectively.
+
+   The essence of the codec is LPC and block-based coding of the LPC
+   residual signal.  For each 160/240 (20 ms/30 ms) sample block, the
+   following major steps are performed: A set of LPC filters are
+   computed, and the speech signal is filtered through them to produce
+   the residual signal.  The codec uses scalar quantization of the
+   dominant part, in terms of energy, of the residual signal for the
+   block.  The dominant state is of length 57/58 (20 ms/30 ms) samples
+   and forms a start state for dynamic codebooks constructed from the
+   already coded parts of the residual signal.  These dynamic codebooks
+   are used to code the remaining parts of the residual signal.  By this
+   method, coding independence between blocks is achieved, resulting in
+   elimination of propagation of perceptual degradations due to packet
+   loss.  The method facilitates high-quality packet loss concealment
+   (PLC).
+
+2.1.  Encoder
+
+   The input to the encoder SHOULD be 16 bit uniform PCM sampled at 8
+   kHz.  It SHOULD be partitioned into blocks of BLOCKL=160/240 samples
+   for the 20/30 ms frame size.  Each block is divided into NSUB=4/6
+   consecutive sub-blocks of SUBL=40 samples each.  For 30 ms frame
+   size, the encoder performs two LPC_FILTERORDER=10 linear-predictive
+   coding (LPC) analyses.  The first analysis applies a smooth window
+   centered over the second sub-block and extending to the middle of the
+   fifth sub-block.  The second LPC analysis applies a smooth asymmetric
+   window centered over the fifth sub-block and extending to the end of
+   the sixth sub-block.  For 20 ms frame size, one LPC_FILTERORDER=10
+   linear-predictive coding (LPC) analysis is performed with a smooth
+   window centered over the third sub-frame.
+
+
+
+
+Andersen, et al.              Experimental                      [Page 5]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   For each of the LPC analyses, a set of line-spectral frequencies
+   (LSFs) are obtained, quantized, and interpolated to obtain LSF
+   coefficients for each sub-block.  Subsequently, the LPC residual is
+   computed by using the quantized and interpolated LPC analysis
+   filters.
+
+   The two consecutive sub-blocks of the residual exhibiting the maximal
+   weighted energy are identified.  Within these two sub-blocks, the
+   start state (segment) is selected from two choices: the first 57/58
+   samples or the last 57/58 samples of the two consecutive sub-blocks.
+   The selected segment is the one of higher energy.  The start state is
+   encoded with scalar quantization.
+
+   A dynamic codebook encoding procedure is used to encode 1) the 23/22
+   (20 ms/30 ms) remaining samples in the two sub-blocks containing the
+   start state; 2) the sub-blocks after the start state in time; and 3)
+   the sub-blocks before the start state in time.  Thus, the encoding
+   target can be either the 23/22 samples remaining of the two sub-
+   blocks containing the start state or a 40-sample sub-block.  This
+   target can consist of samples indexed forward in time or backward in
+   time, depending on the location of the start state.
+
+   The codebook coding is based on an adaptive codebook built from a
+   codebook memory that contains decoded LPC excitation samples from the
+   already encoded part of the block.  These samples are indexed in the
+   same time direction as the target vector, ending at the sample
+   instant prior to the first sample instant represented in the target
+   vector.  The codebook is used in CB_NSTAGES=3 stages in a successive
+   refinement approach, and the resulting three code vector gains are
+   encoded with 5-, 4-, and 3-bit scalar quantization, respectively.
+
+   The codebook search method employs noise shaping derived from the LPC
+   filters, and the main decision criterion is to minimize the squared
+   error between the target vector and the code vectors.  Each code
+   vector in this codebook comes from one of CB_EXPAND=2 codebook
+   sections.  The first section is filled with delayed, already encoded
+   residual vectors.  The code vectors of the second codebook section
+   are constructed by predefined linear combinations of vectors in the
+   first section of the codebook.
+
+   As codebook encoding with squared-error matching is known to produce
+   a coded signal of less power than does the scalar quantized start
+   state signal, a gain re-scaling method is implemented by a refined
+   search for a better set of codebook gains in terms of power matching
+   after encoding.  This is done by searching for a higher value of the
+   gain factor for the first stage codebook, as the subsequent stage
+   codebook gains are scaled by the first stage gain.
+
+
+
+
+Andersen, et al.              Experimental                      [Page 6]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+2.2.  Decoder
+
+   Typically for packet communications, a jitter buffer placed at the
+   receiving end decides whether the packet containing an encoded signal
+   block has been received or lost.  This logic is not part of the codec
+   described here.  For each encoded signal block received the decoder
+   performs a decoding.  For each lost signal block, the decoder
+   performs a PLC operation.
+
+   The decoding for each block starts by decoding and interpolating the
+   LPC coefficients.  Subsequently the start state is decoded.
+
+   For codebook-encoded segments, each segment is decoded by
+   constructing the three code vectors given by the received codebook
+   indices in the same way that the code vectors were constructed in the
+   encoder.  The three gain factors are also decoded and the resulting
+   decoded signal is given by the sum of the three codebook vectors
+   scaled with respective gain.
+
+   An enhancement algorithm is applied to the reconstructed excitation
+   signal.  This enhancement augments the periodicity of voiced speech
+   regions.  The enhancement is optimized under the constraint that the
+   modification signal (defined as the difference between the enhanced
+   excitation and the excitation signal prior to enhancement) has a
+   short-time energy that does not exceed a preset fraction of the
+   short-time energy of the excitation signal prior to enhancement.
+
+   A packet loss concealment (PLC) operation is easily embedded in the
+   decoder.  The PLC operation can, e.g., be based on repeating LPC
+   filters and obtaining the LPC residual signal by using a long-term
+   prediction estimate from previous residual blocks.
+
+3.  Encoder Principles
+
+   The following block diagram is an overview of all the components of
+   the iLBC encoding procedure.  The description of the blocks contains
+   references to the section where that particular procedure is further
+   described.
+
+
+
+
+
+
+
+
+
+
+
+
+
+Andersen, et al.              Experimental                      [Page 7]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+             +-----------+    +---------+    +---------+
+   speech -> | 1. Pre P  | -> | 2. LPC  | -> | 3. Ana  | ->
+             +-----------+    +---------+    +---------+
+
+             +---------------+   +--------------+
+          -> | 4. Start Sel  | ->| 5. Scalar Qu | ->
+             +---------------+   +--------------+
+
+             +--------------+    +---------------+
+          -> |6. CB Search  | -> | 7. Packetize  | -> payload
+          |  +--------------+ |  +---------------+
+          ----<---------<------
+       sub-frame 0..2/4 (20 ms/30 ms)
+
+   Figure 3.1. Flow chart of the iLBC encoder
+
+   1. Pre-process speech with a HP filter, if needed (section 3.1).
+
+   2. Compute LPC parameters, quantize, and interpolate (section 3.2).
+
+   3. Use analysis filters on speech to compute residual (section 3.3).
+
+   4. Select position of 57/58-sample start state (section 3.5).
+
+   5. Quantize the 57/58-sample start state with scalar quantization
+      (section 3.5).
+
+   6. Search the codebook for each sub-frame.  Start with 23/22 sample
+      block, then encode sub-blocks forward in time, and then encode
+      sub-blocks backward in time.  For each block, the steps in Figure
+      3.4 are performed (section 3.6).
+
+   7. Packetize the bits into the payload specified in Table 3.2.
+
+   The input to the encoder SHOULD be 16-bit uniform PCM sampled at 8
+   kHz.  Also it SHOULD be partitioned into blocks of BLOCKL=160/240
+   samples.  Each block input to the encoder is divided into NSUB=4/6
+   consecutive sub-blocks of SUBL=40 samples each.
+
+
+
+
+
+
+
+
+
+
+
+
+
+Andersen, et al.              Experimental                      [Page 8]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+             0        39        79       119       159
+             +---------------------------------------+
+             |    1    |    2    |    3    |    4    |
+             +---------------------------------------+
+                            20 ms frame
+
+   0        39        79       119       159       199       239
+   +-----------------------------------------------------------+
+   |    1    |    2    |    3    |    4    |    5    |    6    |
+   +-----------------------------------------------------------+
+                                  30 ms frame
+   Figure 3.2. One input block to the encoder for 20 ms (with four sub-
+   frames) and 30 ms (with six sub-frames).
+
+3.1.  Pre-processing
+
+   In some applications, the recorded speech signal contains DC level
+   and/or 50/60 Hz noise.  If these components have not been removed
+   prior to the encoder call, they should be removed by a high-pass
+   filter.  A reference implementation of this, using a filter with a
+   cutoff frequency of 90 Hz, can be found in Appendix A.28.
+
+3.2.  LPC Analysis and Quantization
+
+   The input to the LPC analysis module is a possibly high-pass filtered
+   speech buffer, speech_hp, that contains 240/300 (LPC_LOOKBACK +
+   BLOCKL = 80/60 + 160/240 = 240/300) speech samples, where samples 0
+   through 79/59 are from the previous block and samples 80/60 through
+   239/299 are from the current block.  No look-ahead into the next
+   block is used.  For the very first block processed, the look-back
+   samples are assumed to be zeros.
+
+   For each input block, the LPC analysis calculates one/two set(s) of
+   LPC_FILTERORDER=10 LPC filter coefficients using the autocorrelation
+   method and the Levinson-Durbin recursion.  These coefficients are
+   converted to the Line Spectrum Frequency representation.  In the 20
+   ms case, the single lsf set represents the spectral characteristics
+   as measured at the center of the third sub-block.  For 30 ms frames,
+   the first set, lsf1, represents the spectral properties of the input
+   signal at the center of the second sub-block, and the other set,
+   lsf2, represents the spectral characteristics as measured at the
+   center of the fifth sub-block.  The details of the computation for 30
+   ms frames are described in sections 3.2.1 through 3.2.6.  Section
+   3.2.7 explains how the LPC Analysis and Quantization differs for 20
+   ms frames.
+
+
+
+
+
+
+Andersen, et al.              Experimental                      [Page 9]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+3.2.1.  Computation of Autocorrelation Coefficients
+
+   The first step in the LPC analysis procedure is to calculate
+   autocorrelation coefficients by using windowed speech samples.  This
+   windowing is the only difference in the LPC analysis procedure for
+   the two sets of coefficients.  For the first set, a 240-sample-long
+   standard symmetric Hanning window is applied to samples 0 through 239
+   of the input data.  The first window, lpc_winTbl, is defined as
+
+      lpc_winTbl[i]= 0.5 * (1.0 - cos((2*PI*(i+1))/(BLOCKL+1)));
+               i=0,...,119
+      lpc_winTbl[i] = winTbl[BLOCKL - i - 1]; i=120,...,239
+
+   The windowed speech speech_hp_win1 is then obtained by multiplying
+   the first 240 samples of the input speech buffer with the window
+   coefficients:
+
+      speech_hp_win1[i] = speech_hp[i] * lpc_winTbl[i];
+               i=0,...,BLOCKL-1
+
+   From these 240 windowed speech samples, 11 (LPC_FILTERORDER + 1)
+   autocorrelation coefficients, acf1, are calculated:
+
+      acf1[lag] += speech_hp_win1[n] * speech_hp_win1[n + lag];
+               lag=0,...,LPC_FILTERORDER; n=0,...,BLOCKL-lag-1
+
+   In order to make the analysis more robust against numerical precision
+   problems, a spectral smoothing procedure is applied by windowing the
+   autocorrelation coefficients before the LPC coefficients are
+   computed.  Also, a white noise floor is added to the autocorrelation
+   function by multiplying coefficient zero by 1.0001 (40dB below the
+   energy of the windowed speech signal).  These two steps are
+   implemented by multiplying the autocorrelation coefficients with the
+   following window:
+
+      lpc_lagwinTbl[0] = 1.0001;
+      lpc_lagwinTbl[i] = exp(-0.5 * ((2 * PI * 60.0 * i) /FS)^2);
+               i=1,...,LPC_FILTERORDER
+               where FS=8000 is the sampling frequency
+
+   Then, the windowed acf function acf1_win is obtained by
+
+      acf1_win[i] = acf1[i] * lpc_lagwinTbl[i];
+               i=0,...,LPC_FILTERORDER
+
+   The second set of autocorrelation coefficients, acf2_win, are
+   obtained in a similar manner.  The window, lpc_asymwinTbl, is applied
+   to samples 60 through 299, i.e., the entire current block.  The
+
+
+
+Andersen, et al.              Experimental                     [Page 10]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   window consists of two segments, the first (samples 0 to 219) being
+   half a Hanning window with length 440 and the second a quarter of a
+   cycle of a cosine wave.  By using this asymmetric window, an LPC
+   analysis centered in the fifth sub-block is obtained without the need
+   for any look-ahead, which would add delay.  The asymmetric window is
+   defined as
+
+      lpc_asymwinTbl[i] = (sin(PI * (i + 1) / 441))^2; i=0,...,219
+
+      lpc_asymwinTbl[i] = cos((i - 220) * PI / 40); i=220,...,239
+
+   and the windowed speech is computed by
+
+      speech_hp_win2[i] = speech_hp[i + LPC_LOOKBACK] *
+               lpc_asymwinTbl[i];  i=0,....BLOCKL-1
+
+   The windowed autocorrelation coefficients are then obtained in
+   exactly the same way as for the first analysis instance.
+
+   The generation of the windows lpc_winTbl, lpc_asymwinTbl, and
+   lpc_lagwinTbl are typically done in advance, and the arrays are
+   stored in ROM rather than repeating the calculation for every block.
+
+3.2.2.  Computation of LPC Coefficients
+
+   From the 2 x 11 smoothed autocorrelation coefficients, acf1_win and
+   acf2_win, the 2 x 11 LPC coefficients, lp1 and lp2, are calculated
+   in the same way for both analysis locations by using the well known
+   Levinson-Durbin recursion.  The first LPC coefficient is always 1.0,
+   resulting in ten unique coefficients.
+
+   After determining the LPC coefficients, a bandwidth expansion
+   procedure is applied to smooth the spectral peaks in the
+   short-term spectrum.  The bandwidth addition is obtained by the
+   following modification of the LPC coefficients:
+
+      lp1_bw[i] = lp1[i] * chirp^i; i=0,...,LPC_FILTERORDER
+      lp2_bw[i] = lp2[i] * chirp^i; i=0,...,LPC_FILTERORDER
+
+   where "chirp" is a real number between 0 and 1.  It is RECOMMENDED to
+   use a value of 0.9.
+
+3.2.3.  Computation of LSF Coefficients from LPC Coefficients
+
+   Thus far, two sets of LPC coefficients that represent the short-term
+   spectral characteristics of the speech signal for two different time
+   locations within the current block have been determined.  These
+   coefficients SHOULD be quantized and interpolated.  Before this is
+
+
+
+Andersen, et al.              Experimental                     [Page 11]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   done, it is advantageous to convert the LPC parameters into another
+   type of representation called Line Spectral Frequencies (LSF).  The
+   LSF parameters are used because they are better suited for
+   quantization and interpolation than the regular LPC coefficients.
+   Many computationally efficient methods for calculating the LSFs from
+   the LPC coefficients have been proposed in the literature.  The
+   detailed implementation of one applicable method can be found in
+   Appendix A.26.  The two arrays of LSF coefficients obtained, lsf1 and
+   lsf2, are of dimension 10 (LPC_FILTERORDER).
+
+3.2.4.  Quantization of LSF Coefficients
+
+   Because the LPC filters defined by the two sets of LSFs are also
+   needed in the decoder, the LSF parameters need to be quantized and
+   transmitted as side information.  The total number of bits required
+   to represent the quantization of the two LSF representations for one
+   block of speech is 40, with 20 bits used for each of lsf1 and lsf2.
+
+   For computational and storage reasons, the LSF vectors are quantized
+   using three-split vector quantization (VQ).  That is, the LSF vectors
+   are split into three sub-vectors that are each quantized with a
+   regular VQ.  The quantized versions of lsf1 and lsf2, qlsf1 and
+   qlsf2, are obtained by using the same memoryless split VQ.  The
+   length of each of these two LSF vectors is 10, and they are split
+   into three sub-vectors containing 3, 3, and 4 values, respectively.
+
+   For each of the sub-vectors, a separate codebook of quantized values
+   has been designed with a standard VQ training method for a large
+   database containing speech from a large number of speakers recorded
+   under various conditions.  The size of each of the three codebooks
+   associated with the split definitions above is
+
+      int size_lsfCbTbl[LSF_NSPLIT] = {64,128,128};
+
+   The actual values of the vector quantization codebook that must be
+   used can be found in the reference code of Appendix A.  Both sets of
+   LSF coefficients, lsf1 and lsf2, are quantized with a standard
+   memoryless split vector quantization (VQ) structure using the squared
+   error criterion in the LSF domain.  The split VQ quantization
+   consists of the following steps:
+
+   1) Quantize the first three LSF coefficients (1 - 3) with a VQ
+      codebook of size 64.
+   2) Quantize the next three LSF coefficients 4 - 6 with VQ a codebook
+      of size 128.
+   3) Quantize the last four LSF coefficients (7 - 10) with a VQ
+      codebook of size 128.
+
+
+
+
+Andersen, et al.              Experimental                     [Page 12]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   This procedure, repeated for lsf1 and lsf2, gives six quantization
+   indices and the quantized sets of LSF coefficients qlsf1 and qlsf2.
+   Each set of three indices is encoded with 6 + 7 + 7 = 20 bits.  The
+   total number of bits used for LSF quantization in a block is thus 40
+   bits.
+
+3.2.5.  Stability Check of LSF Coefficients
+
+   The LSF representation of the LPC filter has the convenient property
+   that the coefficients are ordered by increasing value, i.e., lsf(n-1)
+   < lsf(n), 0 < n < 10, if the corresponding synthesis filter is
+   stable.  As we are employing a split VQ scheme, it is possible that
+   at the split boundaries the LSF coefficients are not ordered
+   correctly and hence that the corresponding LP filter is unstable.  To
+   ensure that the filter used is stable, a stability check is performed
+   for the quantized LSF vectors.  If it turns out that the coefficients
+   are not ordered appropriately (with a safety margin of 50 Hz to
+   ensure that formant peaks are not too narrow), they will be moved
+   apart.  The detailed method for this can be found in Appendix A.40.
+   The same procedure is performed in the decoder.  This ensures that
+   exactly the same LSF representations are used in both encoder and
+   decoder.
+
+3.2.6.  Interpolation of LSF Coefficients
+
+   From the two sets of LSF coefficients that are computed for each
+   block of speech, different LSFs are obtained for each sub-block by
+   means of interpolation.  This procedure is performed for the original
+   LSFs (lsf1 and lsf2), as well as the quantized versions qlsf1 and
+   qlsf2, as both versions are used in the encoder.  Here follows a
+   brief summary of the interpolation scheme; the details are found in
+   the c-code of Appendix A.  In the first sub-block, the average of the
+   second LSF vector from the previous block and the first LSF vector in
+   the current block is used.  For sub-blocks two through five, the LSFs
+   used are obtained by linear interpolation from lsf1 (and qlsf1) to
+   lsf2 (and qlsf2), with lsf1 used in sub-block two and lsf2 in sub-
+   block five.  In the last sub-block, lsf2 is used.  For the very first
+   block it is assumed that the last LSF vector of the previous block is
+   equal to a predefined vector, lsfmeanTbl, obtained by calculating the
+   mean LSF vector of the LSF design database.
+
+   lsfmeanTbl[LPC_FILTERORDER] = {0.281738, 0.445801, 0.663330,
+                  0.962524, 1.251831, 1.533081, 1.850586, 2.137817,
+                  2.481445, 2.777344}
+
+
+
+
+
+
+
+Andersen, et al.              Experimental                     [Page 13]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   The interpolation method is standard linear interpolation in the LSF
+   domain.  The interpolated LSF values are converted to LPC
+   coefficients for each sub-block.  The unquantized and quantized LPC
+   coefficients form two sets of filters respectively.  The unquantized
+   analysis filter for sub-block k is defined as follows
+
+                ___
+                \
+      Ak(z)= 1 + > ak(i)*z^(-i)
+                /__
+             i=1...LPC_FILTERORDER
+
+   The quantized analysis filter for sub-block k is defined as follows
+                 ___
+                 \
+      A~k(z)= 1 + > a~k(i)*z^(-i)
+                 /__
+             i=1...LPC_FILTERORDER
+
+   A reference implementation of the lsf encoding is given in Appendix
+   A.38.  A reference implementation of the corresponding decoding can
+   be found in Appendix A.36.
+
+3.2.7.  LPC Analysis and Quantization for 20 ms Frames
+
+   As previously stated, the codec only calculates one set of LPC
+   parameters for the 20 ms frame size as opposed to two sets for 30 ms
+   frames.  A single set of autocorrelation coefficients is calculated
+   on the LPC_LOOKBACK + BLOCKL = 80 + 160 = 240 samples.  These samples
+   are windowed with the asymmetric window lpc_asymwinTbl, centered over
+   the third sub-frame, to form speech_hp_win.  Autocorrelation
+   coefficients, acf, are calculated on the 240 samples in speech_hp_win
+   and then windowed exactly as in section 3.2.1 (resulting in
+   acf_win).
+
+   This single set of windowed autocorrelation coefficients is used to
+   calculate LPC coefficients, LSF coefficients, and quantized LSF
+   coefficients in exactly the same manner as in sections 3.2.3 through
+   3.2.4.  As for the 30 ms frame size, the ten LSF coefficients are
+   divided into three sub-vectors of size 3, 3, and 4 and quantized by
+   using the same scheme and codebook as in section 3.2.4 to finally get
+   3 quantization indices.  The quantized LSF coefficients are
+   stabilized with the algorithm described in section 3.2.5.
+
+   From the set of LSF coefficients computed for this block and those
+   from the previous block, different LSFs are obtained for each sub-
+   block by means of interpolation.  The interpolation is done linearly
+   in the LSF domain over the four sub-blocks, so that the n-th sub-
+
+
+
+Andersen, et al.              Experimental                     [Page 14]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   frame uses the weight (4-n)/4 for the LSF from old frame and the
+   weight n/4 of the LSF from the current frame.  For the very first
+   block the mean LSF, lsfmeanTbl, is used as the LSF from the previous
+   block.  Similarly as seen in section 3.2.6, both unquantized, A(z),
+   and quantized, A~(z), analysis filters are calculated for each of the
+   four sub-blocks.
+
+3.3.  Calculation of the Residual
+
+   The block of speech samples is filtered by the quantized and
+   interpolated LPC analysis filters to yield the residual signal.  In
+   particular, the corresponding LPC analysis filter for each 40 sample
+   sub-block is used to filter the speech samples for the same sub-
+   block.  The filter memory at the end of each sub-block is carried
+   over to the LPC filter of the next sub-block.  The signal at the
+   output of each LP analysis filter constitutes the residual signal for
+   the corresponding sub-block.
+
+   A reference implementation of the LPC analysis filters is given in
+   Appendix A.10.
+
+3.4.  Perceptual Weighting Filter
+
+   In principle any good design of a perceptual weighting filter can be
+   applied in the encoder without compromising this codec definition.
+   However, it is RECOMMENDED to use the perceptual weighting filter Wk
+   for sub-block k specified below:
+
+      Wk(z)=1/Ak(z/LPC_CHIRP_WEIGHTDENUM), where
+                               LPC_CHIRP_WEIGHTDENUM = 0.4222
+
+   This is a simple design with low complexity that is applied in the
+   LPC residual domain.  Here Ak(z) is the filter obtained for sub-block
+   k from unquantized but interpolated LSF coefficients.
+
+3.5.  Start State Encoder
+
+   The start state is quantized by using a common 6-bit scalar quantizer
+   for the block and a 3-bit scalar quantizer operating on scaled
+   samples in the weighted speech domain.  In the following we describe
+   the state encoding in greater detail.
+
+
+
+
+
+
+
+
+
+
+Andersen, et al.              Experimental                     [Page 15]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+3.5.1.  Start State Estimation
+
+   The two sub-blocks containing the start state are determined by
+   finding the two consecutive sub-blocks in the block having the
+   highest power.  Advantageously, down-weighting is used in the
+   beginning and end of the sub-frames, i.e., the following measure is
+   computed (NSUB=4/6 for 20/30 ms frame size):
+
+      nsub=1,...,NSUB-1
+      ssqn[nsub] = 0.0;
+      for (i=(nsub-1)*SUBL; i<(nsub-1)*SUBL+5; i++)
+               ssqn[nsub] += sampEn_win[i-(nsub-1)*SUBL]*
+                                 residual[i]*residual[i];
+      for (i=(nsub-1)*SUBL+5; i<(nsub+1)*SUBL-5; i++)
+               ssqn[nsub] += residual[i]*residual[i];
+      for (i=(nsub+1)*SUBL-5; i<(nsub+1)*SUBL; i++)
+               ssqn[nsub] += sampEn_win[(nsub+1)*SUBL-i-1]*
+                                 residual[i]*residual[i];
+
+   where sampEn_win[5]={1/6, 2/6, 3/6, 4/6, 5/6}; MAY be used.  The
+   sub-frame number corresponding to the maximum value of
+   ssqEn_win[nsub-1]*ssqn[nsub] is selected as the start state
+   indicator.  A weighting of ssqEn_win[]={0.8,0.9,1.0,0.9,0.8} for 30
+   ms frames and ssqEn_win[]={0.9,1.0,0.9} for 20 ms frames; MAY
+   advantageously be used to bias the start state towards the middle of
+   the frame.
+
+   For 20 ms frames there are three possible positions for the two-sub-
+   block length maximum power segment; the start state position is
+   encoded with 2 bits.  The start state position, start, MUST be
+   encoded as
+
+      start=1: start state in sub-frame 0 and 1
+      start=2: start state in sub-frame 1 and 2
+      start=3: start state in sub-frame 2 and 3
+
+   For 30 ms frames there are five possible positions of the two-sub-
+   block length maximum power segment, the start state position is
+   encoded with 3 bits.  The start state position, start, MUST be
+   encoded as
+
+      start=1: start state in sub-frame 0 and 1
+      start=2: start state in sub-frame 1 and 2
+      start=3: start state in sub-frame 2 and 3
+      start=4: start state in sub-frame 3 and 4
+      start=5: start state in sub-frame 4 and 5
+
+
+
+
+
+Andersen, et al.              Experimental                     [Page 16]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   Hence, in both cases, index 0 is not used.  In order to shorten the
+   start state for bit rate efficiency, the start state is brought down
+   to STATE_SHORT_LEN=57 samples for 20 ms frames and STATE_SHORT_LEN=58
+   samples for 30 ms frames.  The power of the first 23/22 and last
+   23/22 samples of the two sub-frame blocks identified above is
+   computed as the sum of the squared signal sample values, and the
+   23/22-sample segment with the lowest power is excluded from the start
+   state.  One bit is transmitted to indicate which of the two possible
+   57/58 sample segments is used.  The start state position within the
+   two sub-frames determined above, state_first, MUST be encoded as
+
+      state_first=1: start state is first STATE_SHORT_LEN samples
+      state_first=0: start state is last STATE_SHORT_LEN samples
+
+3.5.2.  All-Pass Filtering and Scale Quantization
+
+   The block of residual samples in the start state is first filtered by
+   an all-pass filter with the quantized LPC coefficients as denominator
+   and reversed quantized LPC coefficients as numerator.  The purpose of
+   this phase-dispersion filter is to get a more even distribution of
+   the sample values in the residual signal.  The filtering is performed
+   by circular convolution, where the initial filter memory is set to
+   zero.
+
+      res(0..(STATE_SHORT_LEN-1))   = uncoded start state residual
+      res((STATE_SHORT_LEN)..(2*STATE_SHORT_LEN-1)) = 0
+
+      Pk(z) = A~rk(z)/A~k(z), where
+                                   ___
+                                   \
+      A~rk(z)= z^(-LPC_FILTERORDER)+>a~k(i+1)*z^(i-(LPC_FILTERORDER-1))
+                                   /__
+                               i=0...(LPC_FILTERORDER-1)
+
+      and A~k(z) is taken from the block where the start state begins
+
+      res -> Pk(z) -> filtered
+
+      ccres(k) = filtered(k) + filtered(k+STATE_SHORT_LEN),
+                                        k=0..(STATE_SHORT_LEN-1)
+
+   The all-pass filtered block is searched for its largest magnitude
+   sample.  The 10-logarithm of this magnitude is quantized with a 6-bit
+   quantizer, state_frgqTbl, by finding the nearest representation.
+
+
+
+
+
+
+
+Andersen, et al.              Experimental                     [Page 17]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   This results in an index, idxForMax, corresponding to a quantized
+   value, qmax.  The all-pass filtered residual samples in the block are
+   then multiplied with a scaling factor scal=4.5/(10^qmax) to yield
+   normalized samples.
+
+   state_frgqTbl[64] = {1.000085, 1.071695, 1.140395, 1.206868,
+                  1.277188, 1.351503, 1.429380, 1.500727, 1.569049,
+                  1.639599, 1.707071, 1.781531, 1.840799, 1.901550,
+                  1.956695, 2.006750, 2.055474, 2.102787, 2.142819,
+                  2.183592, 2.217962, 2.257177, 2.295739, 2.332967,
+                  2.369248, 2.402792, 2.435080, 2.468598, 2.503394,
+                  2.539284, 2.572944, 2.605036, 2.636331, 2.668939,
+                  2.698780, 2.729101, 2.759786, 2.789834, 2.818679,
+                  2.848074, 2.877470, 2.906899, 2.936655, 2.967804,
+                  3.000115, 3.033367, 3.066355, 3.104231, 3.141499,
+                  3.183012, 3.222952, 3.265433, 3.308441, 3.350823,
+                  3.395275, 3.442793, 3.490801, 3.542514, 3.604064,
+                  3.666050, 3.740994, 3.830749, 3.938770, 4.101764}
+
+3.5.3.  Scalar Quantization
+
+   The normalized samples are quantized in the perceptually weighted
+   speech domain by a sample-by-sample scalar DPCM quantization as
+   depicted in Figure 3.3.  Each sample in the block is filtered by a
+   weighting filter Wk(z), specified in section 3.4, to form a weighted
+   speech sample x[n].  The target sample d[n] is formed by subtracting
+   a predicted sample y[n], where the prediction filter is given by
+
+           Pk(z) = 1 - 1 / Wk(z).
+
+               +-------+  x[n] +    d[n] +-----------+ u[n]
+   residual -->| Wk(z) |-------->(+)---->| Quantizer |------> quantized
+               +-------+       - /|\     +-----------+    |   residual
+                                  |                      \|/
+                             y[n] +--------------------->(+)
+                                  |                       |
+                                  |        +------+       |
+                                  +--------| Pk(z)|<------+
+                                           +------+
+
+   Figure 3.3.  Quantization of start state samples by DPCM in weighted
+   speech domain.
+
+   The coded state sample u[n] is obtained by quantizing d[n] with a 3-
+   bit quantizer with quantization table state_sq3Tbl.
+
+   state_sq3Tbl[8] = {-3.719849, -2.177490, -1.130005, -0.309692,
+                  0.444214, 1.329712, 2.436279, 3.983887}
+
+
+
+Andersen, et al.              Experimental                     [Page 18]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   The quantized samples are transformed back to the residual domain by
+   1) scaling with 1/scal; 2) time-reversing the scaled samples; 3)
+   filtering the time-reversed samples by the same all-pass filter, as
+   in section 3.5.2, by using circular convolution; and 4) time-
+   reversing the filtered samples.  (More detail is in section 4.2.)
+
+   A reference implementation of the start-state encoding can be found
+   in Appendix A.46.
+
+3.6.  Encoding the Remaining Samples
+
+   A dynamic codebook is used to encode 1) the 23/22 remaining samples
+   in the two sub-blocks containing the start state; 2) the sub-blocks
+   after the start state in time; and 3) the sub-blocks before the start
+   state in time.  Thus, the encoding target can be either the 23/22
+   samples remaining of the 2 sub-blocks containing the start state, or
+   a 40-sample sub-block.  This target can consist of samples that are
+   indexed forward in time or backward in time, depending on the
+   location of the start state.  The length of the target is denoted by
+   lTarget.
+
+   The coding is based on an adaptive codebook that is built from a
+   codebook memory that contains decoded LPC excitation samples from the
+   already encoded part of the block.  These samples are indexed in the
+   same time direction as is the target vector and end at the sample
+   instant prior to the first sample instant represented in the target
+   vector.  The codebook memory has length lMem, which is equal to
+   CB_MEML=147 for the two/four 40-sample sub-blocks and 85 for the
+   23/22-sample sub-block.
+
+   The following figure shows an overview of the encoding procedure.
+
+         +------------+    +---------------+    +-------------+
+      -> | 1. Decode  | -> | 2. Mem setup  | -> | 3. Perc. W. | ->
+         +------------+    +---------------+    +-------------+
+
+         +------------+    +-----------------+
+      -> | 4. Search  | -> | 5. Upd. Target  | ------------------>
+       | +------------+    +------------------ |
+       ----<-------------<-----------<----------
+                     stage=0..2
+
+         +----------------+
+      -> | 6. Recalc G[0] | ---------------> gains and CB indices
+         +----------------+
+
+   Figure 3.4.  Flow chart of the codebook search in the iLBC encoder.
+
+
+
+
+Andersen, et al.              Experimental                     [Page 19]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   1. Decode the part of the residual that has been encoded so far,
+      using the codebook without perceptual weighting.
+
+   2. Set up the memory by taking data from the decoded residual.  This
+      memory is used to construct codebooks.  For blocks preceding the
+      start state, both the decoded residual and the target are time
+      reversed (section 3.6.1).
+   3. Filter the memory + target with the perceptual weighting filter
+      (section 3.6.2).
+
+   4. Search for the best match between the target and the codebook
+      vector.  Compute the optimal gain for this match and quantize that
+      gain (section 3.6.4).
+
+   5. Update the perceptually weighted target by subtracting the
+      contribution from the selected codebook vector from the
+      perceptually weighted memory (quantized gain times selected
+      vector).  Repeat 4 and 5 for the two additional stages.
+
+   6. Calculate the energy loss due to encoding of the residual.  If
+      needed, compensate for this loss by an upscaling and
+      requantization of the gain for the first stage (section 3.7).
+
+   The following sections provide an in-depth description of the
+   different blocks of Figure 3.4.
+
+3.6.1.  Codebook Memory
+
+   The codebook memory is based on the already encoded sub-blocks, so
+   the available data for encoding increases for each new sub-block that
+   has been encoded.  Until enough sub-blocks have been encoded to fill
+   the codebook memory with data, it is padded with zeros.  The
+   following figure shows an example of the order in which the sub-
+   blocks are encoded for the 30 ms frame size if the start state is
+   located in the last 58 samples of sub-block 2 and 3.
+
+   +-----------------------------------------------------+
+   |  5     | 1  |///|////////|    2   |    3   |    4   |
+   +-----------------------------------------------------+
+
+   Figure 3.5.  The order from 1 to 5 in which the sub-blocks are
+   encoded.  The slashed area is the start state.
+
+
+
+
+
+
+
+
+
+Andersen, et al.              Experimental                     [Page 20]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   The first target sub-block to be encoded is number 1, and the
+   corresponding codebook memory is shown in the following figure.  As
+   the target vector comes before the start state in time, the codebook
+   memory and target vector are time reversed; thus, after the block has
+   been time reversed the search algorithm can be reused.  As only the
+   start state has been encoded so far, the last samples of the codebook
+   memory are padded with zeros.
+
+   +-------------------------
+   |zeros|\\\\\\\\|\\\\|  1 |
+   +-------------------------
+
+   Figure 3.6.  The codebook memory, length lMem=85 samples, and the
+   target vector 1, length 22 samples.
+
+   The next step is to encode sub-block 2 by using the memory that now
+   has increased since sub-block 1 has been encoded.  The following
+   figure shows the codebook memory for encoding of sub-block 2.
+
+   +-----------------------------------
+   | zeros | 1  |///|////////|    2   |
+   +-----------------------------------
+
+   Figure 3.7.  The codebook memory, length lMem=147 samples, and the
+   target vector 2, length 40 samples.
+
+   The next step is to encode sub-block 3 by using the memory which has
+   been increased yet again since sub-blocks 1 and 2 have been encoded,
+   but the sub-block still has to be padded with a few zeros.  The
+   following figure shows the codebook memory for encoding of sub-block
+   3.
+
+   +------------------------------------------
+   |zeros| 1  |///|////////|    2   |   3    |
+   +------------------------------------------
+
+   Figure 3.8.  The codebook memory, length lMem=147 samples, and the
+   target vector 3, length 40 samples.
+
+   The next step is to encode sub-block 4 by using the memory which now
+   has increased yet again since sub-blocks 1, 2, and 3 have been
+   encoded.  This time, the memory does not have to be padded with
+   zeros.  The following figure shows the codebook memory for encoding
+   of sub-block 4.
+
+
+
+
+
+
+
+Andersen, et al.              Experimental                     [Page 21]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   +------------------------------------------
+   |1|///|////////|    2   |   3    |   4    |
+   +------------------------------------------
+
+   Figure 3.9.  The codebook memory, length lMem=147 samples, and the
+   target vector 4, length 40 samples.
+
+   The final target sub-block to be encoded is number 5, and the
+   following figure shows the corresponding codebook memory.  As the
+   target vector comes before the start state in time, the codebook
+   memory and target vector are time reversed.
+
+   +-------------------------------------------
+   |  3  |   2    |\\\\\\\\|\\\\|  1 |   5    |
+   +-------------------------------------------
+
+   Figure 3.10.  The codebook memory, length lMem=147 samples, and the
+   target vector 5, length 40 samples.
+
+   For the case of 20 ms frames, the encoding procedure looks almost
+   exactly the same.  The only difference is that the size of the start
+   state is 57 samples and that there are only three sub-blocks to be
+   encoded.  The encoding order is the same as above, starting with the
+   23-sample target and then encoding the two remaining 40-sample sub-
+   blocks, first going forward in time and then going backward in time
+   relative to the start state.
+
+3.6.2.  Perceptual Weighting of Codebook Memory and Target
+
+   To provide a perceptual weighting of the coding error, a
+   concatenation of the codebook memory and the target to be coded is
+   all-pole filtered with the perceptual weighting filter specified in
+   section 3.4.  The filter state of the weighting filter is set to
+   zero.
+
+      in(0..(lMem-1))            = unweighted codebook memory
+      in(lMem..(lMem+lTarget-1)) = unweighted target signal
+
+
+      in -> Wk(z) -> filtered,
+          where Wk(z) is taken from the sub-block of the target
+
+      weighted codebook memory = filtered(0..(lMem-1))
+      weighted target signal = filtered(lMem..(lMem+lTarget-1))
+
+   The codebook search is done with the weighted codebook memory and the
+   weighted target, whereas the decoding and the codebook memory update
+   uses the unweighted codebook memory.
+
+
+
+Andersen, et al.              Experimental                     [Page 22]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+3.6.3.  Codebook Creation
+
+   The codebook for the search is created from the perceptually weighted
+   codebook memory.  It consists of two sections, where the first is
+   referred to as the base codebook and the second as the expanded
+   codebook, as it is created by linear combinations of the first.  Each
+   of these two sections also has a subsection referred to as the
+   augmented codebook.  The augmented codebook is only created and used
+   for the coding of the 40-sample sub-blocks and not for the 23/22-
+   sample sub-block case.  The codebook size used for the different
+   sub-blocks and different stages are summarized in the table below.
+
+                              Stage
+                        1               2 & 3
+           --------------------------------------------
+                22     128  (64+0)*2     128 (64+0)*2
+   Sub-    1:st 40     256  (108+20)*2   128 (44+20)*2
+   Blocks  2:nd 40     256  (108+20)*2   256 (108+20)*2
+           3:rd 40     256  (108+20)*2   256 (108+20)*2
+           4:th 40     256  (108+20)*2   256 (108+20)*2
+
+   Table 3.1.  Codebook sizes for the 30 ms mode.
+
+   Table 3.1 shows the codebook size for the different sub-blocks and
+   stages for 30 ms frames.  Inside the parentheses it shows how the
+   number of codebook vectors is distributed, within the two sections,
+   between the base/expanded codebook and the augmented base/expanded
+   codebook.  It should be interpreted in the following way:
+   (base/expanded cb + augmented base/expanded cb).  The total number of
+   codebook vectors for a specific sub-block and stage is given by the
+   following formula:
+
+   Tot. cb vectors = base cb + aug. base cb + exp. cb + aug. exp. cb
+
+   The corresponding values to Figure 3.1 for 20 ms frames are only
+   slightly modified.  The short sub-block is 23 instead of 22 samples,
+   and the 3:rd and 4:th sub-frame are not present.
+
+3.6.3.1.  Creation of a Base Codebook
+
+   The base codebook is given by the perceptually weighted codebook
+   memory that is mentioned in section 3.5.3.  The different codebook
+   vectors are given by sliding a window of length 23/22 or 40, given by
+   variable lTarget, over the lMem-long perceptually weighted codebook
+   memory.  The indices are ordered so that the codebook vector
+   containing sample (lMem-lTarget-n) to (lMem-n-1) of the codebook
+
+
+
+
+
+Andersen, et al.              Experimental                     [Page 23]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   memory vector has index n, where n=0..lMem-lTarget.  Thus the total
+   number of base codebook vectors is lMem-lTarget+1, and the indices
+   are ordered from sample delay lTarget (23/22 or 40) to lMem+1 (86 or
+   148).
+
+3.6.3.2.  Codebook Expansion
+
+   The base codebook is expanded by a factor of 2, creating an
+   additional section in the codebook.  This new section is obtained by
+   filtering the base codebook, base_cb, with a FIR filter with filter
+   length CB_FILTERLEN=8.  The construction of the expanded codebook
+   compensates for the delay of four samples introduced by the FIR
+   filter.
+
+   cbfiltersTbl[CB_FILTERLEN]={-0.033691, 0.083740, -0.144043,
+                  0.713379, 0.806152, -0.184326,
+                  0.108887, -0.034180};
+
+                   ___
+                   \
+      exp_cb(k)=  + > cbfiltersTbl(i)*x(k-i+4)
+                   /__
+             i=0...(LPC_FILTERORDER-1)
+
+      where x(j) = base_cb(j) for j=0..lMem-1 and 0 otherwise
+
+   The individual codebook vectors of the new filtered codebook, exp_cb,
+   and their indices are obtained in the same fashion as described above
+   for the base codebook.
+
+3.6.3.3.  Codebook Augmentation
+
+   For cases where encoding entire sub-blocks, i.e., cbveclen=40, the
+   base and expanded codebooks are augmented to increase codebook
+   richness.  The codebooks are augmented by vectors produced by
+   interpolation of segments.  The base and expanded codebook,
+   constructed above, consists of vectors corresponding to sample delays
+   in the range from cbveclen to lMem.  The codebook augmentation
+   attempts to augment these codebooks with vectors corresponding to
+   sample delays from 20 to 39.  However, not all of these samples are
+   present in the base codebook and expanded codebook, respectively.
+   Therefore, the augmentation vectors are constructed as linear
+   combinations between samples corresponding to sample delays in the
+   range 20 to 39.  The general idea of this procedure is presented in
+   the following figures and text.  The procedure is performed for both
+   the base codebook and the expanded codebook.
+
+
+
+
+
+Andersen, et al.              Experimental                     [Page 24]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       - - ------------------------|
+    codebook memory                |
+       - - ------------------------|
+                  |-5-|---15---|-5-|
+                  pi  pp       po
+
+                      |        |                       Codebook vector
+                      |---15---|-5-|-----20-----|   <- corresponding to
+                          i     ii      iii            sample delay 20
+
+   Figure 3.11.  Generation of the first augmented codebook.
+
+   Figure 3.11 shows the codebook memory with pointers pi, pp, and po,
+   where pi points to sample 25, pp to sample 20, and po to sample 5.
+   Below the codebook memory, the augmented codebook vector
+   corresponding to sample delay 20 is drawn.  Segment i consists of
+   fifteen samples from pointer pp and forward in time.  Segment ii
+   consists of five interpolated samples from pi and forward and from po
+   and forward.  The samples are linearly interpolated with weights
+   [0.0, 0.2, 0.4, 0.6, 0.8] for pi and weights [1.0, 0.8, 0.6, 0.4,
+   0.2] for po.  Segment iii consists of twenty samples from pp and
+   forward.  The augmented codebook vector corresponding to sample delay
+   21 is produced by moving pointers pp and pi one sample backward in
+   time.  This gives us the following figure.
+
+       - - ------------------------|
+    codebook memory                |
+       - - ------------------------|
+                  |-5-|---16---|-5-|
+                  pi  pp       po
+
+                      |        |                       Codebook vector
+                      |---16---|-5-|-----19-----|   <- corresponding to
+                          i     ii      iii            sample delay 21
+
+   Figure 3.12.  Generation of the second augmented codebook.
+
+   Figure 3.12 shows the codebook memory with pointers pi, pp and po
+   where pi points to sample 26, pp to sample 21, and po to sample 5.
+   Below the codebook memory, the augmented codebook vector
+   corresponding to sample delay 21 is drawn.  Segment i now consists of
+   sixteen samples from pp and forward.  Segment ii consists of five
+   interpolated samples from pi and forward and from po and forward, and
+   the interpolation weights are the same throughout the procedure.
+   Segment iii consists of nineteen samples from pp and forward.  The
+   same procedure of moving the two pointers is continued until the last
+   augmented vector corresponding to sample delay 39 has been created.
+   This gives a total of twenty new codebook vectors to each of the two
+
+
+
+Andersen, et al.              Experimental                     [Page 25]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   sections.  Thus the total number of codebook vectors for each of the
+   two sections, when including the augmented codebook, becomes lMem-
+   SUBL+1+SUBL/2.  This is provided that augmentation is evoked, i.e.,
+   that lTarget=SUBL.
+
+3.6.4.  Codebook Search
+
+   The codebook search uses the codebooks described in the sections
+   above to find the best match of the perceptually weighted target, see
+   section 3.6.2.  The search method is a multi-stage gain-shape
+   matching performed as follows.  At each stage the best shape vector
+   is identified, then the gain is calculated and quantized, and finally
+   the target is updated in preparation for the next codebook search
+   stage.  The number of stages is CB_NSTAGES=3.
+
+   If the target is the 23/22-sample vector the codebooks are indexed so
+   that the base codebook is followed by the expanded codebook.  If the
+   target is 40 samples the order is as follows: base codebook,
+   augmented base codebook, expanded codebook, and augmented expanded
+   codebook.  The size of each codebook section and its corresponding
+   augmented section is given by Table 3.1 in section 3.6.3.
+
+   For example, when the second 40-sample sub-block is coded, indices 0
+   - 107 correspond to the base codebook, 108 - 127 correspond to the
+   augmented base codebook, 128 - 235 correspond to the expanded
+   codebook, and indices 236 - 255 correspond to the augmented expanded
+   codebook.  The indices are divided in the same fashion for all stages
+   in the example.  Only in the case of coding the first 40-sample sub-
+   block is there a difference between stages (see Table 3.1).
+
+3.6.4.1.  Codebook Search at Each Stage
+
+   The codebooks are searched to find the best match to the target at
+   each stage.  When the best match is found, the target is updated and
+   the next-stage search is started.  The three chosen codebook vectors
+   and their corresponding gains constitute the encoded sub-block.  The
+   best match is decided by the following three criteria:
+
+   1. Compute the measure
+
+      (target*cbvec)^2 / ||cbvec||^2
+
+   for all codebook vectors, cbvec, and choose the codebook vector
+   maximizing the measure.  The expression (target*cbvec) is the dot
+   product between the target vector to be coded and the codebook vector
+   for which we compute the measure.  The norm, ||x||, is defined as the
+   square root of (x*x).
+
+
+
+
+Andersen, et al.              Experimental                     [Page 26]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   2. The absolute value of the gain, corresponding to the chosen
+      codebook vector, cbvec, must be smaller than a fixed limit,
+      CB_MAXGAIN=1.3:
+
+            |gain| < CB_MAXGAIN
+
+      where the gain is computed in the following way:
+
+            gain = (target*cbvec) / ||cbvec||^2
+
+   3. For the first stage, the dot product of the chosen codebook vector
+      and target must be positive:
+
+      target*cbvec > 0
+
+   In practice the above criteria are used in a sequential search
+   through all codebook vectors.  The best match is found by registering
+   a new max measure and index whenever the previously registered max
+   measure is surpassed and all other criteria are fulfilled.  If none
+   of the codebook vectors fulfill (2) and (3), the first codebook
+   vector is selected.
+
+3.6.4.2.  Gain Quantization at Each Stage
+
+   The gain follows as a result of the computation
+
+      gain = (target*cbvec) / ||cbvec||^2
+
+   for the optimal codebook vector found by the procedure in section
+   3.6.4.1.
+
+   The three stages quantize the gain, using 5, 4, and 3 bits,
+   respectively.  In the first stage, the gain is limited to positive
+   values.  This gain is quantized by finding the nearest value in the
+   quantization table gain_sq5Tbl.
+
+   gain_sq5Tbl[32]={0.037476, 0.075012, 0.112488, 0.150024, 0.187500,
+                  0.224976, 0.262512, 0.299988, 0.337524, 0.375000,
+                  0.412476, 0.450012, 0.487488, 0.525024, 0.562500,
+                  0.599976, 0.637512, 0.674988, 0.712524, 0.750000,
+                  0.787476, 0.825012, 0.862488, 0.900024, 0.937500,
+                  0.974976, 1.012512, 1.049988, 1.087524, 1.125000,
+                  1.162476, 1.200012}
+
+   The gains of the subsequent two stages can be either positive or
+   negative.  The gains are quantized by using a quantization table
+   times a scale factor.  The second stage uses the table gain_sq4Tbl,
+   and the third stage uses gain_sq3Tbl.  The scale factor equates 0.1
+
+
+
+Andersen, et al.              Experimental                     [Page 27]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   or the absolute value of the quantized gain representation value
+   obtained in the previous stage, whichever is larger.  Again, the
+   resulting gain index is the index to the nearest value of the
+   quantization table times the scale factor.
+
+        gainQ = scaleFact * gain_sqXTbl[index]
+
+   gain_sq4Tbl[16]={-1.049988, -0.900024, -0.750000, -0.599976,
+                  -0.450012, -0.299988, -0.150024, 0.000000, 0.150024,
+                  0.299988, 0.450012, 0.599976, 0.750000, 0.900024,
+                  1.049988, 1.200012}
+
+   gain_sq3Tbl[8]={-1.000000, -0.659973, -0.330017,0.000000,
+                  0.250000, 0.500000, 0.750000, 1.00000}
+
+3.6.4.3.  Preparation of Target for Next Stage
+
+   Before performing the search for the next stage, the perceptually
+   weighted target vector is updated by subtracting from it the selected
+   codebook vector (from the perceptually weighted codebook) times the
+   corresponding quantized gain.
+
+      target[i] = target[i] - gainQ * selected_vec[i];
+
+   A reference implementation of the codebook encoding is found in
+   Appendix A.34.
+
+3.7.  Gain Correction Encoding
+
+   The start state is quantized in a relatively model independent manner
+   using 3 bits per sample.  In contrast, the remaining parts of the
+   block are encoded by using an adaptive codebook.  This codebook will
+   produce high matching accuracy whenever there is a high correlation
+   between the target and the best codebook vector.  For unvoiced speech
+   segments and background noises, this is not necessarily so, which,
+   due to the nature of the squared error criterion, results in a coded
+   signal with less power than the target signal.  As the coded start
+   state has good power matching to the target, the result is a power
+   fluctuation within the encoded frame.  Perceptually, the main problem
+   with this is that the time envelope of the signal energy becomes
+   unsteady.  To overcome this problem, the gains for the codebooks are
+   re-scaled after the codebook encoding by searching for a new gain
+   factor for the first stage codebook that provides better power
+   matching.
+
+   First, the energy for the target signal, tene, is computed along with
+   the energy for the coded signal, cene, given by the addition of the
+   three gain scaled codebook vectors.  Because the gains of the second
+
+
+
+Andersen, et al.              Experimental                     [Page 28]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   and third stage scale with the gain of the first stage, when the
+   first stage gain is changed from gain[0] to gain_sq5Tbl[i] the energy
+   of the coded signal changes from cene to
+
+      cene*(gain_sq5Tbl[i]*gain_sq5Tbl[i])/(gain[0]*gain[0])
+
+   where gain[0] is the gain for the first stage found in the original
+   codebook search.  A refined search is performed by testing the gain
+   indices i=0 to 31, and as long as the new codebook energy as given
+   above is less than tene, the gain index for stage 1 is increased.  A
+   restriction is applied so that the new gain value for stage 1 cannot
+   be more than two times higher than the original value found in the
+   codebook search.  Note that by using this method we do not change the
+   shape of the encoded vector, only the gain or amplitude.
+
+3.8.  Bitstream Definition
+
+   The total number of bits used to describe one frame of 20 ms speech
+   is 304, which fits in 38 bytes and results in a bit rate of 15.20
+   kbit/s.  For the case of a frame length of 30 ms speech, the total
+   number of bits used is 400, which fits in 50 bytes and results in a
+   bit rate of 13.33 kbit/s.  In the bitstream definition, the bits are
+   distributed into three classes according to their bit error or loss
+   sensitivity.  The most sensitive bits (class 1) are placed first in
+   the bitstream for each frame.  The less sensitive bits (class 2) are
+   placed after the class 1 bits.  The least sensitive bits (class 3)
+   are placed at the end of the bitstream for each frame.
+
+   In the 20/30 ms frame length cases for each class, the following hold
+   true: The class 1 bits occupy a total of 6/8 bytes (48/64 bits), the
+   class 2 bits occupy 8/12 bytes (64/96 bits), and the class 3 bits
+   occupy 24/30 bytes (191/239 bits).  This distribution of the bits
+   enables the use of uneven level protection (ULP) as is exploited in
+   the payload format definition for iLBC [1].  The detailed bit
+   allocation is shown in the table below.  When a quantization index is
+   distributed between more classes, the more significant bits belong to
+   the lowest class.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Andersen, et al.              Experimental                     [Page 29]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   Bitstream structure:
+
+   ------------------------------------------------------------------+
+   Parameter                         |       Bits Class <1,2,3>      |
+                                     |  20 ms frame  |  30 ms frame  |
+   ----------------------------------+---------------+---------------+
+                            Split 1  |   6 <6,0,0>   |   6 <6,0,0>   |
+                   LSF 1    Split 2  |   7 <7,0,0>   |   7 <7,0,0>   |
+   LSF                      Split 3  |   7 <7,0,0>   |   7 <7,0,0>   |
+                   ------------------+---------------+---------------+
+                            Split 1  | NA (Not Appl.)|   6 <6,0,0>   |
+                   LSF 2    Split 2  |      NA       |   7 <7,0,0>   |
+                            Split 3  |      NA       |   7 <7,0,0>   |
+                   ------------------+---------------+---------------+
+                   Sum               |  20 <20,0,0>  |  40 <40,0,0>  |
+   ----------------------------------+---------------+---------------+
+   Block Class                       |   2 <2,0,0>   |   3 <3,0,0>   |
+   ----------------------------------+---------------+---------------+
+   Position 22 sample segment        |   1 <1,0,0>   |   1 <1,0,0>   |
+   ----------------------------------+---------------+---------------+
+   Scale Factor State Coder          |   6 <6,0,0>   |   6 <6,0,0>   |
+   ----------------------------------+---------------+---------------+
+                   Sample 0          |   3 <0,1,2>   |   3 <0,1,2>   |
+   Quantized       Sample 1          |   3 <0,1,2>   |   3 <0,1,2>   |
+   Residual           :              |   :    :      |   :    :      |
+   State              :              |   :    :      |   :    :      |
+   Samples            :              |   :    :      |   :    :      |
+                   Sample 56         |   3 <0,1,2>   |   3 <0,1,2>   |
+                   Sample 57         |      NA       |   3 <0,1,2>   |
+                   ------------------+---------------+---------------+
+                   Sum               | 171 <0,57,114>| 174 <0,58,116>|
+   ----------------------------------+---------------+---------------+
+                            Stage 1  |   7 <6,0,1>   |   7 <4,2,1>   |
+   CB for 22/23             Stage 2  |   7 <0,0,7>   |   7 <0,0,7>   |
+   sample block             Stage 3  |   7 <0,0,7>   |   7 <0,0,7>   |
+                   ------------------+---------------+---------------+
+                   Sum               |  21 <6,0,15>  |  21 <4,2,15>  |
+   ----------------------------------+---------------+---------------+
+                            Stage 1  |   5 <2,0,3>   |   5 <1,1,3>   |
+   Gain for 22/23           Stage 2  |   4 <1,1,2>   |   4 <1,1,2>   |
+   sample block             Stage 3  |   3 <0,0,3>   |   3 <0,0,3>   |
+                   ------------------+---------------+---------------+
+                   Sum               |  12 <3,1,8>   |  12 <2,2,8>   |
+   ----------------------------------+---------------+---------------+
+                            Stage 1  |   8 <7,0,1>   |   8 <6,1,1>   |
+               sub-block 1  Stage 2  |   7 <0,0,7>   |   7 <0,0,7>   |
+                            Stage 3  |   7 <0,0,7>   |   7 <0,0,7>   |
+                   ------------------+---------------+---------------+
+
+
+
+Andersen, et al.              Experimental                     [Page 30]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+                            Stage 1  |   8 <0,0,8>   |   8 <0,7,1>   |
+               sub-block 2  Stage 2  |   8 <0,0,8>   |   8 <0,0,8>   |
+   Indices                  Stage 3  |   8 <0,0,8>   |   8 <0,0,8>   |
+   for CB          ------------------+---------------+---------------+
+   sub-blocks               Stage 1  |      NA       |   8 <0,7,1>   |
+               sub-block 3  Stage 2  |      NA       |   8 <0,0,8>   |
+                            Stage 3  |      NA       |   8 <0,0,8>   |
+                   ------------------+---------------+---------------+
+                            Stage 1  |      NA       |   8 <0,7,1>   |
+               sub-block 4  Stage 2  |      NA       |   8 <0,0,8>   |
+                            Stage 3  |      NA       |   8 <0,0,8>   |
+                   ------------------+---------------+---------------+
+                   Sum               |  46 <7,0,39>  |  94 <6,22,66> |
+   ----------------------------------+---------------+---------------+
+                            Stage 1  |   5 <1,2,2>   |   5 <1,2,2>   |
+               sub-block 1  Stage 2  |   4 <1,1,2>   |   4 <1,2,1>   |
+                            Stage 3  |   3 <0,0,3>   |   3 <0,0,3>   |
+                   ------------------+---------------+---------------+
+                            Stage 1  |   5 <1,1,3>   |   5 <0,2,3>   |
+               sub-block 2  Stage 2  |   4 <0,2,2>   |   4 <0,2,2>   |
+                            Stage 3  |   3 <0,0,3>   |   3 <0,0,3>   |
+   Gains for       ------------------+---------------+---------------+
+   sub-blocks               Stage 1  |      NA       |   5 <0,1,4>   |
+               sub-block 3  Stage 2  |      NA       |   4 <0,1,3>   |
+                            Stage 3  |      NA       |   3 <0,0,3>   |
+                   ------------------+---------------+---------------+
+                            Stage 1  |      NA       |   5 <0,1,4>   |
+               sub-block 4  Stage 2  |      NA       |   4 <0,1,3>   |
+                            Stage 3  |      NA       |   3 <0,0,3>   |
+                   ------------------+---------------+---------------+
+                   Sum               |  24 <3,6,15>  |  48 <2,12,34> |
+   ----------------------------------+---------------+---------------+
+   Empty frame indicator             |   1 <0,0,1>   |   1 <0,0,1>   |
+   -------------------------------------------------------------------
+   SUM                                 304 <48,64,192> 400 <64,96,240>
+
+   Table 3.2.  The bitstream definition for iLBC for both the 20 ms
+   frame size mode and the 30 ms frame size mode.
+
+   When packetized into the payload, the bits MUST be sorted as follows:
+   All the class 1 bits in the order (from top to bottom) as specified
+   in the table, all the class 2 bits (from top to bottom), and all the
+   class 3 bits in the same sequential order.  The last bit, the empty
+   frame indicator, SHOULD be set to zero by the encoder.  If this bit
+   is set to 1 the decoder SHOULD treat the data as a lost frame.  For
+   example, this bit can be set to 1 to indicate lost frame for file
+   storage format, as in [1].
+
+
+
+
+Andersen, et al.              Experimental                     [Page 31]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+4.  Decoder Principles
+
+   This section describes the principles of each component of the
+   decoder algorithm.
+
+              +-------------+    +--------+    +---------------+
+   payload -> | 1. Get para | -> | 2. LPC | -> | 3. Sc Dequant | ->
+              +-------------+    +--------+    +---------------+
+
+              +-------------+    +------------------+
+           -> | 4. Mem setup| -> | 5. Construct res |------->
+           |  +-------------+    +-------------------   |
+           ---------<-----------<-----------<------------
+                     Sub-frame 0...2/4 (20 ms/30 ms)
+
+              +----------------+    +----------+
+           -> | 6. Enhance res | -> | 7. Synth | ------------>
+              +----------------+    +----------+
+
+              +-----------------+
+           -> | 8. Post Process | ----------------> decoded speech
+              +-----------------+
+
+   Figure 4.1.  Flow chart of the iLBC decoder.  If a frame was lost,
+   steps 1 to 5 SHOULD be replaced by a PLC algorithm.
+
+   1. Extract the parameters from the bitstream.
+
+   2. Decode the LPC and interpolate (section 4.1).
+
+   3. Construct the 57/58-sample start state (section 4.2).
+
+   4. Set up the memory by using data from the decoded residual.  This
+      memory is used for codebook construction.  For blocks preceding
+      the start state, both the decoded residual and the target are time
+      reversed.  Sub-frames are decoded in the same order as they were
+      encoded.
+
+   5. Construct the residuals of this sub-frame (gain[0]*cbvec[0] +
+      gain[1]*cbvec[1] + gain[2]*cbvec[2]).  Repeat 4 and 5 until the
+      residual of all sub-blocks has been constructed.
+
+   6. Enhance the residual with the post filter (section 4.6).
+
+   7. Synthesis of the residual (section 4.7).
+
+   8. Post process with HP filter, if desired (section 4.8).
+
+
+
+
+Andersen, et al.              Experimental                     [Page 32]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+4.1.  LPC Filter Reconstruction
+
+   The decoding of the LP filter parameters is very straightforward.
+   For a set of three/six indices, the corresponding LSF vector(s) are
+   found by simple table lookup.  For each of the LSF vectors, the three
+   split vectors are concatenated to obtain qlsf1 and qlsf2,
+   respectively (in the 20 ms mode only one LSF vector, qlsf, is
+   constructed).  The next step is the stability check described in
+   section 3.2.5 followed by the interpolation scheme described in
+   section 3.2.6 (3.2.7 for 20 ms frames).  The only difference is that
+   only the quantized LSFs are known at the decoder, and hence the
+   unquantized LSFs are not processed.
+
+   A reference implementation of the LPC filter reconstruction is given
+   in Appendix A.36.
+
+4.2.  Start State Reconstruction
+
+   The scalar encoded STATE_SHORT_LEN=58 (STATE_SHORT_LEN=57 in the 20
+   ms mode) state samples are reconstructed by 1) forming a set of
+   samples (by table lookup) from the index stream idxVec[n], 2)
+   multiplying the set with 1/scal=(10^qmax)/4.5, 3) time reversing the
+   57/58 samples, 4) filtering the time reversed block with the
+   dispersion (all-pass) filter used in the encoder (as described in
+   section 3.5.2); this compensates for the phase distortion of the
+   earlier filter operation, and 5 reversing the 57/58 samples from the
+   previous step.
+
+   in(0..(STATE_SHORT_LEN-1)) = time reversed samples from table
+                                look-up,
+                                idxVecDec((STATE_SHORT_LEN-1)..0)
+
+   in(STATE_SHORT_LEN..(2*STATE_SHORT_LEN-1)) = 0
+
+   Pk(z) = A~rk(z)/A~k(z), where
+                                  ___
+                                  \
+   A~rk(z)= z^(-LPC_FILTERORDER) + > a~ki*z^(i-(LPC_FILTERORDER-1))
+                                  /__
+                              i=0...(LPC_FILTERORDER-1)
+
+   and A~k(z) is taken from the block where the start state begins
+
+   in -> Pk(z) -> filtered
+
+   out(k) = filtered(STATE_SHORT_LEN-1-k) +
+                           filtered(2*STATE_SHORT_LEN-1-k),
+                                         k=0..(STATE_SHORT_LEN-1)
+
+
+
+Andersen, et al.              Experimental                     [Page 33]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   The remaining 23/22 samples in the state are reconstructed by the
+   same adaptive codebook technique described in section 4.3.  The
+   location bit determines whether these are the first or the last 23/22
+   samples of the 80-sample state vector.  If the remaining 23/22
+   samples are the first samples, then the scalar encoded
+   STATE_SHORT_LEN state samples are time-reversed before initialization
+   of the adaptive codebook memory vector.
+
+   A reference implementation of the start state reconstruction is given
+   in Appendix A.44.
+
+4.3.  Excitation Decoding Loop
+
+   The decoding of the LPC excitation vector proceeds in the same order
+   in which the residual was encoded at the encoder.  That is, after the
+   decoding of the entire 80-sample state vector, the forward sub-blocks
+   (corresponding to samples occurring after the state vector samples)
+   are decoded, and then the backward sub-blocks (corresponding to
+   samples occurring before the state vector) are decoded, resulting in
+   a fully decoded block of excitation signal samples.
+
+   In particular, each sub-block is decoded by using the multistage
+   adaptive codebook decoding module described in section 4.4.  This
+   module relies upon an adaptive codebook memory constructed before
+   each run of the adaptive codebook decoding.  The construction of the
+   adaptive codebook memory in the decoder is identical to the method
+   outlined in section 3.6.3, except that it is done on the codebook
+   memory without perceptual weighting.
+
+   For the initial forward sub-block, the last STATE_LEN=80 samples of
+   the length CB_LMEM=147 adaptive codebook memory are filled with the
+   samples of the state vector.  For subsequent forward sub-blocks, the
+   first SUBL=40 samples of the adaptive codebook memory are discarded,
+   the remaining samples are shifted by SUBL samples toward the
+   beginning of the vector, and the newly decoded SUBL=40 samples are
+   placed at the end of the adaptive codebook memory.  For backward
+   sub-blocks, the construction is similar, except that every vector of
+   samples involved is first time reversed.
+
+   A reference implementation of the excitation decoding loop is found
+   in Appendix A.5.
+
+
+
+
+
+
+
+
+
+
+Andersen, et al.              Experimental                     [Page 34]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+4.4.  Multistage Adaptive Codebook Decoding
+
+   The Multistage Adaptive Codebook Decoding module is used at both the
+   sender (encoder) and the receiver (decoder) ends to produce a
+   synthetic signal in the residual domain that is eventually used to
+   produce synthetic speech.  The module takes the index values used to
+   construct vectors that are scaled and summed together to produce a
+   synthetic signal that is the output of the module.
+
+4.4.1.  Construction of the Decoded Excitation Signal
+
+   The unpacked index values provided at the input to the module are
+   references to extended codebooks, which are constructed as described
+   in section 3.6.3, except that they are based on the codebook memory
+   without the perceptual weighting.  The unpacked three indices are
+   used to look up three codebook vectors.  The unpacked three gain
+   indices are used to decode the corresponding 3 gains.  In this
+   decoding, the successive rescaling, as described in section 3.6.4.2,
+   is applied.
+
+   A reference implementation of the adaptive codebook decoding is
+   listed in Appendix A.32.
+
+4.5.  Packet Loss Concealment
+
+   If packet loss occurs, the decoder receives a signal saying that
+   information regarding a block is lost.  For such blocks it is
+   RECOMMENDED to use a Packet Loss Concealment (PLC) unit to create a
+   decoded signal that masks the effect of that packet loss.  In the
+   following we will describe an example of a PLC unit that can be used
+   with the iLBC codec.  As the PLC unit is used only at the decoder,
+   the PLC unit does not affect interoperability between
+   implementations.  Other PLC implementations MAY therefore be used.
+
+   The PLC described operates on the LP filters and the excitation
+   signals and is based on the following principles:
+
+4.5.1.  Block Received Correctly and Previous Block Also Received
+
+   If the block is received correctly, the PLC only records state
+   information of the current block that can be used in case the next
+   block is lost.  The LP filter coefficients for each sub-block and the
+   entire decoded excitation signal are all saved in the decoder state
+   structure.  All of this information will be needed if the following
+   block is lost.
+
+
+
+
+
+
+Andersen, et al.              Experimental                     [Page 35]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+4.5.2.  Block Not Received
+
+   If the block is not received, the block substitution is based on a
+   pitch-synchronous repetition of the excitation signal, which is
+   filtered by the last LP filter of the previous block.  The previous
+   block's information is stored in the decoder state structure.
+
+   A correlation analysis is performed on the previous block's
+   excitation signal in order to detect the amount of pitch periodicity
+   and a pitch value.  The correlation measure is also used to decide on
+   the voicing level (the degree to which the previous block's
+   excitation was a voiced or roughly periodic signal).  The excitation
+   in the previous block is used to create an excitation for the block
+   to be substituted, such that the pitch of the previous block is
+   maintained.  Therefore, the new excitation is constructed in a
+   pitch-synchronous manner.  In order to avoid a buzzy-sounding
+   substituted block, a random excitation is mixed with the new pitch
+   periodic excitation, and the relative use of the two components is
+   computed from the correlation measure (voicing level).
+
+   For the block to be substituted, the newly constructed excitation
+   signal is then passed through the LP filter to produce the speech
+   that will be substituted for the lost block.
+
+   For several consecutive lost blocks, the packet loss concealment
+   continues in a similar manner.  The correlation measure of the last
+   block received is still used along with the same pitch value.  The LP
+   filters of the last block received are also used again.  The energy
+   of the substituted excitation for consecutive lost blocks is
+   decreased, leading to a dampened excitation, and therefore to
+   dampened speech.
+
+4.5.3.  Block Received Correctly When Previous Block Not Received
+
+   For the case in which a block is received correctly when the previous
+   block was not, the correctly received block's directly decoded speech
+   (based solely on the received block) is not used as the actual
+   output.  The reason for this is that the directly decoded speech does
+   not necessarily smoothly merge into the synthetic speech generated
+   for the previous lost block.  If the two signals are not smoothly
+   merged, an audible discontinuity is accidentally produced.
+   Therefore, a correlation analysis between the two blocks of
+   excitation signal (the excitation of the previous concealed block and
+   that of the current received block) is performed to find the best
+   phase match.  Then a simple overlap-add procedure is performed to
+   merge the previous excitation smoothly into the current block's
+   excitation.
+
+
+
+
+Andersen, et al.              Experimental                     [Page 36]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   The exact implementation of the packet loss concealment does not
+   influence interoperability of the codec.
+
+   A reference implementation of the packet loss concealment is
+   suggested in Appendix A.14.  Exact compliance with this suggested
+   algorithm is not needed for a reference implementation to be fully
+   compatible with the overall codec specification.
+
+4.6.  Enhancement
+
+   The decoder contains an enhancement unit that operates on the
+   reconstructed excitation signal.  The enhancement unit increases the
+   perceptual quality of the reconstructed signal by reducing the
+   speech-correlated noise in the voiced speech segments.  Compared to
+   traditional postfilters, the enhancer has an advantage in that it can
+   only modify the excitation signal slightly.  This means that there is
+   no risk of over enhancement.  The enhancer works very similarly for
+   both the 20 ms frame size mode and the 30 ms frame size mode.
+
+   For the mode with 20 ms frame size, the enhancer uses a memory of six
+   80-sample excitation blocks prior in time plus the two new 80-sample
+   excitation blocks.  For each block of 160 new unenhanced excitation
+   samples, 160 enhanced excitation samples are produced.  The enhanced
+   excitation is 40-sample delayed compared to the unenhanced
+   excitation, as the enhancer algorithm uses lookahead.
+
+   For the mode with 30 ms frame size, the enhancer uses a memory of
+   five 80-sample excitation blocks prior in time plus the three new
+   80-sample excitation blocks.  For each block of 240 new unenhanced
+   excitation samples, 240 enhanced excitation samples are produced.
+   The enhanced excitation is 80-sample delayed compared to the
+   unenhanced excitation, as the enhancer algorithm uses lookahead.
+
+   Outline of Enhancer
+
+   The speech enhancement unit operates on sub-blocks of 80 samples,
+   which means that there are two/three 80 sample sub-blocks per frame.
+   Each of these two/three sub-blocks is enhanced separately, but in an
+   analogous manner.
+
+
+
+
+
+
+
+
+
+
+
+
+Andersen, et al.              Experimental                     [Page 37]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   unenhanced residual
+           |
+           |   +---------------+    +--------------+
+           +-> | 1. Pitch Est  | -> | 2. Find PSSQ | -------->
+               +---------------+  | +--------------+
+                                  +-----<-------<------<--+
+               +------------+         enh block 0..1/2    |
+            -> | 3. Smooth  |                             |
+               +------------+                             |
+                 \                                        |
+                 /\                                       |
+                /  \   Already                            |
+               / 4. \----------->----------->-----------+ |
+               \Crit/ Fulfilled                         | |
+                \? /                                    v |
+                 \/                                     | |
+                  \  +-----------------+    +---------+ | |
+              Not +->| 5. Use Constr.  | -> | 6. Mix  | ----->
+           Fulfilled +-----------------+    +---------+
+
+            ---------------> enhanced residual
+
+   Figure 4.2.  Flow chart of the enhancer.
+
+   1. Pitch estimation of each of the two/three new 80-sample blocks.
+
+   2. Find the pitch-period-synchronous sequence n (for block k) by a
+      search around the estimated pitch value.  Do this for n=1,2,3,
+      -1,-2,-3.
+
+   3. Calculate the smoothed residual generated by the six pitch-
+      period-synchronous sequences from prior step.
+
+   4. Check if the smoothed residual satisfies the criterion (section
+      4.6.4).
+
+   5. Use constraint to calculate mixing factor (section 4.6.5).
+
+   6. Mix smoothed signal with unenhanced residual (pssq(n) n=0).
+
+   The main idea of the enhancer is to find three 80 sample blocks
+   before and three 80-sample blocks after the analyzed unenhanced sub-
+   block and to use these to improve the quality of the excitation in
+   that sub-block.  The six blocks are chosen so that they have the
+   highest possible correlation with the unenhanced sub-block that is
+   being enhanced.  In other words, the six blocks are pitch-period-
+   synchronous sequences to the unenhanced sub-block.
+
+
+
+
+Andersen, et al.              Experimental                     [Page 38]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   A linear combination of the six pitch-period-synchronous sequences is
+   calculated that approximates the sub-block.  If the squared error
+   between the approximation and the unenhanced sub-block is small
+   enough, the enhanced residual is set equal to this approximation.
+   For the cases when the squared error criterion is not fulfilled, a
+   linear combination of the approximation and the unenhanced residual
+   forms the enhanced residual.
+
+4.6.1.  Estimating the Pitch
+
+   Pitch estimates are needed to determine the locations of the pitch-
+   period-synchronous sequences in a complexity-efficient way.  For each
+   of the new two/three sub-blocks, a pitch estimate is calculated by
+   finding the maximum correlation in the range from lag 20 to lag 120.
+   These pitch estimates are used to narrow down the search for the best
+   possible pitch-period-synchronous sequences.
+
+4.6.2.  Determination of the Pitch-Synchronous Sequences
+
+   Upon receiving the pitch estimates from the prior step, the enhancer
+   analyzes and enhances one 80-sample sub-block at a time.  The pitch-
+   period-synchronous-sequences pssq(n) can be viewed as vectors of
+   length 80 samples each shifted n*lag samples from the current sub-
+   block.  The six pitch-period-synchronous-sequences, pssq(-3) to
+   pssq(-1) and pssq(1) to pssq(3), are found one at a time by the steps
+   below:
+
+   1) Calculate the estimate of the position of the pssq(n).  For
+      pssq(n) in front of pssq(0) (n > 0), the location of the pssq(n)
+      is estimated by moving one pitch estimate forward in time from the
+      exact location of pssq(n-1).  Similarly, pssq(n) behind pssq(0) (n
+      < 0) is estimated by moving one pitch estimate backward in time
+      from the exact location of pssq(n+1).  If the estimated pssq(n)
+      vector location is totally within the enhancer memory (Figure
+      4.3), steps 2, 3, and 4 are performed, otherwise the pssq(n) is
+      set to zeros.
+
+   2) Compute the correlation between the unenhanced excitation and
+      vectors around the estimated location interval of pssq(n).  The
+      correlation is calculated in the interval estimated location +/- 2
+      samples.  This results in five correlation values.
+
+   3) The five correlation values are upsampled by a factor of 4, by
+      using four simple upsampling filters (MA filters with coefficients
+      upsFilter1.. upsFilter4).  Within these the maximum value is
+      found, which specifies the best pitch-period with a resolution of
+      a quarter of a sample.
+
+
+
+
+Andersen, et al.              Experimental                     [Page 39]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+      upsFilter1[7]={0.000000 0.000000 0.000000 1.000000
+             0.000000 0.000000 0.000000}
+      upsFilter2[7]={0.015625 -0.076904 0.288330 0.862061
+            -0.106445 0.018799 -0.015625}
+      upsFilter3[7]={0.023682 -0.124268 0.601563 0.601563
+            -0.124268 0.023682 -0.023682}
+      upsFilter4[7]={0.018799 -0.106445 0.862061 0.288330
+            -0.076904 0.015625 -0.018799}
+
+   4) Generate the pssq(n) vector by upsampling of the excitation memory
+      and extracting the sequence that corresponds to the lag delay that
+      was calculated in prior step.
+
+   With the steps above, all the pssq(n) can be found in an iterative
+   manner, first moving backward in time from pssq(0) and then forward
+   in time from pssq(0).
+
+
+   0              159             319             479             639
+   +---------------------------------------------------------------+
+   |  -5   |  -4   |  -3   |  -2   |  -1   |   0   |   1   |   2   |
+   +---------------------------------------------------------------+
+                                               |pssq 0 |
+                                          |pssq -1| |pssq 1 |
+                                       |pssq -2|       |pssq 2 |
+                                    |pssq -3|             |pssq 3 |
+
+   Figure 4.3.  Enhancement for 20 ms frame size.
+
+   Figure 4.3 depicts pitch-period-synchronous sequences in the
+   enhancement of the first 80 sample block in the 20 ms frame size
+   mode.  The unenhanced signal input is stored in the last two sub-
+   blocks (1 - 2), and the six other sub-blocks contain unenhanced
+   residual prior-in-time.  We perform the enhancement algorithm on two
+   blocks of 80 samples, where the first of the two blocks consists of
+   the last 40 samples of sub-block 0 and the first 40 samples of sub-
+   block 1.  The second 80-sample block consists of the last 40 samples
+   of sub-block 1 and the first 40 samples of sub-block 2.
+
+
+
+
+
+
+
+
+
+
+
+
+
+Andersen, et al.              Experimental                     [Page 40]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   0              159             319             479             639
+   +---------------------------------------------------------------+
+   |  -4   |  -3   |  -2   |  -1   |   0   |   1   |   2   |   3   |
+   +---------------------------------------------------------------+
+                                   |pssq 0 |
+                              |pssq -1| |pssq 1 |
+                           |pssq -2|       |pssq 2 |
+                        |pssq -3|             |pssq 3 |
+
+   Figure 4.4.  Enhancement for 30 ms frame size.
+
+   Figure 4.4 depicts pitch-period-synchronous sequences in the
+   enhancement of the first 80-sample block in the 30 ms frame size
+   mode.  The unenhanced signal input is stored in the last three sub-
+   blocks (1 - 3).  The five other sub-blocks contain unenhanced
+   residual prior-in-time.  The enhancement algorithm is performed on
+   the three 80 sample sub-blocks 0, 1, and 2.
+
+4.6.3.  Calculation of the Smoothed Excitation
+
+   A linear combination of the six pssq(n) (n!=0) form a smoothed
+   approximation, z, of pssq(0).  Most of the weight is put on the
+   sequences that are close to pssq(0), as these are likely to be most
+   similar to pssq(0).  The smoothed vector is also rescaled so that the
+   energy of z is the same as the energy of pssq(0).
+
+      ___
+      \
+   y = > pssq(i) * pssq_weight(i)
+      /__
+   i=-3,-2,-1,1,2,3
+
+   pssq_weight(i) = 0.5*(1-cos(2*pi*(i+4)/(2*3+2)))
+
+   z = C * y, where C = ||pssq(0)||/||y||
+
+4.6.4.  Enhancer Criterion
+
+   The criterion of the enhancer is that the enhanced excitation is not
+   allowed to differ much from the unenhanced excitation.  This
+   criterion is checked for each 80-sample sub-block.
+
+   e < (b * ||pssq(0)||^2), where b=0.05 and   (Constraint 1)
+
+   e = (pssq(0)-z)*(pssq(0)-z), and "*" means the dot product
+
+
+
+
+
+
+Andersen, et al.              Experimental                     [Page 41]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+4.6.5.  Enhancing the excitation
+
+   From the criterion in the previous section, it is clear that the
+   excitation is not allowed to change much.  The purpose of this
+   constraint is to prevent the creation of an enhanced signal
+   significantly different from the original signal.  This also means
+   that the constraint limits the numerical size of the errors that the
+   enhancement procedure can make.  That is especially important in
+   unvoiced segments and background noise segments for which increased
+   periodicity could lead to lower perceived quality.
+
+   When the constraint in the prior section is not met, the enhanced
+   residual is instead calculated through a constrained optimization by
+   using the Lagrange multiplier technique.  The new constraint is that
+
+      e = (b * ||pssq(0)||^2)                     (Constraint 2)
+
+   We distinguish two solution regions for the optimization: 1) the
+   region where the first constraint is fulfilled and 2) the region
+   where the first constraint is not fulfilled and the second constraint
+   must be used.
+
+   In the first case, where the second constraint is not needed, the
+   optimized re-estimated vector is simply z, the energy-scaled version
+   of y.
+
+   In the second case, where the second constraint is activated and
+   becomes an equality constraint, we have
+
+      z= A*y + B*pssq(0)
+
+   where
+
+      A = sqrt((b-b^2/4)*(w00*w00)/ (w11*w00 + w10*w10)) and
+
+      w11 = pssq(0)*pssq(0)
+      w00 = y*y
+      w10 = y*pssq(0)    (* symbolizes the dot product)
+
+   and
+
+      B = 1 - b/2 - A * w10/w00
+
+   Appendix A.16 contains a listing of a reference implementation for
+   the enhancement method.
+
+
+
+
+
+
+Andersen, et al.              Experimental                     [Page 42]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+4.7.  Synthesis Filtering
+
+   Upon decoding or PLC of the LP excitation block, the decoded speech
+   block is obtained by running the decoded LP synthesis filter,
+   1/A~k(z), over the block.  The synthesis filters have to be shifted
+   to compensate for the delay in the enhancer.  For 20 ms frame size
+   mode, they SHOULD be shifted one 40-sample sub-block, and for 30 ms
+   frame size mode, they SHOULD be shifted two 40-sample sub-blocks.
+   The LP coefficients SHOULD be changed at the first sample of every
+   sub-block while keeping the filter state.  For PLC blocks, one
+   solution is to apply the last LP coefficients of the last decoded
+   speech block for all sub-blocks.
+
+   The reference implementation for the synthesis filtering can be found
+   in Appendix A.48.
+
+4.8.  Post Filtering
+
+   If desired, the decoded block can be filtered by a high-pass filter.
+   This removes the low frequencies of the decoded signal.  A reference
+   implementation of this, with cutoff at 65 Hz, is shown in Appendix
+   A.30.
+
+5.  Security Considerations
+
+   This algorithm for the coding of speech signals is not subject to any
+   known security consideration; however, its RTP payload format [1] is
+   subject to several considerations, which are addressed there.
+   Confidentiality of the media streams is achieved by encryption;
+   therefore external mechanisms, such as SRTP [5], MAY be used for that
+   purpose.
+
+6.  Evaluation of the iLBC Implementations
+
+   It is possible and suggested to evaluate certain iLBC implementation
+   by utilizing methodology and tools available at
+   http://www.ilbcfreeware.org/evaluation.html
+
+7.  References
+
+7.1.  Normative References
+
+   [1] Duric, A. and S. Andersen, "Real-time Transport Protocol (RTP)
+       Payload Format for internet Low Bit Rate Codec (iLBC) Speech",
+       RFC 3952, December 2004.
+
+   [2] Bradner, S., "Key words for use in RFCs to Indicate Requirement
+       Levels", BCP 14, RFC 2119, March 1997.
+
+
+
+Andersen, et al.              Experimental                     [Page 43]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   [3] PacketCable(TM) Audio/Video Codecs Specification, Cable
+       Television Laboratories, Inc.
+
+7.2.  Informative References
+
+   [4] ITU-T Recommendation G.711, available online from the ITU
+       bookstore at http://www.itu.int.
+
+   [5] Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norman,
+       "The Secure Real Time Transport Protocol (SRTP)", RFC 3711, March
+       2004.
+
+8.  Acknowledgements
+
+   This extensive work, besides listed authors, has the following
+   authors, who could not have been listed among "official" authors (due
+   to IESG restrictions in the number of authors who can be listed):
+
+      Manohar N. Murthi (Department of Electrical and Computer
+      Engineering, University of Miami), Fredrik Galschiodt, Julian
+      Spittka, and Jan Skoglund (Global IP Sound).
+
+   The authors are deeply indebted to the following people and thank
+   them sincerely:
+
+      Henry Sinnreich, Patrik Faltstrom, Alan Johnston, and Jean-
+      Francois Mule for great support of the iLBC initiative and for
+      valuable feedback and comments.
+
+      Peter Vary, Frank Mertz, and Christoph Erdmann (RWTH Aachen);
+      Vladimir Cuperman (Niftybox LLC); Thomas Eriksson (Chalmers Univ
+      of Tech), and Gernot Kubin (TU Graz), for thorough review of the
+      iLBC document and their valuable feedback and remarks.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Andersen, et al.              Experimental                     [Page 44]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+APPENDIX A.  Reference Implementation
+
+   This appendix contains the complete c-code for a reference
+   implementation of encoder and decoder for the specified codec.
+
+   The c-code consists of the following files with highest-level
+   functions:
+
+         iLBC_test.c: main function for evaluation purpose
+         iLBC_encode.h: encoder header
+         iLBC_encode.c: encoder function
+         iLBC_decode.h: decoder header
+         iLBC_decode.c: decoder function
+
+   The following files contain global defines and constants:
+
+         iLBC_define.h: global defines
+         constants.h: global constants header
+         constants.c: global constants memory allocations
+
+   The following files contain subroutines:
+
+         anaFilter.h: lpc analysis filter header
+         anaFilter.c: lpc analysis filter function
+         createCB.h: codebook construction header
+         createCB.c: codebook construction function
+         doCPLC.h: packet loss concealment header
+         doCPLC.c: packet loss concealment function
+         enhancer.h: signal enhancement header
+         enhancer.c: signal enhancement function
+         filter.h: general filter header
+         filter.c: general filter functions
+         FrameClassify.h: start state classification header
+         FrameClassify.c: start state classification function
+         gainquant.h: gain quantization header
+         gainquant.c: gain quantization function
+         getCBvec.h: codebook vector construction header
+         getCBvec.c: codebook vector construction function
+         helpfun.h: general purpose header
+         helpfun.c: general purpose functions
+         hpInput.h: input high pass filter header
+         hpInput.c: input high pass filter function
+         hpOutput.h: output high pass filter header
+         hpOutput.c: output high pass filter function
+         iCBConstruct.h: excitation decoding header
+         iCBConstruct.c: excitation decoding function
+         iCBSearch.h: excitation encoding header
+         iCBSearch.c: excitation encoding function
+
+
+
+Andersen, et al.              Experimental                     [Page 45]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+         LPCdecode.h: lpc decoding header
+         LPCdecode.c: lpc decoding function
+         LPCencode.h: lpc encoding header
+         LPCencode.c: lpc encoding function
+         lsf.h: line spectral frequencies header
+         lsf.c: line spectral frequencies functions
+         packing.h: bitstream packetization header
+         packing.c: bitstream packetization functions
+         StateConstructW.h: state decoding header
+         StateConstructW.c: state decoding functions
+         StateSearchW.h: state encoding header
+         StateSearchW.c: state encoding function
+         syntFilter.h: lpc synthesis filter header
+         syntFilter.c: lpc synthesis filter function
+
+   The implementation is portable and should work on many different
+   platforms.  However, it is not difficult to optimize the
+   implementation on particular platforms, an exercise left to the
+   reader.
+
+A.1.  iLBC_test.c
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       iLBC_test.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <math.h>
+   #include <stdlib.h>
+   #include <stdio.h>
+   #include <string.h>
+   #include "iLBC_define.h"
+   #include "iLBC_encode.h"
+   #include "iLBC_decode.h"
+
+   /* Runtime statistics */
+   #include <time.h>
+
+   #define ILBCNOOFWORDS_MAX   (NO_OF_BYTES_30MS/2)
+
+   /*----------------------------------------------------------------*
+    *  Encoder interface function
+
+
+
+Andersen, et al.              Experimental                     [Page 46]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+    *---------------------------------------------------------------*/
+
+   short encode(   /* (o) Number of bytes encoded */
+       iLBC_Enc_Inst_t *iLBCenc_inst,
+                                   /* (i/o) Encoder instance */
+       short *encoded_data,    /* (o) The encoded bytes */
+       short *data                 /* (i) The signal block to encode*/
+   ){
+       float block[BLOCKL_MAX];
+       int k;
+
+       /* convert signal to float */
+
+       for (k=0; k<iLBCenc_inst->blockl; k++)
+           block[k] = (float)data[k];
+
+       /* do the actual encoding */
+
+       iLBC_encode((unsigned char *)encoded_data, block, iLBCenc_inst);
+
+
+       return (iLBCenc_inst->no_of_bytes);
+   }
+
+   /*----------------------------------------------------------------*
+    *  Decoder interface function
+    *---------------------------------------------------------------*/
+
+   short decode(       /* (o) Number of decoded samples */
+       iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) Decoder instance */
+       short *decoded_data,        /* (o) Decoded signal block*/
+       short *encoded_data,        /* (i) Encoded bytes */
+       short mode                       /* (i) 0=PL, 1=Normal */
+   ){
+       int k;
+       float decblock[BLOCKL_MAX], dtmp;
+
+       /* check if mode is valid */
+
+       if (mode<0 || mode>1) {
+           printf("\nERROR - Wrong mode - 0, 1 allowed\n"); exit(3);}
+
+       /* do actual decoding of block */
+
+       iLBC_decode(decblock, (unsigned char *)encoded_data,
+           iLBCdec_inst, mode);
+
+       /* convert to short */
+
+
+
+Andersen, et al.              Experimental                     [Page 47]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       for (k=0; k<iLBCdec_inst->blockl; k++){
+           dtmp=decblock[k];
+
+           if (dtmp<MIN_SAMPLE)
+               dtmp=MIN_SAMPLE;
+           else if (dtmp>MAX_SAMPLE)
+               dtmp=MAX_SAMPLE;
+           decoded_data[k] = (short) dtmp;
+       }
+
+       return (iLBCdec_inst->blockl);
+   }
+
+   /*---------------------------------------------------------------*
+    *  Main program to test iLBC encoding and decoding
+    *
+    *  Usage:
+    *    exefile_name.exe <infile> <bytefile> <outfile> <channel>
+    *
+    *    <infile>   : Input file, speech for encoder (16-bit pcm file)
+    *    <bytefile> : Bit stream output from the encoder
+    *    <outfile>  : Output file, decoded speech (16-bit pcm file)
+    *    <channel>  : Bit error file, optional (16-bit)
+    *                     1 - Packet received correctly
+    *                     0 - Packet Lost
+    *
+    *--------------------------------------------------------------*/
+
+   int main(int argc, char* argv[])
+   {
+
+       /* Runtime statistics */
+
+       float starttime;
+       float runtime;
+       float outtime;
+
+       FILE *ifileid,*efileid,*ofileid, *cfileid;
+       short data[BLOCKL_MAX];
+       short encoded_data[ILBCNOOFWORDS_MAX], decoded_data[BLOCKL_MAX];
+       int len;
+       short pli, mode;
+       int blockcount = 0;
+       int packetlosscount = 0;
+
+       /* Create structs */
+       iLBC_Enc_Inst_t Enc_Inst;
+       iLBC_Dec_Inst_t Dec_Inst;
+
+
+
+Andersen, et al.              Experimental                     [Page 48]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       /* get arguments and open files */
+
+       if ((argc!=5) && (argc!=6)) {
+           fprintf(stderr,
+           "\n*-----------------------------------------------*\n");
+           fprintf(stderr,
+           "   %s <20,30> input encoded decoded (channel)\n\n",
+               argv[0]);
+           fprintf(stderr,
+           "   mode    : Frame size for the encoding/decoding\n");
+           fprintf(stderr,
+           "                 20 - 20 ms\n");
+           fprintf(stderr,
+           "                 30 - 30 ms\n");
+           fprintf(stderr,
+           "   input   : Speech for encoder (16-bit pcm file)\n");
+           fprintf(stderr,
+           "   encoded : Encoded bit stream\n");
+           fprintf(stderr,
+           "   decoded : Decoded speech (16-bit pcm file)\n");
+           fprintf(stderr,
+           "   channel : Packet loss pattern, optional (16-bit)\n");
+           fprintf(stderr,
+           "                  1 - Packet received correctly\n");
+           fprintf(stderr,
+           "                  0 - Packet Lost\n");
+           fprintf(stderr,
+           "*-----------------------------------------------*\n\n");
+           exit(1);
+       }
+       mode=atoi(argv[1]);
+       if (mode != 20 && mode != 30) {
+           fprintf(stderr,"Wrong mode %s, must be 20, or 30\n",
+               argv[1]);
+           exit(2);
+       }
+       if ( (ifileid=fopen(argv[2],"rb")) == NULL) {
+           fprintf(stderr,"Cannot open input file %s\n", argv[2]);
+           exit(2);}
+       if ( (efileid=fopen(argv[3],"wb")) == NULL) {
+           fprintf(stderr, "Cannot open encoded file %s\n",
+               argv[3]); exit(1);}
+       if ( (ofileid=fopen(argv[4],"wb")) == NULL) {
+           fprintf(stderr, "Cannot open decoded file %s\n",
+               argv[4]); exit(1);}
+       if (argc==6) {
+           if( (cfileid=fopen(argv[5],"rb")) == NULL) {
+               fprintf(stderr, "Cannot open channel file %s\n",
+
+
+
+Andersen, et al.              Experimental                     [Page 49]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+                   argv[5]);
+               exit(1);
+           }
+       } else {
+           cfileid=NULL;
+       }
+
+       /* print info */
+
+       fprintf(stderr, "\n");
+       fprintf(stderr,
+           "*---------------------------------------------------*\n");
+       fprintf(stderr,
+           "*                                                   *\n");
+       fprintf(stderr,
+           "*      iLBC test program                            *\n");
+       fprintf(stderr,
+           "*                                                   *\n");
+       fprintf(stderr,
+           "*                                                   *\n");
+       fprintf(stderr,
+           "*---------------------------------------------------*\n");
+       fprintf(stderr,"\nMode           : %2d ms\n", mode);
+       fprintf(stderr,"Input file     : %s\n", argv[2]);
+       fprintf(stderr,"Encoded file   : %s\n", argv[3]);
+       fprintf(stderr,"Output file    : %s\n", argv[4]);
+       if (argc==6) {
+           fprintf(stderr,"Channel file   : %s\n", argv[5]);
+       }
+       fprintf(stderr,"\n");
+
+       /* Initialization */
+
+       initEncode(&Enc_Inst, mode);
+       initDecode(&Dec_Inst, mode, 1);
+
+       /* Runtime statistics */
+
+       starttime=clock()/(float)CLOCKS_PER_SEC;
+
+       /* loop over input blocks */
+
+       while (fread(data,sizeof(short),Enc_Inst.blockl,ifileid)==
+               Enc_Inst.blockl) {
+
+           blockcount++;
+
+           /* encoding */
+
+
+
+Andersen, et al.              Experimental                     [Page 50]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+           fprintf(stderr, "--- Encoding block %i --- ",blockcount);
+           len=encode(&Enc_Inst, encoded_data, data);
+           fprintf(stderr, "\r");
+
+           /* write byte file */
+
+           fwrite(encoded_data, sizeof(unsigned char), len, efileid);
+
+           /* get channel data if provided */
+           if (argc==6) {
+               if (fread(&pli, sizeof(short), 1, cfileid)) {
+                   if ((pli!=0)&&(pli!=1)) {
+                       fprintf(stderr, "Error in channel file\n");
+                       exit(0);
+                   }
+                   if (pli==0) {
+                       /* Packet loss -> remove info from frame */
+                       memset(encoded_data, 0,
+                           sizeof(short)*ILBCNOOFWORDS_MAX);
+                       packetlosscount++;
+                   }
+               } else {
+                   fprintf(stderr, "Error. Channel file too short\n");
+                   exit(0);
+               }
+           } else {
+               pli=1;
+           }
+
+           /* decoding */
+
+           fprintf(stderr, "--- Decoding block %i --- ",blockcount);
+
+           len=decode(&Dec_Inst, decoded_data, encoded_data, pli);
+           fprintf(stderr, "\r");
+
+           /* write output file */
+
+           fwrite(decoded_data,sizeof(short),len,ofileid);
+       }
+
+       /* Runtime statistics */
+
+       runtime = (float)(clock()/(float)CLOCKS_PER_SEC-starttime);
+       outtime = (float)((float)blockcount*(float)mode/1000.0);
+       printf("\n\nLength of speech file: %.1f s\n", outtime);
+       printf("Packet loss          : %.1f%%\n",
+           100.0*(float)packetlosscount/(float)blockcount);
+
+
+
+Andersen, et al.              Experimental                     [Page 51]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       printf("Time to run iLBC     :");
+       printf(" %.1f s (%.1f %% of realtime)\n\n", runtime,
+           (100*runtime/outtime));
+
+       /* close files */
+
+       fclose(ifileid);  fclose(efileid); fclose(ofileid);
+       if (argc==6) {
+           fclose(cfileid);
+       }
+       return(0);
+   }
+
+A.2.  iLBC_encode.h
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       iLBC_encode.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_ILBCENCODE_H
+   #define __iLBC_ILBCENCODE_H
+
+   #include "iLBC_define.h"
+
+   short initEncode(                   /* (o) Number of bytes
+                                              encoded */
+       iLBC_Enc_Inst_t *iLBCenc_inst,  /* (i/o) Encoder instance */
+       int mode                    /* (i) frame size mode */
+   );
+
+   void iLBC_encode(
+
+       unsigned char *bytes,           /* (o) encoded data bits iLBC */
+       float *block,                   /* (o) speech vector to
+                                              encode */
+       iLBC_Enc_Inst_t *iLBCenc_inst   /* (i/o) the general encoder
+                                              state */
+   );
+
+   #endif
+
+
+
+
+Andersen, et al.              Experimental                     [Page 52]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+A.3.  iLBC_encode.c
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       iLBC_encode.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <math.h>
+   #include <stdlib.h>
+   #include <string.h>
+
+   #include "iLBC_define.h"
+   #include "LPCencode.h"
+   #include "FrameClassify.h"
+   #include "StateSearchW.h"
+   #include "StateConstructW.h"
+   #include "helpfun.h"
+   #include "constants.h"
+   #include "packing.h"
+   #include "iCBSearch.h"
+   #include "iCBConstruct.h"
+   #include "hpInput.h"
+   #include "anaFilter.h"
+   #include "syntFilter.h"
+
+   /*----------------------------------------------------------------*
+    *  Initiation of encoder instance.
+    *---------------------------------------------------------------*/
+
+   short initEncode(                   /* (o) Number of bytes
+                                              encoded */
+       iLBC_Enc_Inst_t *iLBCenc_inst,  /* (i/o) Encoder instance */
+       int mode                    /* (i) frame size mode */
+   ){
+       iLBCenc_inst->mode = mode;
+       if (mode==30) {
+           iLBCenc_inst->blockl = BLOCKL_30MS;
+           iLBCenc_inst->nsub = NSUB_30MS;
+           iLBCenc_inst->nasub = NASUB_30MS;
+           iLBCenc_inst->lpc_n = LPC_N_30MS;
+           iLBCenc_inst->no_of_bytes = NO_OF_BYTES_30MS;
+           iLBCenc_inst->no_of_words = NO_OF_WORDS_30MS;
+
+
+
+Andersen, et al.              Experimental                     [Page 53]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+           iLBCenc_inst->state_short_len=STATE_SHORT_LEN_30MS;
+           /* ULP init */
+           iLBCenc_inst->ULP_inst=&ULP_30msTbl;
+       }
+       else if (mode==20) {
+           iLBCenc_inst->blockl = BLOCKL_20MS;
+           iLBCenc_inst->nsub = NSUB_20MS;
+           iLBCenc_inst->nasub = NASUB_20MS;
+           iLBCenc_inst->lpc_n = LPC_N_20MS;
+           iLBCenc_inst->no_of_bytes = NO_OF_BYTES_20MS;
+           iLBCenc_inst->no_of_words = NO_OF_WORDS_20MS;
+           iLBCenc_inst->state_short_len=STATE_SHORT_LEN_20MS;
+           /* ULP init */
+           iLBCenc_inst->ULP_inst=&ULP_20msTbl;
+       }
+       else {
+           exit(2);
+       }
+
+       memset((*iLBCenc_inst).anaMem, 0,
+           LPC_FILTERORDER*sizeof(float));
+       memcpy((*iLBCenc_inst).lsfold, lsfmeanTbl,
+           LPC_FILTERORDER*sizeof(float));
+       memcpy((*iLBCenc_inst).lsfdeqold, lsfmeanTbl,
+           LPC_FILTERORDER*sizeof(float));
+       memset((*iLBCenc_inst).lpc_buffer, 0,
+           (LPC_LOOKBACK+BLOCKL_MAX)*sizeof(float));
+       memset((*iLBCenc_inst).hpimem, 0, 4*sizeof(float));
+
+       return (iLBCenc_inst->no_of_bytes);
+   }
+
+   /*----------------------------------------------------------------*
+    *  main encoder function
+    *---------------------------------------------------------------*/
+
+   void iLBC_encode(
+       unsigned char *bytes,           /* (o) encoded data bits iLBC */
+       float *block,                   /* (o) speech vector to
+                                              encode */
+       iLBC_Enc_Inst_t *iLBCenc_inst   /* (i/o) the general encoder
+                                              state */
+   ){
+
+       float data[BLOCKL_MAX];
+       float residual[BLOCKL_MAX], reverseResidual[BLOCKL_MAX];
+
+       int start, idxForMax, idxVec[STATE_LEN];
+
+
+
+Andersen, et al.              Experimental                     [Page 54]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       float reverseDecresidual[BLOCKL_MAX], mem[CB_MEML];
+       int n, k, meml_gotten, Nfor, Nback, i, pos;
+       int gain_index[CB_NSTAGES*NASUB_MAX],
+           extra_gain_index[CB_NSTAGES];
+       int cb_index[CB_NSTAGES*NASUB_MAX],extra_cb_index[CB_NSTAGES];
+       int lsf_i[LSF_NSPLIT*LPC_N_MAX];
+       unsigned char *pbytes;
+       int diff, start_pos, state_first;
+       float en1, en2;
+       int index, ulp, firstpart;
+       int subcount, subframe;
+       float weightState[LPC_FILTERORDER];
+       float syntdenum[NSUB_MAX*(LPC_FILTERORDER+1)];
+       float weightdenum[NSUB_MAX*(LPC_FILTERORDER+1)];
+       float decresidual[BLOCKL_MAX];
+
+       /* high pass filtering of input signal if such is not done
+              prior to calling this function */
+
+       hpInput(block, iLBCenc_inst->blockl,
+                   data, (*iLBCenc_inst).hpimem);
+
+       /* otherwise simply copy */
+
+       /*memcpy(data,block,iLBCenc_inst->blockl*sizeof(float));*/
+
+       /* LPC of hp filtered input data */
+
+       LPCencode(syntdenum, weightdenum, lsf_i, data, iLBCenc_inst);
+
+
+       /* inverse filter to get residual */
+
+       for (n=0; n<iLBCenc_inst->nsub; n++) {
+           anaFilter(&data[n*SUBL], &syntdenum[n*(LPC_FILTERORDER+1)],
+               SUBL, &residual[n*SUBL], iLBCenc_inst->anaMem);
+       }
+
+       /* find state location */
+
+       start = FrameClassify(iLBCenc_inst, residual);
+
+       /* check if state should be in first or last part of the
+       two subframes */
+
+       diff = STATE_LEN - iLBCenc_inst->state_short_len;
+       en1 = 0;
+       index = (start-1)*SUBL;
+
+
+
+Andersen, et al.              Experimental                     [Page 55]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       for (i = 0; i < iLBCenc_inst->state_short_len; i++) {
+           en1 += residual[index+i]*residual[index+i];
+       }
+       en2 = 0;
+       index = (start-1)*SUBL+diff;
+       for (i = 0; i < iLBCenc_inst->state_short_len; i++) {
+           en2 += residual[index+i]*residual[index+i];
+       }
+
+
+       if (en1 > en2) {
+           state_first = 1;
+           start_pos = (start-1)*SUBL;
+       } else {
+           state_first = 0;
+           start_pos = (start-1)*SUBL + diff;
+       }
+
+       /* scalar quantization of state */
+
+       StateSearchW(iLBCenc_inst, &residual[start_pos],
+           &syntdenum[(start-1)*(LPC_FILTERORDER+1)],
+           &weightdenum[(start-1)*(LPC_FILTERORDER+1)], &idxForMax,
+           idxVec, iLBCenc_inst->state_short_len, state_first);
+
+       StateConstructW(idxForMax, idxVec,
+           &syntdenum[(start-1)*(LPC_FILTERORDER+1)],
+           &decresidual[start_pos], iLBCenc_inst->state_short_len);
+
+       /* predictive quantization in state */
+
+       if (state_first) { /* put adaptive part in the end */
+
+           /* setup memory */
+
+           memset(mem, 0,
+               (CB_MEML-iLBCenc_inst->state_short_len)*sizeof(float));
+           memcpy(mem+CB_MEML-iLBCenc_inst->state_short_len,
+               decresidual+start_pos,
+               iLBCenc_inst->state_short_len*sizeof(float));
+           memset(weightState, 0, LPC_FILTERORDER*sizeof(float));
+
+           /* encode sub-frames */
+
+           iCBSearch(iLBCenc_inst, extra_cb_index, extra_gain_index,
+               &residual[start_pos+iLBCenc_inst->state_short_len],
+               mem+CB_MEML-stMemLTbl,
+               stMemLTbl, diff, CB_NSTAGES,
+
+
+
+Andersen, et al.              Experimental                     [Page 56]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+               &weightdenum[start*(LPC_FILTERORDER+1)],
+               weightState, 0);
+
+           /* construct decoded vector */
+
+           iCBConstruct(
+               &decresidual[start_pos+iLBCenc_inst->state_short_len],
+               extra_cb_index, extra_gain_index,
+               mem+CB_MEML-stMemLTbl,
+               stMemLTbl, diff, CB_NSTAGES);
+
+       }
+       else { /* put adaptive part in the beginning */
+
+           /* create reversed vectors for prediction */
+
+           for (k=0; k<diff; k++) {
+               reverseResidual[k] = residual[(start+1)*SUBL-1
+                   -(k+iLBCenc_inst->state_short_len)];
+           }
+
+           /* setup memory */
+
+           meml_gotten = iLBCenc_inst->state_short_len;
+           for (k=0; k<meml_gotten; k++) {
+               mem[CB_MEML-1-k] = decresidual[start_pos + k];
+           }
+           memset(mem, 0, (CB_MEML-k)*sizeof(float));
+           memset(weightState, 0, LPC_FILTERORDER*sizeof(float));
+
+           /* encode sub-frames */
+
+           iCBSearch(iLBCenc_inst, extra_cb_index, extra_gain_index,
+               reverseResidual, mem+CB_MEML-stMemLTbl, stMemLTbl,
+               diff, CB_NSTAGES,
+               &weightdenum[(start-1)*(LPC_FILTERORDER+1)],
+               weightState, 0);
+
+           /* construct decoded vector */
+
+           iCBConstruct(reverseDecresidual, extra_cb_index,
+               extra_gain_index, mem+CB_MEML-stMemLTbl, stMemLTbl,
+               diff, CB_NSTAGES);
+
+           /* get decoded residual from reversed vector */
+
+           for (k=0; k<diff; k++) {
+               decresidual[start_pos-1-k] = reverseDecresidual[k];
+
+
+
+Andersen, et al.              Experimental                     [Page 57]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+           }
+       }
+
+       /* counter for predicted sub-frames */
+
+       subcount=0;
+
+       /* forward prediction of sub-frames */
+
+       Nfor = iLBCenc_inst->nsub-start-1;
+
+
+       if ( Nfor > 0 ) {
+
+           /* setup memory */
+
+           memset(mem, 0, (CB_MEML-STATE_LEN)*sizeof(float));
+           memcpy(mem+CB_MEML-STATE_LEN, decresidual+(start-1)*SUBL,
+               STATE_LEN*sizeof(float));
+           memset(weightState, 0, LPC_FILTERORDER*sizeof(float));
+
+           /* loop over sub-frames to encode */
+
+           for (subframe=0; subframe<Nfor; subframe++) {
+
+               /* encode sub-frame */
+
+               iCBSearch(iLBCenc_inst, cb_index+subcount*CB_NSTAGES,
+                   gain_index+subcount*CB_NSTAGES,
+                   &residual[(start+1+subframe)*SUBL],
+                   mem+CB_MEML-memLfTbl[subcount],
+                   memLfTbl[subcount], SUBL, CB_NSTAGES,
+                   &weightdenum[(start+1+subframe)*
+                               (LPC_FILTERORDER+1)],
+                   weightState, subcount+1);
+
+               /* construct decoded vector */
+
+               iCBConstruct(&decresidual[(start+1+subframe)*SUBL],
+                   cb_index+subcount*CB_NSTAGES,
+                   gain_index+subcount*CB_NSTAGES,
+                   mem+CB_MEML-memLfTbl[subcount],
+                   memLfTbl[subcount], SUBL, CB_NSTAGES);
+
+               /* update memory */
+
+               memcpy(mem, mem+SUBL, (CB_MEML-SUBL)*sizeof(float));
+               memcpy(mem+CB_MEML-SUBL,
+
+
+
+Andersen, et al.              Experimental                     [Page 58]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+                   &decresidual[(start+1+subframe)*SUBL],
+                   SUBL*sizeof(float));
+               memset(weightState, 0, LPC_FILTERORDER*sizeof(float));
+
+               subcount++;
+           }
+       }
+
+
+       /* backward prediction of sub-frames */
+
+       Nback = start-1;
+
+
+       if ( Nback > 0 ) {
+
+           /* create reverse order vectors */
+
+           for (n=0; n<Nback; n++) {
+               for (k=0; k<SUBL; k++) {
+                   reverseResidual[n*SUBL+k] =
+                       residual[(start-1)*SUBL-1-n*SUBL-k];
+                   reverseDecresidual[n*SUBL+k] =
+                       decresidual[(start-1)*SUBL-1-n*SUBL-k];
+               }
+           }
+
+           /* setup memory */
+
+           meml_gotten = SUBL*(iLBCenc_inst->nsub+1-start);
+
+
+           if ( meml_gotten > CB_MEML ) {
+               meml_gotten=CB_MEML;
+           }
+           for (k=0; k<meml_gotten; k++) {
+               mem[CB_MEML-1-k] = decresidual[(start-1)*SUBL + k];
+           }
+           memset(mem, 0, (CB_MEML-k)*sizeof(float));
+           memset(weightState, 0, LPC_FILTERORDER*sizeof(float));
+
+           /* loop over sub-frames to encode */
+
+           for (subframe=0; subframe<Nback; subframe++) {
+
+               /* encode sub-frame */
+
+               iCBSearch(iLBCenc_inst, cb_index+subcount*CB_NSTAGES,
+
+
+
+Andersen, et al.              Experimental                     [Page 59]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+                   gain_index+subcount*CB_NSTAGES,
+                   &reverseResidual[subframe*SUBL],
+                   mem+CB_MEML-memLfTbl[subcount],
+                   memLfTbl[subcount], SUBL, CB_NSTAGES,
+                   &weightdenum[(start-2-subframe)*
+                               (LPC_FILTERORDER+1)],
+                   weightState, subcount+1);
+
+               /* construct decoded vector */
+
+               iCBConstruct(&reverseDecresidual[subframe*SUBL],
+                   cb_index+subcount*CB_NSTAGES,
+                   gain_index+subcount*CB_NSTAGES,
+                   mem+CB_MEML-memLfTbl[subcount],
+                   memLfTbl[subcount], SUBL, CB_NSTAGES);
+
+               /* update memory */
+
+               memcpy(mem, mem+SUBL, (CB_MEML-SUBL)*sizeof(float));
+               memcpy(mem+CB_MEML-SUBL,
+                   &reverseDecresidual[subframe*SUBL],
+                   SUBL*sizeof(float));
+               memset(weightState, 0, LPC_FILTERORDER*sizeof(float));
+
+               subcount++;
+
+           }
+
+           /* get decoded residual from reversed vector */
+
+           for (i=0; i<SUBL*Nback; i++) {
+               decresidual[SUBL*Nback - i - 1] =
+                   reverseDecresidual[i];
+           }
+       }
+       /* end encoding part */
+
+       /* adjust index */
+       index_conv_enc(cb_index);
+
+       /* pack bytes */
+
+       pbytes=bytes;
+       pos=0;
+
+       /* loop over the 3 ULP classes */
+
+       for (ulp=0; ulp<3; ulp++) {
+
+
+
+Andersen, et al.              Experimental                     [Page 60]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+
+           /* LSF */
+           for (k=0; k<LSF_NSPLIT*iLBCenc_inst->lpc_n; k++) {
+               packsplit(&lsf_i[k], &firstpart, &lsf_i[k],
+                   iLBCenc_inst->ULP_inst->lsf_bits[k][ulp],
+                   iLBCenc_inst->ULP_inst->lsf_bits[k][ulp]+
+                   iLBCenc_inst->ULP_inst->lsf_bits[k][ulp+1]+
+                   iLBCenc_inst->ULP_inst->lsf_bits[k][ulp+2]);
+               dopack( &pbytes, firstpart,
+                   iLBCenc_inst->ULP_inst->lsf_bits[k][ulp], &pos);
+           }
+
+           /* Start block info */
+
+           packsplit(&start, &firstpart, &start,
+               iLBCenc_inst->ULP_inst->start_bits[ulp],
+               iLBCenc_inst->ULP_inst->start_bits[ulp]+
+               iLBCenc_inst->ULP_inst->start_bits[ulp+1]+
+               iLBCenc_inst->ULP_inst->start_bits[ulp+2]);
+           dopack( &pbytes, firstpart,
+               iLBCenc_inst->ULP_inst->start_bits[ulp], &pos);
+
+           packsplit(&state_first, &firstpart, &state_first,
+               iLBCenc_inst->ULP_inst->startfirst_bits[ulp],
+               iLBCenc_inst->ULP_inst->startfirst_bits[ulp]+
+               iLBCenc_inst->ULP_inst->startfirst_bits[ulp+1]+
+               iLBCenc_inst->ULP_inst->startfirst_bits[ulp+2]);
+           dopack( &pbytes, firstpart,
+               iLBCenc_inst->ULP_inst->startfirst_bits[ulp], &pos);
+
+           packsplit(&idxForMax, &firstpart, &idxForMax,
+               iLBCenc_inst->ULP_inst->scale_bits[ulp],
+               iLBCenc_inst->ULP_inst->scale_bits[ulp]+
+               iLBCenc_inst->ULP_inst->scale_bits[ulp+1]+
+               iLBCenc_inst->ULP_inst->scale_bits[ulp+2]);
+           dopack( &pbytes, firstpart,
+               iLBCenc_inst->ULP_inst->scale_bits[ulp], &pos);
+
+           for (k=0; k<iLBCenc_inst->state_short_len; k++) {
+               packsplit(idxVec+k, &firstpart, idxVec+k,
+                   iLBCenc_inst->ULP_inst->state_bits[ulp],
+                   iLBCenc_inst->ULP_inst->state_bits[ulp]+
+                   iLBCenc_inst->ULP_inst->state_bits[ulp+1]+
+                   iLBCenc_inst->ULP_inst->state_bits[ulp+2]);
+               dopack( &pbytes, firstpart,
+                   iLBCenc_inst->ULP_inst->state_bits[ulp], &pos);
+           }
+
+
+
+
+Andersen, et al.              Experimental                     [Page 61]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+           /* 23/22 (20ms/30ms) sample block */
+
+           for (k=0;k<CB_NSTAGES;k++) {
+               packsplit(extra_cb_index+k, &firstpart,
+                   extra_cb_index+k,
+                   iLBCenc_inst->ULP_inst->extra_cb_index[k][ulp],
+                   iLBCenc_inst->ULP_inst->extra_cb_index[k][ulp]+
+                   iLBCenc_inst->ULP_inst->extra_cb_index[k][ulp+1]+
+                   iLBCenc_inst->ULP_inst->extra_cb_index[k][ulp+2]);
+               dopack( &pbytes, firstpart,
+                   iLBCenc_inst->ULP_inst->extra_cb_index[k][ulp],
+                   &pos);
+           }
+
+           for (k=0;k<CB_NSTAGES;k++) {
+               packsplit(extra_gain_index+k, &firstpart,
+                   extra_gain_index+k,
+                   iLBCenc_inst->ULP_inst->extra_cb_gain[k][ulp],
+                   iLBCenc_inst->ULP_inst->extra_cb_gain[k][ulp]+
+                   iLBCenc_inst->ULP_inst->extra_cb_gain[k][ulp+1]+
+                   iLBCenc_inst->ULP_inst->extra_cb_gain[k][ulp+2]);
+               dopack( &pbytes, firstpart,
+                   iLBCenc_inst->ULP_inst->extra_cb_gain[k][ulp],
+                   &pos);
+           }
+
+           /* The two/four (20ms/30ms) 40 sample sub-blocks */
+
+           for (i=0; i<iLBCenc_inst->nasub; i++) {
+               for (k=0; k<CB_NSTAGES; k++) {
+                   packsplit(cb_index+i*CB_NSTAGES+k, &firstpart,
+                       cb_index+i*CB_NSTAGES+k,
+                       iLBCenc_inst->ULP_inst->cb_index[i][k][ulp],
+                       iLBCenc_inst->ULP_inst->cb_index[i][k][ulp]+
+                       iLBCenc_inst->ULP_inst->cb_index[i][k][ulp+1]+
+                       iLBCenc_inst->ULP_inst->cb_index[i][k][ulp+2]);
+                   dopack( &pbytes, firstpart,
+                       iLBCenc_inst->ULP_inst->cb_index[i][k][ulp],
+                       &pos);
+               }
+           }
+
+           for (i=0; i<iLBCenc_inst->nasub; i++) {
+               for (k=0; k<CB_NSTAGES; k++) {
+                   packsplit(gain_index+i*CB_NSTAGES+k, &firstpart,
+                       gain_index+i*CB_NSTAGES+k,
+                       iLBCenc_inst->ULP_inst->cb_gain[i][k][ulp],
+                       iLBCenc_inst->ULP_inst->cb_gain[i][k][ulp]+
+
+
+
+Andersen, et al.              Experimental                     [Page 62]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+                       iLBCenc_inst->ULP_inst->cb_gain[i][k][ulp+1]+
+                       iLBCenc_inst->ULP_inst->cb_gain[i][k][ulp+2]);
+                   dopack( &pbytes, firstpart,
+                       iLBCenc_inst->ULP_inst->cb_gain[i][k][ulp],
+                       &pos);
+               }
+           }
+       }
+
+       /* set the last bit to zero (otherwise the decoder
+          will treat it as a lost frame) */
+       dopack( &pbytes, 0, 1, &pos);
+   }
+
+A.4.  iLBC_decode.h
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       iLBC_decode.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_ILBCDECODE_H
+   #define __iLBC_ILBCDECODE_H
+
+   #include "iLBC_define.h"
+
+   short initDecode(                   /* (o) Number of decoded
+                                              samples */
+       iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) Decoder instance */
+       int mode,                       /* (i) frame size mode */
+       int use_enhancer                /* (i) 1 to use enhancer
+                                              0 to run without
+                                                enhancer */
+   );
+
+   void iLBC_decode(
+       float *decblock,            /* (o) decoded signal block */
+       unsigned char *bytes,           /* (i) encoded signal bits */
+       iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) the decoder state
+                                                structure */
+       int mode                    /* (i) 0: bad packet, PLC,
+                                              1: normal */
+
+
+
+Andersen, et al.              Experimental                     [Page 63]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   );
+
+   #endif
+
+A.5.  iLBC_decode.c
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       iLBC_decode.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <math.h>
+   #include <stdlib.h>
+
+   #include "iLBC_define.h"
+   #include "StateConstructW.h"
+   #include "LPCdecode.h"
+   #include "iCBConstruct.h"
+   #include "doCPLC.h"
+   #include "helpfun.h"
+   #include "constants.h"
+   #include "packing.h"
+   #include "string.h"
+   #include "enhancer.h"
+   #include "hpOutput.h"
+   #include "syntFilter.h"
+
+   /*----------------------------------------------------------------*
+    *  Initiation of decoder instance.
+    *---------------------------------------------------------------*/
+
+   short initDecode(                   /* (o) Number of decoded
+                                              samples */
+       iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) Decoder instance */
+       int mode,                       /* (i) frame size mode */
+       int use_enhancer                /* (i) 1 to use enhancer
+                                              0 to run without
+                                                enhancer */
+   ){
+       int i;
+
+       iLBCdec_inst->mode = mode;
+
+
+
+Andersen, et al.              Experimental                     [Page 64]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       if (mode==30) {
+           iLBCdec_inst->blockl = BLOCKL_30MS;
+           iLBCdec_inst->nsub = NSUB_30MS;
+           iLBCdec_inst->nasub = NASUB_30MS;
+           iLBCdec_inst->lpc_n = LPC_N_30MS;
+           iLBCdec_inst->no_of_bytes = NO_OF_BYTES_30MS;
+           iLBCdec_inst->no_of_words = NO_OF_WORDS_30MS;
+           iLBCdec_inst->state_short_len=STATE_SHORT_LEN_30MS;
+           /* ULP init */
+           iLBCdec_inst->ULP_inst=&ULP_30msTbl;
+       }
+       else if (mode==20) {
+           iLBCdec_inst->blockl = BLOCKL_20MS;
+           iLBCdec_inst->nsub = NSUB_20MS;
+           iLBCdec_inst->nasub = NASUB_20MS;
+           iLBCdec_inst->lpc_n = LPC_N_20MS;
+           iLBCdec_inst->no_of_bytes = NO_OF_BYTES_20MS;
+           iLBCdec_inst->no_of_words = NO_OF_WORDS_20MS;
+           iLBCdec_inst->state_short_len=STATE_SHORT_LEN_20MS;
+           /* ULP init */
+           iLBCdec_inst->ULP_inst=&ULP_20msTbl;
+       }
+       else {
+           exit(2);
+       }
+
+       memset(iLBCdec_inst->syntMem, 0,
+           LPC_FILTERORDER*sizeof(float));
+       memcpy((*iLBCdec_inst).lsfdeqold, lsfmeanTbl,
+           LPC_FILTERORDER*sizeof(float));
+
+       memset(iLBCdec_inst->old_syntdenum, 0,
+           ((LPC_FILTERORDER + 1)*NSUB_MAX)*sizeof(float));
+       for (i=0; i<NSUB_MAX; i++)
+           iLBCdec_inst->old_syntdenum[i*(LPC_FILTERORDER+1)]=1.0;
+
+       iLBCdec_inst->last_lag = 20;
+
+       iLBCdec_inst->prevLag = 120;
+       iLBCdec_inst->per = 0.0;
+       iLBCdec_inst->consPLICount = 0;
+       iLBCdec_inst->prevPLI = 0;
+       iLBCdec_inst->prevLpc[0] = 1.0;
+       memset(iLBCdec_inst->prevLpc+1,0,
+           LPC_FILTERORDER*sizeof(float));
+       memset(iLBCdec_inst->prevResidual, 0, BLOCKL_MAX*sizeof(float));
+       iLBCdec_inst->seed=777;
+
+
+
+
+Andersen, et al.              Experimental                     [Page 65]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       memset(iLBCdec_inst->hpomem, 0, 4*sizeof(float));
+
+       iLBCdec_inst->use_enhancer = use_enhancer;
+       memset(iLBCdec_inst->enh_buf, 0, ENH_BUFL*sizeof(float));
+       for (i=0;i<ENH_NBLOCKS_TOT;i++)
+           iLBCdec_inst->enh_period[i]=(float)40.0;
+
+       iLBCdec_inst->prev_enh_pl = 0;
+
+       return (iLBCdec_inst->blockl);
+   }
+
+   /*----------------------------------------------------------------*
+    *  frame residual decoder function (subrutine to iLBC_decode)
+    *---------------------------------------------------------------*/
+
+   void Decode(
+       iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) the decoder state
+                                                structure */
+       float *decresidual,             /* (o) decoded residual frame */
+       int start,                      /* (i) location of start
+                                              state */
+       int idxForMax,                  /* (i) codebook index for the
+                                              maximum value */
+       int *idxVec,                /* (i) codebook indexes for the
+                                              samples  in the start
+                                              state */
+       float *syntdenum,               /* (i) the decoded synthesis
+                                              filter coefficients */
+       int *cb_index,                  /* (i) the indexes for the
+                                              adaptive codebook */
+       int *gain_index,            /* (i) the indexes for the
+                                              corresponding gains */
+       int *extra_cb_index,        /* (i) the indexes for the
+                                              adaptive codebook part
+                                              of start state */
+       int *extra_gain_index,          /* (i) the indexes for the
+                                              corresponding gains */
+       int state_first                 /* (i) 1 if non adaptive part
+                                              of start state comes
+                                              first 0 if that part
+                                              comes last */
+   ){
+       float reverseDecresidual[BLOCKL_MAX], mem[CB_MEML];
+       int k, meml_gotten, Nfor, Nback, i;
+       int diff, start_pos;
+       int subcount, subframe;
+
+
+
+
+Andersen, et al.              Experimental                     [Page 66]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       diff = STATE_LEN - iLBCdec_inst->state_short_len;
+
+       if (state_first == 1) {
+           start_pos = (start-1)*SUBL;
+       } else {
+           start_pos = (start-1)*SUBL + diff;
+       }
+
+       /* decode scalar part of start state */
+
+       StateConstructW(idxForMax, idxVec,
+           &syntdenum[(start-1)*(LPC_FILTERORDER+1)],
+           &decresidual[start_pos], iLBCdec_inst->state_short_len);
+
+
+       if (state_first) { /* put adaptive part in the end */
+
+           /* setup memory */
+
+           memset(mem, 0,
+               (CB_MEML-iLBCdec_inst->state_short_len)*sizeof(float));
+           memcpy(mem+CB_MEML-iLBCdec_inst->state_short_len,
+               decresidual+start_pos,
+               iLBCdec_inst->state_short_len*sizeof(float));
+
+           /* construct decoded vector */
+
+           iCBConstruct(
+               &decresidual[start_pos+iLBCdec_inst->state_short_len],
+               extra_cb_index, extra_gain_index, mem+CB_MEML-stMemLTbl,
+               stMemLTbl, diff, CB_NSTAGES);
+
+       }
+       else {/* put adaptive part in the beginning */
+
+           /* create reversed vectors for prediction */
+
+           for (k=0; k<diff; k++) {
+               reverseDecresidual[k] =
+                   decresidual[(start+1)*SUBL-1-
+                           (k+iLBCdec_inst->state_short_len)];
+           }
+
+           /* setup memory */
+
+           meml_gotten = iLBCdec_inst->state_short_len;
+           for (k=0; k<meml_gotten; k++){
+               mem[CB_MEML-1-k] = decresidual[start_pos + k];
+
+
+
+Andersen, et al.              Experimental                     [Page 67]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+           }
+           memset(mem, 0, (CB_MEML-k)*sizeof(float));
+
+           /* construct decoded vector */
+
+           iCBConstruct(reverseDecresidual, extra_cb_index,
+               extra_gain_index, mem+CB_MEML-stMemLTbl, stMemLTbl,
+               diff, CB_NSTAGES);
+
+           /* get decoded residual from reversed vector */
+
+           for (k=0; k<diff; k++) {
+               decresidual[start_pos-1-k] = reverseDecresidual[k];
+           }
+       }
+
+       /* counter for predicted sub-frames */
+
+       subcount=0;
+
+       /* forward prediction of sub-frames */
+
+       Nfor = iLBCdec_inst->nsub-start-1;
+
+       if ( Nfor > 0 ){
+
+           /* setup memory */
+
+           memset(mem, 0, (CB_MEML-STATE_LEN)*sizeof(float));
+           memcpy(mem+CB_MEML-STATE_LEN, decresidual+(start-1)*SUBL,
+               STATE_LEN*sizeof(float));
+
+           /* loop over sub-frames to encode */
+
+           for (subframe=0; subframe<Nfor; subframe++) {
+
+               /* construct decoded vector */
+
+               iCBConstruct(&decresidual[(start+1+subframe)*SUBL],
+                   cb_index+subcount*CB_NSTAGES,
+                   gain_index+subcount*CB_NSTAGES,
+                   mem+CB_MEML-memLfTbl[subcount],
+                   memLfTbl[subcount], SUBL, CB_NSTAGES);
+
+               /* update memory */
+
+               memcpy(mem, mem+SUBL, (CB_MEML-SUBL)*sizeof(float));
+               memcpy(mem+CB_MEML-SUBL,
+
+
+
+Andersen, et al.              Experimental                     [Page 68]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+                   &decresidual[(start+1+subframe)*SUBL],
+                   SUBL*sizeof(float));
+
+               subcount++;
+
+           }
+
+       }
+
+       /* backward prediction of sub-frames */
+
+       Nback = start-1;
+
+       if ( Nback > 0 ) {
+
+           /* setup memory */
+
+           meml_gotten = SUBL*(iLBCdec_inst->nsub+1-start);
+
+           if ( meml_gotten > CB_MEML ) {
+               meml_gotten=CB_MEML;
+           }
+           for (k=0; k<meml_gotten; k++) {
+               mem[CB_MEML-1-k] = decresidual[(start-1)*SUBL + k];
+           }
+           memset(mem, 0, (CB_MEML-k)*sizeof(float));
+
+           /* loop over subframes to decode */
+
+           for (subframe=0; subframe<Nback; subframe++) {
+
+               /* construct decoded vector */
+
+               iCBConstruct(&reverseDecresidual[subframe*SUBL],
+                   cb_index+subcount*CB_NSTAGES,
+                   gain_index+subcount*CB_NSTAGES,
+                   mem+CB_MEML-memLfTbl[subcount], memLfTbl[subcount],
+                   SUBL, CB_NSTAGES);
+
+               /* update memory */
+
+               memcpy(mem, mem+SUBL, (CB_MEML-SUBL)*sizeof(float));
+               memcpy(mem+CB_MEML-SUBL,
+                   &reverseDecresidual[subframe*SUBL],
+                   SUBL*sizeof(float));
+
+               subcount++;
+           }
+
+
+
+Andersen, et al.              Experimental                     [Page 69]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+           /* get decoded residual from reversed vector */
+
+           for (i=0; i<SUBL*Nback; i++)
+               decresidual[SUBL*Nback - i - 1] =
+               reverseDecresidual[i];
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  main decoder function
+    *---------------------------------------------------------------*/
+
+   void iLBC_decode(
+       float *decblock,            /* (o) decoded signal block */
+       unsigned char *bytes,           /* (i) encoded signal bits */
+       iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) the decoder state
+                                                structure */
+       int mode                    /* (i) 0: bad packet, PLC,
+                                              1: normal */
+   ){
+       float data[BLOCKL_MAX];
+       float lsfdeq[LPC_FILTERORDER*LPC_N_MAX];
+       float PLCresidual[BLOCKL_MAX], PLClpc[LPC_FILTERORDER + 1];
+       float zeros[BLOCKL_MAX], one[LPC_FILTERORDER + 1];
+       int k, i, start, idxForMax, pos, lastpart, ulp;
+       int lag, ilag;
+       float cc, maxcc;
+       int idxVec[STATE_LEN];
+       int check;
+       int gain_index[NASUB_MAX*CB_NSTAGES],
+           extra_gain_index[CB_NSTAGES];
+       int cb_index[CB_NSTAGES*NASUB_MAX], extra_cb_index[CB_NSTAGES];
+       int lsf_i[LSF_NSPLIT*LPC_N_MAX];
+       int state_first;
+       int last_bit;
+       unsigned char *pbytes;
+       float weightdenum[(LPC_FILTERORDER + 1)*NSUB_MAX];
+       int order_plus_one;
+       float syntdenum[NSUB_MAX*(LPC_FILTERORDER+1)];
+       float decresidual[BLOCKL_MAX];
+
+       if (mode>0) { /* the data are good */
+
+           /* decode data */
+
+           pbytes=bytes;
+           pos=0;
+
+
+
+
+Andersen, et al.              Experimental                     [Page 70]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+           /* Set everything to zero before decoding */
+
+           for (k=0; k<LSF_NSPLIT*LPC_N_MAX; k++) {
+               lsf_i[k]=0;
+           }
+           start=0;
+           state_first=0;
+           idxForMax=0;
+           for (k=0; k<iLBCdec_inst->state_short_len; k++) {
+               idxVec[k]=0;
+           }
+           for (k=0; k<CB_NSTAGES; k++) {
+               extra_cb_index[k]=0;
+           }
+           for (k=0; k<CB_NSTAGES; k++) {
+               extra_gain_index[k]=0;
+           }
+           for (i=0; i<iLBCdec_inst->nasub; i++) {
+               for (k=0; k<CB_NSTAGES; k++) {
+                   cb_index[i*CB_NSTAGES+k]=0;
+               }
+           }
+           for (i=0; i<iLBCdec_inst->nasub; i++) {
+               for (k=0; k<CB_NSTAGES; k++) {
+                   gain_index[i*CB_NSTAGES+k]=0;
+               }
+           }
+
+           /* loop over ULP classes */
+
+           for (ulp=0; ulp<3; ulp++) {
+
+               /* LSF */
+               for (k=0; k<LSF_NSPLIT*iLBCdec_inst->lpc_n; k++){
+                   unpack( &pbytes, &lastpart,
+                       iLBCdec_inst->ULP_inst->lsf_bits[k][ulp], &pos);
+                   packcombine(&lsf_i[k], lastpart,
+                       iLBCdec_inst->ULP_inst->lsf_bits[k][ulp]);
+               }
+
+               /* Start block info */
+
+               unpack( &pbytes, &lastpart,
+                   iLBCdec_inst->ULP_inst->start_bits[ulp], &pos);
+               packcombine(&start, lastpart,
+                   iLBCdec_inst->ULP_inst->start_bits[ulp]);
+
+               unpack( &pbytes, &lastpart,
+
+
+
+Andersen, et al.              Experimental                     [Page 71]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+                   iLBCdec_inst->ULP_inst->startfirst_bits[ulp], &pos);
+               packcombine(&state_first, lastpart,
+                   iLBCdec_inst->ULP_inst->startfirst_bits[ulp]);
+
+               unpack( &pbytes, &lastpart,
+                   iLBCdec_inst->ULP_inst->scale_bits[ulp], &pos);
+               packcombine(&idxForMax, lastpart,
+                   iLBCdec_inst->ULP_inst->scale_bits[ulp]);
+
+               for (k=0; k<iLBCdec_inst->state_short_len; k++) {
+                   unpack( &pbytes, &lastpart,
+                       iLBCdec_inst->ULP_inst->state_bits[ulp], &pos);
+                   packcombine(idxVec+k, lastpart,
+                       iLBCdec_inst->ULP_inst->state_bits[ulp]);
+               }
+
+               /* 23/22 (20ms/30ms) sample block */
+
+               for (k=0; k<CB_NSTAGES; k++) {
+                   unpack( &pbytes, &lastpart,
+                       iLBCdec_inst->ULP_inst->extra_cb_index[k][ulp],
+                       &pos);
+                   packcombine(extra_cb_index+k, lastpart,
+                       iLBCdec_inst->ULP_inst->extra_cb_index[k][ulp]);
+               }
+               for (k=0; k<CB_NSTAGES; k++) {
+                   unpack( &pbytes, &lastpart,
+                       iLBCdec_inst->ULP_inst->extra_cb_gain[k][ulp],
+                       &pos);
+                   packcombine(extra_gain_index+k, lastpart,
+                       iLBCdec_inst->ULP_inst->extra_cb_gain[k][ulp]);
+               }
+
+               /* The two/four (20ms/30ms) 40 sample sub-blocks */
+
+               for (i=0; i<iLBCdec_inst->nasub; i++) {
+                   for (k=0; k<CB_NSTAGES; k++) {
+                       unpack( &pbytes, &lastpart,
+                       iLBCdec_inst->ULP_inst->cb_index[i][k][ulp],
+                           &pos);
+                       packcombine(cb_index+i*CB_NSTAGES+k, lastpart,
+                       iLBCdec_inst->ULP_inst->cb_index[i][k][ulp]);
+                   }
+               }
+
+               for (i=0; i<iLBCdec_inst->nasub; i++) {
+                   for (k=0; k<CB_NSTAGES; k++) {
+                       unpack( &pbytes, &lastpart,
+
+
+
+Andersen, et al.              Experimental                     [Page 72]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+                       iLBCdec_inst->ULP_inst->cb_gain[i][k][ulp],
+                           &pos);
+                       packcombine(gain_index+i*CB_NSTAGES+k, lastpart,
+                           iLBCdec_inst->ULP_inst->cb_gain[i][k][ulp]);
+                   }
+               }
+           }
+           /* Extract last bit. If it is 1 this indicates an
+              empty/lost frame */
+           unpack( &pbytes, &last_bit, 1, &pos);
+
+           /* Check for bit errors or empty/lost frames */
+           if (start<1)
+               mode = 0;
+           if (iLBCdec_inst->mode==20 && start>3)
+               mode = 0;
+           if (iLBCdec_inst->mode==30 && start>5)
+               mode = 0;
+           if (last_bit==1)
+               mode = 0;
+
+           if (mode==1) { /* No bit errors was detected,
+                             continue decoding */
+
+               /* adjust index */
+               index_conv_dec(cb_index);
+
+               /* decode the lsf */
+
+               SimplelsfDEQ(lsfdeq, lsf_i, iLBCdec_inst->lpc_n);
+               check=LSF_check(lsfdeq, LPC_FILTERORDER,
+                   iLBCdec_inst->lpc_n);
+               DecoderInterpolateLSF(syntdenum, weightdenum,
+                   lsfdeq, LPC_FILTERORDER, iLBCdec_inst);
+
+               Decode(iLBCdec_inst, decresidual, start, idxForMax,
+                   idxVec, syntdenum, cb_index, gain_index,
+                   extra_cb_index, extra_gain_index,
+                   state_first);
+
+               /* preparing the plc for a future loss! */
+
+               doThePLC(PLCresidual, PLClpc, 0, decresidual,
+                   syntdenum +
+                   (LPC_FILTERORDER + 1)*(iLBCdec_inst->nsub - 1),
+                   (*iLBCdec_inst).last_lag, iLBCdec_inst);
+
+
+
+
+
+Andersen, et al.              Experimental                     [Page 73]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+               memcpy(decresidual, PLCresidual,
+                   iLBCdec_inst->blockl*sizeof(float));
+           }
+
+       }
+
+       if (mode == 0) {
+           /* the data is bad (either a PLC call
+            * was made or a severe bit error was detected)
+            */
+
+           /* packet loss conceal */
+
+           memset(zeros, 0, BLOCKL_MAX*sizeof(float));
+
+           one[0] = 1;
+           memset(one+1, 0, LPC_FILTERORDER*sizeof(float));
+
+           start=0;
+
+           doThePLC(PLCresidual, PLClpc, 1, zeros, one,
+               (*iLBCdec_inst).last_lag, iLBCdec_inst);
+           memcpy(decresidual, PLCresidual,
+               iLBCdec_inst->blockl*sizeof(float));
+
+           order_plus_one = LPC_FILTERORDER + 1;
+           for (i = 0; i < iLBCdec_inst->nsub; i++) {
+               memcpy(syntdenum+(i*order_plus_one), PLClpc,
+                   order_plus_one*sizeof(float));
+           }
+       }
+
+       if (iLBCdec_inst->use_enhancer == 1) {
+
+           /* post filtering */
+
+           iLBCdec_inst->last_lag =
+               enhancerInterface(data, decresidual, iLBCdec_inst);
+
+           /* synthesis filtering */
+
+           if (iLBCdec_inst->mode==20) {
+               /* Enhancer has 40 samples delay */
+               i=0;
+               syntFilter(data + i*SUBL,
+                   iLBCdec_inst->old_syntdenum +
+                   (i+iLBCdec_inst->nsub-1)*(LPC_FILTERORDER+1),
+                   SUBL, iLBCdec_inst->syntMem);
+
+
+
+Andersen, et al.              Experimental                     [Page 74]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+               for (i=1; i < iLBCdec_inst->nsub; i++) {
+                   syntFilter(data + i*SUBL,
+                       syntdenum + (i-1)*(LPC_FILTERORDER+1),
+                       SUBL, iLBCdec_inst->syntMem);
+               }
+           } else if (iLBCdec_inst->mode==30) {
+               /* Enhancer has 80 samples delay */
+               for (i=0; i < 2; i++) {
+                   syntFilter(data + i*SUBL,
+                       iLBCdec_inst->old_syntdenum +
+                       (i+iLBCdec_inst->nsub-2)*(LPC_FILTERORDER+1),
+                       SUBL, iLBCdec_inst->syntMem);
+               }
+               for (i=2; i < iLBCdec_inst->nsub; i++) {
+                   syntFilter(data + i*SUBL,
+                       syntdenum + (i-2)*(LPC_FILTERORDER+1), SUBL,
+                       iLBCdec_inst->syntMem);
+               }
+           }
+
+       } else {
+
+           /* Find last lag */
+           lag = 20;
+           maxcc = xCorrCoef(&decresidual[BLOCKL_MAX-ENH_BLOCKL],
+               &decresidual[BLOCKL_MAX-ENH_BLOCKL-lag], ENH_BLOCKL);
+
+           for (ilag=21; ilag<120; ilag++) {
+               cc = xCorrCoef(&decresidual[BLOCKL_MAX-ENH_BLOCKL],
+                   &decresidual[BLOCKL_MAX-ENH_BLOCKL-ilag],
+                   ENH_BLOCKL);
+
+               if (cc > maxcc) {
+                   maxcc = cc;
+                   lag = ilag;
+               }
+           }
+           iLBCdec_inst->last_lag = lag;
+
+           /* copy data and run synthesis filter */
+
+           memcpy(data, decresidual,
+               iLBCdec_inst->blockl*sizeof(float));
+           for (i=0; i < iLBCdec_inst->nsub; i++) {
+               syntFilter(data + i*SUBL,
+                   syntdenum + i*(LPC_FILTERORDER+1), SUBL,
+                   iLBCdec_inst->syntMem);
+           }
+
+
+
+Andersen, et al.              Experimental                     [Page 75]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       }
+
+       /* high pass filtering on output if desired, otherwise
+          copy to out */
+
+       hpOutput(data, iLBCdec_inst->blockl,
+                   decblock,iLBCdec_inst->hpomem);
+
+       /* memcpy(decblock,data,iLBCdec_inst->blockl*sizeof(float));*/
+
+       memcpy(iLBCdec_inst->old_syntdenum, syntdenum,
+
+           iLBCdec_inst->nsub*(LPC_FILTERORDER+1)*sizeof(float));
+
+       iLBCdec_inst->prev_enh_pl=0;
+
+       if (mode==0) { /* PLC was used */
+           iLBCdec_inst->prev_enh_pl=1;
+       }
+   }
+
+A.6.  iLBC_define.h
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       iLBC_define.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+   #include <string.h>
+
+   #ifndef __iLBC_ILBCDEFINE_H
+   #define __iLBC_ILBCDEFINE_H
+
+   /* general codec settings */
+
+   #define FS                      (float)8000.0
+   #define BLOCKL_20MS             160
+   #define BLOCKL_30MS             240
+   #define BLOCKL_MAX              240
+   #define NSUB_20MS               4
+   #define NSUB_30MS               6
+   #define NSUB_MAX            6
+   #define NASUB_20MS              2
+
+
+
+Andersen, et al.              Experimental                     [Page 76]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   #define NASUB_30MS              4
+   #define NASUB_MAX               4
+   #define SUBL                40
+   #define STATE_LEN               80
+   #define STATE_SHORT_LEN_30MS    58
+   #define STATE_SHORT_LEN_20MS    57
+
+   /* LPC settings */
+
+   #define LPC_FILTERORDER         10
+   #define LPC_CHIRP_SYNTDENUM     (float)0.9025
+   #define LPC_CHIRP_WEIGHTDENUM   (float)0.4222
+   #define LPC_LOOKBACK        60
+   #define LPC_N_20MS              1
+   #define LPC_N_30MS              2
+   #define LPC_N_MAX               2
+   #define LPC_ASYMDIFF        20
+   #define LPC_BW                  (float)60.0
+   #define LPC_WN                  (float)1.0001
+   #define LSF_NSPLIT              3
+   #define LSF_NUMBER_OF_STEPS     4
+   #define LPC_HALFORDER           (LPC_FILTERORDER/2)
+
+   /* cb settings */
+
+   #define CB_NSTAGES              3
+   #define CB_EXPAND               2
+   #define CB_MEML                 147
+   #define CB_FILTERLEN        2*4
+   #define CB_HALFFILTERLEN    4
+   #define CB_RESRANGE             34
+   #define CB_MAXGAIN              (float)1.3
+
+   /* enhancer */
+
+   #define ENH_BLOCKL              80  /* block length */
+   #define ENH_BLOCKL_HALF         (ENH_BLOCKL/2)
+   #define ENH_HL                  3   /* 2*ENH_HL+1 is number blocks
+                                          in said second sequence */
+   #define ENH_SLOP            2   /* max difference estimated and
+                                          correct pitch period */
+   #define ENH_PLOCSL              20  /* pitch-estimates and pitch-
+                                          locations buffer length */
+   #define ENH_OVERHANG        2
+   #define ENH_UPS0            4   /* upsampling rate */
+   #define ENH_FL0                 3   /* 2*FLO+1 is the length of
+                                          each filter */
+   #define ENH_VECTL               (ENH_BLOCKL+2*ENH_FL0)
+
+
+
+Andersen, et al.              Experimental                     [Page 77]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   #define ENH_CORRDIM             (2*ENH_SLOP+1)
+   #define ENH_NBLOCKS             (BLOCKL_MAX/ENH_BLOCKL)
+   #define ENH_NBLOCKS_EXTRA       5
+   #define ENH_NBLOCKS_TOT         8   /* ENH_NBLOCKS +
+                                          ENH_NBLOCKS_EXTRA */
+   #define ENH_BUFL            (ENH_NBLOCKS_TOT)*ENH_BLOCKL
+   #define ENH_ALPHA0              (float)0.05
+
+   /* Down sampling */
+
+   #define FILTERORDER_DS          7
+   #define DELAY_DS            3
+   #define FACTOR_DS               2
+
+   /* bit stream defs */
+
+   #define NO_OF_BYTES_20MS    38
+   #define NO_OF_BYTES_30MS    50
+   #define NO_OF_WORDS_20MS    19
+   #define NO_OF_WORDS_30MS    25
+   #define STATE_BITS              3
+   #define BYTE_LEN            8
+   #define ULP_CLASSES             3
+
+   /* help parameters */
+
+   #define FLOAT_MAX               (float)1.0e37
+   #define EPS                     (float)2.220446049250313e-016
+   #define PI                      (float)3.14159265358979323846
+   #define MIN_SAMPLE              -32768
+   #define MAX_SAMPLE              32767
+   #define TWO_PI                  (float)6.283185307
+   #define PI2                     (float)0.159154943
+
+   /* type definition encoder instance */
+   typedef struct iLBC_ULP_Inst_t_ {
+       int lsf_bits[6][ULP_CLASSES+2];
+       int start_bits[ULP_CLASSES+2];
+       int startfirst_bits[ULP_CLASSES+2];
+       int scale_bits[ULP_CLASSES+2];
+       int state_bits[ULP_CLASSES+2];
+       int extra_cb_index[CB_NSTAGES][ULP_CLASSES+2];
+       int extra_cb_gain[CB_NSTAGES][ULP_CLASSES+2];
+       int cb_index[NSUB_MAX][CB_NSTAGES][ULP_CLASSES+2];
+       int cb_gain[NSUB_MAX][CB_NSTAGES][ULP_CLASSES+2];
+   } iLBC_ULP_Inst_t;
+
+   /* type definition encoder instance */
+
+
+
+Andersen, et al.              Experimental                     [Page 78]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   typedef struct iLBC_Enc_Inst_t_ {
+
+       /* flag for frame size mode */
+       int mode;
+
+       /* basic parameters for different frame sizes */
+       int blockl;
+       int nsub;
+       int nasub;
+       int no_of_bytes, no_of_words;
+       int lpc_n;
+       int state_short_len;
+       const iLBC_ULP_Inst_t *ULP_inst;
+
+       /* analysis filter state */
+       float anaMem[LPC_FILTERORDER];
+
+       /* old lsf parameters for interpolation */
+       float lsfold[LPC_FILTERORDER];
+       float lsfdeqold[LPC_FILTERORDER];
+
+       /* signal buffer for LP analysis */
+       float lpc_buffer[LPC_LOOKBACK + BLOCKL_MAX];
+
+       /* state of input HP filter */
+       float hpimem[4];
+
+   } iLBC_Enc_Inst_t;
+
+   /* type definition decoder instance */
+   typedef struct iLBC_Dec_Inst_t_ {
+
+       /* flag for frame size mode */
+       int mode;
+
+       /* basic parameters for different frame sizes */
+       int blockl;
+       int nsub;
+       int nasub;
+       int no_of_bytes, no_of_words;
+       int lpc_n;
+       int state_short_len;
+       const iLBC_ULP_Inst_t *ULP_inst;
+
+       /* synthesis filter state */
+       float syntMem[LPC_FILTERORDER];
+
+       /* old LSF for interpolation */
+
+
+
+Andersen, et al.              Experimental                     [Page 79]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       float lsfdeqold[LPC_FILTERORDER];
+
+       /* pitch lag estimated in enhancer and used in PLC */
+       int last_lag;
+
+       /* PLC state information */
+       int prevLag, consPLICount, prevPLI, prev_enh_pl;
+       float prevLpc[LPC_FILTERORDER+1];
+       float prevResidual[NSUB_MAX*SUBL];
+       float per;
+       unsigned long seed;
+
+       /* previous synthesis filter parameters */
+       float old_syntdenum[(LPC_FILTERORDER + 1)*NSUB_MAX];
+
+       /* state of output HP filter */
+       float hpomem[4];
+
+       /* enhancer state information */
+       int use_enhancer;
+       float enh_buf[ENH_BUFL];
+       float enh_period[ENH_NBLOCKS_TOT];
+
+   } iLBC_Dec_Inst_t;
+
+   #endif
+
+A.7.  constants.h
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       constants.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_CONSTANTS_H
+   #define __iLBC_CONSTANTS_H
+
+   #include "iLBC_define.h"
+
+
+   /* ULP bit allocation */
+
+
+
+
+Andersen, et al.              Experimental                     [Page 80]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   extern const iLBC_ULP_Inst_t ULP_20msTbl;
+   extern const iLBC_ULP_Inst_t ULP_30msTbl;
+
+   /* high pass filters */
+
+   extern float hpi_zero_coefsTbl[];
+   extern float hpi_pole_coefsTbl[];
+   extern float hpo_zero_coefsTbl[];
+   extern float hpo_pole_coefsTbl[];
+
+   /* low pass filters */
+   extern float lpFilt_coefsTbl[];
+
+   /* LPC analysis and quantization */
+
+   extern float lpc_winTbl[];
+   extern float lpc_asymwinTbl[];
+   extern float lpc_lagwinTbl[];
+   extern float lsfCbTbl[];
+   extern float lsfmeanTbl[];
+   extern int   dim_lsfCbTbl[];
+   extern int   size_lsfCbTbl[];
+   extern float lsf_weightTbl_30ms[];
+   extern float lsf_weightTbl_20ms[];
+
+   /* state quantization tables */
+
+   extern float state_sq3Tbl[];
+   extern float state_frgqTbl[];
+
+   /* gain quantization tables */
+
+   extern float gain_sq3Tbl[];
+   extern float gain_sq4Tbl[];
+   extern float gain_sq5Tbl[];
+
+   /* adaptive codebook definitions */
+
+   extern int search_rangeTbl[5][CB_NSTAGES];
+   extern int memLfTbl[];
+   extern int stMemLTbl;
+   extern float cbfiltersTbl[CB_FILTERLEN];
+
+   /* enhancer definitions */
+
+   extern float polyphaserTbl[];
+   extern float enh_plocsTbl[];
+
+
+
+
+Andersen, et al.              Experimental                     [Page 81]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   #endif
+
+A.8.  constants.c
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       constants.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include "iLBC_define.h"
+
+   /* ULP bit allocation */
+
+       /* 20 ms frame */
+
+   const iLBC_ULP_Inst_t ULP_20msTbl = {
+       /* LSF */
+       {   {6,0,0,0,0}, {7,0,0,0,0}, {7,0,0,0,0},
+           {0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}},
+       /* Start state location, gain and samples */
+       {2,0,0,0,0},
+       {1,0,0,0,0},
+       {6,0,0,0,0},
+       {0,1,2,0,0},
+       /* extra CB index and extra CB gain */
+       {{6,0,1,0,0}, {0,0,7,0,0}, {0,0,7,0,0}},
+       {{2,0,3,0,0}, {1,1,2,0,0}, {0,0,3,0,0}},
+       /* CB index and CB gain */
+       {   {{7,0,1,0,0}, {0,0,7,0,0}, {0,0,7,0,0}},
+           {{0,0,8,0,0}, {0,0,8,0,0}, {0,0,8,0,0}},
+           {{0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}},
+           {{0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}}},
+       {   {{1,2,2,0,0}, {1,1,2,0,0}, {0,0,3,0,0}},
+           {{1,1,3,0,0}, {0,2,2,0,0}, {0,0,3,0,0}},
+           {{0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}},
+           {{0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}}}
+   };
+
+       /* 30 ms frame */
+
+   const iLBC_ULP_Inst_t ULP_30msTbl = {
+       /* LSF */
+
+
+
+Andersen, et al.              Experimental                     [Page 82]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       {   {6,0,0,0,0}, {7,0,0,0,0}, {7,0,0,0,0},
+           {6,0,0,0,0}, {7,0,0,0,0}, {7,0,0,0,0}},
+       /* Start state location, gain and samples */
+       {3,0,0,0,0},
+       {1,0,0,0,0},
+       {6,0,0,0,0},
+       {0,1,2,0,0},
+       /* extra CB index and extra CB gain */
+       {{4,2,1,0,0}, {0,0,7,0,0}, {0,0,7,0,0}},
+       {{1,1,3,0,0}, {1,1,2,0,0}, {0,0,3,0,0}},
+       /* CB index and CB gain */
+       {   {{6,1,1,0,0}, {0,0,7,0,0}, {0,0,7,0,0}},
+           {{0,7,1,0,0}, {0,0,8,0,0}, {0,0,8,0,0}},
+           {{0,7,1,0,0}, {0,0,8,0,0}, {0,0,8,0,0}},
+           {{0,7,1,0,0}, {0,0,8,0,0}, {0,0,8,0,0}}},
+       {   {{1,2,2,0,0}, {1,2,1,0,0}, {0,0,3,0,0}},
+           {{0,2,3,0,0}, {0,2,2,0,0}, {0,0,3,0,0}},
+           {{0,1,4,0,0}, {0,1,3,0,0}, {0,0,3,0,0}},
+           {{0,1,4,0,0}, {0,1,3,0,0}, {0,0,3,0,0}}}
+   };
+
+   /* HP Filters */
+
+   float hpi_zero_coefsTbl[3] = {
+       (float)0.92727436, (float)-1.8544941, (float)0.92727436
+   };
+   float hpi_pole_coefsTbl[3] = {
+       (float)1.0, (float)-1.9059465, (float)0.9114024
+   };
+   float hpo_zero_coefsTbl[3] = {
+       (float)0.93980581, (float)-1.8795834, (float)0.93980581
+   };
+   float hpo_pole_coefsTbl[3] = {
+       (float)1.0, (float)-1.9330735, (float)0.93589199
+   };
+
+   /* LP Filter */
+
+   float lpFilt_coefsTbl[FILTERORDER_DS]={
+       (float)-0.066650, (float)0.125000, (float)0.316650,
+       (float)0.414063, (float)0.316650,
+       (float)0.125000, (float)-0.066650
+   };
+
+   /* State quantization tables */
+
+   float state_sq3Tbl[8] = {
+       (float)-3.719849, (float)-2.177490, (float)-1.130005,
+
+
+
+Andersen, et al.              Experimental                     [Page 83]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       (float)-0.309692, (float)0.444214, (float)1.329712,
+       (float)2.436279, (float)3.983887
+   };
+
+   float state_frgqTbl[64] = {
+       (float)1.000085, (float)1.071695, (float)1.140395,
+       (float)1.206868, (float)1.277188, (float)1.351503,
+       (float)1.429380, (float)1.500727, (float)1.569049,
+       (float)1.639599, (float)1.707071, (float)1.781531,
+       (float)1.840799, (float)1.901550, (float)1.956695,
+       (float)2.006750, (float)2.055474, (float)2.102787,
+       (float)2.142819, (float)2.183592, (float)2.217962,
+       (float)2.257177, (float)2.295739, (float)2.332967,
+       (float)2.369248, (float)2.402792, (float)2.435080,
+       (float)2.468598, (float)2.503394, (float)2.539284,
+       (float)2.572944, (float)2.605036, (float)2.636331,
+       (float)2.668939, (float)2.698780, (float)2.729101,
+       (float)2.759786, (float)2.789834, (float)2.818679,
+       (float)2.848074, (float)2.877470, (float)2.906899,
+       (float)2.936655, (float)2.967804, (float)3.000115,
+       (float)3.033367, (float)3.066355, (float)3.104231,
+       (float)3.141499, (float)3.183012, (float)3.222952,
+       (float)3.265433, (float)3.308441, (float)3.350823,
+       (float)3.395275, (float)3.442793, (float)3.490801,
+       (float)3.542514, (float)3.604064, (float)3.666050,
+       (float)3.740994, (float)3.830749, (float)3.938770,
+       (float)4.101764
+   };
+
+   /* CB tables */
+
+   int search_rangeTbl[5][CB_NSTAGES]={{58,58,58}, {108,44,44},
+               {108,108,108}, {108,108,108}, {108,108,108}};
+   int stMemLTbl=85;
+   int memLfTbl[NASUB_MAX]={147,147,147,147};
+
+   /* expansion filter(s) */
+
+   float cbfiltersTbl[CB_FILTERLEN]={
+       (float)-0.034180, (float)0.108887, (float)-0.184326,
+       (float)0.806152,  (float)0.713379, (float)-0.144043,
+       (float)0.083740,  (float)-0.033691
+   };
+
+   /* Gain Quantization */
+
+   float gain_sq3Tbl[8]={
+       (float)-1.000000,  (float)-0.659973,  (float)-0.330017,
+
+
+
+Andersen, et al.              Experimental                     [Page 84]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       (float)0.000000, (float)0.250000, (float)0.500000,
+       (float)0.750000, (float)1.00000};
+
+   float gain_sq4Tbl[16]={
+       (float)-1.049988, (float)-0.900024, (float)-0.750000,
+       (float)-0.599976, (float)-0.450012, (float)-0.299988,
+       (float)-0.150024, (float)0.000000, (float)0.150024,
+       (float)0.299988, (float)0.450012, (float)0.599976,
+       (float)0.750000, (float)0.900024, (float)1.049988,
+       (float)1.200012};
+
+   float gain_sq5Tbl[32]={
+       (float)0.037476, (float)0.075012, (float)0.112488,
+       (float)0.150024, (float)0.187500, (float)0.224976,
+       (float)0.262512, (float)0.299988, (float)0.337524,
+       (float)0.375000, (float)0.412476, (float)0.450012,
+       (float)0.487488, (float)0.525024, (float)0.562500,
+       (float)0.599976, (float)0.637512, (float)0.674988,
+       (float)0.712524, (float)0.750000, (float)0.787476,
+       (float)0.825012, (float)0.862488, (float)0.900024,
+       (float)0.937500, (float)0.974976, (float)1.012512,
+       (float)1.049988, (float)1.087524, (float)1.125000,
+       (float)1.162476, (float)1.200012};
+
+   /* Enhancer - Upsamling a factor 4 (ENH_UPS0 = 4) */
+   float polyphaserTbl[ENH_UPS0*(2*ENH_FL0+1)]={
+       (float)0.000000, (float)0.000000, (float)0.000000,
+   (float)1.000000,
+           (float)0.000000, (float)0.000000, (float)0.000000,
+       (float)0.015625, (float)-0.076904, (float)0.288330,
+   (float)0.862061,
+           (float)-0.106445, (float)0.018799, (float)-0.015625,
+       (float)0.023682, (float)-0.124268, (float)0.601563,
+   (float)0.601563,
+           (float)-0.124268, (float)0.023682, (float)-0.023682,
+       (float)0.018799, (float)-0.106445, (float)0.862061,
+   (float)0.288330,
+           (float)-0.076904, (float)0.015625, (float)-0.018799};
+
+   float enh_plocsTbl[ENH_NBLOCKS_TOT] = {(float)40.0, (float)120.0,
+               (float)200.0, (float)280.0, (float)360.0,
+               (float)440.0, (float)520.0, (float)600.0};
+
+   /* LPC analysis and quantization */
+
+   int dim_lsfCbTbl[LSF_NSPLIT] = {3, 3, 4};
+   int size_lsfCbTbl[LSF_NSPLIT] = {64,128,128};
+
+
+
+
+Andersen, et al.              Experimental                     [Page 85]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   float lsfmeanTbl[LPC_FILTERORDER] = {
+       (float)0.281738, (float)0.445801, (float)0.663330,
+       (float)0.962524, (float)1.251831, (float)1.533081,
+       (float)1.850586, (float)2.137817, (float)2.481445,
+       (float)2.777344};
+
+   float lsf_weightTbl_30ms[6] = {(float)(1.0/2.0), (float)1.0,
+   (float)(2.0/3.0),
+       (float)(1.0/3.0), (float)0.0, (float)0.0};
+
+   float lsf_weightTbl_20ms[4] = {(float)(3.0/4.0), (float)(2.0/4.0),
+       (float)(1.0/4.0), (float)(0.0)};
+
+   /* Hanning LPC window */
+   float lpc_winTbl[BLOCKL_MAX]={
+       (float)0.000183, (float)0.000671, (float)0.001526,
+       (float)0.002716, (float)0.004242, (float)0.006104,
+       (float)0.008301, (float)0.010834, (float)0.013702,
+       (float)0.016907, (float)0.020416, (float)0.024261,
+       (float)0.028442, (float)0.032928, (float)0.037750,
+       (float)0.042877, (float)0.048309, (float)0.054047,
+       (float)0.060089, (float)0.066437, (float)0.073090,
+       (float)0.080017, (float)0.087219, (float)0.094727,
+       (float)0.102509, (float)0.110535, (float)0.118835,
+       (float)0.127411, (float)0.136230, (float)0.145294,
+       (float)0.154602, (float)0.164154, (float)0.173920,
+       (float)0.183899, (float)0.194122, (float)0.204529,
+       (float)0.215149, (float)0.225952, (float)0.236938,
+       (float)0.248108, (float)0.259460, (float)0.270966,
+       (float)0.282654, (float)0.294464, (float)0.306396,
+       (float)0.318481, (float)0.330688, (float)0.343018,
+       (float)0.355438, (float)0.367981, (float)0.380585,
+       (float)0.393280, (float)0.406067, (float)0.418884,
+       (float)0.431763, (float)0.444702, (float)0.457672,
+       (float)0.470673, (float)0.483704, (float)0.496735,
+       (float)0.509766, (float)0.522797, (float)0.535828,
+       (float)0.548798, (float)0.561768, (float)0.574677,
+       (float)0.587524, (float)0.600342, (float)0.613068,
+       (float)0.625732, (float)0.638306, (float)0.650787,
+       (float)0.663147, (float)0.675415, (float)0.687561,
+       (float)0.699585, (float)0.711487, (float)0.723206,
+       (float)0.734802, (float)0.746216, (float)0.757477,
+       (float)0.768585, (float)0.779480, (float)0.790192,
+       (float)0.800720, (float)0.811005, (float)0.821106,
+       (float)0.830994, (float)0.840668, (float)0.850067,
+       (float)0.859253, (float)0.868225, (float)0.876892,
+       (float)0.885345, (float)0.893524, (float)0.901428,
+       (float)0.909058, (float)0.916412, (float)0.923492,
+
+
+
+Andersen, et al.              Experimental                     [Page 86]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       (float)0.930267, (float)0.936768, (float)0.942963,
+       (float)0.948853, (float)0.954437, (float)0.959717,
+       (float)0.964691, (float)0.969360, (float)0.973694,
+       (float)0.977692, (float)0.981384, (float)0.984741,
+       (float)0.987762, (float)0.990479, (float)0.992828,
+       (float)0.994873, (float)0.996552, (float)0.997925,
+       (float)0.998932, (float)0.999603, (float)0.999969,
+       (float)0.999969, (float)0.999603, (float)0.998932,
+       (float)0.997925, (float)0.996552, (float)0.994873,
+       (float)0.992828, (float)0.990479, (float)0.987762,
+       (float)0.984741, (float)0.981384, (float)0.977692,
+       (float)0.973694, (float)0.969360, (float)0.964691,
+       (float)0.959717, (float)0.954437, (float)0.948853,
+       (float)0.942963, (float)0.936768, (float)0.930267,
+       (float)0.923492, (float)0.916412, (float)0.909058,
+       (float)0.901428, (float)0.893524, (float)0.885345,
+       (float)0.876892, (float)0.868225, (float)0.859253,
+       (float)0.850067, (float)0.840668, (float)0.830994,
+       (float)0.821106, (float)0.811005, (float)0.800720,
+       (float)0.790192, (float)0.779480, (float)0.768585,
+       (float)0.757477, (float)0.746216, (float)0.734802,
+       (float)0.723206, (float)0.711487, (float)0.699585,
+       (float)0.687561, (float)0.675415, (float)0.663147,
+       (float)0.650787, (float)0.638306, (float)0.625732,
+       (float)0.613068, (float)0.600342, (float)0.587524,
+       (float)0.574677, (float)0.561768, (float)0.548798,
+       (float)0.535828, (float)0.522797, (float)0.509766,
+       (float)0.496735, (float)0.483704, (float)0.470673,
+       (float)0.457672, (float)0.444702, (float)0.431763,
+       (float)0.418884, (float)0.406067, (float)0.393280,
+       (float)0.380585, (float)0.367981, (float)0.355438,
+       (float)0.343018, (float)0.330688, (float)0.318481,
+       (float)0.306396, (float)0.294464, (float)0.282654,
+       (float)0.270966, (float)0.259460, (float)0.248108,
+       (float)0.236938, (float)0.225952, (float)0.215149,
+       (float)0.204529, (float)0.194122, (float)0.183899,
+       (float)0.173920, (float)0.164154, (float)0.154602,
+       (float)0.145294, (float)0.136230, (float)0.127411,
+       (float)0.118835, (float)0.110535, (float)0.102509,
+       (float)0.094727, (float)0.087219, (float)0.080017,
+       (float)0.073090, (float)0.066437, (float)0.060089,
+       (float)0.054047, (float)0.048309, (float)0.042877,
+       (float)0.037750, (float)0.032928, (float)0.028442,
+       (float)0.024261, (float)0.020416, (float)0.016907,
+       (float)0.013702, (float)0.010834, (float)0.008301,
+       (float)0.006104, (float)0.004242, (float)0.002716,
+       (float)0.001526, (float)0.000671, (float)0.000183
+   };
+
+
+
+Andersen, et al.              Experimental                     [Page 87]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   /* Asymmetric LPC window */
+   float lpc_asymwinTbl[BLOCKL_MAX]={
+       (float)0.000061, (float)0.000214, (float)0.000458,
+       (float)0.000824, (float)0.001282, (float)0.001831,
+       (float)0.002472, (float)0.003235, (float)0.004120,
+       (float)0.005066, (float)0.006134, (float)0.007294,
+       (float)0.008545, (float)0.009918, (float)0.011383,
+       (float)0.012939, (float)0.014587, (float)0.016357,
+       (float)0.018219, (float)0.020172, (float)0.022217,
+       (float)0.024353, (float)0.026611, (float)0.028961,
+       (float)0.031372, (float)0.033905, (float)0.036530,
+       (float)0.039276, (float)0.042084, (float)0.044983,
+       (float)0.047974, (float)0.051086, (float)0.054260,
+       (float)0.057526, (float)0.060883, (float)0.064331,
+       (float)0.067871, (float)0.071503, (float)0.075226,
+       (float)0.079010, (float)0.082916, (float)0.086884,
+       (float)0.090942, (float)0.095062, (float)0.099304,
+       (float)0.103607, (float)0.107971, (float)0.112427,
+       (float)0.116974, (float)0.121582, (float)0.126282,
+       (float)0.131073, (float)0.135895, (float)0.140839,
+       (float)0.145813, (float)0.150879, (float)0.156006,
+       (float)0.161224, (float)0.166504, (float)0.171844,
+       (float)0.177246, (float)0.182709, (float)0.188263,
+       (float)0.193848, (float)0.199524, (float)0.205231,
+       (float)0.211029, (float)0.216858, (float)0.222778,
+       (float)0.228729, (float)0.234741, (float)0.240814,
+       (float)0.246918, (float)0.253082, (float)0.259308,
+       (float)0.265564, (float)0.271881, (float)0.278259,
+       (float)0.284668, (float)0.291107, (float)0.297607,
+       (float)0.304138, (float)0.310730, (float)0.317322,
+       (float)0.323975, (float)0.330658, (float)0.337372,
+       (float)0.344147, (float)0.350922, (float)0.357727,
+       (float)0.364594, (float)0.371460, (float)0.378357,
+       (float)0.385284, (float)0.392212, (float)0.399170,
+       (float)0.406158, (float)0.413177, (float)0.420197,
+       (float)0.427246, (float)0.434296, (float)0.441376,
+       (float)0.448456, (float)0.455536, (float)0.462646,
+       (float)0.469757, (float)0.476868, (float)0.483978,
+       (float)0.491089, (float)0.498230, (float)0.505341,
+       (float)0.512451, (float)0.519592, (float)0.526703,
+       (float)0.533813, (float)0.540924, (float)0.548004,
+       (float)0.555084, (float)0.562164, (float)0.569244,
+       (float)0.576294, (float)0.583313, (float)0.590332,
+       (float)0.597321, (float)0.604309, (float)0.611267,
+       (float)0.618195, (float)0.625092, (float)0.631989,
+       (float)0.638855, (float)0.645660, (float)0.652466,
+       (float)0.659241, (float)0.665985, (float)0.672668,
+       (float)0.679352, (float)0.685974, (float)0.692566,
+
+
+
+Andersen, et al.              Experimental                     [Page 88]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       (float)0.699127, (float)0.705658, (float)0.712128,
+       (float)0.718536, (float)0.724945, (float)0.731262,
+       (float)0.737549, (float)0.743805, (float)0.750000,
+       (float)0.756134, (float)0.762238, (float)0.768280,
+       (float)0.774261, (float)0.780182, (float)0.786072,
+       (float)0.791870, (float)0.797638, (float)0.803314,
+       (float)0.808960, (float)0.814514, (float)0.820038,
+       (float)0.825470, (float)0.830841, (float)0.836151,
+       (float)0.841400, (float)0.846558, (float)0.851654,
+       (float)0.856689, (float)0.861633, (float)0.866516,
+       (float)0.871338, (float)0.876068, (float)0.880737,
+       (float)0.885315, (float)0.889801, (float)0.894226,
+       (float)0.898560, (float)0.902832, (float)0.907013,
+       (float)0.911102, (float)0.915100, (float)0.919037,
+       (float)0.922882, (float)0.926636, (float)0.930328,
+       (float)0.933899, (float)0.937408, (float)0.940796,
+       (float)0.944122, (float)0.947357, (float)0.950470,
+       (float)0.953522, (float)0.956482, (float)0.959351,
+       (float)0.962097, (float)0.964783, (float)0.967377,
+       (float)0.969849, (float)0.972229, (float)0.974518,
+       (float)0.976715, (float)0.978821, (float)0.980835,
+       (float)0.982727, (float)0.984528, (float)0.986237,
+       (float)0.987854, (float)0.989380, (float)0.990784,
+       (float)0.992096, (float)0.993317, (float)0.994415,
+       (float)0.995422, (float)0.996338, (float)0.997162,
+       (float)0.997864, (float)0.998474, (float)0.998962,
+       (float)0.999390, (float)0.999695, (float)0.999878,
+       (float)0.999969, (float)0.999969, (float)0.996918,
+       (float)0.987701, (float)0.972382, (float)0.951050,
+       (float)0.923889, (float)0.891022, (float)0.852631,
+       (float)0.809021, (float)0.760406, (float)0.707092,
+       (float)0.649445, (float)0.587799, (float)0.522491,
+       (float)0.453979, (float)0.382690, (float)0.309021,
+       (float)0.233459, (float)0.156433, (float)0.078461
+   };
+
+   /* Lag window for LPC */
+   float lpc_lagwinTbl[LPC_FILTERORDER + 1]={
+       (float)1.000100, (float)0.998890, (float)0.995569,
+           (float)0.990057, (float)0.982392,
+       (float)0.972623, (float)0.960816, (float)0.947047,
+           (float)0.931405, (float)0.913989, (float)0.894909};
+
+   /* LSF quantization*/
+   float lsfCbTbl[64 * 3 + 128 * 3 + 128 * 4] = {
+   (float)0.155396, (float)0.273193, (float)0.451172,
+   (float)0.390503, (float)0.648071, (float)1.002075,
+   (float)0.440186, (float)0.692261, (float)0.955688,
+
+
+
+Andersen, et al.              Experimental                     [Page 89]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   (float)0.343628, (float)0.642334, (float)1.071533,
+   (float)0.318359, (float)0.491577, (float)0.670532,
+   (float)0.193115, (float)0.375488, (float)0.725708,
+   (float)0.364136, (float)0.510376, (float)0.658691,
+   (float)0.297485, (float)0.527588, (float)0.842529,
+   (float)0.227173, (float)0.365967, (float)0.563110,
+   (float)0.244995, (float)0.396729, (float)0.636475,
+   (float)0.169434, (float)0.300171, (float)0.520264,
+   (float)0.312866, (float)0.464478, (float)0.643188,
+   (float)0.248535, (float)0.429932, (float)0.626099,
+   (float)0.236206, (float)0.491333, (float)0.817139,
+   (float)0.334961, (float)0.625122, (float)0.895752,
+   (float)0.343018, (float)0.518555, (float)0.698608,
+   (float)0.372803, (float)0.659790, (float)0.945435,
+   (float)0.176880, (float)0.316528, (float)0.581421,
+   (float)0.416382, (float)0.625977, (float)0.805176,
+   (float)0.303223, (float)0.568726, (float)0.915039,
+   (float)0.203613, (float)0.351440, (float)0.588135,
+   (float)0.221191, (float)0.375000, (float)0.614746,
+   (float)0.199951, (float)0.323364, (float)0.476074,
+   (float)0.300781, (float)0.433350, (float)0.566895,
+   (float)0.226196, (float)0.354004, (float)0.507568,
+   (float)0.300049, (float)0.508179, (float)0.711670,
+   (float)0.312012, (float)0.492676, (float)0.763428,
+   (float)0.329956, (float)0.541016, (float)0.795776,
+   (float)0.373779, (float)0.604614, (float)0.928833,
+   (float)0.210571, (float)0.452026, (float)0.755249,
+   (float)0.271118, (float)0.473267, (float)0.662476,
+   (float)0.285522, (float)0.436890, (float)0.634399,
+   (float)0.246704, (float)0.565552, (float)0.859009,
+   (float)0.270508, (float)0.406250, (float)0.553589,
+   (float)0.361450, (float)0.578491, (float)0.813843,
+   (float)0.342651, (float)0.482788, (float)0.622437,
+   (float)0.340332, (float)0.549438, (float)0.743164,
+   (float)0.200439, (float)0.336304, (float)0.540894,
+   (float)0.407837, (float)0.644775, (float)0.895142,
+   (float)0.294678, (float)0.454834, (float)0.699097,
+   (float)0.193115, (float)0.344482, (float)0.643188,
+   (float)0.275757, (float)0.420776, (float)0.598755,
+   (float)0.380493, (float)0.608643, (float)0.861084,
+   (float)0.222778, (float)0.426147, (float)0.676514,
+   (float)0.407471, (float)0.700195, (float)1.053101,
+   (float)0.218384, (float)0.377197, (float)0.669922,
+   (float)0.313232, (float)0.454102, (float)0.600952,
+   (float)0.347412, (float)0.571533, (float)0.874146,
+   (float)0.238037, (float)0.405396, (float)0.729492,
+   (float)0.223877, (float)0.412964, (float)0.822021,
+   (float)0.395264, (float)0.582153, (float)0.743896,
+
+
+
+Andersen, et al.              Experimental                     [Page 90]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   (float)0.247925, (float)0.485596, (float)0.720581,
+   (float)0.229126, (float)0.496582, (float)0.907715,
+   (float)0.260132, (float)0.566895, (float)1.012695,
+   (float)0.337402, (float)0.611572, (float)0.978149,
+   (float)0.267822, (float)0.447632, (float)0.769287,
+   (float)0.250610, (float)0.381714, (float)0.530029,
+   (float)0.430054, (float)0.805054, (float)1.221924,
+   (float)0.382568, (float)0.544067, (float)0.701660,
+   (float)0.383545, (float)0.710327, (float)1.149170,
+   (float)0.271362, (float)0.529053, (float)0.775513,
+   (float)0.246826, (float)0.393555, (float)0.588623,
+   (float)0.266846, (float)0.422119, (float)0.676758,
+   (float)0.311523, (float)0.580688, (float)0.838623,
+   (float)1.331177, (float)1.576782, (float)1.779541,
+   (float)1.160034, (float)1.401978, (float)1.768188,
+   (float)1.161865, (float)1.525146, (float)1.715332,
+   (float)0.759521, (float)0.913940, (float)1.119873,
+   (float)0.947144, (float)1.121338, (float)1.282471,
+   (float)1.015015, (float)1.557007, (float)1.804932,
+   (float)1.172974, (float)1.402100, (float)1.692627,
+   (float)1.087524, (float)1.474243, (float)1.665405,
+   (float)0.899536, (float)1.105225, (float)1.406250,
+   (float)1.148438, (float)1.484741, (float)1.796265,
+   (float)0.785645, (float)1.209839, (float)1.567749,
+   (float)0.867798, (float)1.166504, (float)1.450684,
+   (float)0.922485, (float)1.229858, (float)1.420898,
+   (float)0.791260, (float)1.123291, (float)1.409546,
+   (float)0.788940, (float)0.966064, (float)1.340332,
+   (float)1.051147, (float)1.272827, (float)1.556641,
+   (float)0.866821, (float)1.181152, (float)1.538818,
+   (float)0.906738, (float)1.373535, (float)1.607910,
+   (float)1.244751, (float)1.581421, (float)1.933838,
+   (float)0.913940, (float)1.337280, (float)1.539673,
+   (float)0.680542, (float)0.959229, (float)1.662720,
+   (float)0.887207, (float)1.430542, (float)1.800781,
+   (float)0.912598, (float)1.433594, (float)1.683960,
+   (float)0.860474, (float)1.060303, (float)1.455322,
+   (float)1.005127, (float)1.381104, (float)1.706909,
+   (float)0.800781, (float)1.363892, (float)1.829102,
+   (float)0.781860, (float)1.124390, (float)1.505981,
+   (float)1.003662, (float)1.471436, (float)1.684692,
+   (float)0.981323, (float)1.309570, (float)1.618042,
+   (float)1.228760, (float)1.554321, (float)1.756470,
+   (float)0.734375, (float)0.895752, (float)1.225586,
+   (float)0.841797, (float)1.055664, (float)1.249268,
+   (float)0.920166, (float)1.119385, (float)1.486206,
+   (float)0.894409, (float)1.539063, (float)1.828979,
+   (float)1.283691, (float)1.543335, (float)1.858276,
+
+
+
+Andersen, et al.              Experimental                     [Page 91]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   (float)0.676025, (float)0.933105, (float)1.490845,
+   (float)0.821289, (float)1.491821, (float)1.739868,
+   (float)0.923218, (float)1.144653, (float)1.580566,
+   (float)1.057251, (float)1.345581, (float)1.635864,
+   (float)0.888672, (float)1.074951, (float)1.353149,
+   (float)0.942749, (float)1.195435, (float)1.505493,
+   (float)1.492310, (float)1.788086, (float)2.039673,
+   (float)1.070313, (float)1.634399, (float)1.860962,
+   (float)1.253296, (float)1.488892, (float)1.686035,
+   (float)0.647095, (float)0.864014, (float)1.401855,
+   (float)0.866699, (float)1.254883, (float)1.453369,
+   (float)1.063965, (float)1.532593, (float)1.731323,
+   (float)1.167847, (float)1.521484, (float)1.884033,
+   (float)0.956055, (float)1.502075, (float)1.745605,
+   (float)0.928711, (float)1.288574, (float)1.479614,
+   (float)1.088013, (float)1.380737, (float)1.570801,
+   (float)0.905029, (float)1.186768, (float)1.371948,
+   (float)1.057861, (float)1.421021, (float)1.617432,
+   (float)1.108276, (float)1.312500, (float)1.501465,
+   (float)0.979492, (float)1.416992, (float)1.624268,
+   (float)1.276001, (float)1.661011, (float)2.007935,
+   (float)0.993042, (float)1.168579, (float)1.331665,
+   (float)0.778198, (float)0.944946, (float)1.235962,
+   (float)1.223755, (float)1.491333, (float)1.815674,
+   (float)0.852661, (float)1.350464, (float)1.722290,
+   (float)1.134766, (float)1.593140, (float)1.787354,
+   (float)1.051392, (float)1.339722, (float)1.531006,
+   (float)0.803589, (float)1.271240, (float)1.652100,
+   (float)0.755737, (float)1.143555, (float)1.639404,
+   (float)0.700928, (float)0.837280, (float)1.130371,
+   (float)0.942749, (float)1.197876, (float)1.669800,
+   (float)0.993286, (float)1.378296, (float)1.566528,
+   (float)0.801025, (float)1.095337, (float)1.298950,
+   (float)0.739990, (float)1.032959, (float)1.383667,
+   (float)0.845703, (float)1.072266, (float)1.543823,
+   (float)0.915649, (float)1.072266, (float)1.224487,
+   (float)1.021973, (float)1.226196, (float)1.481323,
+   (float)0.999878, (float)1.204102, (float)1.555908,
+   (float)0.722290, (float)0.913940, (float)1.340210,
+   (float)0.673340, (float)0.835938, (float)1.259521,
+   (float)0.832397, (float)1.208374, (float)1.394165,
+   (float)0.962158, (float)1.576172, (float)1.912842,
+   (float)1.166748, (float)1.370850, (float)1.556763,
+   (float)0.946289, (float)1.138550, (float)1.400391,
+   (float)1.035034, (float)1.218262, (float)1.386475,
+   (float)1.393799, (float)1.717773, (float)2.000244,
+   (float)0.972656, (float)1.260986, (float)1.760620,
+   (float)1.028198, (float)1.288452, (float)1.484619,
+
+
+
+Andersen, et al.              Experimental                     [Page 92]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   (float)0.773560, (float)1.258057, (float)1.756714,
+   (float)1.080322, (float)1.328003, (float)1.742676,
+   (float)0.823975, (float)1.450806, (float)1.917725,
+   (float)0.859009, (float)1.016602, (float)1.191895,
+   (float)0.843994, (float)1.131104, (float)1.645020,
+   (float)1.189697, (float)1.702759, (float)1.894409,
+   (float)1.346680, (float)1.763184, (float)2.066040,
+   (float)0.980469, (float)1.253784, (float)1.441650,
+   (float)1.338135, (float)1.641968, (float)1.932739,
+   (float)1.223267, (float)1.424194, (float)1.626465,
+   (float)0.765747, (float)1.004150, (float)1.579102,
+   (float)1.042847, (float)1.269165, (float)1.647461,
+   (float)0.968750, (float)1.257568, (float)1.555786,
+   (float)0.826294, (float)0.993408, (float)1.275146,
+   (float)0.742310, (float)0.950439, (float)1.430542,
+   (float)1.054321, (float)1.439819, (float)1.828003,
+   (float)1.072998, (float)1.261719, (float)1.441895,
+   (float)0.859375, (float)1.036377, (float)1.314819,
+   (float)0.895752, (float)1.267212, (float)1.605591,
+   (float)0.805420, (float)0.962891, (float)1.142334,
+   (float)0.795654, (float)1.005493, (float)1.468506,
+   (float)1.105347, (float)1.313843, (float)1.584839,
+   (float)0.792236, (float)1.221802, (float)1.465698,
+   (float)1.170532, (float)1.467651, (float)1.664063,
+   (float)0.838257, (float)1.153198, (float)1.342163,
+   (float)0.968018, (float)1.198242, (float)1.391235,
+   (float)1.250122, (float)1.623535, (float)1.823608,
+   (float)0.711670, (float)1.058350, (float)1.512085,
+   (float)1.204834, (float)1.454468, (float)1.739136,
+   (float)1.137451, (float)1.421753, (float)1.620117,
+   (float)0.820435, (float)1.322754, (float)1.578247,
+   (float)0.798706, (float)1.005005, (float)1.213867,
+   (float)0.980713, (float)1.324951, (float)1.512939,
+   (float)1.112305, (float)1.438843, (float)1.735596,
+   (float)1.135498, (float)1.356689, (float)1.635742,
+   (float)1.101318, (float)1.387451, (float)1.686523,
+   (float)0.849854, (float)1.276978, (float)1.523438,
+   (float)1.377930, (float)1.627563, (float)1.858154,
+   (float)0.884888, (float)1.095459, (float)1.287476,
+   (float)1.289795, (float)1.505859, (float)1.756592,
+   (float)0.817505, (float)1.384155, (float)1.650513,
+   (float)1.446655, (float)1.702148, (float)1.931885,
+   (float)0.835815, (float)1.023071, (float)1.385376,
+   (float)0.916626, (float)1.139038, (float)1.335327,
+   (float)0.980103, (float)1.174072, (float)1.453735,
+   (float)1.705688, (float)2.153809, (float)2.398315, (float)2.743408,
+   (float)1.797119, (float)2.016846, (float)2.445679, (float)2.701904,
+   (float)1.990356, (float)2.219116, (float)2.576416, (float)2.813477,
+
+
+
+Andersen, et al.              Experimental                     [Page 93]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   (float)1.849365, (float)2.190918, (float)2.611572, (float)2.835083,
+   (float)1.657959, (float)1.854370, (float)2.159058, (float)2.726196,
+   (float)1.437744, (float)1.897705, (float)2.253174, (float)2.655396,
+   (float)2.028687, (float)2.247314, (float)2.542358, (float)2.875854,
+   (float)1.736938, (float)1.922119, (float)2.185913, (float)2.743408,
+   (float)1.521606, (float)1.870972, (float)2.526855, (float)2.786987,
+   (float)1.841431, (float)2.050659, (float)2.463623, (float)2.857666,
+   (float)1.590088, (float)2.067261, (float)2.427979, (float)2.794434,
+   (float)1.746826, (float)2.057373, (float)2.320190, (float)2.800781,
+   (float)1.734619, (float)1.940552, (float)2.306030, (float)2.826416,
+   (float)1.786255, (float)2.204468, (float)2.457520, (float)2.795288,
+   (float)1.861084, (float)2.170532, (float)2.414551, (float)2.763672,
+   (float)2.001465, (float)2.307617, (float)2.552734, (float)2.811890,
+   (float)1.784424, (float)2.124146, (float)2.381592, (float)2.645508,
+   (float)1.888794, (float)2.135864, (float)2.418579, (float)2.861206,
+   (float)2.301147, (float)2.531250, (float)2.724976, (float)2.913086,
+   (float)1.837769, (float)2.051270, (float)2.261963, (float)2.553223,
+   (float)2.012939, (float)2.221191, (float)2.440186, (float)2.678101,
+   (float)1.429565, (float)1.858276, (float)2.582275, (float)2.845703,
+   (float)1.622803, (float)1.897705, (float)2.367310, (float)2.621094,
+   (float)1.581543, (float)1.960449, (float)2.515869, (float)2.736450,
+   (float)1.419434, (float)1.933960, (float)2.394653, (float)2.746704,
+   (float)1.721924, (float)2.059570, (float)2.421753, (float)2.769653,
+   (float)1.911011, (float)2.220703, (float)2.461060, (float)2.740723,
+   (float)1.581177, (float)1.860840, (float)2.516968, (float)2.874634,
+   (float)1.870361, (float)2.098755, (float)2.432373, (float)2.656494,
+   (float)2.059692, (float)2.279785, (float)2.495605, (float)2.729370,
+   (float)1.815674, (float)2.181519, (float)2.451538, (float)2.680542,
+   (float)1.407959, (float)1.768311, (float)2.343018, (float)2.668091,
+   (float)2.168701, (float)2.394653, (float)2.604736, (float)2.829346,
+   (float)1.636230, (float)1.865723, (float)2.329102, (float)2.824219,
+   (float)1.878906, (float)2.139526, (float)2.376709, (float)2.679810,
+   (float)1.765381, (float)1.971802, (float)2.195435, (float)2.586914,
+   (float)2.164795, (float)2.410889, (float)2.673706, (float)2.903198,
+   (float)2.071899, (float)2.331055, (float)2.645874, (float)2.907104,
+   (float)2.026001, (float)2.311523, (float)2.594849, (float)2.863892,
+   (float)1.948975, (float)2.180786, (float)2.514893, (float)2.797852,
+   (float)1.881836, (float)2.130859, (float)2.478149, (float)2.804199,
+   (float)2.238159, (float)2.452759, (float)2.652832, (float)2.868286,
+   (float)1.897949, (float)2.101685, (float)2.524292, (float)2.880127,
+   (float)1.856445, (float)2.074585, (float)2.541016, (float)2.791748,
+   (float)1.695557, (float)2.199097, (float)2.506226, (float)2.742676,
+   (float)1.612671, (float)1.877075, (float)2.435425, (float)2.732910,
+   (float)1.568848, (float)1.786499, (float)2.194580, (float)2.768555,
+   (float)1.953369, (float)2.164551, (float)2.486938, (float)2.874023,
+   (float)1.388306, (float)1.725342, (float)2.384521, (float)2.771851,
+   (float)2.115356, (float)2.337769, (float)2.592896, (float)2.864014,
+   (float)1.905762, (float)2.111328, (float)2.363525, (float)2.789307,
+
+
+
+Andersen, et al.              Experimental                     [Page 94]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   (float)1.882568, (float)2.332031, (float)2.598267, (float)2.827637,
+   (float)1.683594, (float)2.088745, (float)2.361938, (float)2.608643,
+   (float)1.874023, (float)2.182129, (float)2.536133, (float)2.766968,
+   (float)1.861938, (float)2.070435, (float)2.309692, (float)2.700562,
+   (float)1.722168, (float)2.107422, (float)2.477295, (float)2.837646,
+   (float)1.926880, (float)2.184692, (float)2.442627, (float)2.663818,
+   (float)2.123901, (float)2.337280, (float)2.553101, (float)2.777466,
+   (float)1.588135, (float)1.911499, (float)2.212769, (float)2.543945,
+   (float)2.053955, (float)2.370850, (float)2.712158, (float)2.939941,
+   (float)2.210449, (float)2.519653, (float)2.770386, (float)2.958618,
+   (float)2.199463, (float)2.474731, (float)2.718262, (float)2.919922,
+   (float)1.960083, (float)2.175415, (float)2.608032, (float)2.888794,
+   (float)1.953735, (float)2.185181, (float)2.428223, (float)2.809570,
+   (float)1.615234, (float)2.036499, (float)2.576538, (float)2.834595,
+   (float)1.621094, (float)2.028198, (float)2.431030, (float)2.664673,
+   (float)1.824951, (float)2.267456, (float)2.514526, (float)2.747925,
+   (float)1.994263, (float)2.229126, (float)2.475220, (float)2.833984,
+   (float)1.746338, (float)2.011353, (float)2.588257, (float)2.826904,
+   (float)1.562866, (float)2.135986, (float)2.471680, (float)2.687256,
+   (float)1.748901, (float)2.083496, (float)2.460938, (float)2.686279,
+   (float)1.758057, (float)2.131470, (float)2.636597, (float)2.891602,
+   (float)2.071289, (float)2.299072, (float)2.550781, (float)2.814331,
+   (float)1.839600, (float)2.094360, (float)2.496460, (float)2.723999,
+   (float)1.882202, (float)2.088257, (float)2.636841, (float)2.923096,
+   (float)1.957886, (float)2.153198, (float)2.384399, (float)2.615234,
+   (float)1.992920, (float)2.351196, (float)2.654419, (float)2.889771,
+   (float)2.012817, (float)2.262451, (float)2.643799, (float)2.903076,
+   (float)2.025635, (float)2.254761, (float)2.508423, (float)2.784058,
+   (float)2.316040, (float)2.589355, (float)2.794189, (float)2.963623,
+   (float)1.741211, (float)2.279541, (float)2.578491, (float)2.816284,
+   (float)1.845337, (float)2.055786, (float)2.348511, (float)2.822021,
+   (float)1.679932, (float)1.926514, (float)2.499756, (float)2.835693,
+   (float)1.722534, (float)1.946899, (float)2.448486, (float)2.728760,
+   (float)1.829834, (float)2.043213, (float)2.580444, (float)2.867676,
+   (float)1.676636, (float)2.071655, (float)2.322510, (float)2.704834,
+   (float)1.791504, (float)2.113525, (float)2.469727, (float)2.784058,
+   (float)1.977051, (float)2.215088, (float)2.497437, (float)2.726929,
+   (float)1.800171, (float)2.106689, (float)2.357788, (float)2.738892,
+   (float)1.827759, (float)2.170166, (float)2.525879, (float)2.852417,
+   (float)1.918335, (float)2.132813, (float)2.488403, (float)2.728149,
+   (float)1.916748, (float)2.225098, (float)2.542603, (float)2.857666,
+   (float)1.761230, (float)1.976074, (float)2.507446, (float)2.884521,
+   (float)2.053711, (float)2.367432, (float)2.608032, (float)2.837646,
+   (float)1.595337, (float)2.000977, (float)2.307129, (float)2.578247,
+   (float)1.470581, (float)2.031250, (float)2.375854, (float)2.647583,
+   (float)1.801392, (float)2.128052, (float)2.399780, (float)2.822876,
+   (float)1.853638, (float)2.066650, (float)2.429199, (float)2.751465,
+   (float)1.956299, (float)2.163696, (float)2.394775, (float)2.734253,
+
+
+
+Andersen, et al.              Experimental                     [Page 95]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   (float)1.963623, (float)2.275757, (float)2.585327, (float)2.865234,
+   (float)1.887451, (float)2.105469, (float)2.331787, (float)2.587402,
+   (float)2.120117, (float)2.443359, (float)2.733887, (float)2.941406,
+   (float)1.506348, (float)1.766968, (float)2.400513, (float)2.851807,
+   (float)1.664551, (float)1.981079, (float)2.375732, (float)2.774414,
+   (float)1.720703, (float)1.978882, (float)2.391479, (float)2.640991,
+   (float)1.483398, (float)1.814819, (float)2.434448, (float)2.722290,
+   (float)1.769043, (float)2.136597, (float)2.563721, (float)2.774414,
+   (float)1.810791, (float)2.049316, (float)2.373901, (float)2.613647,
+   (float)1.788330, (float)2.005981, (float)2.359131, (float)2.723145,
+   (float)1.785156, (float)1.993164, (float)2.399780, (float)2.832520,
+   (float)1.695313, (float)2.022949, (float)2.522583, (float)2.745117,
+   (float)1.584106, (float)1.965576, (float)2.299927, (float)2.715576,
+   (float)1.894897, (float)2.249878, (float)2.655884, (float)2.897705,
+   (float)1.720581, (float)1.995728, (float)2.299438, (float)2.557007,
+   (float)1.619385, (float)2.173950, (float)2.574219, (float)2.787964,
+   (float)1.883179, (float)2.220459, (float)2.474365, (float)2.825073,
+   (float)1.447632, (float)2.045044, (float)2.555542, (float)2.744873,
+   (float)1.502686, (float)2.156616, (float)2.653320, (float)2.846558,
+   (float)1.711548, (float)1.944092, (float)2.282959, (float)2.685791,
+   (float)1.499756, (float)1.867554, (float)2.341064, (float)2.578857,
+   (float)1.916870, (float)2.135132, (float)2.568237, (float)2.826050,
+   (float)1.498047, (float)1.711182, (float)2.223267, (float)2.755127,
+   (float)1.808716, (float)1.997559, (float)2.256470, (float)2.758545,
+   (float)2.088501, (float)2.402710, (float)2.667358, (float)2.890259,
+   (float)1.545044, (float)1.819214, (float)2.324097, (float)2.692993,
+   (float)1.796021, (float)2.012573, (float)2.505737, (float)2.784912,
+   (float)1.786499, (float)2.041748, (float)2.290405, (float)2.650757,
+   (float)1.938232, (float)2.264404, (float)2.529053, (float)2.796143
+   };
+
+A.9.  anaFilter.h
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       anaFilter.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_ANAFILTER_H
+   #define __iLBC_ANAFILTER_H
+
+   void anaFilter(
+
+
+
+Andersen, et al.              Experimental                     [Page 96]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       float *In,  /* (i) Signal to be filtered */
+       float *a,   /* (i) LP parameters */
+       int len,/* (i) Length of signal */
+       float *Out, /* (o) Filtered signal */
+       float *mem  /* (i/o) Filter state */
+   );
+
+   #endif
+
+A.10.  anaFilter.c
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       anaFilter.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <string.h>
+   #include "iLBC_define.h"
+
+   /*----------------------------------------------------------------*
+    *  LP analysis filter.
+    *---------------------------------------------------------------*/
+
+   void anaFilter(
+       float *In,  /* (i) Signal to be filtered */
+       float *a,   /* (i) LP parameters */
+       int len,/* (i) Length of signal */
+       float *Out, /* (o) Filtered signal */
+       float *mem  /* (i/o) Filter state */
+   ){
+       int i, j;
+       float *po, *pi, *pm, *pa;
+
+       po = Out;
+
+       /* Filter first part using memory from past */
+
+       for (i=0; i<LPC_FILTERORDER; i++) {
+           pi = &In[i];
+           pm = &mem[LPC_FILTERORDER-1];
+           pa = a;
+           *po=0.0;
+
+
+
+Andersen, et al.              Experimental                     [Page 97]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+           for (j=0; j<=i; j++) {
+               *po+=(*pa++)*(*pi--);
+           }
+           for (j=i+1; j<LPC_FILTERORDER+1; j++) {
+
+               *po+=(*pa++)*(*pm--);
+           }
+           po++;
+       }
+
+       /* Filter last part where the state is entirely
+          in the input vector */
+
+       for (i=LPC_FILTERORDER; i<len; i++) {
+           pi = &In[i];
+           pa = a;
+           *po=0.0;
+           for (j=0; j<LPC_FILTERORDER+1; j++) {
+               *po+=(*pa++)*(*pi--);
+           }
+           po++;
+       }
+
+       /* Update state vector */
+
+       memcpy(mem, &In[len-LPC_FILTERORDER],
+           LPC_FILTERORDER*sizeof(float));
+   }
+
+A.11.  createCB.h
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       createCB.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_CREATECB_H
+   #define __iLBC_CREATECB_H
+
+   void filteredCBvecs(
+       float *cbvectors,   /* (o) Codebook vector for the
+                                  higher section */
+
+
+
+Andersen, et al.              Experimental                     [Page 98]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       float *mem,         /* (i) Buffer to create codebook
+                                  vectors from */
+       int lMem        /* (i) Length of buffer */
+   );
+
+   void searchAugmentedCB(
+       int low,        /* (i) Start index for the search */
+       int high,           /* (i) End index for the search */
+       int stage,          /* (i) Current stage */
+       int startIndex,     /* (i) CB index for the first
+                                  augmented vector */
+       float *target,      /* (i) Target vector for encoding */
+       float *buffer,      /* (i) Pointer to the end of the
+                                  buffer for augmented codebook
+                                  construction */
+       float *max_measure, /* (i/o) Currently maximum measure */
+       int *best_index,/* (o) Currently the best index */
+       float *gain,    /* (o) Currently the best gain */
+       float *energy,      /* (o) Energy of augmented
+                                  codebook vectors */
+       float *invenergy/* (o) Inv energy of aug codebook
+                                  vectors */
+   );
+
+   void createAugmentedVec(
+       int index,          /* (i) Index for the aug vector
+                                  to be created */
+       float *buffer,      /* (i) Pointer to the end of the
+                                  buffer for augmented codebook
+                                  construction */
+       float *cbVec    /* (o) The construced codebook vector */
+   );
+
+   #endif
+
+A.12.  createCB.c
+
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       createCB.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+
+
+Andersen, et al.              Experimental                     [Page 99]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   #include "iLBC_define.h"
+   #include "constants.h"
+   #include <string.h>
+   #include <math.h>
+
+   /*----------------------------------------------------------------*
+    *  Construct an additional codebook vector by filtering the
+    *  initial codebook buffer. This vector is then used to expand
+    *  the codebook with an additional section.
+    *---------------------------------------------------------------*/
+
+   void filteredCBvecs(
+       float *cbvectors,   /* (o) Codebook vectors for the
+                                  higher section */
+       float *mem,         /* (i) Buffer to create codebook
+                                  vector from */
+       int lMem        /* (i) Length of buffer */
+   ){
+       int j, k;
+       float *pp, *pp1;
+       float tempbuff2[CB_MEML+CB_FILTERLEN];
+       float *pos;
+
+       memset(tempbuff2, 0, (CB_HALFFILTERLEN-1)*sizeof(float));
+       memcpy(&tempbuff2[CB_HALFFILTERLEN-1], mem, lMem*sizeof(float));
+       memset(&tempbuff2[lMem+CB_HALFFILTERLEN-1], 0,
+           (CB_HALFFILTERLEN+1)*sizeof(float));
+
+       /* Create codebook vector for higher section by filtering */
+
+       /* do filtering */
+       pos=cbvectors;
+       memset(pos, 0, lMem*sizeof(float));
+       for (k=0; k<lMem; k++) {
+           pp=&tempbuff2[k];
+           pp1=&cbfiltersTbl[CB_FILTERLEN-1];
+           for (j=0;j<CB_FILTERLEN;j++) {
+               (*pos)+=(*pp++)*(*pp1--);
+           }
+           pos++;
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  Search the augmented part of the codebook to find the best
+    *  measure.
+    *----------------------------------------------------------------*/
+
+
+
+
+Andersen, et al.              Experimental                    [Page 100]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   void searchAugmentedCB(
+       int low,        /* (i) Start index for the search */
+       int high,           /* (i) End index for the search */
+       int stage,          /* (i) Current stage */
+       int startIndex,     /* (i) Codebook index for the first
+                                  aug vector */
+       float *target,      /* (i) Target vector for encoding */
+       float *buffer,      /* (i) Pointer to the end of the buffer for
+                                  augmented codebook construction */
+       float *max_measure, /* (i/o) Currently maximum measure */
+       int *best_index,/* (o) Currently the best index */
+       float *gain,    /* (o) Currently the best gain */
+       float *energy,      /* (o) Energy of augmented codebook
+                                  vectors */
+       float *invenergy/* (o) Inv energy of augmented codebook
+                                  vectors */
+   ) {
+       int icount, ilow, j, tmpIndex;
+       float *pp, *ppo, *ppi, *ppe, crossDot, alfa;
+       float weighted, measure, nrjRecursive;
+       float ftmp;
+
+       /* Compute the energy for the first (low-5)
+          noninterpolated samples */
+       nrjRecursive = (float) 0.0;
+       pp = buffer - low + 1;
+       for (j=0; j<(low-5); j++) {
+           nrjRecursive += ( (*pp)*(*pp) );
+           pp++;
+       }
+       ppe = buffer - low;
+
+
+       for (icount=low; icount<=high; icount++) {
+
+           /* Index of the codebook vector used for retrieving
+              energy values */
+           tmpIndex = startIndex+icount-20;
+
+           ilow = icount-4;
+
+           /* Update the energy recursively to save complexity */
+           nrjRecursive = nrjRecursive + (*ppe)*(*ppe);
+           ppe--;
+           energy[tmpIndex] = nrjRecursive;
+
+           /* Compute cross dot product for the first (low-5)
+              samples */
+
+
+
+Andersen, et al.              Experimental                    [Page 101]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+           crossDot = (float) 0.0;
+           pp = buffer-icount;
+           for (j=0; j<ilow; j++) {
+               crossDot += target[j]*(*pp++);
+           }
+
+           /* interpolation */
+           alfa = (float) 0.2;
+           ppo = buffer-4;
+           ppi = buffer-icount-4;
+           for (j=ilow; j<icount; j++) {
+               weighted = ((float)1.0-alfa)*(*ppo)+alfa*(*ppi);
+               ppo++;
+               ppi++;
+               energy[tmpIndex] += weighted*weighted;
+               crossDot += target[j]*weighted;
+               alfa += (float)0.2;
+           }
+
+           /* Compute energy and cross dot product for the
+              remaining samples */
+           pp = buffer - icount;
+           for (j=icount; j<SUBL; j++) {
+               energy[tmpIndex] += (*pp)*(*pp);
+               crossDot += target[j]*(*pp++);
+           }
+
+           if (energy[tmpIndex]>0.0) {
+               invenergy[tmpIndex]=(float)1.0/(energy[tmpIndex]+EPS);
+           } else {
+               invenergy[tmpIndex] = (float) 0.0;
+           }
+
+           if (stage==0) {
+               measure = (float)-10000000.0;
+
+               if (crossDot > 0.0) {
+                   measure = crossDot*crossDot*invenergy[tmpIndex];
+               }
+           }
+           else {
+               measure = crossDot*crossDot*invenergy[tmpIndex];
+           }
+
+           /* check if measure is better */
+           ftmp = crossDot*invenergy[tmpIndex];
+
+           if ((measure>*max_measure) && (fabs(ftmp)<CB_MAXGAIN)) {
+
+
+
+Andersen, et al.              Experimental                    [Page 102]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+               *best_index = tmpIndex;
+               *max_measure = measure;
+               *gain = ftmp;
+           }
+       }
+   }
+
+
+   /*----------------------------------------------------------------*
+    *  Recreate a specific codebook vector from the augmented part.
+    *
+    *----------------------------------------------------------------*/
+
+   void createAugmentedVec(
+       int index,      /* (i) Index for the augmented vector
+                              to be created */
+       float *buffer,  /* (i) Pointer to the end of the buffer for
+                              augmented codebook construction */
+       float *cbVec/* (o) The construced codebook vector */
+   ) {
+       int ilow, j;
+       float *pp, *ppo, *ppi, alfa, alfa1, weighted;
+
+       ilow = index-5;
+
+       /* copy the first noninterpolated part */
+
+       pp = buffer-index;
+       memcpy(cbVec,pp,sizeof(float)*index);
+
+       /* interpolation */
+
+       alfa1 = (float)0.2;
+       alfa = 0.0;
+       ppo = buffer-5;
+       ppi = buffer-index-5;
+       for (j=ilow; j<index; j++) {
+           weighted = ((float)1.0-alfa)*(*ppo)+alfa*(*ppi);
+           ppo++;
+           ppi++;
+           cbVec[j] = weighted;
+           alfa += alfa1;
+       }
+
+       /* copy the second noninterpolated part */
+
+       pp = buffer - index;
+       memcpy(cbVec+index,pp,sizeof(float)*(SUBL-index));
+
+
+
+Andersen, et al.              Experimental                    [Page 103]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   }
+
+A.13.  doCPLC.h
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       doCPLC.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_DOLPC_H
+   #define __iLBC_DOLPC_H
+
+   void doThePLC(
+       float *PLCresidual, /* (o) concealed residual */
+       float *PLClpc,      /* (o) concealed LP parameters */
+       int PLI,        /* (i) packet loss indicator
+                                  0 - no PL, 1 = PL */
+       float *decresidual, /* (i) decoded residual */
+       float *lpc,         /* (i) decoded LPC (only used for no PL) */
+       int inlag,          /* (i) pitch lag */
+       iLBC_Dec_Inst_t *iLBCdec_inst
+                           /* (i/o) decoder instance */
+   );
+
+   #endif
+
+A.14.  doCPLC.c
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       doCPLC.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <math.h>
+   #include <string.h>
+   #include <stdio.h>
+
+
+
+Andersen, et al.              Experimental                    [Page 104]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   #include "iLBC_define.h"
+
+   /*----------------------------------------------------------------*
+    *  Compute cross correlation and pitch gain for pitch prediction
+    *  of last subframe at given lag.
+    *---------------------------------------------------------------*/
+
+   void compCorr(
+       float *cc,      /* (o) cross correlation coefficient */
+       float *gc,      /* (o) gain */
+       float *pm,
+       float *buffer,  /* (i) signal buffer */
+       int lag,    /* (i) pitch lag */
+       int bLen,       /* (i) length of buffer */
+       int sRange      /* (i) correlation search length */
+   ){
+       int i;
+       float ftmp1, ftmp2, ftmp3;
+
+       /* Guard against getting outside buffer */
+       if ((bLen-sRange-lag)<0) {
+           sRange=bLen-lag;
+       }
+
+       ftmp1 = 0.0;
+       ftmp2 = 0.0;
+       ftmp3 = 0.0;
+       for (i=0; i<sRange; i++) {
+           ftmp1 += buffer[bLen-sRange+i] *
+               buffer[bLen-sRange+i-lag];
+           ftmp2 += buffer[bLen-sRange+i-lag] *
+                   buffer[bLen-sRange+i-lag];
+           ftmp3 += buffer[bLen-sRange+i] *
+                   buffer[bLen-sRange+i];
+       }
+
+       if (ftmp2 > 0.0) {
+           *cc = ftmp1*ftmp1/ftmp2;
+           *gc = (float)fabs(ftmp1/ftmp2);
+           *pm=(float)fabs(ftmp1)/
+               ((float)sqrt(ftmp2)*(float)sqrt(ftmp3));
+       }
+       else {
+           *cc = 0.0;
+           *gc = 0.0;
+           *pm=0.0;
+       }
+   }
+
+
+
+Andersen, et al.              Experimental                    [Page 105]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   /*----------------------------------------------------------------*
+    *  Packet loss concealment routine. Conceals a residual signal
+    *  and LP parameters. If no packet loss, update state.
+    *---------------------------------------------------------------*/
+
+   void doThePLC(
+       float *PLCresidual, /* (o) concealed residual */
+       float *PLClpc,      /* (o) concealed LP parameters */
+       int PLI,        /* (i) packet loss indicator
+                                  0 - no PL, 1 = PL */
+       float *decresidual, /* (i) decoded residual */
+       float *lpc,         /* (i) decoded LPC (only used for no PL) */
+       int inlag,          /* (i) pitch lag */
+       iLBC_Dec_Inst_t *iLBCdec_inst
+                           /* (i/o) decoder instance */
+   ){
+       int lag=20, randlag;
+       float gain, maxcc;
+       float use_gain;
+       float gain_comp, maxcc_comp, per, max_per;
+       int i, pick, use_lag;
+       float ftmp, randvec[BLOCKL_MAX], pitchfact, energy;
+
+       /* Packet Loss */
+
+       if (PLI == 1) {
+
+           iLBCdec_inst->consPLICount += 1;
+
+           /* if previous frame not lost,
+              determine pitch pred. gain */
+
+           if (iLBCdec_inst->prevPLI != 1) {
+
+               /* Search around the previous lag to find the
+                  best pitch period */
+
+               lag=inlag-3;
+               compCorr(&maxcc, &gain, &max_per,
+                   iLBCdec_inst->prevResidual,
+                   lag, iLBCdec_inst->blockl, 60);
+               for (i=inlag-2;i<=inlag+3;i++) {
+                   compCorr(&maxcc_comp, &gain_comp, &per,
+                       iLBCdec_inst->prevResidual,
+                       i, iLBCdec_inst->blockl, 60);
+
+                   if (maxcc_comp>maxcc) {
+                       maxcc=maxcc_comp;
+
+
+
+Andersen, et al.              Experimental                    [Page 106]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+                       gain=gain_comp;
+                       lag=i;
+                       max_per=per;
+                   }
+               }
+
+           }
+
+           /* previous frame lost, use recorded lag and periodicity */
+
+           else {
+               lag=iLBCdec_inst->prevLag;
+               max_per=iLBCdec_inst->per;
+           }
+
+           /* downscaling */
+
+           use_gain=1.0;
+           if (iLBCdec_inst->consPLICount*iLBCdec_inst->blockl>320)
+               use_gain=(float)0.9;
+           else if (iLBCdec_inst->consPLICount*
+                           iLBCdec_inst->blockl>2*320)
+               use_gain=(float)0.7;
+           else if (iLBCdec_inst->consPLICount*
+                           iLBCdec_inst->blockl>3*320)
+               use_gain=(float)0.5;
+           else if (iLBCdec_inst->consPLICount*
+                           iLBCdec_inst->blockl>4*320)
+               use_gain=(float)0.0;
+
+           /* mix noise and pitch repeatition */
+           ftmp=(float)sqrt(max_per);
+           if (ftmp>(float)0.7)
+               pitchfact=(float)1.0;
+           else if (ftmp>(float)0.4)
+               pitchfact=(ftmp-(float)0.4)/((float)0.7-(float)0.4);
+           else
+               pitchfact=0.0;
+
+
+           /* avoid repetition of same pitch cycle */
+           use_lag=lag;
+           if (lag<80) {
+               use_lag=2*lag;
+           }
+
+           /* compute concealed residual */
+
+
+
+
+Andersen, et al.              Experimental                    [Page 107]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+           energy = 0.0;
+           for (i=0; i<iLBCdec_inst->blockl; i++) {
+
+               /* noise component */
+
+               iLBCdec_inst->seed=(iLBCdec_inst->seed*69069L+1) &
+                   (0x80000000L-1);
+               randlag = 50 + ((signed long) iLBCdec_inst->seed)%70;
+               pick = i - randlag;
+
+               if (pick < 0) {
+                   randvec[i] =
+                       iLBCdec_inst->prevResidual[
+                                   iLBCdec_inst->blockl+pick];
+               } else {
+                   randvec[i] =  randvec[pick];
+               }
+
+               /* pitch repeatition component */
+               pick = i - use_lag;
+
+               if (pick < 0) {
+                   PLCresidual[i] =
+                       iLBCdec_inst->prevResidual[
+                                   iLBCdec_inst->blockl+pick];
+               } else {
+                   PLCresidual[i] = PLCresidual[pick];
+               }
+
+               /* mix random and periodicity component */
+
+               if (i<80)
+                   PLCresidual[i] = use_gain*(pitchfact *
+                               PLCresidual[i] +
+                               ((float)1.0 - pitchfact) * randvec[i]);
+               else if (i<160)
+                   PLCresidual[i] = (float)0.95*use_gain*(pitchfact *
+                               PLCresidual[i] +
+                               ((float)1.0 - pitchfact) * randvec[i]);
+               else
+                   PLCresidual[i] = (float)0.9*use_gain*(pitchfact *
+                               PLCresidual[i] +
+                               ((float)1.0 - pitchfact) * randvec[i]);
+
+               energy += PLCresidual[i] * PLCresidual[i];
+           }
+
+           /* less than 30 dB, use only noise */
+
+
+
+Andersen, et al.              Experimental                    [Page 108]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+
+           if (sqrt(energy/(float)iLBCdec_inst->blockl) < 30.0) {
+               gain=0.0;
+               for (i=0; i<iLBCdec_inst->blockl; i++) {
+                   PLCresidual[i] = randvec[i];
+               }
+           }
+
+           /* use old LPC */
+
+           memcpy(PLClpc,iLBCdec_inst->prevLpc,
+               (LPC_FILTERORDER+1)*sizeof(float));
+
+       }
+
+       /* no packet loss, copy input */
+
+       else {
+           memcpy(PLCresidual, decresidual,
+               iLBCdec_inst->blockl*sizeof(float));
+           memcpy(PLClpc, lpc, (LPC_FILTERORDER+1)*sizeof(float));
+           iLBCdec_inst->consPLICount = 0;
+       }
+
+       /* update state */
+
+       if (PLI) {
+           iLBCdec_inst->prevLag = lag;
+           iLBCdec_inst->per=max_per;
+       }
+
+       iLBCdec_inst->prevPLI = PLI;
+       memcpy(iLBCdec_inst->prevLpc, PLClpc,
+           (LPC_FILTERORDER+1)*sizeof(float));
+       memcpy(iLBCdec_inst->prevResidual, PLCresidual,
+           iLBCdec_inst->blockl*sizeof(float));
+   }
+
+A.15.  enhancer.h
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       enhancer.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+
+
+Andersen, et al.              Experimental                    [Page 109]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   ******************************************************************/
+
+   #ifndef __ENHANCER_H
+   #define __ENHANCER_H
+
+   #include "iLBC_define.h"
+
+   float xCorrCoef(
+       float *target,      /* (i) first array */
+       float *regressor,   /* (i) second array */
+       int subl        /* (i) dimension arrays */
+   );
+
+   int enhancerInterface(
+       float *out,         /* (o) the enhanced recidual signal */
+       float *in,          /* (i) the recidual signal to enhance */
+       iLBC_Dec_Inst_t *iLBCdec_inst
+                           /* (i/o) the decoder state structure */
+   );
+
+   #endif
+
+A.16.  enhancer.c
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       enhancer.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <math.h>
+   #include <string.h>
+   #include "iLBC_define.h"
+   #include "constants.h"
+   #include "filter.h"
+
+   /*----------------------------------------------------------------*
+    * Find index in array such that the array element with said
+    * index is the element of said array closest to "value"
+    * according to the squared-error criterion
+    *---------------------------------------------------------------*/
+
+   void NearestNeighbor(
+
+
+
+Andersen, et al.              Experimental                    [Page 110]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       int   *index,   /* (o) index of array element closest
+                              to value */
+       float *array,   /* (i) data array */
+       float value,/* (i) value */
+       int arlength/* (i) dimension of data array */
+   ){
+       int i;
+       float bestcrit,crit;
+
+       crit=array[0]-value;
+       bestcrit=crit*crit;
+       *index=0;
+       for (i=1; i<arlength; i++) {
+           crit=array[i]-value;
+           crit=crit*crit;
+
+           if (crit<bestcrit) {
+               bestcrit=crit;
+               *index=i;
+           }
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    * compute cross correlation between sequences
+    *---------------------------------------------------------------*/
+
+   void mycorr1(
+       float* corr,    /* (o) correlation of seq1 and seq2 */
+       float* seq1,    /* (i) first sequence */
+       int dim1,           /* (i) dimension first seq1 */
+       const float *seq2,  /* (i) second sequence */
+       int dim2        /* (i) dimension seq2 */
+   ){
+       int i,j;
+
+       for (i=0; i<=dim1-dim2; i++) {
+           corr[i]=0.0;
+           for (j=0; j<dim2; j++) {
+               corr[i] += seq1[i+j] * seq2[j];
+           }
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    * upsample finite array assuming zeros outside bounds
+    *---------------------------------------------------------------*/
+
+
+
+
+Andersen, et al.              Experimental                    [Page 111]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   void enh_upsample(
+       float* useq1,   /* (o) upsampled output sequence */
+       float* seq1,/* (i) unupsampled sequence */
+       int dim1,       /* (i) dimension seq1 */
+       int hfl         /* (i) polyphase filter length=2*hfl+1 */
+   ){
+       float *pu,*ps;
+       int i,j,k,q,filterlength,hfl2;
+       const float *polyp[ENH_UPS0]; /* pointers to
+                                        polyphase columns */
+       const float *pp;
+
+       /* define pointers for filter */
+
+       filterlength=2*hfl+1;
+
+       if ( filterlength > dim1 ) {
+           hfl2=(int) (dim1/2);
+           for (j=0; j<ENH_UPS0; j++) {
+               polyp[j]=polyphaserTbl+j*filterlength+hfl-hfl2;
+           }
+           hfl=hfl2;
+           filterlength=2*hfl+1;
+       }
+       else {
+           for (j=0; j<ENH_UPS0; j++) {
+               polyp[j]=polyphaserTbl+j*filterlength;
+           }
+       }
+
+       /* filtering: filter overhangs left side of sequence */
+
+       pu=useq1;
+       for (i=hfl; i<filterlength; i++) {
+           for (j=0; j<ENH_UPS0; j++) {
+               *pu=0.0;
+               pp = polyp[j];
+               ps = seq1+i;
+               for (k=0; k<=i; k++) {
+                   *pu += *ps-- * *pp++;
+               }
+               pu++;
+           }
+       }
+
+       /* filtering: simple convolution=inner products */
+
+       for (i=filterlength; i<dim1; i++) {
+
+
+
+Andersen, et al.              Experimental                    [Page 112]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+           for (j=0;j<ENH_UPS0; j++){
+               *pu=0.0;
+               pp = polyp[j];
+               ps = seq1+i;
+               for (k=0; k<filterlength; k++) {
+                   *pu += *ps-- * *pp++;
+               }
+               pu++;
+           }
+       }
+
+       /* filtering: filter overhangs right side of sequence */
+
+       for (q=1; q<=hfl; q++) {
+           for (j=0; j<ENH_UPS0; j++) {
+               *pu=0.0;
+               pp = polyp[j]+q;
+               ps = seq1+dim1-1;
+               for (k=0; k<filterlength-q; k++) {
+                   *pu += *ps-- * *pp++;
+               }
+               pu++;
+           }
+       }
+   }
+
+
+   /*----------------------------------------------------------------*
+    * find segment starting near idata+estSegPos that has highest
+    * correlation with idata+centerStartPos through
+    * idata+centerStartPos+ENH_BLOCKL-1 segment is found at a
+    * resolution of ENH_UPSO times the original of the original
+    * sampling rate
+    *---------------------------------------------------------------*/
+
+   void refiner(
+       float *seg,         /* (o) segment array */
+       float *updStartPos, /* (o) updated start point */
+       float* idata,       /* (i) original data buffer */
+       int idatal,         /* (i) dimension of idata */
+       int centerStartPos, /* (i) beginning center segment */
+       float estSegPos,/* (i) estimated beginning other segment */
+       float period    /* (i) estimated pitch period */
+   ){
+       int estSegPosRounded,searchSegStartPos,searchSegEndPos,corrdim;
+       int tloc,tloc2,i,st,en,fraction;
+       float vect[ENH_VECTL],corrVec[ENH_CORRDIM],maxv;
+       float corrVecUps[ENH_CORRDIM*ENH_UPS0];
+
+
+
+Andersen, et al.              Experimental                    [Page 113]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       /* defining array bounds */
+
+       estSegPosRounded=(int)(estSegPos - 0.5);
+
+       searchSegStartPos=estSegPosRounded-ENH_SLOP;
+
+       if (searchSegStartPos<0) {
+           searchSegStartPos=0;
+       }
+       searchSegEndPos=estSegPosRounded+ENH_SLOP;
+
+       if (searchSegEndPos+ENH_BLOCKL >= idatal) {
+           searchSegEndPos=idatal-ENH_BLOCKL-1;
+       }
+       corrdim=searchSegEndPos-searchSegStartPos+1;
+
+       /* compute upsampled correlation (corr33) and find
+          location of max */
+
+       mycorr1(corrVec,idata+searchSegStartPos,
+           corrdim+ENH_BLOCKL-1,idata+centerStartPos,ENH_BLOCKL);
+       enh_upsample(corrVecUps,corrVec,corrdim,ENH_FL0);
+       tloc=0; maxv=corrVecUps[0];
+       for (i=1; i<ENH_UPS0*corrdim; i++) {
+
+           if (corrVecUps[i]>maxv) {
+               tloc=i;
+               maxv=corrVecUps[i];
+           }
+       }
+
+       /* make vector can be upsampled without ever running outside
+          bounds */
+
+       *updStartPos= (float)searchSegStartPos +
+           (float)tloc/(float)ENH_UPS0+(float)1.0;
+       tloc2=(int)(tloc/ENH_UPS0);
+
+       if (tloc>tloc2*ENH_UPS0) {
+           tloc2++;
+       }
+       st=searchSegStartPos+tloc2-ENH_FL0;
+
+       if (st<0) {
+           memset(vect,0,-st*sizeof(float));
+           memcpy(&vect[-st],idata, (ENH_VECTL+st)*sizeof(float));
+       }
+       else {
+
+
+
+Andersen, et al.              Experimental                    [Page 114]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+           en=st+ENH_VECTL;
+
+           if (en>idatal) {
+               memcpy(vect, &idata[st],
+                   (ENH_VECTL-(en-idatal))*sizeof(float));
+               memset(&vect[ENH_VECTL-(en-idatal)], 0,
+                   (en-idatal)*sizeof(float));
+           }
+           else {
+               memcpy(vect, &idata[st], ENH_VECTL*sizeof(float));
+           }
+       }
+       fraction=tloc2*ENH_UPS0-tloc;
+
+       /* compute the segment (this is actually a convolution) */
+
+       mycorr1(seg,vect,ENH_VECTL,polyphaserTbl+(2*ENH_FL0+1)*fraction,
+           2*ENH_FL0+1);
+   }
+
+   /*----------------------------------------------------------------*
+    * find the smoothed output data
+    *---------------------------------------------------------------*/
+
+   void smath(
+       float *odata,   /* (o) smoothed output */
+       float *sseq,/* (i) said second sequence of waveforms */
+       int hl,         /* (i) 2*hl+1 is sseq dimension */
+       float alpha0/* (i) max smoothing energy fraction */
+   ){
+       int i,k;
+       float w00,w10,w11,A,B,C,*psseq,err,errs;
+       float surround[BLOCKL_MAX]; /* shape contributed by other than
+                                      current */
+       float wt[2*ENH_HL+1];       /* waveform weighting to get
+                                      surround shape */
+       float denom;
+
+       /* create shape of contribution from all waveforms except the
+          current one */
+
+       for (i=1; i<=2*hl+1; i++) {
+           wt[i-1] = (float)0.5*(1 - (float)cos(2*PI*i/(2*hl+2)));
+       }
+       wt[hl]=0.0; /* for clarity, not used */
+       for (i=0; i<ENH_BLOCKL; i++) {
+           surround[i]=sseq[i]*wt[0];
+       }
+
+
+
+Andersen, et al.              Experimental                    [Page 115]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       for (k=1; k<hl; k++) {
+           psseq=sseq+k*ENH_BLOCKL;
+           for(i=0;i<ENH_BLOCKL; i++) {
+               surround[i]+=psseq[i]*wt[k];
+           }
+       }
+       for (k=hl+1; k<=2*hl; k++) {
+           psseq=sseq+k*ENH_BLOCKL;
+           for(i=0;i<ENH_BLOCKL; i++) {
+               surround[i]+=psseq[i]*wt[k];
+           }
+       }
+
+       /* compute some inner products */
+
+       w00 = w10 = w11 = 0.0;
+       psseq=sseq+hl*ENH_BLOCKL; /* current block  */
+       for (i=0; i<ENH_BLOCKL;i++) {
+           w00+=psseq[i]*psseq[i];
+           w11+=surround[i]*surround[i];
+           w10+=surround[i]*psseq[i];
+       }
+
+       if (fabs(w11) < 1.0) {
+           w11=1.0;
+       }
+       C = (float)sqrt( w00/w11);
+
+       /* first try enhancement without power-constraint */
+
+       errs=0.0;
+       psseq=sseq+hl*ENH_BLOCKL;
+       for (i=0; i<ENH_BLOCKL; i++) {
+           odata[i]=C*surround[i];
+           err=psseq[i]-odata[i];
+           errs+=err*err;
+       }
+
+       /* if constraint violated by first try, add constraint */
+
+       if (errs > alpha0 * w00) {
+           if ( w00 < 1) {
+               w00=1;
+           }
+           denom = (w11*w00-w10*w10)/(w00*w00);
+
+           if (denom > 0.0001) { /* eliminates numerical problems
+                                    for if smooth */
+
+
+
+Andersen, et al.              Experimental                    [Page 116]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+               A = (float)sqrt( (alpha0- alpha0*alpha0/4)/denom);
+               B = -alpha0/2 - A * w10/w00;
+               B = B+1;
+           }
+           else { /* essentially no difference between cycles;
+                     smoothing not needed */
+               A= 0.0;
+               B= 1.0;
+           }
+
+           /* create smoothed sequence */
+
+           psseq=sseq+hl*ENH_BLOCKL;
+           for (i=0; i<ENH_BLOCKL; i++) {
+               odata[i]=A*surround[i]+B*psseq[i];
+           }
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    * get the pitch-synchronous sample sequence
+    *---------------------------------------------------------------*/
+
+   void getsseq(
+       float *sseq,    /* (o) the pitch-synchronous sequence */
+       float *idata,       /* (i) original data */
+       int idatal,         /* (i) dimension of data */
+       int centerStartPos, /* (i) where current block starts */
+       float *period,      /* (i) rough-pitch-period array */
+       float *plocs,       /* (i) where periods of period array
+                                  are taken */
+       int periodl,    /* (i) dimension period array */
+       int hl              /* (i) 2*hl+1 is the number of sequences */
+   ){
+       int i,centerEndPos,q;
+       float blockStartPos[2*ENH_HL+1];
+       int lagBlock[2*ENH_HL+1];
+       float plocs2[ENH_PLOCSL];
+       float *psseq;
+
+       centerEndPos=centerStartPos+ENH_BLOCKL-1;
+
+       /* present */
+
+       NearestNeighbor(lagBlock+hl,plocs,
+           (float)0.5*(centerStartPos+centerEndPos),periodl);
+
+       blockStartPos[hl]=(float)centerStartPos;
+
+
+
+Andersen, et al.              Experimental                    [Page 117]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       psseq=sseq+ENH_BLOCKL*hl;
+       memcpy(psseq, idata+centerStartPos, ENH_BLOCKL*sizeof(float));
+
+       /* past */
+
+       for (q=hl-1; q>=0; q--) {
+           blockStartPos[q]=blockStartPos[q+1]-period[lagBlock[q+1]];
+           NearestNeighbor(lagBlock+q,plocs,
+               blockStartPos[q]+
+               ENH_BLOCKL_HALF-period[lagBlock[q+1]], periodl);
+
+
+           if (blockStartPos[q]-ENH_OVERHANG>=0) {
+               refiner(sseq+q*ENH_BLOCKL, blockStartPos+q, idata,
+                   idatal, centerStartPos, blockStartPos[q],
+                   period[lagBlock[q+1]]);
+           } else {
+               psseq=sseq+q*ENH_BLOCKL;
+               memset(psseq, 0, ENH_BLOCKL*sizeof(float));
+           }
+       }
+
+       /* future */
+
+       for (i=0; i<periodl; i++) {
+           plocs2[i]=plocs[i]-period[i];
+       }
+       for (q=hl+1; q<=2*hl; q++) {
+           NearestNeighbor(lagBlock+q,plocs2,
+               blockStartPos[q-1]+ENH_BLOCKL_HALF,periodl);
+
+           blockStartPos[q]=blockStartPos[q-1]+period[lagBlock[q]];
+           if (blockStartPos[q]+ENH_BLOCKL+ENH_OVERHANG<idatal) {
+               refiner(sseq+ENH_BLOCKL*q, blockStartPos+q, idata,
+                   idatal, centerStartPos, blockStartPos[q],
+                   period[lagBlock[q]]);
+           }
+           else {
+               psseq=sseq+q*ENH_BLOCKL;
+               memset(psseq, 0, ENH_BLOCKL*sizeof(float));
+           }
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    * perform enhancement on idata+centerStartPos through
+    * idata+centerStartPos+ENH_BLOCKL-1
+    *---------------------------------------------------------------*/
+
+
+
+Andersen, et al.              Experimental                    [Page 118]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   void enhancer(
+       float *odata,       /* (o) smoothed block, dimension blockl */
+       float *idata,       /* (i) data buffer used for enhancing */
+       int idatal,         /* (i) dimension idata */
+       int centerStartPos, /* (i) first sample current block
+                                  within idata */
+       float alpha0,       /* (i) max correction-energy-fraction
+                                 (in [0,1]) */
+       float *period,      /* (i) pitch period array */
+       float *plocs,       /* (i) locations where period array
+                                  values valid */
+       int periodl         /* (i) dimension of period and plocs */
+   ){
+       float sseq[(2*ENH_HL+1)*ENH_BLOCKL];
+
+       /* get said second sequence of segments */
+
+       getsseq(sseq,idata,idatal,centerStartPos,period,
+           plocs,periodl,ENH_HL);
+
+       /* compute the smoothed output from said second sequence */
+
+       smath(odata,sseq,ENH_HL,alpha0);
+
+   }
+
+   /*----------------------------------------------------------------*
+    * cross correlation
+    *---------------------------------------------------------------*/
+
+   float xCorrCoef(
+       float *target,      /* (i) first array */
+       float *regressor,   /* (i) second array */
+       int subl        /* (i) dimension arrays */
+   ){
+       int i;
+       float ftmp1, ftmp2;
+
+       ftmp1 = 0.0;
+       ftmp2 = 0.0;
+       for (i=0; i<subl; i++) {
+           ftmp1 += target[i]*regressor[i];
+           ftmp2 += regressor[i]*regressor[i];
+       }
+
+       if (ftmp1 > 0.0) {
+           return (float)(ftmp1*ftmp1/ftmp2);
+       }
+
+
+
+Andersen, et al.              Experimental                    [Page 119]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       else {
+           return (float)0.0;
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    * interface for enhancer
+    *---------------------------------------------------------------*/
+
+   int enhancerInterface(
+       float *out,                     /* (o) enhanced signal */
+       float *in,                      /* (i) unenhanced signal */
+       iLBC_Dec_Inst_t *iLBCdec_inst   /* (i) buffers etc */
+   ){
+       float *enh_buf, *enh_period;
+       int iblock, isample;
+       int lag=0, ilag, i, ioffset;
+       float cc, maxcc;
+       float ftmp1, ftmp2;
+       float *inPtr, *enh_bufPtr1, *enh_bufPtr2;
+       float plc_pred[ENH_BLOCKL];
+
+       float lpState[6], downsampled[(ENH_NBLOCKS*ENH_BLOCKL+120)/2];
+       int inLen=ENH_NBLOCKS*ENH_BLOCKL+120;
+       int start, plc_blockl, inlag;
+
+       enh_buf=iLBCdec_inst->enh_buf;
+       enh_period=iLBCdec_inst->enh_period;
+
+       memmove(enh_buf, &enh_buf[iLBCdec_inst->blockl],
+           (ENH_BUFL-iLBCdec_inst->blockl)*sizeof(float));
+
+       memcpy(&enh_buf[ENH_BUFL-iLBCdec_inst->blockl], in,
+           iLBCdec_inst->blockl*sizeof(float));
+
+       if (iLBCdec_inst->mode==30)
+           plc_blockl=ENH_BLOCKL;
+       else
+           plc_blockl=40;
+
+       /* when 20 ms frame, move processing one block */
+       ioffset=0;
+       if (iLBCdec_inst->mode==20) ioffset=1;
+
+       i=3-ioffset;
+       memmove(enh_period, &enh_period[i],
+           (ENH_NBLOCKS_TOT-i)*sizeof(float));
+
+
+
+
+Andersen, et al.              Experimental                    [Page 120]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       /* Set state information to the 6 samples right before
+          the samples to be downsampled. */
+
+       memcpy(lpState,
+           enh_buf+(ENH_NBLOCKS_EXTRA+ioffset)*ENH_BLOCKL-126,
+           6*sizeof(float));
+
+       /* Down sample a factor 2 to save computations */
+
+       DownSample(enh_buf+(ENH_NBLOCKS_EXTRA+ioffset)*ENH_BLOCKL-120,
+                   lpFilt_coefsTbl, inLen-ioffset*ENH_BLOCKL,
+                   lpState, downsampled);
+
+       /* Estimate the pitch in the down sampled domain. */
+       for (iblock = 0; iblock<ENH_NBLOCKS-ioffset; iblock++) {
+
+           lag = 10;
+           maxcc = xCorrCoef(downsampled+60+iblock*
+               ENH_BLOCKL_HALF, downsampled+60+iblock*
+               ENH_BLOCKL_HALF-lag, ENH_BLOCKL_HALF);
+           for (ilag=11; ilag<60; ilag++) {
+               cc = xCorrCoef(downsampled+60+iblock*
+                   ENH_BLOCKL_HALF, downsampled+60+iblock*
+                   ENH_BLOCKL_HALF-ilag, ENH_BLOCKL_HALF);
+
+               if (cc > maxcc) {
+                   maxcc = cc;
+                   lag = ilag;
+               }
+           }
+
+           /* Store the estimated lag in the non-downsampled domain */
+           enh_period[iblock+ENH_NBLOCKS_EXTRA+ioffset] = (float)lag*2;
+
+
+       }
+
+
+       /* PLC was performed on the previous packet */
+       if (iLBCdec_inst->prev_enh_pl==1) {
+
+           inlag=(int)enh_period[ENH_NBLOCKS_EXTRA+ioffset];
+
+           lag = inlag-1;
+           maxcc = xCorrCoef(in, in+lag, plc_blockl);
+           for (ilag=inlag; ilag<=inlag+1; ilag++) {
+               cc = xCorrCoef(in, in+ilag, plc_blockl);
+
+
+
+
+Andersen, et al.              Experimental                    [Page 121]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+               if (cc > maxcc) {
+                   maxcc = cc;
+                   lag = ilag;
+               }
+           }
+
+           enh_period[ENH_NBLOCKS_EXTRA+ioffset-1]=(float)lag;
+
+           /* compute new concealed residual for the old lookahead,
+              mix the forward PLC with a backward PLC from
+              the new frame */
+
+           inPtr=&in[lag-1];
+
+           enh_bufPtr1=&plc_pred[plc_blockl-1];
+
+           if (lag>plc_blockl) {
+               start=plc_blockl;
+           } else {
+               start=lag;
+           }
+
+           for (isample = start; isample>0; isample--) {
+               *enh_bufPtr1-- = *inPtr--;
+           }
+
+           enh_bufPtr2=&enh_buf[ENH_BUFL-1-iLBCdec_inst->blockl];
+           for (isample = (plc_blockl-1-lag); isample>=0; isample--) {
+               *enh_bufPtr1-- = *enh_bufPtr2--;
+           }
+
+           /* limit energy change */
+           ftmp2=0.0;
+           ftmp1=0.0;
+           for (i=0;i<plc_blockl;i++) {
+               ftmp2+=enh_buf[ENH_BUFL-1-iLBCdec_inst->blockl-i]*
+                   enh_buf[ENH_BUFL-1-iLBCdec_inst->blockl-i];
+               ftmp1+=plc_pred[i]*plc_pred[i];
+           }
+           ftmp1=(float)sqrt(ftmp1/(float)plc_blockl);
+           ftmp2=(float)sqrt(ftmp2/(float)plc_blockl);
+           if (ftmp1>(float)2.0*ftmp2 && ftmp1>0.0) {
+               for (i=0;i<plc_blockl-10;i++) {
+                   plc_pred[i]*=(float)2.0*ftmp2/ftmp1;
+               }
+               for (i=plc_blockl-10;i<plc_blockl;i++) {
+                   plc_pred[i]*=(float)(i-plc_blockl+10)*
+                       ((float)1.0-(float)2.0*ftmp2/ftmp1)/(float)(10)+
+
+
+
+Andersen, et al.              Experimental                    [Page 122]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+                       (float)2.0*ftmp2/ftmp1;
+               }
+           }
+
+           enh_bufPtr1=&enh_buf[ENH_BUFL-1-iLBCdec_inst->blockl];
+           for (i=0; i<plc_blockl; i++) {
+               ftmp1 = (float) (i+1) / (float) (plc_blockl+1);
+               *enh_bufPtr1 *= ftmp1;
+               *enh_bufPtr1 += ((float)1.0-ftmp1)*
+                                   plc_pred[plc_blockl-1-i];
+               enh_bufPtr1--;
+           }
+       }
+
+       if (iLBCdec_inst->mode==20) {
+           /* Enhancer with 40 samples delay */
+           for (iblock = 0; iblock<2; iblock++) {
+               enhancer(out+iblock*ENH_BLOCKL, enh_buf,
+                   ENH_BUFL, (5+iblock)*ENH_BLOCKL+40,
+                   ENH_ALPHA0, enh_period, enh_plocsTbl,
+                       ENH_NBLOCKS_TOT);
+           }
+       } else if (iLBCdec_inst->mode==30) {
+           /* Enhancer with 80 samples delay */
+           for (iblock = 0; iblock<3; iblock++) {
+               enhancer(out+iblock*ENH_BLOCKL, enh_buf,
+                   ENH_BUFL, (4+iblock)*ENH_BLOCKL,
+                   ENH_ALPHA0, enh_period, enh_plocsTbl,
+                       ENH_NBLOCKS_TOT);
+           }
+       }
+
+       return (lag*2);
+   }
+
+A.17.  filter.h
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       filter.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+
+
+
+Andersen, et al.              Experimental                    [Page 123]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   #ifndef __iLBC_FILTER_H
+   #define __iLBC_FILTER_H
+
+   void AllPoleFilter(
+       float *InOut,   /* (i/o) on entrance InOut[-orderCoef] to
+                              InOut[-1] contain the state of the
+                              filter (delayed samples). InOut[0] to
+                              InOut[lengthInOut-1] contain the filter
+                              input, on en exit InOut[-orderCoef] to
+                              InOut[-1] is unchanged and InOut[0] to
+                              InOut[lengthInOut-1] contain filtered
+                              samples */
+       float *Coef,/* (i) filter coefficients, Coef[0] is assumed
+                              to be 1.0 */
+       int lengthInOut,/* (i) number of input/output samples */
+       int orderCoef   /* (i) number of filter coefficients */
+   );
+
+   void AllZeroFilter(
+       float *In,      /* (i) In[0] to In[lengthInOut-1] contain
+                              filter input samples */
+       float *Coef,/* (i) filter coefficients (Coef[0] is assumed
+                              to be 1.0) */
+       int lengthInOut,/* (i) number of input/output samples */
+       int orderCoef,  /* (i) number of filter coefficients */
+       float *Out      /* (i/o) on entrance Out[-orderCoef] to Out[-1]
+                              contain the filter state, on exit Out[0]
+                              to Out[lengthInOut-1] contain filtered
+                              samples */
+   );
+
+   void ZeroPoleFilter(
+       float *In,      /* (i) In[0] to In[lengthInOut-1] contain filter
+                              input samples In[-orderCoef] to In[-1]
+                              contain state of all-zero section */
+       float *ZeroCoef,/* (i) filter coefficients for all-zero
+                              section (ZeroCoef[0] is assumed to
+                              be 1.0) */
+       float *PoleCoef,/* (i) filter coefficients for all-pole section
+                              (ZeroCoef[0] is assumed to be 1.0) */
+       int lengthInOut,/* (i) number of input/output samples */
+       int orderCoef,  /* (i) number of filter coefficients */
+       float *Out      /* (i/o) on entrance Out[-orderCoef] to Out[-1]
+                              contain state of all-pole section. On
+                              exit Out[0] to Out[lengthInOut-1]
+                              contain filtered samples */
+   );
+
+
+
+
+Andersen, et al.              Experimental                    [Page 124]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   void DownSample (
+       float  *In,     /* (i) input samples */
+       float  *Coef,   /* (i) filter coefficients */
+       int lengthIn,   /* (i) number of input samples */
+       float  *state,  /* (i) filter state */
+       float  *Out     /* (o) downsampled output */
+   );
+
+   #endif
+
+A.18.  filter.c
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       filter.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include "iLBC_define.h"
+
+   /*----------------------------------------------------------------*
+    *  all-pole filter
+    *---------------------------------------------------------------*/
+
+   void AllPoleFilter(
+       float *InOut,   /* (i/o) on entrance InOut[-orderCoef] to
+                              InOut[-1] contain the state of the
+                              filter (delayed samples). InOut[0] to
+                              InOut[lengthInOut-1] contain the filter
+                              input, on en exit InOut[-orderCoef] to
+                              InOut[-1] is unchanged and InOut[0] to
+                              InOut[lengthInOut-1] contain filtered
+                              samples */
+       float *Coef,/* (i) filter coefficients, Coef[0] is assumed
+                              to be 1.0 */
+       int lengthInOut,/* (i) number of input/output samples */
+       int orderCoef   /* (i) number of filter coefficients */
+   ){
+       int n,k;
+
+       for(n=0;n<lengthInOut;n++){
+           for(k=1;k<=orderCoef;k++){
+               *InOut -= Coef[k]*InOut[-k];
+
+
+
+Andersen, et al.              Experimental                    [Page 125]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+           }
+           InOut++;
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  all-zero filter
+    *---------------------------------------------------------------*/
+
+   void AllZeroFilter(
+       float *In,      /* (i) In[0] to In[lengthInOut-1] contain
+                              filter input samples */
+       float *Coef,/* (i) filter coefficients (Coef[0] is assumed
+                              to be 1.0) */
+       int lengthInOut,/* (i) number of input/output samples */
+       int orderCoef,  /* (i) number of filter coefficients */
+       float *Out      /* (i/o) on entrance Out[-orderCoef] to Out[-1]
+                              contain the filter state, on exit Out[0]
+                              to Out[lengthInOut-1] contain filtered
+                              samples */
+   ){
+       int n,k;
+
+       for(n=0;n<lengthInOut;n++){
+           *Out = Coef[0]*In[0];
+           for(k=1;k<=orderCoef;k++){
+               *Out += Coef[k]*In[-k];
+           }
+           Out++;
+           In++;
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  pole-zero filter
+    *---------------------------------------------------------------*/
+
+   void ZeroPoleFilter(
+       float *In,      /* (i) In[0] to In[lengthInOut-1] contain
+                              filter input samples In[-orderCoef] to
+                              In[-1] contain state of all-zero
+                              section */
+       float *ZeroCoef,/* (i) filter coefficients for all-zero
+                              section (ZeroCoef[0] is assumed to
+                              be 1.0) */
+       float *PoleCoef,/* (i) filter coefficients for all-pole section
+                              (ZeroCoef[0] is assumed to be 1.0) */
+       int lengthInOut,/* (i) number of input/output samples */
+
+
+
+Andersen, et al.              Experimental                    [Page 126]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       int orderCoef,  /* (i) number of filter coefficients */
+       float *Out      /* (i/o) on entrance Out[-orderCoef] to Out[-1]
+                              contain state of all-pole section. On
+                              exit Out[0] to Out[lengthInOut-1]
+                              contain filtered samples */
+   ){
+       AllZeroFilter(In,ZeroCoef,lengthInOut,orderCoef,Out);
+       AllPoleFilter(Out,PoleCoef,lengthInOut,orderCoef);
+   }
+
+   /*----------------------------------------------------------------*
+    * downsample (LP filter and decimation)
+    *---------------------------------------------------------------*/
+
+   void DownSample (
+       float  *In,     /* (i) input samples */
+       float  *Coef,   /* (i) filter coefficients */
+       int lengthIn,   /* (i) number of input samples */
+       float  *state,  /* (i) filter state */
+       float  *Out     /* (o) downsampled output */
+   ){
+       float   o;
+       float *Out_ptr = Out;
+       float *Coef_ptr, *In_ptr;
+       float *state_ptr;
+       int i, j, stop;
+
+       /* LP filter and decimate at the same time */
+
+       for (i = DELAY_DS; i < lengthIn; i+=FACTOR_DS)
+       {
+           Coef_ptr = &Coef[0];
+           In_ptr = &In[i];
+           state_ptr = &state[FILTERORDER_DS-2];
+
+           o = (float)0.0;
+
+           stop = (i < FILTERORDER_DS) ? i + 1 : FILTERORDER_DS;
+
+           for (j = 0; j < stop; j++)
+           {
+               o += *Coef_ptr++ * (*In_ptr--);
+           }
+           for (j = i + 1; j < FILTERORDER_DS; j++)
+           {
+               o += *Coef_ptr++ * (*state_ptr--);
+           }
+
+
+
+
+Andersen, et al.              Experimental                    [Page 127]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+           *Out_ptr++ = o;
+       }
+
+       /* Get the last part (use zeros as input for the future) */
+
+       for (i=(lengthIn+FACTOR_DS); i<(lengthIn+DELAY_DS);
+               i+=FACTOR_DS) {
+
+           o=(float)0.0;
+
+           if (i<lengthIn) {
+               Coef_ptr = &Coef[0];
+               In_ptr = &In[i];
+               for (j=0; j<FILTERORDER_DS; j++) {
+                       o += *Coef_ptr++ * (*Out_ptr--);
+               }
+           } else {
+               Coef_ptr = &Coef[i-lengthIn];
+               In_ptr = &In[lengthIn-1];
+               for (j=0; j<FILTERORDER_DS-(i-lengthIn); j++) {
+                       o += *Coef_ptr++ * (*In_ptr--);
+               }
+           }
+           *Out_ptr++ = o;
+       }
+   }
+
+A.19.  FrameClassify.h
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       FrameClassify.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_FRAMECLASSIFY_H
+   #define __iLBC_FRAMECLASSIFY_H
+
+   int FrameClassify(      /* index to the max-energy sub-frame */
+       iLBC_Enc_Inst_t *iLBCenc_inst,
+                           /* (i/o) the encoder state structure */
+       float *residual     /* (i) lpc residual signal */
+   );
+
+
+
+Andersen, et al.              Experimental                    [Page 128]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   #endif
+
+A.20.  FrameClassify.c
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       FrameClassify.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include "iLBC_define.h"
+
+   /*---------------------------------------------------------------*
+    *  Classification of subframes to localize start state
+    *--------------------------------------------------------------*/
+
+   int FrameClassify(      /* index to the max-energy sub-frame */
+       iLBC_Enc_Inst_t *iLBCenc_inst,
+                           /* (i/o) the encoder state structure */
+       float *residual     /* (i) lpc residual signal */
+   ) {
+       float max_ssqEn, fssqEn[NSUB_MAX], bssqEn[NSUB_MAX], *pp;
+       int n, l, max_ssqEn_n;
+       const float ssqEn_win[NSUB_MAX-1]={(float)0.8,(float)0.9,
+           (float)1.0,(float)0.9,(float)0.8};
+       const float sampEn_win[5]={(float)1.0/(float)6.0,
+           (float)2.0/(float)6.0, (float)3.0/(float)6.0,
+           (float)4.0/(float)6.0, (float)5.0/(float)6.0};
+
+       /* init the front and back energies to zero */
+
+       memset(fssqEn, 0, NSUB_MAX*sizeof(float));
+       memset(bssqEn, 0, NSUB_MAX*sizeof(float));
+
+       /* Calculate front of first seqence */
+
+       n=0;
+       pp=residual;
+       for (l=0; l<5; l++) {
+           fssqEn[n] += sampEn_win[l] * (*pp) * (*pp);
+           pp++;
+       }
+       for (l=5; l<SUBL; l++) {
+
+
+
+Andersen, et al.              Experimental                    [Page 129]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+           fssqEn[n] += (*pp) * (*pp);
+           pp++;
+       }
+
+       /* Calculate front and back of all middle sequences */
+
+       for (n=1; n<iLBCenc_inst->nsub-1; n++) {
+           pp=residual+n*SUBL;
+           for (l=0; l<5; l++) {
+               fssqEn[n] += sampEn_win[l] * (*pp) * (*pp);
+               bssqEn[n] += (*pp) * (*pp);
+               pp++;
+           }
+           for (l=5; l<SUBL-5; l++) {
+               fssqEn[n] += (*pp) * (*pp);
+               bssqEn[n] += (*pp) * (*pp);
+               pp++;
+           }
+           for (l=SUBL-5; l<SUBL; l++) {
+               fssqEn[n] += (*pp) * (*pp);
+               bssqEn[n] += sampEn_win[SUBL-l-1] * (*pp) * (*pp);
+               pp++;
+           }
+       }
+
+       /* Calculate back of last seqence */
+
+       n=iLBCenc_inst->nsub-1;
+       pp=residual+n*SUBL;
+       for (l=0; l<SUBL-5; l++) {
+           bssqEn[n] += (*pp) * (*pp);
+           pp++;
+       }
+       for (l=SUBL-5; l<SUBL; l++) {
+           bssqEn[n] += sampEn_win[SUBL-l-1] * (*pp) * (*pp);
+           pp++;
+       }
+
+       /* find the index to the weighted 80 sample with
+          most energy */
+
+       if (iLBCenc_inst->mode==20) l=1;
+       else                        l=0;
+
+       max_ssqEn=(fssqEn[0]+bssqEn[1])*ssqEn_win[l];
+       max_ssqEn_n=1;
+       for (n=2; n<iLBCenc_inst->nsub; n++) {
+
+
+
+
+Andersen, et al.              Experimental                    [Page 130]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+           l++;
+           if ((fssqEn[n-1]+bssqEn[n])*ssqEn_win[l] > max_ssqEn) {
+               max_ssqEn=(fssqEn[n-1]+bssqEn[n]) *
+                               ssqEn_win[l];
+               max_ssqEn_n=n;
+           }
+       }
+
+       return max_ssqEn_n;
+   }
+
+A.21.  gainquant.h
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       gainquant.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_GAINQUANT_H
+   #define __iLBC_GAINQUANT_H
+
+   float gainquant(/* (o) quantized gain value */
+       float in,       /* (i) gain value */
+       float maxIn,/* (i) maximum of gain value */
+       int cblen,      /* (i) number of quantization indices */
+       int *index      /* (o) quantization index */
+   );
+
+   float gaindequant(  /* (o) quantized gain value */
+       int index,      /* (i) quantization index */
+       float maxIn,/* (i) maximum of unquantized gain */
+       int cblen       /* (i) number of quantization indices */
+   );
+
+   #endif
+
+A.22.  gainquant.c
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+
+
+
+Andersen, et al.              Experimental                    [Page 131]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       gainquant.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <string.h>
+   #include <math.h>
+   #include "constants.h"
+   #include "filter.h"
+
+   /*----------------------------------------------------------------*
+    *  quantizer for the gain in the gain-shape coding of residual
+    *---------------------------------------------------------------*/
+
+   float gainquant(/* (o) quantized gain value */
+       float in,       /* (i) gain value */
+       float maxIn,/* (i) maximum of gain value */
+       int cblen,      /* (i) number of quantization indices */
+       int *index      /* (o) quantization index */
+   ){
+       int i, tindex;
+       float minmeasure,measure, *cb, scale;
+
+       /* ensure a lower bound on the scaling factor */
+
+       scale=maxIn;
+
+       if (scale<0.1) {
+           scale=(float)0.1;
+       }
+
+       /* select the quantization table */
+
+       if (cblen == 8) {
+           cb = gain_sq3Tbl;
+       } else if (cblen == 16) {
+           cb = gain_sq4Tbl;
+       } else  {
+           cb = gain_sq5Tbl;
+       }
+
+       /* select the best index in the quantization table */
+
+       minmeasure=10000000.0;
+       tindex=0;
+       for (i=0; i<cblen; i++) {
+
+
+
+Andersen, et al.              Experimental                    [Page 132]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+           measure=(in-scale*cb[i])*(in-scale*cb[i]);
+
+           if (measure<minmeasure) {
+               tindex=i;
+               minmeasure=measure;
+           }
+       }
+       *index=tindex;
+
+       /* return the quantized value */
+
+       return scale*cb[tindex];
+   }
+
+   /*----------------------------------------------------------------*
+    *  decoder for quantized gains in the gain-shape coding of
+    *  residual
+    *---------------------------------------------------------------*/
+
+   float gaindequant(  /* (o) quantized gain value */
+       int index,      /* (i) quantization index */
+       float maxIn,/* (i) maximum of unquantized gain */
+       int cblen       /* (i) number of quantization indices */
+   ){
+       float scale;
+
+       /* obtain correct scale factor */
+
+       scale=(float)fabs(maxIn);
+
+       if (scale<0.1) {
+           scale=(float)0.1;
+       }
+
+       /* select the quantization table and return the decoded value */
+
+       if (cblen==8) {
+           return scale*gain_sq3Tbl[index];
+       } else if (cblen==16) {
+           return scale*gain_sq4Tbl[index];
+       }
+       else if (cblen==32) {
+           return scale*gain_sq5Tbl[index];
+       }
+
+       return 0.0;
+   }
+
+
+
+
+Andersen, et al.              Experimental                    [Page 133]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+A.23.  getCBvec.h
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       getCBvec.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_GETCBVEC_H
+   #define __iLBC_GETCBVEC_H
+
+   void getCBvec(
+       float *cbvec,   /* (o) Constructed codebook vector */
+       float *mem,     /* (i) Codebook buffer */
+       int index,      /* (i) Codebook index */
+       int lMem,       /* (i) Length of codebook buffer */
+       int cbveclen/* (i) Codebook vector length */
+   );
+
+   #endif
+
+A.24.  getCBvec.c
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       getCBvec.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include "iLBC_define.h"
+   #include "constants.h"
+   #include <string.h>
+
+   /*----------------------------------------------------------------*
+    *  Construct codebook vector for given index.
+    *---------------------------------------------------------------*/
+
+   void getCBvec(
+
+
+
+Andersen, et al.              Experimental                    [Page 134]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       float *cbvec,   /* (o) Constructed codebook vector */
+       float *mem,     /* (i) Codebook buffer */
+       int index,      /* (i) Codebook index */
+       int lMem,       /* (i) Length of codebook buffer */
+       int cbveclen/* (i) Codebook vector length */
+   ){
+       int j, k, n, memInd, sFilt;
+       float tmpbuf[CB_MEML];
+       int base_size;
+       int ilow, ihigh;
+       float alfa, alfa1;
+
+       /* Determine size of codebook sections */
+
+       base_size=lMem-cbveclen+1;
+
+       if (cbveclen==SUBL) {
+           base_size+=cbveclen/2;
+       }
+
+       /* No filter -> First codebook section */
+
+       if (index<lMem-cbveclen+1) {
+
+           /* first non-interpolated vectors */
+
+           k=index+cbveclen;
+           /* get vector */
+           memcpy(cbvec, mem+lMem-k, cbveclen*sizeof(float));
+
+       } else if (index < base_size) {
+
+           k=2*(index-(lMem-cbveclen+1))+cbveclen;
+
+           ihigh=k/2;
+           ilow=ihigh-5;
+
+           /* Copy first noninterpolated part */
+
+           memcpy(cbvec, mem+lMem-k/2, ilow*sizeof(float));
+
+           /* interpolation */
+
+           alfa1=(float)0.2;
+           alfa=0.0;
+           for (j=ilow; j<ihigh; j++) {
+               cbvec[j]=((float)1.0-alfa)*mem[lMem-k/2+j]+
+                   alfa*mem[lMem-k+j];
+
+
+
+Andersen, et al.              Experimental                    [Page 135]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+               alfa+=alfa1;
+           }
+
+           /* Copy second noninterpolated part */
+
+           memcpy(cbvec+ihigh, mem+lMem-k+ihigh,
+               (cbveclen-ihigh)*sizeof(float));
+
+       }
+
+       /* Higher codebook section based on filtering */
+
+       else {
+
+           /* first non-interpolated vectors */
+
+           if (index-base_size<lMem-cbveclen+1) {
+               float tempbuff2[CB_MEML+CB_FILTERLEN+1];
+               float *pos;
+               float *pp, *pp1;
+
+               memset(tempbuff2, 0,
+                   CB_HALFFILTERLEN*sizeof(float));
+               memcpy(&tempbuff2[CB_HALFFILTERLEN], mem,
+                   lMem*sizeof(float));
+               memset(&tempbuff2[lMem+CB_HALFFILTERLEN], 0,
+                   (CB_HALFFILTERLEN+1)*sizeof(float));
+
+               k=index-base_size+cbveclen;
+               sFilt=lMem-k;
+               memInd=sFilt+1-CB_HALFFILTERLEN;
+
+               /* do filtering */
+               pos=cbvec;
+               memset(pos, 0, cbveclen*sizeof(float));
+               for (n=0; n<cbveclen; n++) {
+                   pp=&tempbuff2[memInd+n+CB_HALFFILTERLEN];
+                   pp1=&cbfiltersTbl[CB_FILTERLEN-1];
+                   for (j=0; j<CB_FILTERLEN; j++) {
+                       (*pos)+=(*pp++)*(*pp1--);
+                   }
+                   pos++;
+               }
+           }
+
+           /* interpolated vectors */
+
+           else {
+
+
+
+Andersen, et al.              Experimental                    [Page 136]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+               float tempbuff2[CB_MEML+CB_FILTERLEN+1];
+
+               float *pos;
+               float *pp, *pp1;
+               int i;
+
+               memset(tempbuff2, 0,
+                   CB_HALFFILTERLEN*sizeof(float));
+               memcpy(&tempbuff2[CB_HALFFILTERLEN], mem,
+                   lMem*sizeof(float));
+               memset(&tempbuff2[lMem+CB_HALFFILTERLEN], 0,
+                   (CB_HALFFILTERLEN+1)*sizeof(float));
+
+               k=2*(index-base_size-
+                   (lMem-cbveclen+1))+cbveclen;
+               sFilt=lMem-k;
+               memInd=sFilt+1-CB_HALFFILTERLEN;
+
+               /* do filtering */
+               pos=&tmpbuf[sFilt];
+               memset(pos, 0, k*sizeof(float));
+               for (i=0; i<k; i++) {
+                   pp=&tempbuff2[memInd+i+CB_HALFFILTERLEN];
+                   pp1=&cbfiltersTbl[CB_FILTERLEN-1];
+                   for (j=0; j<CB_FILTERLEN; j++) {
+                       (*pos)+=(*pp++)*(*pp1--);
+                   }
+                   pos++;
+               }
+
+               ihigh=k/2;
+               ilow=ihigh-5;
+
+               /* Copy first noninterpolated part */
+
+               memcpy(cbvec, tmpbuf+lMem-k/2,
+                   ilow*sizeof(float));
+
+               /* interpolation */
+
+               alfa1=(float)0.2;
+               alfa=0.0;
+               for (j=ilow; j<ihigh; j++) {
+                   cbvec[j]=((float)1.0-alfa)*
+                       tmpbuf[lMem-k/2+j]+alfa*tmpbuf[lMem-k+j];
+                   alfa+=alfa1;
+               }
+
+
+
+
+Andersen, et al.              Experimental                    [Page 137]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+               /* Copy second noninterpolated part */
+
+               memcpy(cbvec+ihigh, tmpbuf+lMem-k+ihigh,
+                   (cbveclen-ihigh)*sizeof(float));
+           }
+       }
+   }
+
+A.25.  helpfun.h
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       helpfun.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_HELPFUN_H
+   #define __iLBC_HELPFUN_H
+
+   void autocorr(
+       float *r,       /* (o) autocorrelation vector */
+       const float *x, /* (i) data vector */
+       int N,          /* (i) length of data vector */
+       int order       /* largest lag for calculated
+                          autocorrelations */
+   );
+
+   void window(
+       float *z,       /* (o) the windowed data */
+       const float *x, /* (i) the original data vector */
+       const float *y, /* (i) the window */
+       int N           /* (i) length of all vectors */
+   );
+
+   void levdurb(
+       float *a,       /* (o) lpc coefficient vector starting
+                              with 1.0 */
+       float *k,       /* (o) reflection coefficients */
+       float *r,       /* (i) autocorrelation vector */
+       int order       /* (i) order of lpc filter */
+   );
+
+   void interpolate(
+
+
+
+Andersen, et al.              Experimental                    [Page 138]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       float *out,     /* (o) the interpolated vector */
+       float *in1,     /* (i) the first vector for the
+                              interpolation */
+       float *in2,     /* (i) the second vector for the
+                              interpolation */
+       float coef,     /* (i) interpolation weights */
+       int length      /* (i) length of all vectors */
+   );
+
+   void bwexpand(
+       float *out,     /* (o) the bandwidth expanded lpc
+                              coefficients */
+       float *in,      /* (i) the lpc coefficients before bandwidth
+                              expansion */
+       float coef,     /* (i) the bandwidth expansion factor */
+       int length      /* (i) the length of lpc coefficient vectors */
+   );
+
+   void vq(
+       float *Xq,      /* (o) the quantized vector */
+       int *index,     /* (o) the quantization index */
+       const float *CB,/* (i) the vector quantization codebook */
+       float *X,       /* (i) the vector to quantize */
+       int n_cb,       /* (i) the number of vectors in the codebook */
+       int dim         /* (i) the dimension of all vectors */
+   );
+
+   void SplitVQ(
+       float *qX,      /* (o) the quantized vector */
+       int *index,     /* (o) a vector of indexes for all vector
+                              codebooks in the split */
+       float *X,       /* (i) the vector to quantize */
+       const float *CB,/* (i) the quantizer codebook */
+       int nsplit,     /* the number of vector splits */
+       const int *dim, /* the dimension of X and qX */
+       const int *cbsize /* the number of vectors in the codebook */
+   );
+
+
+   void sort_sq(
+       float *xq,      /* (o) the quantized value */
+       int *index,     /* (o) the quantization index */
+       float x,    /* (i) the value to quantize */
+       const float *cb,/* (i) the quantization codebook */
+       int cb_size     /* (i) the size of the quantization codebook */
+   );
+
+   int LSF_check(      /* (o) 1 for stable lsf vectors and 0 for
+
+
+
+Andersen, et al.              Experimental                    [Page 139]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+                              nonstable ones */
+       float *lsf,     /* (i) a table of lsf vectors */
+       int dim,    /* (i) the dimension of each lsf vector */
+       int NoAn    /* (i) the number of lsf vectors in the
+                              table */
+   );
+
+   #endif
+
+A.26.  helpfun.c
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       helpfun.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <math.h>
+
+   #include "iLBC_define.h"
+   #include "constants.h"
+
+   /*----------------------------------------------------------------*
+    *  calculation of auto correlation
+    *---------------------------------------------------------------*/
+
+   void autocorr(
+       float *r,       /* (o) autocorrelation vector */
+       const float *x, /* (i) data vector */
+       int N,          /* (i) length of data vector */
+       int order       /* largest lag for calculated
+                          autocorrelations */
+   ){
+       int     lag, n;
+       float   sum;
+
+       for (lag = 0; lag <= order; lag++) {
+           sum = 0;
+           for (n = 0; n < N - lag; n++) {
+               sum += x[n] * x[n+lag];
+           }
+           r[lag] = sum;
+       }
+
+
+
+Andersen, et al.              Experimental                    [Page 140]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   }
+
+   /*----------------------------------------------------------------*
+    *  window multiplication
+    *---------------------------------------------------------------*/
+
+   void window(
+       float *z,       /* (o) the windowed data */
+       const float *x, /* (i) the original data vector */
+       const float *y, /* (i) the window */
+       int N           /* (i) length of all vectors */
+   ){
+       int     i;
+
+       for (i = 0; i < N; i++) {
+           z[i] = x[i] * y[i];
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  levinson-durbin solution for lpc coefficients
+    *---------------------------------------------------------------*/
+
+   void levdurb(
+       float *a,       /* (o) lpc coefficient vector starting
+                              with 1.0 */
+       float *k,       /* (o) reflection coefficients */
+       float *r,       /* (i) autocorrelation vector */
+       int order       /* (i) order of lpc filter */
+   ){
+       float  sum, alpha;
+       int     m, m_h, i;
+
+       a[0] = 1.0;
+
+       if (r[0] < EPS) { /* if r[0] <= 0, set LPC coeff. to zero */
+           for (i = 0; i < order; i++) {
+               k[i] = 0;
+               a[i+1] = 0;
+           }
+       } else {
+           a[1] = k[0] = -r[1]/r[0];
+           alpha = r[0] + r[1] * k[0];
+           for (m = 1; m < order; m++){
+               sum = r[m + 1];
+               for (i = 0; i < m; i++){
+                   sum += a[i+1] * r[m - i];
+               }
+
+
+
+Andersen, et al.              Experimental                    [Page 141]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+               k[m] = -sum / alpha;
+               alpha += k[m] * sum;
+               m_h = (m + 1) >> 1;
+               for (i = 0; i < m_h; i++){
+                   sum = a[i+1] + k[m] * a[m - i];
+                   a[m - i] += k[m] * a[i+1];
+                   a[i+1] = sum;
+               }
+               a[m+1] = k[m];
+           }
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  interpolation between vectors
+    *---------------------------------------------------------------*/
+
+   void interpolate(
+       float *out,      /* (o) the interpolated vector */
+       float *in1,     /* (i) the first vector for the
+                              interpolation */
+       float *in2,     /* (i) the second vector for the
+                              interpolation */
+       float coef,      /* (i) interpolation weights */
+       int length      /* (i) length of all vectors */
+   ){
+       int i;
+       float invcoef;
+
+       invcoef = (float)1.0 - coef;
+       for (i = 0; i < length; i++) {
+           out[i] = coef * in1[i] + invcoef * in2[i];
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  lpc bandwidth expansion
+    *---------------------------------------------------------------*/
+
+   void bwexpand(
+       float *out,      /* (o) the bandwidth expanded lpc
+                              coefficients */
+       float *in,      /* (i) the lpc coefficients before bandwidth
+                              expansion */
+       float coef,     /* (i) the bandwidth expansion factor */
+       int length      /* (i) the length of lpc coefficient vectors */
+   ){
+       int i;
+
+
+
+Andersen, et al.              Experimental                    [Page 142]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       float  chirp;
+
+       chirp = coef;
+
+       out[0] = in[0];
+       for (i = 1; i < length; i++) {
+           out[i] = chirp * in[i];
+           chirp *= coef;
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  vector quantization
+    *---------------------------------------------------------------*/
+
+   void vq(
+       float *Xq,      /* (o) the quantized vector */
+       int *index,     /* (o) the quantization index */
+       const float *CB,/* (i) the vector quantization codebook */
+       float *X,       /* (i) the vector to quantize */
+       int n_cb,       /* (i) the number of vectors in the codebook */
+       int dim         /* (i) the dimension of all vectors */
+   ){
+       int     i, j;
+       int     pos, minindex;
+       float   dist, tmp, mindist;
+
+       pos = 0;
+       mindist = FLOAT_MAX;
+       minindex = 0;
+       for (j = 0; j < n_cb; j++) {
+           dist = X[0] - CB[pos];
+           dist *= dist;
+           for (i = 1; i < dim; i++) {
+               tmp = X[i] - CB[pos + i];
+               dist += tmp*tmp;
+           }
+
+           if (dist < mindist) {
+               mindist = dist;
+               minindex = j;
+           }
+           pos += dim;
+       }
+       for (i = 0; i < dim; i++) {
+           Xq[i] = CB[minindex*dim + i];
+       }
+       *index = minindex;
+
+
+
+Andersen, et al.              Experimental                    [Page 143]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   }
+
+   /*----------------------------------------------------------------*
+    *  split vector quantization
+    *---------------------------------------------------------------*/
+
+   void SplitVQ(
+       float *qX,      /* (o) the quantized vector */
+       int *index,     /* (o) a vector of indexes for all vector
+                              codebooks in the split */
+       float *X,       /* (i) the vector to quantize */
+       const float *CB,/* (i) the quantizer codebook */
+       int nsplit,     /* the number of vector splits */
+       const int *dim, /* the dimension of X and qX */
+       const int *cbsize /* the number of vectors in the codebook */
+   ){
+       int    cb_pos, X_pos, i;
+
+       cb_pos = 0;
+       X_pos= 0;
+       for (i = 0; i < nsplit; i++) {
+           vq(qX + X_pos, index + i, CB + cb_pos, X + X_pos,
+               cbsize[i], dim[i]);
+           X_pos += dim[i];
+           cb_pos += dim[i] * cbsize[i];
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  scalar quantization
+    *---------------------------------------------------------------*/
+
+   void sort_sq(
+       float *xq,      /* (o) the quantized value */
+       int *index,     /* (o) the quantization index */
+       float x,    /* (i) the value to quantize */
+       const float *cb,/* (i) the quantization codebook */
+       int cb_size      /* (i) the size of the quantization codebook */
+   ){
+       int i;
+
+       if (x <= cb[0]) {
+           *index = 0;
+           *xq = cb[0];
+       } else {
+           i = 0;
+           while ((x > cb[i]) && i < cb_size - 1) {
+               i++;
+
+
+
+Andersen, et al.              Experimental                    [Page 144]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+           }
+
+           if (x > ((cb[i] + cb[i - 1])/2)) {
+               *index = i;
+               *xq = cb[i];
+           } else {
+               *index = i - 1;
+               *xq = cb[i - 1];
+           }
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  check for stability of lsf coefficients
+    *---------------------------------------------------------------*/
+
+   int LSF_check(    /* (o) 1 for stable lsf vectors and 0 for
+                              nonstable ones */
+       float *lsf,     /* (i) a table of lsf vectors */
+       int dim,    /* (i) the dimension of each lsf vector */
+       int NoAn    /* (i) the number of lsf vectors in the
+                              table */
+   ){
+       int k,n,m, Nit=2, change=0,pos;
+       float tmp;
+       static float eps=(float)0.039; /* 50 Hz */
+       static float eps2=(float)0.0195;
+       static float maxlsf=(float)3.14; /* 4000 Hz */
+       static float minlsf=(float)0.01; /* 0 Hz */
+
+       /* LSF separation check*/
+
+       for (n=0; n<Nit; n++) { /* Run through a couple of times */
+           for (m=0; m<NoAn; m++) { /* Number of analyses per frame */
+               for (k=0; k<(dim-1); k++) {
+                   pos=m*dim+k;
+
+                   if ((lsf[pos+1]-lsf[pos])<eps) {
+
+                       if (lsf[pos+1]<lsf[pos]) {
+                           tmp=lsf[pos+1];
+                           lsf[pos+1]= lsf[pos]+eps2;
+                           lsf[pos]= lsf[pos+1]-eps2;
+                       } else {
+                           lsf[pos]-=eps2;
+                           lsf[pos+1]+=eps2;
+                       }
+                       change=1;
+
+
+
+Andersen, et al.              Experimental                    [Page 145]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+                   }
+
+                   if (lsf[pos]<minlsf) {
+                       lsf[pos]=minlsf;
+                       change=1;
+                   }
+
+                   if (lsf[pos]>maxlsf) {
+                       lsf[pos]=maxlsf;
+                       change=1;
+                   }
+               }
+           }
+       }
+
+       return change;
+   }
+
+A.27.  hpInput.h
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       hpInput.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_HPINPUT_H
+   #define __iLBC_HPINPUT_H
+
+   void hpInput(
+       float *In,  /* (i) vector to filter */
+       int len,    /* (i) length of vector to filter */
+       float *Out, /* (o) the resulting filtered vector */
+       float *mem  /* (i/o) the filter state */
+   );
+
+   #endif
+
+A.28.  hpInput.c
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+
+
+Andersen, et al.              Experimental                    [Page 146]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       hpInput.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include "constants.h"
+
+   /*----------------------------------------------------------------*
+    *  Input high-pass filter
+    *---------------------------------------------------------------*/
+
+   void hpInput(
+       float *In,  /* (i) vector to filter */
+       int len,    /* (i) length of vector to filter */
+       float *Out, /* (o) the resulting filtered vector */
+       float *mem  /* (i/o) the filter state */
+   ){
+       int i;
+       float *pi, *po;
+
+       /* all-zero section*/
+
+       pi = &In[0];
+       po = &Out[0];
+       for (i=0; i<len; i++) {
+           *po = hpi_zero_coefsTbl[0] * (*pi);
+           *po += hpi_zero_coefsTbl[1] * mem[0];
+           *po += hpi_zero_coefsTbl[2] * mem[1];
+
+           mem[1] = mem[0];
+           mem[0] = *pi;
+           po++;
+           pi++;
+
+       }
+
+       /* all-pole section*/
+
+       po = &Out[0];
+       for (i=0; i<len; i++) {
+           *po -= hpi_pole_coefsTbl[1] * mem[2];
+           *po -= hpi_pole_coefsTbl[2] * mem[3];
+
+           mem[3] = mem[2];
+           mem[2] = *po;
+           po++;
+
+
+
+Andersen, et al.              Experimental                    [Page 147]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       }
+   }
+
+A.29.  hpOutput.h
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       hpOutput.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_HPOUTPUT_H
+   #define __iLBC_HPOUTPUT_H
+
+   void hpOutput(
+       float *In,  /* (i) vector to filter */
+       int len,/* (i) length of vector to filter */
+       float *Out, /* (o) the resulting filtered vector */
+       float *mem  /* (i/o) the filter state */
+   );
+
+   #endif
+
+A.30.  hpOutput.c
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       hpOutput.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include "constants.h"
+
+   /*----------------------------------------------------------------*
+    *  Output high-pass filter
+    *---------------------------------------------------------------*/
+
+   void hpOutput(
+
+
+
+Andersen, et al.              Experimental                    [Page 148]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       float *In,  /* (i) vector to filter */
+       int len,/* (i) length of vector to filter */
+       float *Out, /* (o) the resulting filtered vector */
+       float *mem  /* (i/o) the filter state */
+   ){
+       int i;
+       float *pi, *po;
+
+       /* all-zero section*/
+
+       pi = &In[0];
+       po = &Out[0];
+       for (i=0; i<len; i++) {
+           *po = hpo_zero_coefsTbl[0] * (*pi);
+           *po += hpo_zero_coefsTbl[1] * mem[0];
+           *po += hpo_zero_coefsTbl[2] * mem[1];
+
+           mem[1] = mem[0];
+           mem[0] = *pi;
+           po++;
+           pi++;
+
+       }
+
+       /* all-pole section*/
+
+       po = &Out[0];
+       for (i=0; i<len; i++) {
+           *po -= hpo_pole_coefsTbl[1] * mem[2];
+           *po -= hpo_pole_coefsTbl[2] * mem[3];
+
+           mem[3] = mem[2];
+           mem[2] = *po;
+           po++;
+       }
+   }
+
+A.31.  iCBConstruct.h
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       iCBConstruct.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+
+
+
+Andersen, et al.              Experimental                    [Page 149]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   ******************************************************************/
+
+   #ifndef __iLBC_ICBCONSTRUCT_H
+   #define __iLBC_ICBCONSTRUCT_H
+
+   void index_conv_enc(
+       int *index          /* (i/o) Codebook indexes */
+   );
+
+   void index_conv_dec(
+       int *index          /* (i/o) Codebook indexes */
+   );
+
+   void iCBConstruct(
+       float *decvector,   /* (o) Decoded vector */
+       int *index,         /* (i) Codebook indices */
+       int *gain_index,/* (i) Gain quantization indices */
+       float *mem,         /* (i) Buffer for codevector construction */
+       int lMem,           /* (i) Length of buffer */
+       int veclen,         /* (i) Length of vector */
+       int nStages         /* (i) Number of codebook stages */
+   );
+
+   #endif
+
+A.32.  iCBConstruct.c
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       iCBConstruct.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <math.h>
+
+   #include "iLBC_define.h"
+   #include "gainquant.h"
+   #include "getCBvec.h"
+
+   /*----------------------------------------------------------------*
+    *  Convert the codebook indexes to make the search easier
+    *---------------------------------------------------------------*/
+
+
+
+
+Andersen, et al.              Experimental                    [Page 150]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   void index_conv_enc(
+       int *index          /* (i/o) Codebook indexes */
+   ){
+       int k;
+
+       for (k=1; k<CB_NSTAGES; k++) {
+
+           if ((index[k]>=108)&&(index[k]<172)) {
+               index[k]-=64;
+           } else if (index[k]>=236) {
+               index[k]-=128;
+           } else {
+               /* ERROR */
+           }
+       }
+   }
+
+   void index_conv_dec(
+       int *index          /* (i/o) Codebook indexes */
+   ){
+       int k;
+
+       for (k=1; k<CB_NSTAGES; k++) {
+
+           if ((index[k]>=44)&&(index[k]<108)) {
+               index[k]+=64;
+           } else if ((index[k]>=108)&&(index[k]<128)) {
+               index[k]+=128;
+           } else {
+               /* ERROR */
+           }
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  Construct decoded vector from codebook and gains.
+    *---------------------------------------------------------------*/
+
+   void iCBConstruct(
+       float *decvector,   /* (o) Decoded vector */
+       int *index,         /* (i) Codebook indices */
+       int *gain_index,/* (i) Gain quantization indices */
+       float *mem,         /* (i) Buffer for codevector construction */
+       int lMem,           /* (i) Length of buffer */
+       int veclen,         /* (i) Length of vector */
+       int nStages         /* (i) Number of codebook stages */
+   ){
+       int j,k;
+
+
+
+Andersen, et al.              Experimental                    [Page 151]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       float gain[CB_NSTAGES];
+       float cbvec[SUBL];
+
+       /* gain de-quantization */
+
+       gain[0] = gaindequant(gain_index[0], 1.0, 32);
+       if (nStages > 1) {
+           gain[1] = gaindequant(gain_index[1],
+               (float)fabs(gain[0]), 16);
+       }
+       if (nStages > 2) {
+           gain[2] = gaindequant(gain_index[2],
+               (float)fabs(gain[1]), 8);
+       }
+
+       /* codebook vector construction and construction of
+       total vector */
+
+       getCBvec(cbvec, mem, index[0], lMem, veclen);
+       for (j=0;j<veclen;j++){
+           decvector[j] = gain[0]*cbvec[j];
+       }
+       if (nStages > 1) {
+           for (k=1; k<nStages; k++) {
+               getCBvec(cbvec, mem, index[k], lMem, veclen);
+               for (j=0;j<veclen;j++) {
+                   decvector[j] += gain[k]*cbvec[j];
+               }
+           }
+       }
+   }
+
+A.33.  iCBSearch.h
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       iCBSearch.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_ICBSEARCH_H
+   #define __iLBC_ICBSEARCH_H
+
+
+
+
+Andersen, et al.              Experimental                    [Page 152]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   void iCBSearch(
+       iLBC_Enc_Inst_t *iLBCenc_inst,
+                           /* (i) the encoder state structure */
+       int *index,         /* (o) Codebook indices */
+       int *gain_index,/* (o) Gain quantization indices */
+       float *intarget,/* (i) Target vector for encoding */
+       float *mem,         /* (i) Buffer for codebook construction */
+       int lMem,           /* (i) Length of buffer */
+       int lTarget,    /* (i) Length of vector */
+       int nStages,    /* (i) Number of codebook stages */
+       float *weightDenum, /* (i) weighting filter coefficients */
+       float *weightState, /* (i) weighting filter state */
+       int block           /* (i) the sub-block number */
+   );
+
+   #endif
+
+A.34.  iCBSearch.c
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       iCBSearch.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <math.h>
+   #include <string.h>
+
+   #include "iLBC_define.h"
+   #include "gainquant.h"
+   #include "createCB.h"
+   #include "filter.h"
+   #include "constants.h"
+
+   /*----------------------------------------------------------------*
+    *  Search routine for codebook encoding and gain quantization.
+    *---------------------------------------------------------------*/
+
+   void iCBSearch(
+       iLBC_Enc_Inst_t *iLBCenc_inst,
+                           /* (i) the encoder state structure */
+       int *index,         /* (o) Codebook indices */
+       int *gain_index,/* (o) Gain quantization indices */
+
+
+
+Andersen, et al.              Experimental                    [Page 153]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       float *intarget,/* (i) Target vector for encoding */
+       float *mem,         /* (i) Buffer for codebook construction */
+       int lMem,           /* (i) Length of buffer */
+       int lTarget,    /* (i) Length of vector */
+       int nStages,    /* (i) Number of codebook stages */
+       float *weightDenum, /* (i) weighting filter coefficients */
+       float *weightState, /* (i) weighting filter state */
+       int block           /* (i) the sub-block number */
+   ){
+       int i, j, icount, stage, best_index, range, counter;
+       float max_measure, gain, measure, crossDot, ftmp;
+       float gains[CB_NSTAGES];
+       float target[SUBL];
+       int base_index, sInd, eInd, base_size;
+       int sIndAug=0, eIndAug=0;
+       float buf[CB_MEML+SUBL+2*LPC_FILTERORDER];
+       float invenergy[CB_EXPAND*128], energy[CB_EXPAND*128];
+       float *pp, *ppi=0, *ppo=0, *ppe=0;
+       float cbvectors[CB_MEML];
+       float tene, cene, cvec[SUBL];
+       float aug_vec[SUBL];
+
+       memset(cvec,0,SUBL*sizeof(float));
+
+       /* Determine size of codebook sections */
+
+       base_size=lMem-lTarget+1;
+
+       if (lTarget==SUBL) {
+           base_size=lMem-lTarget+1+lTarget/2;
+       }
+
+       /* setup buffer for weighting */
+
+       memcpy(buf,weightState,sizeof(float)*LPC_FILTERORDER);
+       memcpy(buf+LPC_FILTERORDER,mem,lMem*sizeof(float));
+       memcpy(buf+LPC_FILTERORDER+lMem,intarget,lTarget*sizeof(float));
+
+       /* weighting */
+
+       AllPoleFilter(buf+LPC_FILTERORDER, weightDenum,
+           lMem+lTarget, LPC_FILTERORDER);
+
+       /* Construct the codebook and target needed */
+
+       memcpy(target, buf+LPC_FILTERORDER+lMem, lTarget*sizeof(float));
+
+       tene=0.0;
+
+
+
+Andersen, et al.              Experimental                    [Page 154]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       for (i=0; i<lTarget; i++) {
+           tene+=target[i]*target[i];
+       }
+
+       /* Prepare search over one more codebook section. This section
+          is created by filtering the original buffer with a filter. */
+
+       filteredCBvecs(cbvectors, buf+LPC_FILTERORDER, lMem);
+
+       /* The Main Loop over stages */
+
+       for (stage=0; stage<nStages; stage++) {
+
+           range = search_rangeTbl[block][stage];
+
+           /* initialize search measure */
+
+           max_measure = (float)-10000000.0;
+           gain = (float)0.0;
+           best_index = 0;
+
+           /* Compute cross dot product between the target
+              and the CB memory */
+
+           crossDot=0.0;
+           pp=buf+LPC_FILTERORDER+lMem-lTarget;
+           for (j=0; j<lTarget; j++) {
+               crossDot += target[j]*(*pp++);
+           }
+
+           if (stage==0) {
+
+               /* Calculate energy in the first block of
+                 'lTarget' samples. */
+               ppe = energy;
+               ppi = buf+LPC_FILTERORDER+lMem-lTarget-1;
+               ppo = buf+LPC_FILTERORDER+lMem-1;
+
+               *ppe=0.0;
+               pp=buf+LPC_FILTERORDER+lMem-lTarget;
+               for (j=0; j<lTarget; j++) {
+                   *ppe+=(*pp)*(*pp++);
+               }
+
+               if (*ppe>0.0) {
+                   invenergy[0] = (float) 1.0 / (*ppe + EPS);
+               } else {
+                   invenergy[0] = (float) 0.0;
+
+
+
+Andersen, et al.              Experimental                    [Page 155]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+               }
+               ppe++;
+
+               measure=(float)-10000000.0;
+
+               if (crossDot > 0.0) {
+                      measure = crossDot*crossDot*invenergy[0];
+               }
+           }
+           else {
+               measure = crossDot*crossDot*invenergy[0];
+           }
+
+           /* check if measure is better */
+           ftmp = crossDot*invenergy[0];
+
+           if ((measure>max_measure) && (fabs(ftmp)<CB_MAXGAIN)) {
+               best_index = 0;
+               max_measure = measure;
+               gain = ftmp;
+           }
+
+           /* loop over the main first codebook section,
+              full search */
+
+           for (icount=1; icount<range; icount++) {
+
+               /* calculate measure */
+
+               crossDot=0.0;
+               pp = buf+LPC_FILTERORDER+lMem-lTarget-icount;
+
+               for (j=0; j<lTarget; j++) {
+                   crossDot += target[j]*(*pp++);
+               }
+
+               if (stage==0) {
+                   *ppe++ = energy[icount-1] + (*ppi)*(*ppi) -
+                       (*ppo)*(*ppo);
+                   ppo--;
+                   ppi--;
+
+                   if (energy[icount]>0.0) {
+                       invenergy[icount] =
+                           (float)1.0/(energy[icount]+EPS);
+                   } else {
+                       invenergy[icount] = (float) 0.0;
+                   }
+
+
+
+Andersen, et al.              Experimental                    [Page 156]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+                   measure=(float)-10000000.0;
+
+                   if (crossDot > 0.0) {
+                       measure = crossDot*crossDot*invenergy[icount];
+                   }
+               }
+               else {
+                   measure = crossDot*crossDot*invenergy[icount];
+               }
+
+               /* check if measure is better */
+               ftmp = crossDot*invenergy[icount];
+
+               if ((measure>max_measure) && (fabs(ftmp)<CB_MAXGAIN)) {
+                   best_index = icount;
+                   max_measure = measure;
+                   gain = ftmp;
+               }
+           }
+
+           /* Loop over augmented part in the first codebook
+            * section, full search.
+            * The vectors are interpolated.
+            */
+
+           if (lTarget==SUBL) {
+
+               /* Search for best possible cb vector and
+                  compute the CB-vectors' energy. */
+               searchAugmentedCB(20, 39, stage, base_size-lTarget/2,
+                   target, buf+LPC_FILTERORDER+lMem,
+                   &max_measure, &best_index, &gain, energy,
+                   invenergy);
+           }
+
+           /* set search range for following codebook sections */
+
+           base_index=best_index;
+
+           /* unrestricted search */
+
+           if (CB_RESRANGE == -1) {
+               sInd=0;
+               eInd=range-1;
+               sIndAug=20;
+               eIndAug=39;
+           }
+
+
+
+
+Andersen, et al.              Experimental                    [Page 157]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+           /* restricted search around best index from first
+           codebook section */
+
+           else {
+               /* Initialize search indices */
+               sIndAug=0;
+               eIndAug=0;
+               sInd=base_index-CB_RESRANGE/2;
+               eInd=sInd+CB_RESRANGE;
+
+               if (lTarget==SUBL) {
+
+                   if (sInd<0) {
+
+                       sIndAug = 40 + sInd;
+                       eIndAug = 39;
+                       sInd=0;
+
+                   } else if ( base_index < (base_size-20) ) {
+
+                       if (eInd > range) {
+                           sInd -= (eInd-range);
+                           eInd = range;
+                       }
+                   } else { /* base_index >= (base_size-20) */
+
+                       if (sInd < (base_size-20)) {
+                           sIndAug = 20;
+                           sInd = 0;
+                           eInd = 0;
+                           eIndAug = 19 + CB_RESRANGE;
+
+                           if(eIndAug > 39) {
+                               eInd = eIndAug-39;
+                               eIndAug = 39;
+                           }
+                       } else {
+                           sIndAug = 20 + sInd - (base_size-20);
+                           eIndAug = 39;
+                           sInd = 0;
+                           eInd = CB_RESRANGE - (eIndAug-sIndAug+1);
+                       }
+                   }
+
+               } else { /* lTarget = 22 or 23 */
+
+                   if (sInd < 0) {
+                       eInd -= sInd;
+
+
+
+Andersen, et al.              Experimental                    [Page 158]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+                       sInd = 0;
+                   }
+
+                   if(eInd > range) {
+                       sInd -= (eInd - range);
+                       eInd = range;
+                   }
+               }
+           }
+
+           /* search of higher codebook section */
+
+           /* index search range */
+           counter = sInd;
+           sInd += base_size;
+           eInd += base_size;
+
+
+           if (stage==0) {
+               ppe = energy+base_size;
+               *ppe=0.0;
+
+               pp=cbvectors+lMem-lTarget;
+               for (j=0; j<lTarget; j++) {
+                   *ppe+=(*pp)*(*pp++);
+               }
+
+               ppi = cbvectors + lMem - 1 - lTarget;
+               ppo = cbvectors + lMem - 1;
+
+               for (j=0; j<(range-1); j++) {
+                   *(ppe+1) = *ppe + (*ppi)*(*ppi) - (*ppo)*(*ppo);
+                   ppo--;
+                   ppi--;
+                   ppe++;
+               }
+           }
+
+           /* loop over search range */
+
+           for (icount=sInd; icount<eInd; icount++) {
+
+               /* calculate measure */
+
+               crossDot=0.0;
+               pp=cbvectors + lMem - (counter++) - lTarget;
+
+               for (j=0;j<lTarget;j++) {
+
+
+
+Andersen, et al.              Experimental                    [Page 159]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+                   crossDot += target[j]*(*pp++);
+               }
+
+               if (energy[icount]>0.0) {
+                   invenergy[icount] =(float)1.0/(energy[icount]+EPS);
+               } else {
+                   invenergy[icount] =(float)0.0;
+               }
+
+               if (stage==0) {
+
+                   measure=(float)-10000000.0;
+
+                   if (crossDot > 0.0) {
+                       measure = crossDot*crossDot*
+                           invenergy[icount];
+                   }
+               }
+               else {
+                   measure = crossDot*crossDot*invenergy[icount];
+               }
+
+               /* check if measure is better */
+               ftmp = crossDot*invenergy[icount];
+
+               if ((measure>max_measure) && (fabs(ftmp)<CB_MAXGAIN)) {
+                   best_index = icount;
+                   max_measure = measure;
+                   gain = ftmp;
+               }
+           }
+
+           /* Search the augmented CB inside the limited range. */
+
+           if ((lTarget==SUBL)&&(sIndAug!=0)) {
+               searchAugmentedCB(sIndAug, eIndAug, stage,
+                   2*base_size-20, target, cbvectors+lMem,
+                   &max_measure, &best_index, &gain, energy,
+                   invenergy);
+           }
+
+           /* record best index */
+
+           index[stage] = best_index;
+
+           /* gain quantization */
+
+           if (stage==0){
+
+
+
+Andersen, et al.              Experimental                    [Page 160]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+
+               if (gain<0.0){
+                   gain = 0.0;
+               }
+
+               if (gain>CB_MAXGAIN) {
+                   gain = (float)CB_MAXGAIN;
+               }
+               gain = gainquant(gain, 1.0, 32, &gain_index[stage]);
+           }
+           else {
+               if (stage==1) {
+                   gain = gainquant(gain, (float)fabs(gains[stage-1]),
+                       16, &gain_index[stage]);
+               } else {
+                   gain = gainquant(gain, (float)fabs(gains[stage-1]),
+                       8, &gain_index[stage]);
+               }
+           }
+
+           /* Extract the best (according to measure)
+              codebook vector */
+
+           if (lTarget==(STATE_LEN-iLBCenc_inst->state_short_len)) {
+
+               if (index[stage]<base_size) {
+                   pp=buf+LPC_FILTERORDER+lMem-lTarget-index[stage];
+               } else {
+                   pp=cbvectors+lMem-lTarget-
+                       index[stage]+base_size;
+               }
+           } else {
+
+               if (index[stage]<base_size) {
+                   if (index[stage]<(base_size-20)) {
+                       pp=buf+LPC_FILTERORDER+lMem-
+                           lTarget-index[stage];
+                   } else {
+                       createAugmentedVec(index[stage]-base_size+40,
+                               buf+LPC_FILTERORDER+lMem,aug_vec);
+                       pp=aug_vec;
+                   }
+               } else {
+                   int filterno, position;
+
+                   filterno=index[stage]/base_size;
+                   position=index[stage]-filterno*base_size;
+
+
+
+
+Andersen, et al.              Experimental                    [Page 161]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+
+                   if (position<(base_size-20)) {
+                       pp=cbvectors+filterno*lMem-lTarget-
+                           index[stage]+filterno*base_size;
+                   } else {
+                       createAugmentedVec(
+                           index[stage]-(filterno+1)*base_size+40,
+                           cbvectors+filterno*lMem,aug_vec);
+                       pp=aug_vec;
+                   }
+               }
+           }
+
+           /* Subtract the best codebook vector, according
+              to measure, from the target vector */
+
+           for (j=0;j<lTarget;j++) {
+               cvec[j] += gain*(*pp);
+               target[j] -= gain*(*pp++);
+           }
+
+           /* record quantized gain */
+
+           gains[stage]=gain;
+
+       }/* end of Main Loop. for (stage=0;... */
+
+       /* Gain adjustment for energy matching */
+       cene=0.0;
+       for (i=0; i<lTarget; i++) {
+           cene+=cvec[i]*cvec[i];
+       }
+       j=gain_index[0];
+
+       for (i=gain_index[0]; i<32; i++) {
+           ftmp=cene*gain_sq5Tbl[i]*gain_sq5Tbl[i];
+
+           if ((ftmp<(tene*gains[0]*gains[0])) &&
+               (gain_sq5Tbl[j]<(2.0*gains[0]))) {
+               j=i;
+           }
+       }
+       gain_index[0]=j;
+   }
+
+
+
+
+
+
+
+Andersen, et al.              Experimental                    [Page 162]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+A.35.  LPCdecode.h
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       LPC_decode.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_LPC_DECODE_H
+   #define __iLBC_LPC_DECODE_H
+
+   void LSFinterpolate2a_dec(
+       float *a,           /* (o) lpc coefficients for a sub-frame */
+       float *lsf1,    /* (i) first lsf coefficient vector */
+       float *lsf2,    /* (i) second lsf coefficient vector */
+       float coef,         /* (i) interpolation weight */
+       int length          /* (i) length of lsf vectors */
+   );
+
+   void SimplelsfDEQ(
+       float *lsfdeq,      /* (o) dequantized lsf coefficients */
+       int *index,         /* (i) quantization index */
+       int lpc_n           /* (i) number of LPCs */
+   );
+
+   void DecoderInterpolateLSF(
+       float *syntdenum,   /* (o) synthesis filter coefficients */
+       float *weightdenum, /* (o) weighting denumerator
+                                  coefficients */
+       float *lsfdeq,      /* (i) dequantized lsf coefficients */
+       int length,         /* (i) length of lsf coefficient vector */
+       iLBC_Dec_Inst_t *iLBCdec_inst
+                           /* (i) the decoder state structure */
+   );
+
+   #endif
+
+
+
+
+
+
+
+
+
+
+Andersen, et al.              Experimental                    [Page 163]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+A.36.  LPCdecode.c
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       LPC_decode.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <math.h>
+   #include <string.h>
+
+   #include "helpfun.h"
+   #include "lsf.h"
+   #include "iLBC_define.h"
+   #include "constants.h"
+
+   /*---------------------------------------------------------------*
+    *  interpolation of lsf coefficients for the decoder
+    *--------------------------------------------------------------*/
+
+   void LSFinterpolate2a_dec(
+       float *a,           /* (o) lpc coefficients for a sub-frame */
+       float *lsf1,    /* (i) first lsf coefficient vector */
+       float *lsf2,    /* (i) second lsf coefficient vector */
+       float coef,         /* (i) interpolation weight */
+       int length          /* (i) length of lsf vectors */
+   ){
+       float  lsftmp[LPC_FILTERORDER];
+
+       interpolate(lsftmp, lsf1, lsf2, coef, length);
+       lsf2a(a, lsftmp);
+   }
+
+   /*---------------------------------------------------------------*
+    *  obtain dequantized lsf coefficients from quantization index
+    *--------------------------------------------------------------*/
+
+   void SimplelsfDEQ(
+       float *lsfdeq,    /* (o) dequantized lsf coefficients */
+       int *index,         /* (i) quantization index */
+       int lpc_n           /* (i) number of LPCs */
+   ){
+       int i, j, pos, cb_pos;
+
+
+
+Andersen, et al.              Experimental                    [Page 164]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       /* decode first LSF */
+
+       pos = 0;
+       cb_pos = 0;
+       for (i = 0; i < LSF_NSPLIT; i++) {
+           for (j = 0; j < dim_lsfCbTbl[i]; j++) {
+               lsfdeq[pos + j] = lsfCbTbl[cb_pos +
+                   (long)(index[i])*dim_lsfCbTbl[i] + j];
+           }
+           pos += dim_lsfCbTbl[i];
+           cb_pos += size_lsfCbTbl[i]*dim_lsfCbTbl[i];
+       }
+
+       if (lpc_n>1) {
+
+           /* decode last LSF */
+
+           pos = 0;
+           cb_pos = 0;
+           for (i = 0; i < LSF_NSPLIT; i++) {
+               for (j = 0; j < dim_lsfCbTbl[i]; j++) {
+                   lsfdeq[LPC_FILTERORDER + pos + j] =
+                       lsfCbTbl[cb_pos +
+                       (long)(index[LSF_NSPLIT + i])*
+                       dim_lsfCbTbl[i] + j];
+               }
+               pos += dim_lsfCbTbl[i];
+               cb_pos += size_lsfCbTbl[i]*dim_lsfCbTbl[i];
+           }
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  obtain synthesis and weighting filters form lsf coefficients
+    *---------------------------------------------------------------*/
+
+   void DecoderInterpolateLSF(
+       float *syntdenum, /* (o) synthesis filter coefficients */
+       float *weightdenum, /* (o) weighting denumerator
+                                  coefficients */
+       float *lsfdeq,       /* (i) dequantized lsf coefficients */
+       int length,         /* (i) length of lsf coefficient vector */
+       iLBC_Dec_Inst_t *iLBCdec_inst
+                           /* (i) the decoder state structure */
+   ){
+       int    i, pos, lp_length;
+       float  lp[LPC_FILTERORDER + 1], *lsfdeq2;
+
+
+
+
+Andersen, et al.              Experimental                    [Page 165]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       lsfdeq2 = lsfdeq + length;
+       lp_length = length + 1;
+
+       if (iLBCdec_inst->mode==30) {
+           /* sub-frame 1: Interpolation between old and first */
+
+           LSFinterpolate2a_dec(lp, iLBCdec_inst->lsfdeqold, lsfdeq,
+               lsf_weightTbl_30ms[0], length);
+           memcpy(syntdenum,lp,lp_length*sizeof(float));
+           bwexpand(weightdenum, lp, LPC_CHIRP_WEIGHTDENUM,
+               lp_length);
+
+           /* sub-frames 2 to 6: interpolation between first
+              and last LSF */
+
+           pos = lp_length;
+           for (i = 1; i < 6; i++) {
+               LSFinterpolate2a_dec(lp, lsfdeq, lsfdeq2,
+                   lsf_weightTbl_30ms[i], length);
+               memcpy(syntdenum + pos,lp,lp_length*sizeof(float));
+               bwexpand(weightdenum + pos, lp,
+                   LPC_CHIRP_WEIGHTDENUM, lp_length);
+               pos += lp_length;
+           }
+       }
+       else {
+           pos = 0;
+           for (i = 0; i < iLBCdec_inst->nsub; i++) {
+               LSFinterpolate2a_dec(lp, iLBCdec_inst->lsfdeqold,
+                   lsfdeq, lsf_weightTbl_20ms[i], length);
+               memcpy(syntdenum+pos,lp,lp_length*sizeof(float));
+               bwexpand(weightdenum+pos, lp, LPC_CHIRP_WEIGHTDENUM,
+                   lp_length);
+               pos += lp_length;
+           }
+       }
+
+       /* update memory */
+
+       if (iLBCdec_inst->mode==30)
+           memcpy(iLBCdec_inst->lsfdeqold, lsfdeq2,
+                       length*sizeof(float));
+       else
+           memcpy(iLBCdec_inst->lsfdeqold, lsfdeq,
+                       length*sizeof(float));
+
+   }
+
+
+
+
+Andersen, et al.              Experimental                    [Page 166]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+A.37.  LPCencode.h
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       LPCencode.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_LPCENCOD_H
+   #define __iLBC_LPCENCOD_H
+
+   void LPCencode(
+       float *syntdenum,   /* (i/o) synthesis filter coefficients
+                                  before/after encoding */
+       float *weightdenum, /* (i/o) weighting denumerator coefficients
+                                  before/after encoding */
+       int *lsf_index,     /* (o) lsf quantization index */
+       float *data,    /* (i) lsf coefficients to quantize */
+       iLBC_Enc_Inst_t *iLBCenc_inst
+                           /* (i/o) the encoder state structure */
+   );
+
+   #endif
+
+A.38.  LPCencode.c
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       LPCencode.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <string.h>
+
+   #include "iLBC_define.h"
+   #include "helpfun.h"
+   #include "lsf.h"
+   #include "constants.h"
+
+
+
+Andersen, et al.              Experimental                    [Page 167]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   /*----------------------------------------------------------------*
+    *  lpc analysis (subrutine to LPCencode)
+    *---------------------------------------------------------------*/
+
+   void SimpleAnalysis(
+       float *lsf,         /* (o) lsf coefficients */
+       float *data,    /* (i) new data vector */
+       iLBC_Enc_Inst_t *iLBCenc_inst
+                           /* (i/o) the encoder state structure */
+   ){
+       int k, is;
+       float temp[BLOCKL_MAX], lp[LPC_FILTERORDER + 1];
+       float lp2[LPC_FILTERORDER + 1];
+       float r[LPC_FILTERORDER + 1];
+
+       is=LPC_LOOKBACK+BLOCKL_MAX-iLBCenc_inst->blockl;
+       memcpy(iLBCenc_inst->lpc_buffer+is,data,
+           iLBCenc_inst->blockl*sizeof(float));
+
+       /* No lookahead, last window is asymmetric */
+
+       for (k = 0; k < iLBCenc_inst->lpc_n; k++) {
+
+           is = LPC_LOOKBACK;
+
+           if (k < (iLBCenc_inst->lpc_n - 1)) {
+               window(temp, lpc_winTbl,
+                   iLBCenc_inst->lpc_buffer, BLOCKL_MAX);
+           } else {
+               window(temp, lpc_asymwinTbl,
+                   iLBCenc_inst->lpc_buffer + is, BLOCKL_MAX);
+           }
+
+           autocorr(r, temp, BLOCKL_MAX, LPC_FILTERORDER);
+           window(r, r, lpc_lagwinTbl, LPC_FILTERORDER + 1);
+
+           levdurb(lp, temp, r, LPC_FILTERORDER);
+           bwexpand(lp2, lp, LPC_CHIRP_SYNTDENUM, LPC_FILTERORDER+1);
+
+           a2lsf(lsf + k*LPC_FILTERORDER, lp2);
+       }
+       is=LPC_LOOKBACK+BLOCKL_MAX-iLBCenc_inst->blockl;
+       memmove(iLBCenc_inst->lpc_buffer,
+           iLBCenc_inst->lpc_buffer+LPC_LOOKBACK+BLOCKL_MAX-is,
+           is*sizeof(float));
+   }
+
+   /*----------------------------------------------------------------*
+
+
+
+Andersen, et al.              Experimental                    [Page 168]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+    *  lsf interpolator and conversion from lsf to a coefficients
+    *  (subrutine to SimpleInterpolateLSF)
+    *---------------------------------------------------------------*/
+
+   void LSFinterpolate2a_enc(
+       float *a,       /* (o) lpc coefficients */
+       float *lsf1,/* (i) first set of lsf coefficients */
+       float *lsf2,/* (i) second set of lsf coefficients */
+       float coef,     /* (i) weighting coefficient to use between
+                              lsf1 and lsf2 */
+       long length      /* (i) length of coefficient vectors */
+   ){
+       float  lsftmp[LPC_FILTERORDER];
+
+       interpolate(lsftmp, lsf1, lsf2, coef, length);
+       lsf2a(a, lsftmp);
+   }
+
+   /*----------------------------------------------------------------*
+    *  lsf interpolator (subrutine to LPCencode)
+    *---------------------------------------------------------------*/
+
+   void SimpleInterpolateLSF(
+       float *syntdenum,   /* (o) the synthesis filter denominator
+                                  resulting from the quantized
+                                  interpolated lsf */
+       float *weightdenum, /* (o) the weighting filter denominator
+                                  resulting from the unquantized
+                                  interpolated lsf */
+       float *lsf,         /* (i) the unquantized lsf coefficients */
+       float *lsfdeq,      /* (i) the dequantized lsf coefficients */
+       float *lsfold,      /* (i) the unquantized lsf coefficients of
+                                  the previous signal frame */
+       float *lsfdeqold, /* (i) the dequantized lsf coefficients of
+                                  the previous signal frame */
+       int length,         /* (i) should equate LPC_FILTERORDER */
+       iLBC_Enc_Inst_t *iLBCenc_inst
+                           /* (i/o) the encoder state structure */
+   ){
+       int    i, pos, lp_length;
+       float  lp[LPC_FILTERORDER + 1], *lsf2, *lsfdeq2;
+
+       lsf2 = lsf + length;
+       lsfdeq2 = lsfdeq + length;
+       lp_length = length + 1;
+
+       if (iLBCenc_inst->mode==30) {
+           /* sub-frame 1: Interpolation between old and first
+
+
+
+Andersen, et al.              Experimental                    [Page 169]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+              set of lsf coefficients */
+
+           LSFinterpolate2a_enc(lp, lsfdeqold, lsfdeq,
+               lsf_weightTbl_30ms[0], length);
+           memcpy(syntdenum,lp,lp_length*sizeof(float));
+           LSFinterpolate2a_enc(lp, lsfold, lsf,
+               lsf_weightTbl_30ms[0], length);
+           bwexpand(weightdenum, lp, LPC_CHIRP_WEIGHTDENUM, lp_length);
+
+           /* sub-frame 2 to 6: Interpolation between first
+              and second set of lsf coefficients */
+
+           pos = lp_length;
+           for (i = 1; i < iLBCenc_inst->nsub; i++) {
+               LSFinterpolate2a_enc(lp, lsfdeq, lsfdeq2,
+                   lsf_weightTbl_30ms[i], length);
+               memcpy(syntdenum + pos,lp,lp_length*sizeof(float));
+
+               LSFinterpolate2a_enc(lp, lsf, lsf2,
+                   lsf_weightTbl_30ms[i], length);
+               bwexpand(weightdenum + pos, lp,
+                   LPC_CHIRP_WEIGHTDENUM, lp_length);
+               pos += lp_length;
+           }
+       }
+       else {
+           pos = 0;
+           for (i = 0; i < iLBCenc_inst->nsub; i++) {
+               LSFinterpolate2a_enc(lp, lsfdeqold, lsfdeq,
+                   lsf_weightTbl_20ms[i], length);
+               memcpy(syntdenum+pos,lp,lp_length*sizeof(float));
+               LSFinterpolate2a_enc(lp, lsfold, lsf,
+                   lsf_weightTbl_20ms[i], length);
+               bwexpand(weightdenum+pos, lp,
+                   LPC_CHIRP_WEIGHTDENUM, lp_length);
+               pos += lp_length;
+           }
+       }
+
+       /* update memory */
+
+       if (iLBCenc_inst->mode==30) {
+           memcpy(lsfold, lsf2, length*sizeof(float));
+           memcpy(lsfdeqold, lsfdeq2, length*sizeof(float));
+       }
+       else {
+           memcpy(lsfold, lsf, length*sizeof(float));
+           memcpy(lsfdeqold, lsfdeq, length*sizeof(float));
+
+
+
+Andersen, et al.              Experimental                    [Page 170]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  lsf quantizer (subrutine to LPCencode)
+    *---------------------------------------------------------------*/
+
+   void SimplelsfQ(
+       float *lsfdeq,    /* (o) dequantized lsf coefficients
+                              (dimension FILTERORDER) */
+       int *index,     /* (o) quantization index */
+       float *lsf,      /* (i) the lsf coefficient vector to be
+                              quantized (dimension FILTERORDER ) */
+       int lpc_n     /* (i) number of lsf sets to quantize */
+   ){
+       /* Quantize first LSF with memoryless split VQ */
+       SplitVQ(lsfdeq, index, lsf, lsfCbTbl, LSF_NSPLIT,
+           dim_lsfCbTbl, size_lsfCbTbl);
+
+       if (lpc_n==2) {
+           /* Quantize second LSF with memoryless split VQ */
+           SplitVQ(lsfdeq + LPC_FILTERORDER, index + LSF_NSPLIT,
+               lsf + LPC_FILTERORDER, lsfCbTbl, LSF_NSPLIT,
+               dim_lsfCbTbl, size_lsfCbTbl);
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  lpc encoder
+    *---------------------------------------------------------------*/
+
+   void LPCencode(
+       float *syntdenum, /* (i/o) synthesis filter coefficients
+                                  before/after encoding */
+       float *weightdenum, /* (i/o) weighting denumerator
+                                  coefficients before/after
+                                  encoding */
+       int *lsf_index,     /* (o) lsf quantization index */
+       float *data,    /* (i) lsf coefficients to quantize */
+       iLBC_Enc_Inst_t *iLBCenc_inst
+                           /* (i/o) the encoder state structure */
+   ){
+       float lsf[LPC_FILTERORDER * LPC_N_MAX];
+       float lsfdeq[LPC_FILTERORDER * LPC_N_MAX];
+       int change=0;
+
+       SimpleAnalysis(lsf, data, iLBCenc_inst);
+       SimplelsfQ(lsfdeq, lsf_index, lsf, iLBCenc_inst->lpc_n);
+
+
+
+Andersen, et al.              Experimental                    [Page 171]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       change=LSF_check(lsfdeq, LPC_FILTERORDER, iLBCenc_inst->lpc_n);
+       SimpleInterpolateLSF(syntdenum, weightdenum,
+           lsf, lsfdeq, iLBCenc_inst->lsfold,
+           iLBCenc_inst->lsfdeqold, LPC_FILTERORDER, iLBCenc_inst);
+   }
+
+A.39.  lsf.h
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       lsf.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_LSF_H
+   #define __iLBC_LSF_H
+
+   void a2lsf(
+       float *freq,/* (o) lsf coefficients */
+       float *a    /* (i) lpc coefficients */
+   );
+
+   void lsf2a(
+       float *a_coef,  /* (o) lpc coefficients */
+       float *freq     /* (i) lsf coefficients */
+   );
+
+   #endif
+
+A.40.  lsf.c
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       lsf.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <string.h>
+
+
+
+Andersen, et al.              Experimental                    [Page 172]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   #include <math.h>
+
+   #include "iLBC_define.h"
+
+   /*----------------------------------------------------------------*
+    *  conversion from lpc coefficients to lsf coefficients
+    *---------------------------------------------------------------*/
+
+   void a2lsf(
+       float *freq,/* (o) lsf coefficients */
+       float *a    /* (i) lpc coefficients */
+   ){
+       float steps[LSF_NUMBER_OF_STEPS] =
+           {(float)0.00635, (float)0.003175, (float)0.0015875,
+           (float)0.00079375};
+       float step;
+       int step_idx;
+       int lsp_index;
+       float p[LPC_HALFORDER];
+       float q[LPC_HALFORDER];
+       float p_pre[LPC_HALFORDER];
+       float q_pre[LPC_HALFORDER];
+       float old_p, old_q, *old;
+       float *pq_coef;
+       float omega, old_omega;
+       int i;
+       float hlp, hlp1, hlp2, hlp3, hlp4, hlp5;
+
+       for (i=0; i<LPC_HALFORDER; i++) {
+           p[i] = (float)-1.0 * (a[i + 1] + a[LPC_FILTERORDER - i]);
+           q[i] = a[LPC_FILTERORDER - i] - a[i + 1];
+       }
+
+       p_pre[0] = (float)-1.0 - p[0];
+       p_pre[1] = - p_pre[0] - p[1];
+       p_pre[2] = - p_pre[1] - p[2];
+       p_pre[3] = - p_pre[2] - p[3];
+       p_pre[4] = - p_pre[3] - p[4];
+       p_pre[4] = p_pre[4] / 2;
+
+       q_pre[0] = (float)1.0 - q[0];
+       q_pre[1] = q_pre[0] - q[1];
+       q_pre[2] = q_pre[1] - q[2];
+       q_pre[3] = q_pre[2] - q[3];
+       q_pre[4] = q_pre[3] - q[4];
+       q_pre[4] = q_pre[4] / 2;
+
+       omega = 0.0;
+
+
+
+Andersen, et al.              Experimental                    [Page 173]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       old_omega = 0.0;
+
+       old_p = FLOAT_MAX;
+       old_q = FLOAT_MAX;
+
+       /* Here we loop through lsp_index to find all the
+          LPC_FILTERORDER roots for omega. */
+
+       for (lsp_index = 0; lsp_index<LPC_FILTERORDER; lsp_index++) {
+
+           /* Depending on lsp_index being even or odd, we
+           alternatively solve the roots for the two LSP equations. */
+
+
+           if ((lsp_index & 0x1) == 0) {
+               pq_coef = p_pre;
+               old = &old_p;
+           } else {
+               pq_coef = q_pre;
+               old = &old_q;
+           }
+
+           /* Start with low resolution grid */
+
+           for (step_idx = 0, step = steps[step_idx];
+               step_idx < LSF_NUMBER_OF_STEPS;){
+
+               /*  cos(10piw) + pq(0)cos(8piw) + pq(1)cos(6piw) +
+               pq(2)cos(4piw) + pq(3)cod(2piw) + pq(4) */
+
+               hlp = (float)cos(omega * TWO_PI);
+               hlp1 = (float)2.0 * hlp + pq_coef[0];
+               hlp2 = (float)2.0 * hlp * hlp1 - (float)1.0 +
+                   pq_coef[1];
+               hlp3 = (float)2.0 * hlp * hlp2 - hlp1 + pq_coef[2];
+               hlp4 = (float)2.0 * hlp * hlp3 - hlp2 + pq_coef[3];
+               hlp5 = hlp * hlp4 - hlp3 + pq_coef[4];
+
+
+               if (((hlp5 * (*old)) <= 0.0) || (omega >= 0.5)){
+
+                   if (step_idx == (LSF_NUMBER_OF_STEPS - 1)){
+
+                       if (fabs(hlp5) >= fabs(*old)) {
+                           freq[lsp_index] = omega - step;
+                       } else {
+                           freq[lsp_index] = omega;
+                       }
+
+
+
+Andersen, et al.              Experimental                    [Page 174]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+
+
+                       if ((*old) >= 0.0){
+                           *old = (float)-1.0 * FLOAT_MAX;
+                       } else {
+                           *old = FLOAT_MAX;
+                       }
+
+                       omega = old_omega;
+                       step_idx = 0;
+
+                       step_idx = LSF_NUMBER_OF_STEPS;
+                   } else {
+
+                       if (step_idx == 0) {
+                           old_omega = omega;
+                       }
+
+                       step_idx++;
+                       omega -= steps[step_idx];
+
+                       /* Go back one grid step */
+
+                       step = steps[step_idx];
+                   }
+               } else {
+
+               /* increment omega until they are of different sign,
+               and we know there is at least one root between omega
+               and old_omega */
+                   *old = hlp5;
+                   omega += step;
+               }
+           }
+       }
+
+       for (i = 0; i<LPC_FILTERORDER; i++) {
+           freq[i] = freq[i] * TWO_PI;
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  conversion from lsf coefficients to lpc coefficients
+    *---------------------------------------------------------------*/
+
+   void lsf2a(
+       float *a_coef,  /* (o) lpc coefficients */
+       float *freq     /* (i) lsf coefficients */
+
+
+
+Andersen, et al.              Experimental                    [Page 175]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   ){
+       int i, j;
+       float hlp;
+       float p[LPC_HALFORDER], q[LPC_HALFORDER];
+       float a[LPC_HALFORDER + 1], a1[LPC_HALFORDER],
+           a2[LPC_HALFORDER];
+       float b[LPC_HALFORDER + 1], b1[LPC_HALFORDER],
+           b2[LPC_HALFORDER];
+
+       for (i=0; i<LPC_FILTERORDER; i++) {
+           freq[i] = freq[i] * PI2;
+       }
+
+       /* Check input for ill-conditioned cases.  This part is not
+       found in the TIA standard.  It involves the following 2 IF
+       blocks.  If "freq" is judged ill-conditioned, then we first
+       modify freq[0] and freq[LPC_HALFORDER-1] (normally
+       LPC_HALFORDER = 10 for LPC applications), then we adjust
+       the other "freq" values slightly */
+
+
+       if ((freq[0] <= 0.0) || (freq[LPC_FILTERORDER - 1] >= 0.5)){
+
+
+           if (freq[0] <= 0.0) {
+               freq[0] = (float)0.022;
+           }
+
+
+           if (freq[LPC_FILTERORDER - 1] >= 0.5) {
+               freq[LPC_FILTERORDER - 1] = (float)0.499;
+           }
+
+           hlp = (freq[LPC_FILTERORDER - 1] - freq[0]) /
+               (float) (LPC_FILTERORDER - 1);
+
+           for (i=1; i<LPC_FILTERORDER; i++) {
+               freq[i] = freq[i - 1] + hlp;
+           }
+       }
+
+       memset(a1, 0, LPC_HALFORDER*sizeof(float));
+       memset(a2, 0, LPC_HALFORDER*sizeof(float));
+       memset(b1, 0, LPC_HALFORDER*sizeof(float));
+       memset(b2, 0, LPC_HALFORDER*sizeof(float));
+       memset(a, 0, (LPC_HALFORDER+1)*sizeof(float));
+       memset(b, 0, (LPC_HALFORDER+1)*sizeof(float));
+
+
+
+
+Andersen, et al.              Experimental                    [Page 176]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       /* p[i] and q[i] compute cos(2*pi*omega_{2j}) and
+       cos(2*pi*omega_{2j-1} in eqs. 4.2.2.2-1 and 4.2.2.2-2.
+       Note that for this code p[i] specifies the coefficients
+       used in .Q_A(z) while q[i] specifies the coefficients used
+       in .P_A(z) */
+
+       for (i=0; i<LPC_HALFORDER; i++) {
+           p[i] = (float)cos(TWO_PI * freq[2 * i]);
+           q[i] = (float)cos(TWO_PI * freq[2 * i + 1]);
+       }
+
+       a[0] = 0.25;
+       b[0] = 0.25;
+
+       for (i= 0; i<LPC_HALFORDER; i++) {
+           a[i + 1] = a[i] - 2 * p[i] * a1[i] + a2[i];
+           b[i + 1] = b[i] - 2 * q[i] * b1[i] + b2[i];
+           a2[i] = a1[i];
+           a1[i] = a[i];
+           b2[i] = b1[i];
+           b1[i] = b[i];
+       }
+
+       for (j=0; j<LPC_FILTERORDER; j++) {
+
+           if (j == 0) {
+               a[0] = 0.25;
+               b[0] = -0.25;
+           } else {
+               a[0] = b[0] = 0.0;
+           }
+
+           for (i=0; i<LPC_HALFORDER; i++) {
+               a[i + 1] = a[i] - 2 * p[i] * a1[i] + a2[i];
+               b[i + 1] = b[i] - 2 * q[i] * b1[i] + b2[i];
+               a2[i] = a1[i];
+               a1[i] = a[i];
+               b2[i] = b1[i];
+               b1[i] = b[i];
+           }
+
+           a_coef[j + 1] = 2 * (a[LPC_HALFORDER] + b[LPC_HALFORDER]);
+       }
+
+       a_coef[0] = 1.0;
+   }
+
+
+
+
+
+Andersen, et al.              Experimental                    [Page 177]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+A.41.  packing.h
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       packing.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __PACKING_H
+   #define __PACKING_H
+
+   void packsplit(
+       int *index,                 /* (i) the value to split */
+       int *firstpart,             /* (o) the value specified by most
+                                          significant bits */
+       int *rest,                  /* (o) the value specified by least
+                                          significant bits */
+       int bitno_firstpart,    /* (i) number of bits in most
+                                          significant part */
+       int bitno_total             /* (i) number of bits in full range
+                                          of value */
+   );
+
+   void packcombine(
+       int *index,                 /* (i/o) the msb value in the
+                                          combined value out */
+       int rest,                   /* (i) the lsb value */
+       int bitno_rest              /* (i) the number of bits in the
+                                          lsb part */
+   );
+
+   void dopack(
+       unsigned char **bitstream,  /* (i/o) on entrance pointer to
+                                          place in bitstream to pack
+                                          new data, on exit pointer
+                                          to place in bitstream to
+                                          pack future data */
+       int index,                  /* (i) the value to pack */
+       int bitno,                  /* (i) the number of bits that the
+                                          value will fit within */
+       int *pos                /* (i/o) write position in the
+                                          current byte */
+   );
+
+
+
+Andersen, et al.              Experimental                    [Page 178]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   void unpack(
+       unsigned char **bitstream,  /* (i/o) on entrance pointer to
+                                          place in bitstream to
+                                          unpack new data from, on
+                                          exit pointer to place in
+                                          bitstream to unpack future
+                                          data from */
+       int *index,                 /* (o) resulting value */
+       int bitno,                  /* (i) number of bits used to
+                                          represent the value */
+       int *pos                /* (i/o) read position in the
+                                          current byte */
+   );
+
+   #endif
+
+A.42.  packing.c
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       packing.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <math.h>
+   #include <stdlib.h>
+
+   #include "iLBC_define.h"
+   #include "constants.h"
+   #include "helpfun.h"
+   #include "string.h"
+
+   /*----------------------------------------------------------------*
+    *  splitting an integer into first most significant bits and
+    *  remaining least significant bits
+    *---------------------------------------------------------------*/
+
+   void packsplit(
+       int *index,                 /* (i) the value to split */
+       int *firstpart,             /* (o) the value specified by most
+                                          significant bits */
+       int *rest,                  /* (o) the value specified by least
+                                          significant bits */
+
+
+
+Andersen, et al.              Experimental                    [Page 179]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       int bitno_firstpart,    /* (i) number of bits in most
+                                          significant part */
+       int bitno_total             /* (i) number of bits in full range
+                                          of value */
+   ){
+       int bitno_rest = bitno_total-bitno_firstpart;
+
+       *firstpart = *index>>(bitno_rest);
+       *rest = *index-(*firstpart<<(bitno_rest));
+   }
+
+   /*----------------------------------------------------------------*
+    *  combining a value corresponding to msb's with a value
+    *  corresponding to lsb's
+    *---------------------------------------------------------------*/
+
+   void packcombine(
+       int *index,                 /* (i/o) the msb value in the
+                                          combined value out */
+       int rest,                   /* (i) the lsb value */
+       int bitno_rest              /* (i) the number of bits in the
+                                          lsb part */
+   ){
+       *index = *index<<bitno_rest;
+       *index += rest;
+   }
+
+   /*----------------------------------------------------------------*
+    *  packing of bits into bitstream, i.e., vector of bytes
+    *---------------------------------------------------------------*/
+
+   void dopack(
+       unsigned char **bitstream,  /* (i/o) on entrance pointer to
+                                          place in bitstream to pack
+                                          new data, on exit pointer
+                                          to place in bitstream to
+                                          pack future data */
+       int index,                  /* (i) the value to pack */
+       int bitno,                  /* (i) the number of bits that the
+                                          value will fit within */
+       int *pos                /* (i/o) write position in the
+                                          current byte */
+   ){
+       int posLeft;
+
+       /* Clear the bits before starting in a new byte */
+
+       if ((*pos)==0) {
+
+
+
+Andersen, et al.              Experimental                    [Page 180]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+           **bitstream=0;
+       }
+
+       while (bitno>0) {
+
+           /* Jump to the next byte if end of this byte is reached*/
+
+           if (*pos==8) {
+               *pos=0;
+               (*bitstream)++;
+               **bitstream=0;
+           }
+
+           posLeft=8-(*pos);
+
+           /* Insert index into the bitstream */
+
+           if (bitno <= posLeft) {
+               **bitstream |= (unsigned char)(index<<(posLeft-bitno));
+               *pos+=bitno;
+               bitno=0;
+           } else {
+               **bitstream |= (unsigned char)(index>>(bitno-posLeft));
+
+               *pos=8;
+               index-=((index>>(bitno-posLeft))<<(bitno-posLeft));
+
+               bitno-=posLeft;
+           }
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  unpacking of bits from bitstream, i.e., vector of bytes
+    *---------------------------------------------------------------*/
+
+   void unpack(
+       unsigned char **bitstream,  /* (i/o) on entrance pointer to
+                                          place in bitstream to
+                                          unpack new data from, on
+                                          exit pointer to place in
+                                          bitstream to unpack future
+                                          data from */
+       int *index,                 /* (o) resulting value */
+       int bitno,                  /* (i) number of bits used to
+                                          represent the value */
+       int *pos                /* (i/o) read position in the
+                                          current byte */
+
+
+
+Andersen, et al.              Experimental                    [Page 181]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   ){
+       int BitsLeft;
+
+       *index=0;
+
+       while (bitno>0) {
+
+           /* move forward in bitstream when the end of the
+              byte is reached */
+
+           if (*pos==8) {
+               *pos=0;
+               (*bitstream)++;
+           }
+
+           BitsLeft=8-(*pos);
+
+           /* Extract bits to index */
+
+           if (BitsLeft>=bitno) {
+               *index+=((((**bitstream)<<(*pos)) & 0xFF)>>(8-bitno));
+
+               *pos+=bitno;
+               bitno=0;
+           } else {
+
+               if ((8-bitno)>0) {
+                   *index+=((((**bitstream)<<(*pos)) & 0xFF)>>
+                       (8-bitno));
+                   *pos=8;
+               } else {
+                   *index+=(((int)(((**bitstream)<<(*pos)) & 0xFF))<<
+                       (bitno-8));
+                   *pos=8;
+               }
+               bitno-=BitsLeft;
+           }
+       }
+   }
+
+A.43.  StateConstructW.h
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       StateConstructW.h
+
+
+
+
+Andersen, et al.              Experimental                    [Page 182]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_STATECONSTRUCTW_H
+   #define __iLBC_STATECONSTRUCTW_H
+
+   void StateConstructW(
+       int idxForMax,      /* (i) 6-bit index for the quantization of
+                                  max amplitude */
+       int *idxVec,    /* (i) vector of quantization indexes */
+       float *syntDenum,   /* (i) synthesis filter denumerator */
+       float *out,         /* (o) the decoded state vector */
+       int len             /* (i) length of a state vector */
+   );
+
+   #endif
+
+A.44.  StateConstructW.c
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       StateConstructW.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <math.h>
+   #include <string.h>
+
+   #include "iLBC_define.h"
+   #include "constants.h"
+   #include "filter.h"
+
+   /*----------------------------------------------------------------*
+    *  decoding of the start state
+    *---------------------------------------------------------------*/
+
+   void StateConstructW(
+       int idxForMax,      /* (i) 6-bit index for the quantization of
+                                  max amplitude */
+       int *idxVec,    /* (i) vector of quantization indexes */
+       float *syntDenum,   /* (i) synthesis filter denumerator */
+
+
+
+Andersen, et al.              Experimental                    [Page 183]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       float *out,         /* (o) the decoded state vector */
+       int len             /* (i) length of a state vector */
+   ){
+       float maxVal, tmpbuf[LPC_FILTERORDER+2*STATE_LEN], *tmp,
+           numerator[LPC_FILTERORDER+1];
+       float foutbuf[LPC_FILTERORDER+2*STATE_LEN], *fout;
+       int k,tmpi;
+
+       /* decoding of the maximum value */
+
+       maxVal = state_frgqTbl[idxForMax];
+       maxVal = (float)pow(10,maxVal)/(float)4.5;
+
+       /* initialization of buffers and coefficients */
+
+       memset(tmpbuf, 0, LPC_FILTERORDER*sizeof(float));
+       memset(foutbuf, 0, LPC_FILTERORDER*sizeof(float));
+       for (k=0; k<LPC_FILTERORDER; k++) {
+           numerator[k]=syntDenum[LPC_FILTERORDER-k];
+       }
+       numerator[LPC_FILTERORDER]=syntDenum[0];
+       tmp = &tmpbuf[LPC_FILTERORDER];
+       fout = &foutbuf[LPC_FILTERORDER];
+
+       /* decoding of the sample values */
+
+       for (k=0; k<len; k++) {
+           tmpi = len-1-k;
+           /* maxVal = 1/scal */
+           tmp[k] = maxVal*state_sq3Tbl[idxVec[tmpi]];
+       }
+
+       /* circular convolution with all-pass filter */
+
+       memset(tmp+len, 0, len*sizeof(float));
+       ZeroPoleFilter(tmp, numerator, syntDenum, 2*len,
+           LPC_FILTERORDER, fout);
+       for (k=0;k<len;k++) {
+           out[k] = fout[len-1-k]+fout[2*len-1-k];
+       }
+   }
+
+
+
+
+
+
+
+
+
+
+Andersen, et al.              Experimental                    [Page 184]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+A.45.  StateSearchW.h
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       StateSearchW.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_STATESEARCHW_H
+   #define __iLBC_STATESEARCHW_H
+
+   void AbsQuantW(
+       iLBC_Enc_Inst_t *iLBCenc_inst,
+                           /* (i) Encoder instance */
+       float *in,          /* (i) vector to encode */
+       float *syntDenum,   /* (i) denominator of synthesis filter */
+       float *weightDenum, /* (i) denominator of weighting filter */
+       int *out,           /* (o) vector of quantizer indexes */
+       int len,        /* (i) length of vector to encode and
+                                  vector of quantizer indexes */
+       int state_first     /* (i) position of start state in the
+                                  80 vec */
+   );
+
+   void StateSearchW(
+       iLBC_Enc_Inst_t *iLBCenc_inst,
+                           /* (i) Encoder instance */
+       float *residual,/* (i) target residual vector */
+       float *syntDenum,   /* (i) lpc synthesis filter */
+       float *weightDenum, /* (i) weighting filter denuminator */
+       int *idxForMax,     /* (o) quantizer index for maximum
+                                  amplitude */
+       int *idxVec,    /* (o) vector of quantization indexes */
+       int len,        /* (i) length of all vectors */
+       int state_first     /* (i) position of start state in the
+                                  80 vec */
+   );
+
+
+   #endif
+
+
+
+
+
+
+Andersen, et al.              Experimental                    [Page 185]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+A.46.  StateSearchW.c
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       StateSearchW.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <math.h>
+   #include <string.h>
+
+   #include "iLBC_define.h"
+   #include "constants.h"
+   #include "filter.h"
+   #include "helpfun.h"
+
+   /*----------------------------------------------------------------*
+    *  predictive noise shaping encoding of scaled start state
+    *  (subrutine for StateSearchW)
+    *---------------------------------------------------------------*/
+
+   void AbsQuantW(
+       iLBC_Enc_Inst_t *iLBCenc_inst,
+                           /* (i) Encoder instance */
+       float *in,          /* (i) vector to encode */
+       float *syntDenum,   /* (i) denominator of synthesis filter */
+       float *weightDenum, /* (i) denominator of weighting filter */
+       int *out,           /* (o) vector of quantizer indexes */
+       int len,        /* (i) length of vector to encode and
+                                  vector of quantizer indexes */
+       int state_first     /* (i) position of start state in the
+                                  80 vec */
+   ){
+       float *syntOut;
+       float syntOutBuf[LPC_FILTERORDER+STATE_SHORT_LEN_30MS];
+       float toQ, xq;
+       int n;
+       int index;
+
+       /* initialization of buffer for filtering */
+
+       memset(syntOutBuf, 0, LPC_FILTERORDER*sizeof(float));
+
+
+
+
+Andersen, et al.              Experimental                    [Page 186]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       /* initialization of pointer for filtering */
+
+       syntOut = &syntOutBuf[LPC_FILTERORDER];
+
+       /* synthesis and weighting filters on input */
+
+       if (state_first) {
+           AllPoleFilter (in, weightDenum, SUBL, LPC_FILTERORDER);
+       } else {
+           AllPoleFilter (in, weightDenum,
+               iLBCenc_inst->state_short_len-SUBL,
+               LPC_FILTERORDER);
+       }
+
+       /* encoding loop */
+
+       for (n=0; n<len; n++) {
+
+           /* time update of filter coefficients */
+
+           if ((state_first)&&(n==SUBL)){
+               syntDenum += (LPC_FILTERORDER+1);
+               weightDenum += (LPC_FILTERORDER+1);
+
+               /* synthesis and weighting filters on input */
+               AllPoleFilter (&in[n], weightDenum, len-n,
+                   LPC_FILTERORDER);
+
+           } else if ((state_first==0)&&
+               (n==(iLBCenc_inst->state_short_len-SUBL))) {
+               syntDenum += (LPC_FILTERORDER+1);
+               weightDenum += (LPC_FILTERORDER+1);
+
+               /* synthesis and weighting filters on input */
+               AllPoleFilter (&in[n], weightDenum, len-n,
+                   LPC_FILTERORDER);
+
+           }
+
+           /* prediction of synthesized and weighted input */
+
+           syntOut[n] = 0.0;
+           AllPoleFilter (&syntOut[n], weightDenum, 1,
+               LPC_FILTERORDER);
+
+           /* quantization */
+
+           toQ = in[n]-syntOut[n];
+
+
+
+Andersen, et al.              Experimental                    [Page 187]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+           sort_sq(&xq, &index, toQ, state_sq3Tbl, 8);
+           out[n]=index;
+           syntOut[n] = state_sq3Tbl[out[n]];
+
+           /* update of the prediction filter */
+
+           AllPoleFilter(&syntOut[n], weightDenum, 1,
+               LPC_FILTERORDER);
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  encoding of start state
+    *---------------------------------------------------------------*/
+
+   void StateSearchW(
+       iLBC_Enc_Inst_t *iLBCenc_inst,
+                           /* (i) Encoder instance */
+       float *residual,/* (i) target residual vector */
+       float *syntDenum,   /* (i) lpc synthesis filter */
+       float *weightDenum, /* (i) weighting filter denuminator */
+       int *idxForMax,     /* (o) quantizer index for maximum
+                                  amplitude */
+       int *idxVec,    /* (o) vector of quantization indexes */
+       int len,        /* (i) length of all vectors */
+       int state_first     /* (i) position of start state in the
+                                  80 vec */
+   ){
+       float dtmp, maxVal;
+       float tmpbuf[LPC_FILTERORDER+2*STATE_SHORT_LEN_30MS];
+       float *tmp, numerator[1+LPC_FILTERORDER];
+       float foutbuf[LPC_FILTERORDER+2*STATE_SHORT_LEN_30MS], *fout;
+       int k;
+       float qmax, scal;
+
+       /* initialization of buffers and filter coefficients */
+
+       memset(tmpbuf, 0, LPC_FILTERORDER*sizeof(float));
+       memset(foutbuf, 0, LPC_FILTERORDER*sizeof(float));
+       for (k=0; k<LPC_FILTERORDER; k++) {
+           numerator[k]=syntDenum[LPC_FILTERORDER-k];
+       }
+       numerator[LPC_FILTERORDER]=syntDenum[0];
+       tmp = &tmpbuf[LPC_FILTERORDER];
+       fout = &foutbuf[LPC_FILTERORDER];
+
+       /* circular convolution with the all-pass filter */
+
+
+
+
+Andersen, et al.              Experimental                    [Page 188]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       memcpy(tmp, residual, len*sizeof(float));
+       memset(tmp+len, 0, len*sizeof(float));
+       ZeroPoleFilter(tmp, numerator, syntDenum, 2*len,
+           LPC_FILTERORDER, fout);
+       for (k=0; k<len; k++) {
+           fout[k] += fout[k+len];
+       }
+
+       /* identification of the maximum amplitude value */
+
+       maxVal = fout[0];
+       for (k=1; k<len; k++) {
+
+           if (fout[k]*fout[k] > maxVal*maxVal){
+               maxVal = fout[k];
+           }
+       }
+       maxVal=(float)fabs(maxVal);
+
+       /* encoding of the maximum amplitude value */
+
+       if (maxVal < 10.0) {
+           maxVal = 10.0;
+       }
+       maxVal = (float)log10(maxVal);
+       sort_sq(&dtmp, idxForMax, maxVal, state_frgqTbl, 64);
+
+       /* decoding of the maximum amplitude representation value,
+          and corresponding scaling of start state */
+
+       maxVal=state_frgqTbl[*idxForMax];
+       qmax = (float)pow(10,maxVal);
+       scal = (float)(4.5)/qmax;
+       for (k=0; k<len; k++){
+           fout[k] *= scal;
+       }
+
+       /* predictive noise shaping encoding of scaled start state */
+
+       AbsQuantW(iLBCenc_inst, fout,syntDenum,
+           weightDenum,idxVec, len, state_first);
+   }
+
+
+
+
+
+
+
+
+
+Andersen, et al.              Experimental                    [Page 189]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+A.47.  syntFilter.h
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       syntFilter.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_SYNTFILTER_H
+   #define __iLBC_SYNTFILTER_H
+
+   void syntFilter(
+       float *Out,     /* (i/o) Signal to be filtered */
+       float *a,       /* (i) LP parameters */
+       int len,    /* (i) Length of signal */
+       float *mem      /* (i/o) Filter state */
+   );
+
+   #endif
+
+A.48.  syntFilter.c
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       syntFilter.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include "iLBC_define.h"
+
+   /*----------------------------------------------------------------*
+    *  LP synthesis filter.
+    *---------------------------------------------------------------*/
+
+   void syntFilter(
+       float *Out,     /* (i/o) Signal to be filtered */
+       float *a,       /* (i) LP parameters */
+       int len,    /* (i) Length of signal */
+
+
+
+Andersen, et al.              Experimental                    [Page 190]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+       float *mem      /* (i/o) Filter state */
+   ){
+       int i, j;
+       float *po, *pi, *pa, *pm;
+
+       po=Out;
+
+       /* Filter first part using memory from past */
+
+       for (i=0; i<LPC_FILTERORDER; i++) {
+           pi=&Out[i-1];
+           pa=&a[1];
+           pm=&mem[LPC_FILTERORDER-1];
+           for (j=1; j<=i; j++) {
+               *po-=(*pa++)*(*pi--);
+           }
+           for (j=i+1; j<LPC_FILTERORDER+1; j++) {
+               *po-=(*pa++)*(*pm--);
+           }
+           po++;
+       }
+
+       /* Filter last part where the state is entirely in
+          the output vector */
+
+       for (i=LPC_FILTERORDER; i<len; i++) {
+           pi=&Out[i-1];
+           pa=&a[1];
+           for (j=1; j<LPC_FILTERORDER+1; j++) {
+               *po-=(*pa++)*(*pi--);
+           }
+           po++;
+       }
+
+       /* Update state vector */
+
+       memcpy(mem, &Out[len-LPC_FILTERORDER],
+           LPC_FILTERORDER*sizeof(float));
+   }
+
+
+
+
+
+
+
+
+
+
+
+
+Andersen, et al.              Experimental                    [Page 191]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+Authors' Addresses
+
+   Soren Vang Andersen
+   Department of Communication Technology
+   Aalborg University
+   Fredrik Bajers Vej 7A
+   9200 Aalborg
+   Denmark
+
+   Phone:  ++45 9 6358627
+   EMail:  sva@kom.auc.dk
+
+
+   Alan Duric
+   Telio AS
+   Stoperigt. 2
+   Oslo, N-0250
+   Norway
+
+   Phone:  +47 21673555
+   EMail:  alan.duric@telio.no
+
+
+   Henrik Astrom
+   Global IP Sound AB
+   Olandsgatan 42
+   Stockholm, S-11663
+   Sweden
+
+   Phone:  +46 8 54553040
+   EMail:  henrik.astrom@globalipsound.com
+
+
+   Roar Hagen
+   Global IP Sound AB
+   Olandsgatan 42
+   Stockholm, S-11663
+   Sweden
+
+   Phone:  +46 8 54553040
+   EMail:  roar.hagen@globalipsound.com
+
+
+
+
+
+
+
+
+
+
+Andersen, et al.              Experimental                    [Page 192]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+   W. Bastiaan Kleijn
+   Global IP Sound AB
+   Olandsgatan 42
+   Stockholm, S-11663
+   Sweden
+
+   Phone:  +46 8 54553040
+   EMail:  bastiaan.kleijn@globalipsound.com
+
+
+   Jan Linden
+   Global IP Sound Inc.
+   900 Kearny Street, suite 500
+   San Francisco, CA-94133
+   USA
+
+   Phone: +1 415 397 2555
+   EMail: jan.linden@globalipsound.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Andersen, et al.              Experimental                    [Page 193]
+
+RFC 3951              Internet Low Bit Rate Codec          December 2004
+
+
+Full Copyright Statement
+
+   Copyright (C) The Internet Society (2004).
+
+   This document is subject to the rights, licenses and restrictions
+   contained in BCP 78, and except as set forth therein, the authors
+   retain all their rights.
+
+   This document and the information contained herein are provided on an
+   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
+   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
+   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
+   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
+   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+
+Intellectual Property
+
+   The IETF takes no position regarding the validity or scope of any
+   Intellectual Property Rights or other rights that might be claimed to
+   pertain to the implementation or use of the technology described in
+   this document or the extent to which any license under such rights
+   might or might not be available; nor does it represent that it has
+   made any independent effort to identify any such rights.  Information
+   on the IETF's procedures with respect to rights in IETF Documents can
+   be found in BCP 78 and BCP 79.
+
+   Copies of IPR disclosures made to the IETF Secretariat and any
+   assurances of licenses to be made available, or the result of an
+   attempt made to obtain a general license or permission for the use of
+   such proprietary rights by implementers or users of this
+   specification can be obtained from the IETF on-line IPR repository at
+   http://www.ietf.org/ipr.
+
+   The IETF invites any interested party to bring to its attention any
+   copyrights, patents or patent applications, or other proprietary
+   rights that may cover technology that may be required to implement
+   this standard.  Please address the information to the IETF at ietf-
+   ipr@ietf.org.
+
+
+Acknowledgement
+
+   Funding for the RFC Editor function is currently provided by the
+   Internet Society.
+
+
+
+
+
+
+Andersen, et al.              Experimental                    [Page 194]
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/StateConstructW.c asterisk-1.8.3.2_com_amr/codecs/ilbc/StateConstructW.c
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/StateConstructW.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/StateConstructW.c	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,86 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       StateConstructW.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <math.h>
+   #include <string.h>
+
+   #include "iLBC_define.h"
+   #include "constants.h"
+   #include "filter.h"
+
+   /*----------------------------------------------------------------*
+    *  decoding of the start state
+    *---------------------------------------------------------------*/
+
+   void StateConstructW(
+       int idxForMax,      /* (i) 6-bit index for the quantization of
+                                  max amplitude */
+       int *idxVec,    /* (i) vector of quantization indexes */
+       float *syntDenum,   /* (i) synthesis filter denumerator */
+
+
+
+
+
+       float *out,         /* (o) the decoded state vector */
+       int len             /* (i) length of a state vector */
+   ){
+       float maxVal, tmpbuf[LPC_FILTERORDER+2*STATE_LEN], *tmp,
+           numerator[LPC_FILTERORDER+1];
+       float foutbuf[LPC_FILTERORDER+2*STATE_LEN], *fout;
+       int k,tmpi;
+
+       /* decoding of the maximum value */
+
+       maxVal = state_frgqTbl[idxForMax];
+       maxVal = (float)pow(10,maxVal)/(float)4.5;
+
+       /* initialization of buffers and coefficients */
+
+       memset(tmpbuf, 0, LPC_FILTERORDER*sizeof(float));
+       memset(foutbuf, 0, LPC_FILTERORDER*sizeof(float));
+       for (k=0; k<LPC_FILTERORDER; k++) {
+           numerator[k]=syntDenum[LPC_FILTERORDER-k];
+       }
+       numerator[LPC_FILTERORDER]=syntDenum[0];
+       tmp = &tmpbuf[LPC_FILTERORDER];
+       fout = &foutbuf[LPC_FILTERORDER];
+
+       /* decoding of the sample values */
+
+       for (k=0; k<len; k++) {
+           tmpi = len-1-k;
+           /* maxVal = 1/scal */
+           tmp[k] = maxVal*state_sq3Tbl[idxVec[tmpi]];
+       }
+
+       /* circular convolution with all-pass filter */
+
+       memset(tmp+len, 0, len*sizeof(float));
+       ZeroPoleFilter(tmp, numerator, syntDenum, 2*len,
+           LPC_FILTERORDER, fout);
+       for (k=0;k<len;k++) {
+           out[k] = fout[len-1-k]+fout[2*len-1-k];
+       }
+   }
+
+
+
+
+
+
+
+
+
+
+
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/StateConstructW.h asterisk-1.8.3.2_com_amr/codecs/ilbc/StateConstructW.h
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/StateConstructW.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/StateConstructW.h	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,31 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       StateConstructW.h
+
+
+
+
+
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_STATECONSTRUCTW_H
+   #define __iLBC_STATECONSTRUCTW_H
+
+   void StateConstructW(
+       int idxForMax,      /* (i) 6-bit index for the quantization of
+                                  max amplitude */
+       int *idxVec,    /* (i) vector of quantization indexes */
+       float *syntDenum,   /* (i) synthesis filter denumerator */
+       float *out,         /* (o) the decoded state vector */
+       int len             /* (i) length of a state vector */
+   );
+
+   #endif
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/StateSearchW.c asterisk-1.8.3.2_com_amr/codecs/ilbc/StateSearchW.c
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/StateSearchW.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/StateSearchW.c	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,211 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       StateSearchW.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include <math.h>
+   #include <string.h>
+
+   #include "iLBC_define.h"
+   #include "constants.h"
+   #include "filter.h"
+   #include "helpfun.h"
+
+   /*----------------------------------------------------------------*
+    *  predictive noise shaping encoding of scaled start state
+    *  (subrutine for StateSearchW)
+    *---------------------------------------------------------------*/
+
+   void AbsQuantW(
+       iLBC_Enc_Inst_t *iLBCenc_inst,
+                           /* (i) Encoder instance */
+       float *in,          /* (i) vector to encode */
+       float *syntDenum,   /* (i) denominator of synthesis filter */
+       float *weightDenum, /* (i) denominator of weighting filter */
+       int *out,           /* (o) vector of quantizer indexes */
+       int len,        /* (i) length of vector to encode and
+                                  vector of quantizer indexes */
+       int state_first     /* (i) position of start state in the
+                                  80 vec */
+   ){
+       float *syntOut;
+       float syntOutBuf[LPC_FILTERORDER+STATE_SHORT_LEN_30MS];
+       float toQ, xq;
+       int n;
+       int index;
+
+       /* initialization of buffer for filtering */
+
+       memset(syntOutBuf, 0, LPC_FILTERORDER*sizeof(float));
+
+
+
+
+
+
+       /* initialization of pointer for filtering */
+
+       syntOut = &syntOutBuf[LPC_FILTERORDER];
+
+       /* synthesis and weighting filters on input */
+
+       if (state_first) {
+           AllPoleFilter (in, weightDenum, SUBL, LPC_FILTERORDER);
+       } else {
+           AllPoleFilter (in, weightDenum,
+               iLBCenc_inst->state_short_len-SUBL,
+               LPC_FILTERORDER);
+       }
+
+       /* encoding loop */
+
+       for (n=0; n<len; n++) {
+
+           /* time update of filter coefficients */
+
+           if ((state_first)&&(n==SUBL)){
+               syntDenum += (LPC_FILTERORDER+1);
+               weightDenum += (LPC_FILTERORDER+1);
+
+               /* synthesis and weighting filters on input */
+               AllPoleFilter (&in[n], weightDenum, len-n,
+                   LPC_FILTERORDER);
+
+           } else if ((state_first==0)&&
+               (n==(iLBCenc_inst->state_short_len-SUBL))) {
+               syntDenum += (LPC_FILTERORDER+1);
+               weightDenum += (LPC_FILTERORDER+1);
+
+               /* synthesis and weighting filters on input */
+               AllPoleFilter (&in[n], weightDenum, len-n,
+                   LPC_FILTERORDER);
+
+           }
+
+           /* prediction of synthesized and weighted input */
+
+           syntOut[n] = 0.0;
+           AllPoleFilter (&syntOut[n], weightDenum, 1,
+               LPC_FILTERORDER);
+
+           /* quantization */
+
+           toQ = in[n]-syntOut[n];
+
+
+
+
+
+           sort_sq(&xq, &index, toQ, state_sq3Tbl, 8);
+           out[n]=index;
+           syntOut[n] = state_sq3Tbl[out[n]];
+
+           /* update of the prediction filter */
+
+           AllPoleFilter(&syntOut[n], weightDenum, 1,
+               LPC_FILTERORDER);
+       }
+   }
+
+   /*----------------------------------------------------------------*
+    *  encoding of start state
+    *---------------------------------------------------------------*/
+
+   void StateSearchW(
+       iLBC_Enc_Inst_t *iLBCenc_inst,
+                           /* (i) Encoder instance */
+       float *residual,/* (i) target residual vector */
+       float *syntDenum,   /* (i) lpc synthesis filter */
+       float *weightDenum, /* (i) weighting filter denuminator */
+       int *idxForMax,     /* (o) quantizer index for maximum
+                                  amplitude */
+       int *idxVec,    /* (o) vector of quantization indexes */
+       int len,        /* (i) length of all vectors */
+       int state_first     /* (i) position of start state in the
+                                  80 vec */
+   ){
+       float dtmp, maxVal;
+       float tmpbuf[LPC_FILTERORDER+2*STATE_SHORT_LEN_30MS];
+       float *tmp, numerator[1+LPC_FILTERORDER];
+       float foutbuf[LPC_FILTERORDER+2*STATE_SHORT_LEN_30MS], *fout;
+       int k;
+       float qmax, scal;
+
+       /* initialization of buffers and filter coefficients */
+
+       memset(tmpbuf, 0, LPC_FILTERORDER*sizeof(float));
+       memset(foutbuf, 0, LPC_FILTERORDER*sizeof(float));
+       for (k=0; k<LPC_FILTERORDER; k++) {
+           numerator[k]=syntDenum[LPC_FILTERORDER-k];
+       }
+       numerator[LPC_FILTERORDER]=syntDenum[0];
+       tmp = &tmpbuf[LPC_FILTERORDER];
+       fout = &foutbuf[LPC_FILTERORDER];
+
+       /* circular convolution with the all-pass filter */
+
+
+
+
+
+
+       memcpy(tmp, residual, len*sizeof(float));
+       memset(tmp+len, 0, len*sizeof(float));
+       ZeroPoleFilter(tmp, numerator, syntDenum, 2*len,
+           LPC_FILTERORDER, fout);
+       for (k=0; k<len; k++) {
+           fout[k] += fout[k+len];
+       }
+
+       /* identification of the maximum amplitude value */
+
+       maxVal = fout[0];
+       for (k=1; k<len; k++) {
+
+           if (fout[k]*fout[k] > maxVal*maxVal){
+               maxVal = fout[k];
+           }
+       }
+       maxVal=(float)fabs(maxVal);
+
+       /* encoding of the maximum amplitude value */
+
+       if (maxVal < 10.0) {
+           maxVal = 10.0;
+       }
+       maxVal = (float)log10(maxVal);
+       sort_sq(&dtmp, idxForMax, maxVal, state_frgqTbl, 64);
+
+       /* decoding of the maximum amplitude representation value,
+          and corresponding scaling of start state */
+
+       maxVal=state_frgqTbl[*idxForMax];
+       qmax = (float)pow(10,maxVal);
+       scal = (float)(4.5)/qmax;
+       for (k=0; k<len; k++){
+           fout[k] *= scal;
+       }
+
+       /* predictive noise shaping encoding of scaled start state */
+
+       AbsQuantW(iLBCenc_inst, fout,syntDenum,
+           weightDenum,idxVec, len, state_first);
+   }
+
+
+
+
+
+
+
+
+
+
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/StateSearchW.h asterisk-1.8.3.2_com_amr/codecs/ilbc/StateSearchW.h
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/StateSearchW.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/StateSearchW.h	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,52 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       StateSearchW.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_STATESEARCHW_H
+   #define __iLBC_STATESEARCHW_H
+
+   void AbsQuantW(
+       iLBC_Enc_Inst_t *iLBCenc_inst,
+                           /* (i) Encoder instance */
+       float *in,          /* (i) vector to encode */
+       float *syntDenum,   /* (i) denominator of synthesis filter */
+       float *weightDenum, /* (i) denominator of weighting filter */
+       int *out,           /* (o) vector of quantizer indexes */
+       int len,        /* (i) length of vector to encode and
+                                  vector of quantizer indexes */
+       int state_first     /* (i) position of start state in the
+                                  80 vec */
+   );
+
+   void StateSearchW(
+       iLBC_Enc_Inst_t *iLBCenc_inst,
+                           /* (i) Encoder instance */
+       float *residual,/* (i) target residual vector */
+       float *syntDenum,   /* (i) lpc synthesis filter */
+       float *weightDenum, /* (i) weighting filter denuminator */
+       int *idxForMax,     /* (o) quantizer index for maximum
+                                  amplitude */
+       int *idxVec,    /* (o) vector of quantization indexes */
+       int len,        /* (i) length of all vectors */
+       int state_first     /* (i) position of start state in the
+                                  80 vec */
+   );
+
+
+   #endif
+
+
+
+
+
+
+
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/syntFilter.c asterisk-1.8.3.2_com_amr/codecs/ilbc/syntFilter.c
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/syntFilter.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/syntFilter.c	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,80 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       syntFilter.c
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #include "iLBC_define.h"
+
+   /*----------------------------------------------------------------*
+    *  LP synthesis filter.
+    *---------------------------------------------------------------*/
+
+   void syntFilter(
+       float *Out,     /* (i/o) Signal to be filtered */
+       float *a,       /* (i) LP parameters */
+       int len,    /* (i) Length of signal */
+
+
+
+
+
+       float *mem      /* (i/o) Filter state */
+   ){
+       int i, j;
+       float *po, *pi, *pa, *pm;
+
+       po=Out;
+
+       /* Filter first part using memory from past */
+
+       for (i=0; i<LPC_FILTERORDER; i++) {
+           pi=&Out[i-1];
+           pa=&a[1];
+           pm=&mem[LPC_FILTERORDER-1];
+           for (j=1; j<=i; j++) {
+               *po-=(*pa++)*(*pi--);
+           }
+           for (j=i+1; j<LPC_FILTERORDER+1; j++) {
+               *po-=(*pa++)*(*pm--);
+           }
+           po++;
+       }
+
+       /* Filter last part where the state is entirely in
+          the output vector */
+
+       for (i=LPC_FILTERORDER; i<len; i++) {
+           pi=&Out[i-1];
+           pa=&a[1];
+           for (j=1; j<LPC_FILTERORDER+1; j++) {
+               *po-=(*pa++)*(*pi--);
+           }
+           po++;
+       }
+
+       /* Update state vector */
+
+       memcpy(mem, &Out[len-LPC_FILTERORDER],
+           LPC_FILTERORDER*sizeof(float));
+   }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/ilbc/syntFilter.h asterisk-1.8.3.2_com_amr/codecs/ilbc/syntFilter.h
--- asterisk-1.8.3.2_com_rtsp/codecs/ilbc/syntFilter.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-1.8.3.2_com_amr/codecs/ilbc/syntFilter.h	2012-03-26 16:29:07.000000000 +0100
@@ -0,0 +1,24 @@
+
+   /******************************************************************
+
+       iLBC Speech Coder ANSI-C Source Code
+
+       syntFilter.h
+
+       Copyright (C) The Internet Society (2004).
+       All Rights Reserved.
+
+   ******************************************************************/
+
+   #ifndef __iLBC_SYNTFILTER_H
+   #define __iLBC_SYNTFILTER_H
+
+   void syntFilter(
+       float *Out,     /* (i/o) Signal to be filtered */
+       float *a,       /* (i) LP parameters */
+       int len,    /* (i) Length of signal */
+       float *mem      /* (i/o) Filter state */
+   );
+
+   #endif
+
diff -Naur asterisk-1.8.3.2_com_rtsp/codecs/Makefile asterisk-1.8.3.2_com_amr/codecs/Makefile
--- asterisk-1.8.3.2_com_rtsp/codecs/Makefile	2012-03-15 11:13:54.000000000 +0000
+++ asterisk-1.8.3.2_com_amr/codecs/Makefile	2012-03-26 16:29:07.000000000 +0100
@@ -19,6 +19,7 @@
 
 LIBILBC:=ilbc/libilbc.a
 LIBLPC10:=lpc10/liblpc10.a
+LIBAMR:=amr/libamr.a
 
 all: _all
 
@@ -34,6 +35,7 @@
 	$(MAKE) -C lpc10 clean
 	$(MAKE) -C ilbc clean
 	rm -f g722/*.[oa]
+	$(MAKE) -C amr clean
 
 gsm/lib/libgsm.a:
 	@mkdir -p gsm/lib
@@ -47,6 +49,11 @@
 $(LIBILBC):
 	@$(MAKE) -C ilbc all _ASTCFLAGS="$(filter-out -Wmissing-prototypes -Wmissing-declarations -Wshadow,$(_ASTCFLAGS)) $(AST_NO_STRICT_OVERFLOW)"
 
+$(LIBAMR):
+	@$(MAKE) -C amr all
+
+$(if $(filter codec_amr,$(EMBEDDED_MODS)),modules.link,codec_amr.so): $(LIBAMR)
+
 $(if $(filter codec_ilbc,$(EMBEDDED_MODS)),modules.link,codec_ilbc.so): $(LIBILBC)
 
 $(if $(filter codec_g722,$(EMBEDDED_MODS)),modules.link,codec_g722.so): g722/g722_encode.o g722/g722_decode.o
diff -Naur asterisk-1.8.3.2_com_rtsp/main/channel.c asterisk-1.8.3.2_com_amr/main/channel.c
--- asterisk-1.8.3.2_com_rtsp/main/channel.c	2012-03-19 15:21:29.000000000 +0000
+++ asterisk-1.8.3.2_com_amr/main/channel.c	2012-03-26 16:29:08.000000000 +0100
@@ -1000,6 +1000,8 @@
 		AST_FORMAT_ULAW,
 		/*! Unless of course, you're a silly European, so then prefer ALAW */
 		AST_FORMAT_ALAW,
+	    /*! Try AMR */
+	    AST_FORMAT_AMRNB,
 		AST_FORMAT_G719,
 		AST_FORMAT_SIREN14,
 		AST_FORMAT_SIREN7,
@@ -1017,6 +1019,8 @@
 		AST_FORMAT_ADPCM,
 		/*! Okay, we're down to vocoders now, so pick GSM because it's small and easier to
 		    translate and sounds pretty good */
+	    /*! Try AMR-WB */
+	    AST_FORMAT_AMRWB,
 		AST_FORMAT_GSM,
 		/*! iLBC is not too bad */
 		AST_FORMAT_ILBC,
diff -Naur asterisk-1.8.3.2_com_rtsp/main/frame.c asterisk-1.8.3.2_com_amr/main/frame.c
--- asterisk-1.8.3.2_com_rtsp/main/frame.c	2012-03-15 11:13:56.000000000 +0000
+++ asterisk-1.8.3.2_com_amr/main/frame.c	2012-03-26 16:29:09.000000000 +0100
@@ -122,6 +122,11 @@
 	{ AST_FORMAT_SIREN14, "siren14", 32000, "ITU G.722.1 Annex C, (Siren14, licensed from Polycom)", 120, 20, 80, 20, 20 },	/*!< Binary commercial distribution */
 	{ AST_FORMAT_TESTLAW, "testlaw", 8000, "G.711 test-law", 80, 10, 150, 10, 20 },                        /*!< codec_ulaw.c */
 	{ AST_FORMAT_G719, "g719", 48000, "ITU G.719", 160, 20, 80, 20, 20 },
+	{ AST_FORMAT_AMRNB, "amr", 8000, "AMR NB", 32, 20, 300, 0, 20},          /*!< codec_amr.c */
+	{ AST_FORMAT_AMRWB, "amr-wb", 16000, "AMR WB", 32, 20, 300, 0, 20},          /*!< codec_amr.c */
+	{ AST_FORMAT_MPEG4_AUDIO, "aac", 8000, "MPEG4 Audio", 120, 10, 300, 10, 20 }, /*!< MP4A-LATM */
+	{ AST_FORMAT_H263_PLUS_PLUS, "h263pp", 0, "H.263++ Video" },   /*!< H.263++ */
+	{ AST_FORMAT_MPEG4_VIDEO, "mpeg4v", 0, "MPEG4 Video" },  /*!< MPEG4 */
 };
 
 struct ast_frame ast_null_frame = { AST_FRAME_NULL, };
@@ -1442,6 +1447,37 @@
 	return cnt;
 }
 
+// AMR support
+static int amr_samples(unsigned char *data, int datalen)
+{
+   short block_size[16]={ 12, 13, 15, 17, 19, 20, 26, 31, 5, 0, 0, 0, 0, 0, 0, 0 };
+   int samples = 0;
+
+   /* we asume RTP octed aligned format (RFC 4867 section 4.4)
+      skip first octed (CMR) */
+   datalen--;
+   data++;
+
+   while (datalen > 0) {
+      unsigned dec_mode = (data[0]>>3) & 0x000f;
+      unsigned psize = block_size[dec_mode];
+
+      if (psize)
+         samples += 160;
+
+      if ( !(data[0]>>7) ) {
+         /* this was the last ToC entry */
+         break;
+      }
+
+      data++; /* Skip over the block. */
+      datalen --;
+      /* ast_verbose("Got AMR frame size %d inside ast_frame\n", psize); */
+   }
+   /* todo: how can we signal an error while decoding the frame structure? */
+   return samples;
+}
+
 int ast_codec_get_samples(struct ast_frame *f)
 {
 	int samples = 0;
@@ -1498,6 +1534,13 @@
 		/* 48,000 samples per second at 64kbps is 8,000 bytes per second */
 		samples = (int) f->datalen * ((float) 48000 / 8000);
 		break;
+	case AST_FORMAT_AMRNB:
+	case AST_FORMAT_AMRWB: // TODO: correct?
+	    samples = amr_samples(f->data.ptr, f->datalen);
+	    break;
+	case AST_FORMAT_MPEG4_AUDIO:
+	    // TODO:
+	    break;
 	default:
 		ast_log(LOG_WARNING, "Unable to calculate samples for format %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), f->subclass.codec));
 	}
@@ -1549,6 +1592,13 @@
 		/* 48,000 samples per second at 64kbps is 8,000 bytes per second */
 		len = (int) samples / ((float) 48000 / 8000);
 		break;
+	case AST_FORMAT_AMRNB:
+    case AST_FORMAT_AMRWB: // TODO: correct?
+        len = (samples / 160) * 32;
+        break;
+    case AST_FORMAT_MPEG4_AUDIO:
+        // TODO:
+        break;
 	default:
 		ast_log(LOG_WARNING, "Unable to calculate sample length for format %s\n", ast_getformatname(format));
 	}
diff -Naur asterisk-1.8.3.2_com_rtsp/main/rtp_engine.c asterisk-1.8.3.2_com_amr/main/rtp_engine.c
--- asterisk-1.8.3.2_com_rtsp/main/rtp_engine.c	2012-03-15 11:13:56.000000000 +0000
+++ asterisk-1.8.3.2_com_amr/main/rtp_engine.c	2012-03-26 16:29:09.000000000 +0100
@@ -111,6 +111,11 @@
 	*/
 	{{1, AST_FORMAT_G722}, "audio", "G722", 8000},
 	{{1, AST_FORMAT_G726_AAL2}, "audio", "AAL2-G726-32", 8000},
+	{{1, AST_FORMAT_AMRNB}, "audio", "AMR", 8000},
+	{{1, AST_FORMAT_AMRWB}, "audio", "AMR-WB", 16000},
+	{{1, AST_FORMAT_MPEG4_AUDIO}, "audio", "MP4A-LATM", 8000},
+	{{1, AST_FORMAT_MPEG4_AUDIO}, "audio", "AAC", 8000},
+	{{1, AST_FORMAT_MPEG4_AUDIO}, "audio", "MP4A", 8000},
 	{{0, AST_RTP_DTMF}, "audio", "telephone-event", 8000},
 	{{0, AST_RTP_CISCO_DTMF}, "audio", "cisco-telephone-event", 8000},
 	{{0, AST_RTP_CN}, "audio", "CN", 8000},
@@ -119,7 +124,9 @@
 	{{1, AST_FORMAT_H261}, "video", "H261", 90000},
 	{{1, AST_FORMAT_H263}, "video", "H263", 90000},
 	{{1, AST_FORMAT_H263_PLUS}, "video", "h263-1998", 90000},
+	{{1, AST_FORMAT_H263_PLUS}, "video", "H263-1998", 90000},
 	{{1, AST_FORMAT_H264}, "video", "H264", 90000},
+	{{1, AST_FORMAT_H263_PLUS_PLUS}, "video", "H263-2000", 90000},
 	{{1, AST_FORMAT_MP4_VIDEO}, "video", "MP4V-ES", 90000},
 	{{1, AST_FORMAT_T140RED}, "text", "RED", 1000},
 	{{1, AST_FORMAT_T140}, "text", "T140", 1000},
@@ -160,15 +167,20 @@
 	[26] = {1, AST_FORMAT_JPEG},
 	[31] = {1, AST_FORMAT_H261},
 	[34] = {1, AST_FORMAT_H263},
+	[96] = {1, AST_FORMAT_H264},
 	[97] = {1, AST_FORMAT_ILBC},
-	[98] = {1, AST_FORMAT_H263_PLUS},
-	[99] = {1, AST_FORMAT_H264},
+	[98] = {1, AST_FORMAT_AMRNB}, /* Audio AMR-NB */
+	[99] = {1, AST_FORMAT_AMRWB}, /* Audio AMR-WB */
 	[101] = {0, AST_RTP_DTMF},
 	[102] = {1, AST_FORMAT_SIREN7},
 	[103] = {1, AST_FORMAT_H263_PLUS},
 	[104] = {1, AST_FORMAT_MP4_VIDEO},
 	[105] = {1, AST_FORMAT_T140RED},   /* Real time text chat (with redundancy encoding) */
 	[106] = {1, AST_FORMAT_T140},      /* Real time text chat */
+	[107] = {1, AST_FORMAT_H263_PLUS_PLUS},
+	[108] = {1, AST_FORMAT_MPEG4_VIDEO},
+	//MP4A-LATM
+	[109] = {1, AST_FORMAT_MPEG4_AUDIO},
 	[110] = {1, AST_FORMAT_SPEEX},
 	[111] = {1, AST_FORMAT_G726},
 	[112] = {1, AST_FORMAT_G726_AAL2},
diff -Naur asterisk-1.8.3.2_com_rtsp/menuselect-tree asterisk-1.8.3.2_com_amr/menuselect-tree
--- asterisk-1.8.3.2_com_rtsp/menuselect-tree	2012-03-19 15:21:29.000000000 +0000
+++ asterisk-1.8.3.2_com_amr/menuselect-tree	2012-03-26 16:31:57.000000000 +0100
@@ -159,6 +159,8 @@
 	<depend>tonezone</depend>
 	<defaultenabled>no</defaultenabled>
 </member>
+<member name="app_rtsp" displayname="RTSP applications" remove_on_change="apps/app_rtsp.o apps/app_rtsp.so">
+</member>
 <member name="app_saycounted" displayname="Decline words according to channel language" remove_on_change="apps/app_saycounted.o apps/app_saycounted.so">
 	<defaultenabled>no</defaultenabled>
 </member>
@@ -358,6 +360,9 @@
 </member>
 <member name="codec_alaw" displayname="A-law Coder/Decoder" remove_on_change="codecs/codec_alaw.o codecs/codec_alaw.so">
 </member>
+<member name="codec_amr" displayname="AMR Coder/Decoder" remove_on_change="codecs/codec_amr.o codecs/codec_amr.so">
+	
+</member>
 <member name="codec_a_mu" displayname="A-law and Mulaw direct Coder/Decoder" remove_on_change="codecs/codec_a_mu.o codecs/codec_a_mu.so">
 </member>
 <member name="codec_dahdi" displayname="Generic DAHDI Transcoder Codec Translator" remove_on_change="codecs/codec_dahdi.o codecs/codec_dahdi.so">
